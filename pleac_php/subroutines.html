<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Subroutines</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-PHP"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Directories"
HREF="directories.html"><LINK
REL="NEXT"
TITLE="References and Records"
HREF="referencesandrecords.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-PHP</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SUBROUTINES"
>10. Subroutines</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN536"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Since defined at outermost scope, $greeted may be considered a global variable</span>
<span class="nv">$greeted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// ------------</span>

<span class="c1">// Must use, &#39;global&#39;, keyword to inform functions that $greeted already exists as</span>
<span class="c1">// a global variable. If this is not done, a local variable of that name is implicitly</span>
<span class="c1">// defined</span>
<span class="k">function</span> <span class="nf">howManyGreetings</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">global</span> <span class="nv">$greeted</span><span class="p">;</span>
  <span class="k">return</span> <span class="nv">$greeted</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">hello</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">global</span> <span class="nv">$greeted</span><span class="p">;</span>
  <span class="nv">$greeted</span><span class="o">++</span><span class="p">;</span>
  <span class="k">echo</span> <span class="s2">&quot;high there!, this procedure has been called </span><span class="si">{</span><span class="nv">$greeted</span><span class="si">}</span><span class="s2"> times</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="nx">hello</span><span class="p">();</span>
<span class="nv">$greetings</span> <span class="o">=</span> <span class="nx">howManyGreetings</span><span class="p">();</span>
<span class="k">echo</span> <span class="s2">&quot;bye there!, there have been </span><span class="si">{</span><span class="nv">$greetings</span><span class="si">}</span><span class="s2"> greetings so far</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN539"
>Accessing Subroutine Arguments</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Conventionally-defined function together with parameter list</span>
<span class="k">function</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="nv">$side1</span><span class="p">,</span> <span class="nv">$side2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nx">sqrt</span><span class="p">(</span><span class="nx">pow</span><span class="p">(</span><span class="nv">$side1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">pow</span><span class="p">(</span><span class="nv">$side2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// Alternative is to define the function without parameter list, then use</span>
<span class="c1">// &#39;func_get_arg&#39; to extract arguments</span>
<span class="k">function</span> <span class="nf">hypotenuse</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Could check number of arguments passed with: &#39;func_num_args&#39;, which</span>
  <span class="c1">// would be the approach used if dealing with variable number of arguments</span>
  <span class="nv">$side1</span> <span class="o">=</span> <span class="nb">func_get_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nv">$side2</span> <span class="o">=</span> <span class="nb">func_get_arg</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">sqrt</span><span class="p">(</span><span class="nx">pow</span><span class="p">(</span><span class="nv">$side1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">pow</span><span class="p">(</span><span class="nv">$side2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// 1. Conventional function call</span>
<span class="nv">$diag</span> <span class="o">=</span> <span class="nx">hypotenuse</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// ------------</span>

<span class="c1">// 2. Function call using, &#39;call_user_func&#39; library routines</span>
<span class="nv">$funcname</span> <span class="o">=</span> <span class="s1">&#39;hypotenuse&#39;</span><span class="p">;</span>

<span class="c1">// a. Pass function name, and variable number of arguments</span>
<span class="nv">$diag</span> <span class="o">=</span> <span class="nb">call_user_func</span><span class="p">(</span><span class="nv">$funcname</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// b. Package arguments as array, pass together with function name</span>
<span class="nv">$args</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> 
<span class="nv">$diag</span> <span class="o">=</span> <span class="nb">call_user_func_array</span><span class="p">(</span><span class="nv">$funcname</span><span class="p">,</span> <span class="nv">$args</span><span class="p">);</span>

<span class="c1">// ----------------------------</span>

<span class="nv">$nums</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">);</span>

<span class="c1">// ------------</span>

<span class="c1">// Pass-by-value</span>
<span class="k">function</span> <span class="nf">int_all</span><span class="p">(</span><span class="nv">$arr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nb">array_map</span><span class="p">(</span><span class="nb">create_function</span><span class="p">(</span><span class="s1">&#39;$n&#39;</span><span class="p">,</span> <span class="s1">&#39;return (int) $n;&#39;</span><span class="p">),</span> <span class="nv">$arr</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Pass-by-reference</span>
<span class="k">function</span> <span class="nf">trunc_em</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">foreach</span> <span class="p">(</span><span class="nv">$n</span> <span class="k">as</span> <span class="o">&amp;</span><span class="nv">$value</span><span class="p">)</span> <span class="nv">$value</span> <span class="o">=</span> <span class="p">(</span><span class="nx">int</span><span class="p">)</span> <span class="nv">$value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// $nums untouched; $ints is new array</span>
<span class="nv">$ints</span> <span class="o">=</span> <span class="nx">int_all</span><span class="p">(</span><span class="nv">$nums</span><span class="p">);</span>

<span class="c1">// $nums updated</span>
<span class="nx">trunc_em</span><span class="p">(</span><span class="nv">$nums</span><span class="p">);</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN542"
>Making Variables Private to a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Strictly-speaking, PHP is neither lexically [no environment capture] nor</span>
<span class="c1">// dynamically [no variable shadowing] scoped. A script in which several</span>
<span class="c1">// functions have been defined has two, entirely separate, scopes:</span>
<span class="c1">//</span>
<span class="c1">// * A &#39;top-level&#39; scope i.e. everything outside each function</span>
<span class="c1">//</span>
<span class="c1">// * A &#39;local scope&#39; within each function; each function is a self-contained</span>
<span class="c1">//   entity and cannot [via conventional means] access variables outside its</span>
<span class="c1">//   local scope. Accessing a variable that has not been locally defined</span>
<span class="c1">//   serves to define it i.e. accessing a variable assumed to be global</span>
<span class="c1">//   sees a local variable of that name defined</span>
<span class="c1">//</span>
<span class="c1">// The way &#39;global&#39; variables are provided is via a predefined array of</span>
<span class="c1">// variable names, $GLOBALS [it is one of a special set of variables known</span>
<span class="c1">// as &#39;superglobals&#39;; such variables *are* accessable in all scopes]. Each</span>
<span class="c1">// entry in this array is a &#39;global&#39; variable name, and may be freely</span>
<span class="c1">// accessed / updated. A more convenient means of accessing such variables</span>
<span class="c1">// is via the &#39;global&#39; keyword: one or more variables within a function is</span>
<span class="c1">// declared &#39;global&#39;, and those names are then taken to refer to entries</span>
<span class="c1">// in the $GLOBALS array rather than seeing local variables of that name</span>
<span class="c1">// accessed or defined</span>

<span class="k">function</span> <span class="nf">some_func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Variables declared within a function are local to that function</span>
  <span class="nv">$variable</span> <span class="o">=</span> <span class="s1">&#39;something&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Top-level declared variables</span>
<span class="nv">$name</span> <span class="o">=</span> <span class="nv">$argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="nv">$age</span> <span class="o">=</span> <span class="nv">$argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="nv">$c</span> <span class="o">=</span> <span class="nx">fetch_time</span><span class="p">();</span>

<span class="nv">$condition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// ------------</span>

<span class="k">function</span> <span class="nf">run_check</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// The globally-declared variable, &#39;$condition&#39;, is not accessable within</span>
  <span class="c1">// the function unless it declared as &#39;global. Had this not been done then</span>
  <span class="c1">// attempts to access, &#39;$condition&#39;, would have seen a local variable</span>
  <span class="c1">// of that name declared and updated. Same applies to other variables</span>
  <span class="k">global</span> <span class="nv">$condition</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$age</span><span class="p">,</span> <span class="nv">$c</span><span class="p">;</span>

  <span class="nv">$condition</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">check_x</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nv">$y</span> <span class="o">=</span> <span class="s1">&#39;whatever&#39;</span><span class="p">;</span>

  <span class="c1">// This function only has access to the parameter, &#39;$x&#39;, and the locally</span>
  <span class="c1">// declared variable, &#39;$y&#39;.</span>

  <span class="c1">// Whilst &#39;run_check&#39; has access to several global variables, the current</span>
  <span class="c1">// function does not. For it to access the global variable, &#39;$condition&#39;,</span>
  <span class="c1">// it must be declared &#39;global&#39;</span>
  <span class="nx">run_check</span><span class="p">();</span>

  <span class="k">global</span> <span class="nv">$condition</span><span class="p">;</span>

  <span class="c1">// &#39;run_check&#39; will have updated, &#39;$condition&#39;, and since it has been</span>
  <span class="c1">// declared &#39;global&#39; here, it is accessable</span>

  <span class="k">if</span> <span class="p">(</span><span class="nv">$condition</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN545"
>Creating Persistent Private Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Local scopes are not created in the same way as in Perl [by simply enclosing</span>
<span class="c1">// within braces]: only via the creation of functions are local scopes created</span>

<span class="c1">// Doesn&#39;t create a local scope; &#39;$myvariable&#39; is created at top-level</span>
<span class="p">{</span>
  <span class="nv">$myvariable</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// &#39;$myvariable&#39; is accessable here</span>
<span class="k">echo</span> <span class="nv">$myvariable</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>

<span class="c1">// ------------</span>

<span class="p">{</span>
  <span class="nv">$counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Local scope created within function, but not within surrounding braces</span>
  <span class="c1">// so:</span>
  <span class="c1">// * &#39;$counter&#39; is actually a top-level variable, so globally accessable</span>
  <span class="c1">// * &#39;next_counter&#39; has no implict access to &#39;$counter&#39;; must be granted</span>
  <span class="c1">//   via &#39;global&#39; keyword</span>

  <span class="k">function</span> <span class="nf">next_counter</span><span class="p">()</span> <span class="p">{</span> <span class="k">global</span> <span class="nv">$counter</span><span class="p">;</span> <span class="nv">$counter</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// PHP doesn&#39;t, AFAIK, offer an equivalent to Perl&#39;s BEGIN block. Similar</span>
<span class="c1">// behaviour may be obtained by defining a class, and including such code</span>
<span class="c1">// in its constructor</span>

<span class="k">class</span> <span class="nc">BEGIN</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="nv">$myvariable</span><span class="p">;</span>

  <span class="k">function</span> <span class="nf">__construct</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">myvariable</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">function</span> <span class="nf">othersub</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">echo</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">myvariable</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="nv">$b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BEGIN</span><span class="p">();</span>

<span class="nv">$b</span><span class="o">-&gt;</span><span class="na">othersub</span><span class="p">();</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// PHP, like C, supports &#39;static&#39; local variables, that is, those that upon</span>
<span class="c1">// first access are initialised, and thence retain their value between function</span>
<span class="c1">// calls. However, the &#39;counter&#39; example is better implemented as a class</span>

<span class="k">class</span> <span class="nc">Counter</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="nv">$counter</span><span class="p">;</span>

  <span class="k">function</span> <span class="nf">__construct</span><span class="p">(</span><span class="nv">$counter_init</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">counter</span> <span class="o">=</span> <span class="nv">$counter_init</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">function</span> <span class="nf">next_counter</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">counter</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">counter</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">function</span> <span class="nf">prev_counter</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">counter</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">counter</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="nv">$counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Counter</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="k">echo</span> <span class="nv">$counter</span><span class="o">-&gt;</span><span class="na">next_counter</span><span class="p">()</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="k">echo</span> <span class="nv">$counter</span><span class="o">-&gt;</span><span class="na">next_counter</span><span class="p">()</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="k">echo</span> <span class="nv">$counter</span><span class="o">-&gt;</span><span class="na">prev_counter</span><span class="p">()</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN548"
>Determining Current Function Name</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// AFAICT there is no means of obtaining the name of the currently executing</span>
<span class="c1">// function, or, for that matter, perform any stack / activation record,</span>
<span class="c1">// inspection. It *is* possible to:</span>
<span class="c1">//</span>
<span class="c1">// * Obtain a list of the currently-defined functions [&#39;get_defined_functions&#39;]</span>
<span class="c1">// * Check whether a specific function exists [&#39;function_exists&#39;]</span>
<span class="c1">// * Use the &#39;Reflection API&#39;</span>
<span class="c1">//</span>
<span class="c1">// So, to solve this problem would seem to require adopting a convention where</span>
<span class="c1">// a string representing the function name is passed as an argument, or a local</span>
<span class="c1">// variable [perhaps called, &#39;$name&#39;] is so set [contrived, and of limited use]</span>

<span class="k">function</span> <span class="nf">whoami</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nv">$name</span> <span class="o">=</span> <span class="s1">&#39;whoami&#39;</span><span class="p">;</span>
  <span class="k">echo</span> <span class="s2">&quot;I am: </span><span class="si">{</span><span class="nv">$name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="nx">whoami</span><span class="p">();</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN551"
>Passing Arrays and Hashes by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// In PHP all items exist as &#39;memory references&#39; [i.e. non-modifiable pointers],</span>
<span class="c1">// so when passing an item as a function argument, or returning an item from</span>
<span class="c1">// a function, it is this &#39;memory reference&#39; that is passed, and *not* the</span>
<span class="c1">// contents of that item. Should several references to an item exist [e.g. if</span>
<span class="c1">// passed to a function then at least two such references would exist in</span>
<span class="c1">// different scopes] they would all be refering to the same copy of the item.</span>
<span class="c1">// However, if an attempt is made to alter the item is made, a copy is made</span>
<span class="c1">// and it is the copy that is altered, leaving the original intact.</span>
<span class="c1">// </span>
<span class="c1">// The PHP reference mechanism is used to selectively prevent this behaviour,</span>
<span class="c1">// and ensure that if a change is made to an item that no copy is made, and that</span>
<span class="c1">// it is the original item that is changed. Importantly, there is no efficiency</span>
<span class="c1">// gain from passing function parameters using references if the parameter item</span>
<span class="c1">// is not altered.</span>

<span class="c1">// A copy of the item referred to by, &#39;$arr&#39;, is made, and altered; original</span>
<span class="c1">// remains intact</span>
<span class="k">function</span> <span class="nf">array_by_value</span><span class="p">(</span><span class="nv">$arr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nv">$arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="k">echo</span> <span class="nv">$arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span> 
<span class="p">}</span>

<span class="c1">// No copy is made; original item referred to by, &#39;$arr&#39;, is altered</span>
<span class="k">function</span> <span class="nf">array_by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$arr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nv">$arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="k">echo</span> <span class="nv">$arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span> 
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="nv">$arr</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="k">echo</span> <span class="nv">$arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>         <span class="c1">// output: 1 </span>
<span class="nx">array_by_value</span><span class="p">(</span><span class="nv">$arr</span><span class="p">);</span>        <span class="c1">// output: 7</span>
<span class="k">echo</span> <span class="nv">$arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>         <span class="c1">// output: 1 </span>

<span class="nv">$arr</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="k">echo</span> <span class="nv">$arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>         <span class="c1">// output: 1 </span>
<span class="nx">array_by_ref</span><span class="p">(</span><span class="nv">$arr</span><span class="p">);</span>          <span class="c1">// output: 7</span>
<span class="k">echo</span> <span class="nv">$arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>         <span class="c1">// output: 7 </span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Since, &#39;add_vecpair&#39;, does not attempt to alter either, &#39;$x&#39; or &#39;$y&#39;, it makes</span>
<span class="c1">// no difference whether they are &#39;passed by value&#39;, or &#39;passed by reference&#39;</span>
<span class="k">function</span> <span class="nf">add_vecpair</span><span class="p">(</span><span class="nv">$x</span><span class="p">,</span> <span class="nv">$y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nv">$r</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
  <span class="nv">$length</span> <span class="o">=</span> <span class="nb">count</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nv">$length</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span><span class="p">)</span> <span class="nv">$r</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span> <span class="o">+</span> <span class="nv">$y</span><span class="p">[</span><span class="nv">$i</span><span class="p">];</span>
  <span class="k">return</span> <span class="nv">$r</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
<span class="nb">count</span><span class="p">(</span><span class="nv">$arr1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">count</span><span class="p">(</span><span class="nv">$arr2</span><span class="p">)</span> <span class="o">||</span> <span class="k">die</span><span class="p">(</span><span class="s2">&quot;usage: add_vecpair ARR1 ARR2</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

<span class="c1">// &#39;passed by value&#39;</span>
<span class="nv">$arr3</span> <span class="o">=</span> <span class="nx">add_vecpair</span><span class="p">(</span><span class="nv">$arr1</span><span class="p">,</span> <span class="nv">$arr2</span><span class="p">);</span>

<span class="c1">// &#39;passed by reference&#39; [also possible to override default &#39;passed by value&#39;</span>
<span class="c1">// if required]</span>
<span class="nv">$arr3</span> <span class="o">=</span> <span class="nx">add_vecpair</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$arr1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">$arr2</span><span class="p">);</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN554"
>Detecting Return Context</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// PHP can be described as a dynamically typed language because variables serve</span>
<span class="c1">// as identifiers, and the same variable may refer to data of various types.</span>
<span class="c1">// As such, the set of arguments passed to a function may vary in type between</span>
<span class="c1">// calls, as can the type of return value. Where this is likely to occur type</span>
<span class="c1">// checking should be performed either / both within the function body, and</span>
<span class="c1">// when obtaining it&#39;s return value. As for Perl-style &#39;return context&#39;, I</span>
<span class="c1">// don&#39;t believe it is supported by PHP</span>

<span class="c1">// Can return any type</span>
<span class="k">function</span> <span class="nf">mysub</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="k">array</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="s1">&#39;5&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Throw away return type [i.e. returns a &#39;void&#39; type ?]</span>
<span class="nx">mysub</span><span class="p">();</span>

<span class="c1">// Check return type. Can do via:</span>
<span class="c1">// * gettype($var)</span>
<span class="c1">// * is_xxx e.g. is_array($var), is_muneric($var), ...</span>
<span class="nv">$ret</span> <span class="o">=</span> <span class="nx">mysub</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">is_numeric</span><span class="p">(</span><span class="nv">$ret</span><span class="p">))</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">is_array</span><span class="p">(</span><span class="nv">$ret</span><span class="p">))</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">is_string</span><span class="p">(</span><span class="nv">$ret</span><span class="p">))</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN557"
>Passing by Named Parameter</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// PHP doesn&#39;t directly support named / keyword parameters, but these can be</span>
<span class="c1">// easily mimiced using a class of key / value pairs, and passing a variable</span>
<span class="c1">// number of arguments</span>

<span class="k">class</span> <span class="nc">KeyedValue</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nv">$key</span><span class="p">,</span> <span class="nv">$value</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$value</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">key</span> <span class="o">=</span> <span class="nv">$key</span><span class="p">;</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">value</span> <span class="o">=</span> <span class="nv">$value</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">the_func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">foreach</span> <span class="p">(</span><span class="nb">func_get_args</span><span class="p">()</span> <span class="k">as</span> <span class="nv">$arg</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;Key: %10s|Value:%10s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nv">$arg</span><span class="o">-&gt;</span><span class="na">key</span><span class="p">,</span> <span class="nv">$arg</span><span class="o">-&gt;</span><span class="na">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="nx">the_func</span><span class="p">(</span><span class="k">new</span> <span class="nx">KeyedValue</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">),</span>
         <span class="k">new</span> <span class="nx">KeyedValue</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="mi">36</span><span class="p">),</span>
         <span class="k">new</span> <span class="nx">KeyedValue</span><span class="p">(</span><span class="s1">&#39;income&#39;</span><span class="p">,</span> <span class="mi">51000</span><span class="p">));</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Alternatively, an associative array of key / value pairs may be constructed.</span>
<span class="c1">// With the aid of the &#39;extract&#39; built-in function, the key part of this array</span>
<span class="c1">// may be intsntiated to a variable name, thus more closely approximating the</span>
<span class="c1">// behaviour of true named parameters</span>

<span class="k">function</span> <span class="nf">the_func</span><span class="p">(</span><span class="nv">$var_array</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">extract</span><span class="p">(</span><span class="nv">$var_array</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$name</span><span class="p">))</span> <span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;Name:   %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nv">$name</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$age</span><span class="p">))</span> <span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;Age:    %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nv">$age</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$income</span><span class="p">))</span> <span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;Income: %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nv">$income</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="nx">the_func</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;name&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span> <span class="o">=&gt;</span> <span class="mi">36</span><span class="p">,</span> <span class="s1">&#39;income&#39;</span> <span class="o">=&gt;</span> <span class="mi">51000</span><span class="p">));</span>

<span class="c1">// ----------------------------</span>

<span class="k">class</span> <span class="nc">RaceTime</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nv">$time</span><span class="p">,</span> <span class="nv">$dim</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">(</span><span class="nv">$time</span><span class="p">,</span> <span class="nv">$dim</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">time</span> <span class="o">=</span> <span class="nv">$time</span><span class="p">;</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dim</span> <span class="o">=</span> <span class="nv">$dim</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">the_func</span><span class="p">(</span><span class="nv">$var_array</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">extract</span><span class="p">(</span><span class="nv">$var_array</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$start_time</span><span class="p">))</span> <span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;start:  %d - %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nv">$start_time</span><span class="o">-&gt;</span><span class="na">time</span><span class="p">,</span> <span class="nv">$start_time</span><span class="o">-&gt;</span><span class="na">dim</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$finish_time</span><span class="p">))</span> <span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;finish: %d - %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nv">$finish_time</span><span class="o">-&gt;</span><span class="na">time</span><span class="p">,</span> <span class="nv">$finish_time</span><span class="o">-&gt;</span><span class="na">dim</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$incr_time</span><span class="p">))</span> <span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;incr:   %d - %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nv">$incr_time</span><span class="o">-&gt;</span><span class="na">time</span><span class="p">,</span> <span class="nv">$incr_time</span><span class="o">-&gt;</span><span class="na">dim</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="nx">the_func</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;start_time&#39;</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">RaceTime</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">),</span>
               <span class="s1">&#39;finish_time&#39;</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">RaceTime</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">),</span>
               <span class="s1">&#39;incr_time&#39;</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">RaceTime</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">)));</span>

<span class="nx">the_func</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;start_time&#39;</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">RaceTime</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">),</span>
               <span class="s1">&#39;finish_time&#39;</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">RaceTime</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">)));</span>

<span class="nx">the_func</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;start_time&#39;</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">RaceTime</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">)));</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN560"
>Skipping Selected Return Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// The &#39;list&#39; keyword [looks like a function but is actually a special language</span>
<span class="c1">// construct] may be used to perform multiple assignments from a numerically</span>
<span class="c1">// indexed array of values, and offers the added bonus of being able to skip</span>
<span class="c1">// assignment of one, or more, of those values</span>

<span class="k">function</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// ------------</span>

<span class="k">list</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nv">$c</span><span class="p">)</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

<span class="c1">// Provided &#39;func&#39; returns an numerically-indexed array, the following</span>
<span class="c1">// multiple assignment will work</span>
<span class="k">list</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nv">$c</span><span class="p">)</span> <span class="o">=</span> <span class="nx">func</span><span class="p">();</span>

<span class="c1">// Any existing variables no longer wanted would need to be &#39;unset&#39;</span>
<span class="nb">unset</span><span class="p">(</span><span class="nv">$b</span><span class="p">);</span>

<span class="c1">// As above, but second element of return array discarded</span>
<span class="k">list</span><span class="p">(</span><span class="nv">$a</span><span class="p">,,</span><span class="nv">$c</span><span class="p">)</span> <span class="o">=</span> <span class="nx">func</span><span class="p">();</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Care needed to ensure returned array is numerically-indexed</span>
<span class="k">list</span><span class="p">(</span><span class="nv">$dev</span><span class="p">,</span> <span class="nv">$ino</span><span class="p">,,,</span><span class="nv">$uid</span><span class="p">)</span> <span class="o">=</span> <span class="nb">array_slice</span><span class="p">(</span><span class="nb">array_values</span><span class="p">(</span><span class="nb">stat</span><span class="p">(</span><span class="nv">$filename</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN563"
>Returning More Than One Array or Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Multiple return values are possible via packing a set of values within a</span>
<span class="c1">// numerically-indexed array and using &#39;list&#39; to extract them</span>

<span class="k">function</span> <span class="nf">some_func</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">array</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">));</span> <span class="p">}</span>

<span class="c1">// ------------</span>

<span class="k">list</span><span class="p">(</span><span class="nv">$arr</span><span class="p">,</span> <span class="nv">$hash</span><span class="p">)</span> <span class="o">=</span> <span class="nx">some_func</span><span class="p">();</span>

<span class="c1">// ----------------------------</span>

<span class="k">function</span> <span class="nf">some_func</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">$hash</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">array</span><span class="p">(</span><span class="nv">$arr</span><span class="p">,</span> <span class="nv">$hash</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// ------------</span>

<span class="nv">$arrin</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="nv">$hashin</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">);</span>

<span class="k">list</span><span class="p">(</span><span class="nv">$arr</span><span class="p">,</span> <span class="nv">$hash</span><span class="p">)</span> <span class="o">=</span> <span class="nx">some_func</span><span class="p">(</span><span class="nv">$arrin</span><span class="p">,</span> <span class="nv">$hashin</span><span class="p">);</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN566"
>Returning Failure</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// AFAICT, most of the PHP library functions are designed to return some required </span>
<span class="c1">// value on success, and FALSE on exit. Whilst it is possible to return NULL, or</span>
<span class="c1">// one of the recognised &#39;empty&#39; values [e.g. &#39;&#39; or 0 or an empty array etc],</span>
<span class="c1">// FALSE actually seems to be the preferred means of indicating failure</span>

<span class="k">function</span> <span class="nf">a_func</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">FALSE</span><span class="p">;</span> <span class="p">}</span>

<span class="nx">a_func</span><span class="p">()</span> <span class="o">||</span> <span class="k">die</span><span class="p">(</span><span class="s2">&quot;Function failed</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">a_func</span><span class="p">())</span> <span class="k">die</span><span class="p">(</span><span class="s2">&quot;Function failed</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN569"
>Prototyping Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Whether PHP is seen to support prototyping depends on the accepted</span>
<span class="c1">// definition of this term:</span>
<span class="c1">//</span>
<span class="c1">// * Prototyping along the lines used in Ada, Modula X, and even C / C++,</span>
<span class="c1">//   in which a function&#39;s interface is declared separately from its</span>
<span class="c1">//   implementation, is *not* supported</span>
<span class="c1">//</span>
<span class="c1">// * Prototyping in which, as part of the function definition, parameter</span>
<span class="c1">//   information must be supplied. In PHP a function definition neither</span>
<span class="c1">//   parameter, nor return type, information needs to be supplied, though</span>
<span class="c1">//   it is usual to see a parameter list supplied [indicates the number,</span>
<span class="c1">//   positional order, and optionally, whether a parameter is passed by</span>
<span class="c1">//   reference; no type information is present]. In short, prototyping in</span>
<span class="c1">//   PHP is optional, and limited</span>

<span class="k">function</span> <span class="nf">func_with_one_arg</span><span class="p">(</span><span class="nv">$arg1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">func_with_two_arg</span><span class="p">(</span><span class="nv">$arg1</span><span class="p">,</span> <span class="nv">$arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">func_with_three_arg</span><span class="p">(</span><span class="nv">$arg1</span><span class="p">,</span> <span class="nv">$arg2</span><span class="p">,</span> <span class="nv">$arg3</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// The following may be interpreted as meaning a function accepting no</span>
<span class="c1">// arguments:</span>
<span class="k">function</span> <span class="nf">func_with_no_arg</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// whilst the following may mean a function taking zero or more arguments</span>
<span class="k">function</span> <span class="nf">func_with_no_arg_information</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN572"
>Handling Exceptions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Unlike in Perl, PHP&#39;s &#39;die&#39; [actually an alias for &#39;exit&#39;] doesn&#39;t throw</span>
<span class="c1">// an exception, but instead terminates the script, optionally either</span>
<span class="c1">// returning an integer value to the operating system, or printing a message.</span>
<span class="c1">// So, the following, does not exhibit the same behaviour as the Perl example</span>

<span class="k">die</span><span class="p">(</span><span class="s2">&quot;some message</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span> 

<span class="c1">// Instead, like so many modern languages, PHP implements exception handling</span>
<span class="c1">// via the &#39;catch&#39; and &#39;throw&#39; keywords. Furthermore, a C++ or Java programmer</span>
<span class="c1">// would find PHP&#39;s exception handling facility remarkably similar to those</span>
<span class="c1">// of their respective languages. A simple, canonical example follows:</span>

<span class="c1">// Usual to derive new exception classes from the built-in, &#39;Exception&#39;,</span>
<span class="c1">// class</span>
<span class="k">class</span> <span class="nc">MyException</span> <span class="k">extends</span> <span class="nx">Exception</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="k">try</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">if</span> <span class="p">(</span><span class="nv">$some_problem_detected</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">MyException</span><span class="p">(</span><span class="s1">&#39;some message&#39;</span><span class="p">,</span> <span class="nv">$some_error_code</span><span class="p">);</span>
  <span class="c1">// ..</span>
<span class="p">}</span>

<span class="k">catch</span> <span class="p">(</span><span class="nx">MyException</span> <span class="nv">$e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ... handle the problem ...</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="k">class</span> <span class="nc">FullMoonException</span> <span class="k">extends</span> <span class="nx">Exception</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="k">try</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">if</span> <span class="p">(</span><span class="nv">$some_problem_detected</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">FullMoonException</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">,</span> <span class="nv">$full_moon_error_code</span><span class="p">);</span>
  <span class="c1">// ..</span>
<span class="p">}</span>

<span class="k">catch</span> <span class="p">(</span><span class="nx">FullMoonException</span> <span class="nv">$e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ... rethrow the exception - will propagate to higher level ...</span>
  <span class="k">throw</span> <span class="nv">$e</span><span class="p">;</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN575"
>Saving Global Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Please refer to discussion about PHP scope in section two of this chapter.</span>
<span class="c1">// Briefly, PHP assumes a variable name within a function to be local unless</span>
<span class="c1">// it has been specifically declared with the, &#39;global&#39;, keyword, in which</span>
<span class="c1">// case it refers to a variable in the &#39;superglobal&#39; array, &#39;$GLOBALS&#39;. Thus,</span>
<span class="c1">// inadvertant variable name shadowing cannot occur since it is it not possible </span>
<span class="c1">// to use the same name to refer to both a local and a global variable. If</span>
<span class="c1">// accessing a global variable care should be taken to not accidentally update</span>
<span class="c1">// it. The techniques used in this section are simply not required.</span>

<span class="c1">// *** NOT TRANSLATED ***</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN578"
>Redefining a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// In PHP once a function has been defined it remains defined. In other words,</span>
<span class="c1">// it cannot be undefined / deleted, nor can that particular function name be</span>
<span class="c1">// reused to reference another function body. Even the lambda-like functions</span>
<span class="c1">// created via the &#39;create_function&#39; built-in, cannot be undefined [they exist</span>
<span class="c1">// until script termination, thus creating too many of these can actually</span>
<span class="c1">// exhaust memory !]. However, since the latter can be assigned to variables,</span>
<span class="c1">// the same variable name can be used to reference difference functions [and</span>
<span class="c1">// when this is done the reference to the previous function is lost (unless</span>
<span class="c1">// deliberately saved), though the function itself continues to exist].</span>
<span class="c1">//</span>
<span class="c1">// If, however, all that is needed is a simple function aliasing facility,</span>
<span class="c1">// then just assign the function name to a variable, and execute using the</span>
<span class="c1">// variable name</span>

<span class="c1">// Original function</span>
<span class="k">function</span> <span class="nf">expand</span><span class="p">()</span> <span class="p">{</span> <span class="k">echo</span> <span class="s2">&quot;expand</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// Prove that function exists</span>
<span class="k">echo</span> <span class="p">(</span><span class="nb">function_exists</span><span class="p">(</span><span class="s1">&#39;expand&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;yes&#39;</span> <span class="o">:</span> <span class="s1">&#39;no&#39;</span><span class="p">)</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>

<span class="c1">// Use a variable to alias it</span>
<span class="nv">$grow</span> <span class="o">=</span> <span class="s1">&#39;expand&#39;</span><span class="p">;</span>

<span class="c1">// Call function via original name, and variable, respectively</span>
<span class="nx">expand</span><span class="p">();</span>

<span class="nv">$grow</span><span class="p">();</span> 

<span class="c1">// Remove alias variable</span>
<span class="nb">unset</span><span class="p">(</span><span class="nv">$grow</span><span class="p">);</span>

<span class="c1">// ----------------------------</span>

<span class="k">function</span> <span class="nf">fred</span><span class="p">()</span> <span class="p">{</span> <span class="k">echo</span> <span class="s2">&quot;fred</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span> <span class="p">}</span>

<span class="nv">$barney</span> <span class="o">=</span> <span class="s1">&#39;fred&#39;</span><span class="p">;</span>

<span class="nv">$barney</span><span class="p">();</span>

<span class="nb">unset</span><span class="p">(</span><span class="nv">$barney</span><span class="p">);</span>

<span class="nx">fred</span><span class="p">();</span>

<span class="c1">// ------------</span>

<span class="nv">$fred</span> <span class="o">=</span> <span class="nb">create_function</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;echo &quot;fred\n&quot;;&#39;</span><span class="p">);</span>

<span class="nv">$barney</span> <span class="o">=</span> <span class="nv">$fred</span><span class="p">;</span>

<span class="nv">$barney</span><span class="p">();</span>

<span class="nb">unset</span><span class="p">(</span><span class="nv">$barney</span><span class="p">);</span>

<span class="nv">$fred</span><span class="p">();</span>

<span class="c1">// ----------------------------</span>

<span class="k">function</span> <span class="nf">red</span><span class="p">(</span><span class="nv">$text</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;&lt;FONT COLOR=&#39;red&#39;&gt;</span><span class="si">$text</span><span class="s2">&lt;/FONT&gt;&quot;</span><span class="p">;</span> <span class="p">}</span>

<span class="k">echo</span> <span class="nx">red</span><span class="p">(</span><span class="s1">&#39;careful here&#39;</span><span class="p">)</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>

<span class="c1">// ------------</span>

<span class="nv">$colour</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">;</span>

<span class="nv">$$colour</span> <span class="o">=</span> <span class="nb">create_function</span><span class="p">(</span><span class="s1">&#39;$text&#39;</span><span class="p">,</span> <span class="s1">&#39;global $colour;</span>
<span class="s1">return &quot;&lt;FONT COLOR=\&#39;$colour\&#39;&gt;$text&lt;/FONT&gt;&quot;;&#39;</span><span class="p">);</span>

<span class="k">echo</span> <span class="nv">$$colour</span><span class="p">(</span><span class="s1">&#39;careful here&#39;</span><span class="p">)</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>

<span class="nb">unset</span><span class="p">(</span><span class="nv">$$colour</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="nv">$colours</span> <span class="o">=</span> <span class="nb">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;red blue green yellow orange purple violet&#39;</span><span class="p">);</span>

<span class="k">foreach</span> <span class="p">(</span><span class="nv">$colours</span> <span class="k">as</span> <span class="nv">$colour</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nv">$$colour</span> <span class="o">=</span> <span class="nb">create_function</span><span class="p">(</span><span class="s1">&#39;$text&#39;</span><span class="p">,</span> <span class="s1">&#39;global $colour;</span>
<span class="s1">  return &quot;&lt;FONT COLOR=\&#39;$colour\&#39;&gt;$text&lt;/FONT&gt;&quot;;&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">foreach</span> <span class="p">(</span><span class="nv">$colours</span> <span class="k">as</span> <span class="nv">$colour</span><span class="p">)</span> <span class="p">{</span> <span class="k">echo</span> <span class="nv">$$colour</span><span class="p">(</span><span class="s2">&quot;Careful with this </span><span class="si">$colour</span><span class="s2">, James&quot;</span><span class="p">)</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span> <span class="p">}</span>

<span class="k">foreach</span> <span class="p">(</span><span class="nv">$colours</span> <span class="k">as</span> <span class="nv">$colour</span><span class="p">)</span> <span class="p">{</span> <span class="nb">unset</span><span class="p">(</span><span class="nv">$$colour</span><span class="p">);</span> <span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN581"
>Trapping Undefined Function Calls with AUTOLOAD</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// PHP sports an AUTOLOAD facility that is quite easy to use, but, AFAICT, is geared</span>
<span class="c1">// towards the detection of unavailable classes rather than for individual functions.</span>
<span class="c1">// Here is a rudimentary example:</span>

<span class="k">function</span> <span class="nf">__autoload</span><span class="p">(</span><span class="nv">$classname</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">file_exists</span><span class="p">(</span><span class="nv">$classname</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="c1">// Class file does not exist, so handle situation; in this case,</span>
    <span class="c1">// issue error message, and exit program</span>
    <span class="k">die</span><span class="p">(</span><span class="s2">&quot;File for class: </span><span class="si">{</span><span class="nv">$classname</span><span class="si">}</span><span class="s2"> not found - aborting</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="c1">// Class file exists, so load it</span>
    <span class="k">require_once</span> <span class="nv">$classname</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// Attempt to instantiate object of undefined class </span>
<span class="k">new</span> <span class="nx">UnknownClassObject</span><span class="p">();</span>

<span class="c1">// Execution continues here if class exists</span>
<span class="c1">// ...</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// It is also possible to perform [quite extensive] introspection on functions,</span>
<span class="c1">// variables etc, so it is possible to check whether a function exists before</span>
<span class="c1">// executing it, thus allowing a non-existent functions to be searched for and</span>
<span class="c1">// loaded from a source file, or perhaps dynamically defined. An example of what</span>
<span class="c1">// could be described as a custom autoload facility appears below.</span>

<span class="nv">$colours</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="s1">&#39;violet&#39;</span><span class="p">);</span>

<span class="k">foreach</span> <span class="p">(</span><span class="nv">$colours</span> <span class="k">as</span> <span class="nv">$colour</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nv">$$colour</span> <span class="o">=</span> <span class="nb">create_function</span><span class="p">(</span><span class="s1">&#39;$text&#39;</span><span class="p">,</span> <span class="s1">&#39;global $colour;</span>
<span class="s1">  return &quot;&lt;FONT COLOR=\&#39;$colour\&#39;&gt;$text&lt;/FONT&gt;&quot;;&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Let&#39;s add a new colour to the list</span>
<span class="nb">array_push</span><span class="p">(</span><span class="nv">$colours</span><span class="p">,</span> <span class="s1">&#39;chartreuse&#39;</span><span class="p">);</span> 

<span class="k">foreach</span> <span class="p">(</span><span class="nv">$colours</span> <span class="k">as</span> <span class="nv">$colour</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Checking whether function is defined</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">function_exists</span><span class="p">(</span><span class="nv">$$colour</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="c1">// Doesn&#39;t exist, so dynamically define it</span>
    <span class="nv">$$colour</span> <span class="o">=</span> <span class="nb">create_function</span><span class="p">(</span><span class="s1">&#39;$text&#39;</span><span class="p">,</span> <span class="s1">&#39;global $colour;</span>
<span class="s1">    return &quot;&lt;FONT COLOR=\&#39;$colour\&#39;&gt;$text&lt;/FONT&gt;&quot;;&#39;</span><span class="p">);</span>

    <span class="c1">// Alternatively, if it exists in a source file, &#39;include&#39; the file:</span>
    <span class="c1">// include &#39;newcolours.php&#39;</span>
  <span class="p">}</span>

  <span class="k">echo</span> <span class="nv">$$colour</span><span class="p">(</span><span class="s2">&quot;Careful with this </span><span class="si">$colour</span><span class="s2">, James&quot;</span><span class="p">)</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">foreach</span> <span class="p">(</span><span class="nv">$colours</span> <span class="k">as</span> <span class="nv">$colour</span><span class="p">)</span> <span class="nb">unset</span><span class="p">(</span><span class="nv">$$colour</span><span class="p">);</span> </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN584"
>Nesting Subroutines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// *** Warning *** Whilst PHP *does* allow functions to be defined within other</span>
<span class="c1">// functions it needs to be clearly understood that these &#39;inner&#39; functions:</span>
<span class="c1">// * Do not exist until the outer function is called a first time, at which time</span>
<span class="c1">//   they then remain defined</span>
<span class="c1">// * Are global in scope, so are accessable outside the function by their name;</span>
<span class="c1">//   the fact that they are nested within another function has, AFAICT, no bearing</span>
<span class="c1">//   on name resolution</span>
<span class="c1">// * Do not form a closure: the inner function is merely &#39;parked&#39; within the</span>
<span class="c1">//   outer function, and has no implicit access to the outer function&#39;s variables</span>
<span class="c1">//   or other inner functions</span>

<span class="k">function</span> <span class="nf">outer</span><span class="p">(</span><span class="nv">$arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nv">$x</span> <span class="o">=</span> <span class="nv">$arg</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>
  <span class="k">function</span> <span class="nf">inner</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$x</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// *** wrong *** &#39;inner&#39; returns 0 * 19, not ($arg + 35) * 19</span>
  <span class="k">return</span> <span class="nv">$x</span> <span class="o">+</span> <span class="nx">inner</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="k">function</span> <span class="nf">outer</span><span class="p">(</span><span class="nv">$arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nv">$x</span> <span class="o">=</span> <span class="nv">$arg</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>

  <span class="c1">// No implicit access to outer function scope; any required data must be</span>
  <span class="c1">// explicity passed</span>
  <span class="k">function</span> <span class="nf">inner</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$x</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">return</span> <span class="nv">$x</span> <span class="o">+</span> <span class="nx">inner</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------ </span>

<span class="c1">// Equivalent to previously-shown code</span>
<span class="k">function</span> <span class="nf">inner</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nv">$x</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">outer</span><span class="p">(</span><span class="nv">$arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nv">$x</span> <span class="o">=</span> <span class="nv">$arg</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>
  <span class="k">return</span> <span class="nv">$x</span> <span class="o">+</span> <span class="nx">inner</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN587"
>Program: Sorting Your Mail</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// @@INCOMPLETE@@</span>
<span class="c1">// @@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Directories</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>References and Records</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>