<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>File Access</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Perl"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Pattern Matching"
HREF="patternmatching.html"><LINK
REL="NEXT"
TITLE="File Contents"
HREF="filecontents.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Perl</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="patternmatching.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="filecontents.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FILEACCESS"
>7. File Access</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN359"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">open(INPUT, &quot;&lt; /usr/local/widgets/data&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open /usr/local/widgets/data for reading: $!\n&quot;;</span>

<span class="cp">while (&lt;INPUT&gt;) {</span>
<span class="cp">    print if /blue/;</span>
<span class="cp">}</span>
<span class="cp">close(INPUT);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$var = *STDIN;</span>
<span class="cp">mysub($var, *LOGFILE);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>

<span class="cp">$input = IO::File-&gt;new(&quot;&lt; /usr/local/widgets/data&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open /usr/local/widgets/data for reading: $!\n&quot;;</span>

<span class="cp">while (defined($line = $input-&gt;getline())) {</span>
<span class="cp">    chomp($line);</span>
<span class="cp">    STDOUT-&gt;print($line) if $line =~ /blue/;</span>
<span class="cp">}</span>
<span class="cp">$input-&gt;close();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;STDIN&gt;) {                   # reads from STDIN</span>
<span class="cp">    unless (/\d/) {</span>
<span class="cp">        warn &quot;No digit found.\n&quot;;   # writes to STDERR</span>
<span class="cp">    }</span>
<span class="cp">    print &quot;Read: &quot;, $_;             # writes to STDOUT</span>
<span class="cp">}</span>
<span class="cp">END { close(STDOUT)                 or die &quot;couldn&#39;t close STDOUT: $!&quot; }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(LOGFILE, &quot;&gt; /tmp/log&quot;)     or die &quot;Can&#39;t write /tmp/log: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">close(FH)           or die &quot;FH didn&#39;t close: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$old_fh = select(LOGFILE);                  # switch to LOGFILE for output</span>
<span class="cp">print &quot;Countdown initiated ...\n&quot;;</span>
<span class="cp">select($old_fh);                            # return to original output</span>
<span class="cp">print &quot;You have 30 seconds to reach minimum safety distance.\n&quot;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN362"
>Opening a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">open(SOURCE, &quot;&lt; $path&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for reading: $!\n&quot;;</span>

<span class="cp">open(SINK, &quot;&gt; $path&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for writing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;</span>

<span class="cp">sysopen(SOURCE, $path, O_RDONLY)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for reading: $!\n&quot;;</span>

<span class="cp">sysopen(SINK, $path, O_WRONLY)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for writing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>

<span class="cp"># like Perl&#39;s open</span>
<span class="cp">$fh = IO::File-&gt;new(&quot;&gt; $filename&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $filename for writing: $!\n&quot;;</span>

<span class="cp"># like Perl&#39;s sysopen</span>
<span class="cp">$fh = IO::File-&gt;new($filename, O_WRONLY|O_CREAT)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $filename for writing: $!\n&quot;;</span>

<span class="cp"># like stdio&#39;s fopen(3)</span>
<span class="cp">$fh = IO::File-&gt;new($filename, &quot;r+&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $filename for read and write: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FILEHANDLE, $name, $flags)         or die &quot;Can&#39;t open $name : $!&quot;;</span>
<span class="cp">sysopen(FILEHANDLE, $name, $flags, $perms) or die &quot;Can&#39;t open $name : $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;&lt; $path&quot;)                                 or die $!;</span>
<span class="cp">sysopen(FH, $path, O_RDONLY)                        or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;&gt; $path&quot;)                                 or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT)        or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT, 0600)  or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT)         or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT, 0600)   or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;&gt;&gt; $path&quot;)                                or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT)       or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT, 0600) or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_APPEND)               or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;+&lt; $path&quot;)                                or die $!;</span>
<span class="cp">sysopen(FH, $path, O_RDWR)                          or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FH, $path, O_RDWR|O_CREAT)                  or die $!;</span>
<span class="cp">sysopen(FH, $path, O_RDWR|O_CREAT, 0600)            or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT)           or die $!;</span>
<span class="cp">sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT, 0600)     or die $!;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN365"
>Opening Files with Unusual Filenames</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$filename =~ s#^(\s)#./$1#;</span>
<span class="cp">open(HANDLE, &quot;&lt; $filename\0&quot;)          or die &quot;cannot open $filename : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(HANDLE, $filename, O_RDONLY)   or die &quot;cannot open $filename: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$filename = shift @ARGV;</span>
<span class="cp">open(INPUT, $filename)               or die &quot;Couldn&#39;t open $filename : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(OUTPUT, &quot;&gt;$filename&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $filename for writing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;                          # for file constants</span>

<span class="cp">sysopen(OUTPUT, $filename, O_WRONLY|O_TRUNC)</span>
<span class="cp">    or die &quot;Can&#39;t open $filename for writing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file =~ s#^(\s)#./$1#;</span>
<span class="cp">open(OUTPUT, &quot;&gt; $file\0&quot;)</span>
<span class="cp">        or die &quot;Couldn&#39;t open $file for OUTPUT : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN368"
>Expanding Tildes in Filenames</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$filename =~ s{ ^ ~ ( [^/]* ) }</span>
<span class="cp">              { $1</span>
<span class="cp">                    ? (getpwnam($1))[7]</span>
<span class="cp">                    : ( $ENV{HOME} || $ENV{LOGDIR}</span>
<span class="cp">                         || (getpwuid($&gt;))[7]</span>
<span class="cp">                       )</span>
<span class="cp">}ex;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#    ~user</span>
<span class="cp">#    ~user/blah</span>
<span class="cp">#    ~</span>
<span class="cp">#    ~/blah</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN371"
>Making Perl Report Filenames in Errors</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">open($path, &quot;&lt; $path&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for reading : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Argument &quot;3\n&quot; isn&#39;t numeric in multiply at tallyweb line 16, &lt;LOG&gt; chunk 17.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Argument &quot;3\n&quot; isn&#39;t numeric in multiply at tallyweb</span>
<span class="cp">#</span>
<span class="cp">#    line 16, &lt;/usr/local/data/mylog3.dat&gt; chunk 17.</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN374"
>Creating Temporary Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>

<span class="cp">$fh = IO::File-&gt;new_tmpfile</span>
<span class="cp">        or die &quot;Unable to make new temporary file: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>
<span class="cp">use POSIX qw(tmpnam);</span>

<span class="cp"># try new temporary filenames until we get one that didn&#39;t already exist</span>
<span class="cp">do { $name = tmpnam() }</span>
<span class="cp">    until $fh = IO::File-&gt;new($name, O_RDWR|O_CREAT|O_EXCL);</span>

<span class="cp"># install atexit-style handler so that when we exit or die,</span>
<span class="cp"># we automatically delete this temporary file</span>
<span class="cp">END { unlink($name) or die &quot;Couldn&#39;t unlink $name : $!&quot; }</span>

<span class="cp"># now go on to use the file ...</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for (;;) {</span>
<span class="cp">    $name = tmpnam();</span>
<span class="cp">    sysopen(TMP, $tmpnam, O_RDWR | O_CREAT | O_EXCL) &amp;&amp; last;</span>
<span class="cp">}</span>
<span class="cp">unlink $tmpnam;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>

<span class="cp">$fh = IO::File-&gt;new_tmpfile             or die &quot;IO::File-&gt;new_tmpfile: $!&quot;;</span>
<span class="cp">$fh-&gt;autoflush(1);</span>
<span class="cp">print $fh &quot;$i\n&quot; while $i++ &lt; 10;</span>
<span class="cp">seek($fh, 0, 0)                         or die &quot;seek: $!&quot;;</span>
<span class="cp">print &quot;Tmp file has: &quot;, &lt;$fh&gt;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN377"
>Storing Files Inside Your Program Text</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;DATA&gt;) {</span>
<span class="cp">    # process the line</span>
<span class="cp">}</span>
<span class="cp">#__DATA__</span>
<span class="cp"># your data goes here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;main::DATA&gt;) {</span>
<span class="cp">    # process the line</span>
<span class="cp">}</span>
<span class="cp">#__END__</span>
<span class="cp"># your data goes here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(strftime);</span>

<span class="cp">$raw_time = (stat(DATA))[9];</span>
<span class="cp">$size     = -s DATA;</span>
<span class="cp">$kilosize = int($size / 1024) . &#39;k&#39;;</span>

<span class="cp">print &quot;&lt;P&gt;Script size is $kilosize\n&quot;;</span>
<span class="cp">print strftime(&quot;&lt;P&gt;Last script update: %c (%Z)\n&quot;, localtime($raw_time));</span>

<span class="cp">#__DATA__</span>
<span class="cp">#DO NOT REMOVE THE PRECEDING LINE.</span>
<span class="cp">#Everything else in this file will be ignored.</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN380"
>Writing a Filter</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    # do something with the line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    # ...</span>
<span class="cp"> }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unshift(@ARGV, &#39;-&#39;) unless @ARGV;</span>
<span class="cp">while ($ARGV = shift @ARGV) {</span>
<span class="cp">    unless (open(ARGV, $ARGV)) {</span>
<span class="cp">        warn &quot;Can&#39;t open $ARGV: $!\n&quot;;</span>
<span class="cp">        next;</span>
<span class="cp">    }</span>
<span class="cp">    while (defined($_ = &lt;ARGV&gt;)) {</span>
<span class="cp">        # ...</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ARGV = glob(&quot;*.[Cch]&quot;) unless @ARGV;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># arg demo 1: Process optional -c flag </span>
<span class="cp">if (@ARGV &amp;&amp; $ARGV[0] eq &#39;-c&#39;) { </span>
<span class="cp">    $chop_first++;</span>
<span class="cp">    shift;</span>
<span class="cp">}</span>

<span class="cp"># arg demo 2: Process optional -NUMBER flag    </span>
<span class="cp">if (@ARGV &amp;&amp; $ARGV[0] =~ /^-(\d+)$/) { </span>
<span class="cp">    $columns = $1; </span>
<span class="cp">    shift;</span>
<span class="cp">}</span>

<span class="cp"># arg demo 3: Process clustering -a, -i, -n, or -u flags     </span>
<span class="cp">while (@ARGV &amp;&amp; $ARGV[0] =~ /^-(.+)/ &amp;&amp; (shift, ($_ = $1), 1)) { </span>
<span class="cp">    next if /^$/; </span>
<span class="cp">    s/a// &amp;&amp; (++$append,      redo);</span>
<span class="cp">    s/i// &amp;&amp; (++$ignore_ints, redo); </span>
<span class="cp">    s/n// &amp;&amp; (++$nostdout,    redo); </span>
<span class="cp">    s/u// &amp;&amp; (++$unbuffer,    redo); </span>
<span class="cp">    die &quot;usage: $0 [-ainu] [filenames] ...\n&quot;;    </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">undef $/;		     </span>
<span class="cp">while (&lt;&gt;) { 	</span>
<span class="cp">    # $_ now has the complete contents of 	</span>
<span class="cp">    # the file whose name is in $ARGV     </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{     # create block for local 	</span>
<span class="cp">    local $/;         # record separator now undef 	</span>
<span class="cp">    while (&lt;&gt;) { 	    </span>
<span class="cp">        # do something; called functions still have 	    </span>
<span class="cp">        # undeffed version of $/ 	</span>
<span class="cp">    }     </span>
<span class="cp">}                     # $/ restored here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) { 	</span>
<span class="cp">    print &quot;$ARGV:$.:$_&quot;; 	</span>
<span class="cp">    close ARGV if eof;     </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/findlogin1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl   </span>
<span class="cp"># findlogin1 - print all lines containing the string &quot;login&quot;   </span>
<span class="cp">while (&lt;&gt;) {		# loop over files on command line 	</span>
<span class="cp">    print if /login/;     </span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/findlogin2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -n     </span>
<span class="cp"># findlogin2 - print all lines containing the string &quot;login&quot;     </span>
<span class="cp">print if /login/;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -ne &#39;print if /login/&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/lowercase1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># lowercase - turn all lines into lowercase</span>

<span class="cp">use locale;</span>
<span class="cp">while (&lt;&gt;) {                 # loop over lines on command line</span>
<span class="cp">    s/([^\W0-9_])/\l$1/g;    # change all letters to lowercase</span>
<span class="cp">    print;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/lowercase2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -p     </span>
<span class="cp"># lowercase - turn all lines into lowercase     </span>
<span class="cp">use locale;     </span>
<span class="cp">s/([^\W0-9_])/\l$1/g;	# change all letters to lowercase</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -Mlocale -pe &#39;s/([^\W0-9_])/\l$1/g&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/countchunks</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -n    </span>
<span class="cp"># countchunks - count how many words are used.    </span>
<span class="cp"># skip comments, and bail on file if _     _END_     _   </span>
<span class="cp"># or _     _DATA_     _ seen.    </span>
<span class="cp">for (split /\W+/) { </span>
<span class="cp">    next LINE if /^#/; </span>
<span class="cp">    close ARGV if /_     _(DATA|END)_     _/; </span>
<span class="cp">    $chunks++;     </span>
<span class="cp">}     </span>
<span class="cp">END { print &quot;Found $chunks chunks\n&quot; }</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#+0894382237</span>
<span class="cp">#less /etc/motd</span>
<span class="cp">#+0894382239</span>
<span class="cp">#vi ~/.exrc</span>
<span class="cp">#+0894382242</span>
<span class="cp">#date</span>
<span class="cp">#+0894382242</span>
<span class="cp">#who</span>
<span class="cp">#+0894382288</span>
<span class="cp">#telnet home</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -pe &#39;s/^#\+(\d+)\n/localtime($1) . &quot; &quot;/e&#39; </span>
<span class="cp">#Tue May  5 09:30:37 1998     less /etc/motd </span>
<span class="cp">#</span>
<span class="cp">#Tue May  5 09:30:39 1998     vi ~/.exrc </span>
<span class="cp">#</span>
<span class="cp">#Tue May  5 09:30:42 1998     date</span>
<span class="cp">#</span>
<span class="cp">#Tue May  5 09:30:42 1998     who </span>
<span class="cp">#</span>
<span class="cp">#Tue May  5 09:31:28 1998     telnet home</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN383"
>Modifying a File in Place with Temporary File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">open(OLD, &quot;&lt; $old&quot;)         or die &quot;can&#39;t open $old: $!&quot;;</span>
<span class="cp">open(NEW, &quot;&gt; $new&quot;)         or die &quot;can&#39;t open $new: $!&quot;;</span>
<span class="cp">while (&lt;OLD&gt;) {</span>
<span class="cp">    # change $_, then...</span>
<span class="cp">    print NEW $_            or die &quot;can&#39;t write $new: $!&quot;;</span>
<span class="cp">}</span>
<span class="cp">close(OLD)                  or die &quot;can&#39;t close $old: $!&quot;;</span>
<span class="cp">close(NEW)                  or die &quot;can&#39;t close $new: $!&quot;;</span>
<span class="cp">rename($old, &quot;$old.orig&quot;)   or die &quot;can&#39;t rename $old to $old.orig: $!&quot;;</span>
<span class="cp">rename($new, $old)          or die &quot;can&#39;t rename $new to $old: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;OLD&gt;) {</span>
<span class="cp">    if ($. == 20) {</span>
<span class="cp">        print NEW &quot;Extra line 1\n&quot;;</span>
<span class="cp">        print NEW &quot;Extra line 2\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    print NEW $_;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;OLD&gt;) {</span>
<span class="cp">    next if 20 .. 30;</span>
<span class="cp">    print NEW $_;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN386"
>Modifying a File in Place with -i Switch</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">#% perl -i.orig -p -e &#39;FILTER COMMAND&#39; file1 file2 file3 ...</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl -i.orig -p</span>
<span class="cp"># filter commands go here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -pi.orig -e &#39;s/DATE/localtime/e&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    if ($ARGV ne $oldargv) {           # are we at the next file?</span>
<span class="cp">        rename($ARGV, $ARGV . &#39;.orig&#39;);</span>
<span class="cp">        open(ARGVOUT, &quot;&gt;$ARGV&quot;);       # plus error check</span>
<span class="cp">        select(ARGVOUT);</span>
<span class="cp">        $oldargv = $ARGV;</span>
<span class="cp">    }</span>
<span class="cp">    s/DATE/localtime/e;</span>
<span class="cp">}</span>
<span class="cp">continue{</span>
<span class="cp">    print;</span>
<span class="cp">}</span>
<span class="cp">select (STDOUT);                      # restore default output</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Dear Sir/Madam/Ravenous Beast,</span>
<span class="cp">#    As of DATE, our records show your account</span>
<span class="cp">#is overdue.  Please settle by the end of the month.</span>
<span class="cp">#Yours in cheerful usury,</span>
<span class="cp">#    --A. Moneylender</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Dear Sir/Madam/Ravenous Beast,</span>
<span class="cp">#    As of Sat Apr 25 12:28:33 1998, our records show your account</span>
<span class="cp">#is overdue.  Please settle by the end of the month.</span>
<span class="cp">#Yours in cheerful usury,</span>
<span class="cp">#    --A. Moneylender</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -i.old -pe &#39;s{\bhisvar\b}{hervar}g&#39; *.[Cchy]</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># set up to iterate over the *.c files in the current directory,</span>
<span class="cp"># editing in place and saving the old file with a .orig extension</span>
<span class="cp">local $^I   = &#39;.orig&#39;;              # emulate  -i.orig</span>
<span class="cp">local @ARGV = glob(&quot;*.c&quot;);          # initialize list of files</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    if ($. == 1) {</span>
<span class="cp">        print &quot;This line should appear at the top of each file\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    s/\b(p)earl\b/${1}erl/ig;       # Correct typos, preserving case</span>
<span class="cp">    print;</span>
<span class="cp">} continue {close ARGV if eof} </span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN389"
>Modifying a File in Place Without a Temporary File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;+&lt; FILE&quot;)                 or die &quot;Opening: $!&quot;;</span>
<span class="cp">@ARRAY = &lt;FH&gt;;</span>
<span class="cp"># change ARRAY here</span>
<span class="cp">seek(FH,0,0)                        or die &quot;Seeking: $!&quot;;</span>
<span class="cp">print FH @ARRAY                     or die &quot;Printing: $!&quot;;</span>
<span class="cp">truncate(FH,tell(FH))               or die &quot;Truncating: $!&quot;;</span>
<span class="cp">close(FH)                           or die &quot;Closing: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(F, &quot;+&lt; $infile&quot;)       or die &quot;can&#39;t read $infile: $!&quot;;</span>
<span class="cp">$out = &#39;&#39;;</span>
<span class="cp">while (&lt;F&gt;) {</span>
<span class="cp">    s/DATE/localtime/eg;</span>
<span class="cp">    $out .= $_;</span>
<span class="cp">}</span>
<span class="cp">seek(F, 0, 0)               or die &quot;can&#39;t seek to start of $infile: $!&quot;;</span>
<span class="cp">print F $out                or die &quot;can&#39;t print to $infile: $!&quot;;</span>
<span class="cp">truncate(F, tell(F))        or die &quot;can&#39;t truncate $infile: $!&quot;;</span>
<span class="cp">close(F)                    or die &quot;can&#39;t close $infile: $!&quot;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN392"
>Locking a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;+&lt; $path&quot;)                or die &quot;can&#39;t open $path: $!&quot;;</span>
<span class="cp">flock(FH, 2)                        or die &quot;can&#39;t flock $path: $!&quot;;</span>
<span class="cp"># update file, then...</span>
<span class="cp">close(FH)                           or die &quot;can&#39;t close $path: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub LOCK_SH()  { 1 }     #  Shared lock (for reading)</span>
<span class="cp">sub LOCK_EX()  { 2 }     #  Exclusive lock (for writing)</span>
<span class="cp">sub LOCK_NB()  { 4 }     #  Non-blocking request (don&#39;t stall)</span>
<span class="cp">sub LOCK_UN()  { 8 }     #  Free the lock (careful!)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unless (flock(FH, LOCK_EX|LOCK_NB)) {</span>
<span class="cp">    warn &quot;can&#39;t immediately write-lock the file ($!), blocking ...&quot;;</span>
<span class="cp">    unless (flock(FH, LOCK_EX)) {</span>
<span class="cp">        die &quot;can&#39;t get write-lock on numfile: $!&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($] &lt; 5.004) {                   # test Perl version number</span>
<span class="cp">     my $old_fh = select(FH);</span>
<span class="cp">     local $| = 1;                  # enable command buffering</span>
<span class="cp">     local $\ = &#39;&#39;;                 # clear output record separator</span>
<span class="cp">     print &quot;&quot;;                      # trigger output flush</span>
<span class="cp">     select($old_fh);               # restore previous filehandle</span>
<span class="cp">}</span>
<span class="cp">flock(FH, LOCK_UN);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl qw(:DEFAULT :flock);</span>

<span class="cp">sysopen(FH, &quot;numfile&quot;, O_RDWR|O_CREAT)</span>
<span class="cp">                                    or die &quot;can&#39;t open numfile: $!&quot;;</span>
<span class="cp">flock(FH, LOCK_EX)                  or die &quot;can&#39;t write-lock numfile: $!&quot;;</span>
<span class="cp"># Now we have acquired the lock, it&#39;s safe for I/O</span>
<span class="cp">$num = &lt;FH&gt; || 0;                   # DO NOT USE &quot;or&quot; THERE!!</span>
<span class="cp">seek(FH, 0, 0)                      or die &quot;can&#39;t rewind numfile : $!&quot;;</span>
<span class="cp">truncate(FH, 0)                     or die &quot;can&#39;t truncate numfile: $!&quot;;</span>
<span class="cp">print FH $num+1, &quot;\n&quot;               or die &quot;can&#39;t write numfile: $!&quot;;</span>
<span class="cp">close(FH)                           or die &quot;can&#39;t close numfile: $!&quot;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN395"
>Flushing Output</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$old_fh = select(OUTPUT_HANDLE);</span>
<span class="cp">$| = 1;</span>
<span class="cp">select($old_fh);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Handle;</span>
<span class="cp">OUTPUT_HANDLE-&gt;autoflush(1);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/seeme</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># seeme - demo stdio output buffering</span>
<span class="cp">$| = (@ARGV &gt; 0);      # command buffered if arguments given</span>
<span class="cp">print &quot;Now you don&#39;t see it...&quot;;</span>
<span class="cp">sleep 2;</span>
<span class="cp">print &quot;now you do\n&quot;;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">    select((select(OUTPUT_HANDLE), $| = 1)[0]);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use FileHandle;</span>

<span class="cp">STDERR-&gt;autoflush;          # already unbuffered in stdio</span>
<span class="cp">$filehandle-&gt;autoflush(0);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Handle;</span>
<span class="cp"># assume REMOTE_CONN is an interactive socket handle,</span>
<span class="cp"># but DISK_FILE is a handle to a regular file.</span>
<span class="cp">autoflush REMOTE_CONN  1;           # unbuffer for clarity</span>
<span class="cp">autoflush DISK_FILE    0;           # buffer this for speed</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/getpcomidx</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># getpcomidx - fetch www.perl.com&#39;s index.html document</span>
<span class="cp">use IO::Socket;</span>
<span class="cp">$sock = new IO::Socket::INET (PeerAddr =&gt; &#39;www.perl.com&#39;,</span>
<span class="cp">                              PeerPort =&gt; &#39;http(80)&#39;);</span>
<span class="cp">die &quot;Couldn&#39;t create socket: $@&quot; unless $sock;</span>
<span class="cp"># the library doesn&#39;t support $! setting; it uses $@</span>

<span class="cp">$sock-&gt;autoflush(1);</span>

<span class="cp"># Mac *must* have \015\012\015\012 instead of \n\n here.</span>
<span class="cp"># It&#39;s a good idea for others, too, as that&#39;s the spec,</span>
<span class="cp"># but implementations are encouraged to accept &quot;\cJ\cJ&quot; too,</span>
<span class="cp"># and as far as we&#39;re seen, they do.</span>
<span class="cp">$sock-&gt;print(&quot;GET /index.html http/1.1\n\n&quot;);</span>
<span class="cp">$document = join(&#39;&#39;, $sock-&gt;getlines());</span>
<span class="cp">print &quot;DOC IS: $document\n&quot;;</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN398"
>Reading from Many Filehandles Without Blocking</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$rin = &#39;&#39;;</span>
<span class="cp"># repeat next line for all filehandles to poll</span>
<span class="cp">vec($rin, fileno(FH1), 1) = 1;</span>
<span class="cp">vec($rin, fileno(FH2), 1) = 1;</span>
<span class="cp">vec($rin, fileno(FH3), 1) = 1;</span>

<span class="cp">$nfound = select($rout=$rin, undef, undef, 0);</span>
<span class="cp">if ($nfound) {</span>
<span class="cp">  # input waiting on one or more of those 3 filehandles</span>
<span class="cp">  if (vec($rout,fileno(FH1),1)) { </span>
<span class="cp">      # do something with FH1</span>
<span class="cp">  }</span>
<span class="cp">  if (vec($rout,fileno(FH2),1)) {</span>
<span class="cp">      # do something with FH2</span>
<span class="cp">  }</span>
<span class="cp">  if (vec($rout,fileno(FH3),1)) {</span>
<span class="cp">      # do something with FH3</span>
<span class="cp">  }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Select;</span>

<span class="cp">$select = IO::Select-&gt;new();</span>
<span class="cp"># repeat next line for all filehandles to poll</span>
<span class="cp">$select-&gt;add(*FILEHANDLE);</span>
<span class="cp">if (@ready = $select-&gt;can_read(0)) {</span>
<span class="cp">    # input waiting on the filehandles in @ready</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$rin = &#39;&#39;;</span>
<span class="cp">vec($rin, fileno(FILEHANDLE), 1) = 1;</span>
<span class="cp">$nfound = select($rin, undef, undef, 0);    # just check</span>
<span class="cp">if ($nfound) {</span>
<span class="cp">    $line = &lt;FILEHANDLE&gt;;</span>
<span class="cp">    print &quot;I read $line&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN401"
>Doing Non-Blocking I/O</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;</span>

<span class="cp">sysopen(MODEM, &quot;/dev/cua0&quot;, O_NONBLOCK|O_RDWR)</span>
<span class="cp">    or die &quot;Can&#39;t open modem: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;</span>

<span class="cp">$flags = &#39;&#39;;</span>
<span class="cp">fcntl(HANDLE, F_GETFL, $flags)</span>
<span class="cp">    or die &quot;Couldn&#39;t get flags for HANDLE : $!\n&quot;;</span>
<span class="cp">$flags |= O_NONBLOCK;</span>
<span class="cp">fcntl(HANDLE, F_SETFL, $flags)</span>
<span class="cp">    or die &quot;Couldn&#39;t set flags for HANDLE: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(:errno_h);</span>

<span class="cp">$rv = syswrite(HANDLE, $buffer, length $buffer);</span>
<span class="cp">if (!defined($rv) &amp;&amp; $! == EAGAIN) {</span>
<span class="cp">    # would block</span>
<span class="cp">} elsif ($rv != length $buffer) {</span>
<span class="cp">    # incomplete write</span>
<span class="cp">} else {</span>
<span class="cp">    # successfully wrote</span>
<span class="cp">}</span>

<span class="cp">$rv = sysread(HANDLE, $buffer, $BUFSIZ);</span>
<span class="cp">if (!defined($rv) &amp;&amp; $! == EAGAIN) {</span>
<span class="cp">    # would block</span>
<span class="cp">} else {</span>
<span class="cp">    # successfully read $rv bytes from HANDLE</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN404"
>Determining the Number of Bytes to Read</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$size = pack(&quot;L&quot;, 0);</span>
<span class="cp">ioctl(FH, $FIONREAD, $size)     or die &quot;Couldn&#39;t call ioctl: $!\n&quot;;</span>
<span class="cp">$size = unpack(&quot;L&quot;, $size);</span>

<span class="cp"># $size bytes can be read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require &#39;sys/ioctl.ph&#39;;</span>

<span class="cp">$size = pack(&quot;L&quot;, 0);</span>
<span class="cp">ioctl(FH, FIONREAD(), $size)    or die &quot;Couldn&#39;t call ioctl: $!\n&quot;;</span>
<span class="cp">$size = unpack(&quot;L&quot;, $size);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% grep FIONREAD /usr/include/*/*</span>
<span class="cp">#/usr/include/asm/ioctls.h:#define FIONREAD      0x541B</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% cat &gt; fionread.c</span>
<span class="cp">##include &lt;sys/ioctl.h&gt;</span>
<span class="cp">#main() {</span>
<span class="cp">#</span>
<span class="cp">#    printf(&quot;%#08x\n&quot;, FIONREAD);</span>
<span class="cp">#}</span>
<span class="cp">#^D</span>
<span class="cp">#% cc -o fionread fionread</span>
<span class="cp">#% ./fionread</span>
<span class="cp">#0x4004667f</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$FIONREAD = 0x4004667f;         # XXX: opsys dependent</span>

<span class="cp">$size = pack(&quot;L&quot;, 0);</span>
<span class="cp">ioctl(FH, $FIONREAD, $size)     or die &quot;Couldn&#39;t call ioctl: $!\n&quot;;</span>
<span class="cp">$size = unpack(&quot;L&quot;, $size);</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN407"
>Storing Filehandles in Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$variable = *FILEHANDLE;        # save in variable</span>
<span class="cp">subroutine(*FILEHANDLE);        # or pass directly</span>

<span class="cp">sub subroutine {</span>
<span class="cp">    my $fh = shift;</span>
<span class="cp">    print $fh &quot;Hello, filehandle!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use FileHandle;                   # make anon filehandle</span>
<span class="cp">$fh = FileHandle-&gt;new();</span>

<span class="cp">use IO::File;                     # 5.004 or higher</span>
<span class="cp">$fh = IO::File-&gt;new();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$fh_a = IO::File-&gt;new(&quot;&lt; /etc/motd&quot;)    or die &quot;open /etc/motd: $!&quot;;</span>
<span class="cp">$fh_b = *STDIN;</span>
<span class="cp">some_sub($fh_a, $fh_b);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub return_fh {             # make anon filehandle</span>
<span class="cp">    local *FH;              # must be local, not my</span>
<span class="cp">    # now open it if you want to, then...</span>
<span class="cp">    return *FH;</span>
<span class="cp">}</span>

<span class="cp">$handle = return_fh();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub accept_fh {</span>
<span class="cp">    my $fh = shift;</span>
<span class="cp">    print $fh &quot;Sending to indirect filehandle\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub accept_fh {</span>
<span class="cp">    local *FH = shift;</span>
<span class="cp">    print  FH &quot;Sending to localized filehandle\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">accept_fh(*STDOUT);</span>
<span class="cp">accept_fh($handle);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@fd = (*STDIN, *STDOUT, *STDERR);</span>
<span class="cp">print $fd[1] &quot;Type it: &quot;;                           # WRONG</span>
<span class="cp">$got = &lt;$fd[0]&gt;                                     # WRONG</span>
<span class="cp">print $fd[2] &quot;What was that: $got&quot;;                 # WRONG</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print  { $fd[1] } &quot;funny stuff\n&quot;;</span>
<span class="cp">printf { $fd[1] } &quot;Pity the poor %x.\n&quot;, 3_735_928_559;</span>
<span class="cp">Pity the poor deadbeef.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ok = -x &quot;/bin/cat&quot;;                </span>
<span class="cp">print { $ok ? $fd[1] : $fd[2] } &quot;cat stat $ok\n&quot;;</span>
<span class="cp">print { $fd[ 1 + ($ok || 0) ]  } &quot;cat stat $ok\n&quot;;           </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$got = readline($fd[0]);</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN410"
>Caching Open Output Filehandles</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">use FileCache;</span>
<span class="cp">cacheout ($path);         # each time you use a filehandle</span>
<span class="cp">print $path &quot;output&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/splitwulog</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># splitwulog - split wuftpd log by authenticated user</span>
<span class="cp">use FileCache;</span>
<span class="cp">$outdir = &#39;/var/log/ftp/by-user&#39;;</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    unless (defined ($user = (split)[-4])) {</span>
<span class="cp">       warn &quot;Invalid line: $.\n&quot;;</span>
<span class="cp">       next;</span>
<span class="cp">    }</span>
<span class="cp">    $path = &quot;$outdir/$user&quot;;</span>
<span class="cp">    cacheout $path;</span>
<span class="cp">    print $path $_;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN413"
>Printing to Many Filehandles Simultaneously</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">foreach $filehandle (@FILEHANDLES) {</span>
<span class="cp">    print $filehandle $stuff_to_print;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(MANY, &quot;| tee file1 file2 file3 &gt; /dev/null&quot;)   or die $!;</span>
<span class="cp">print MANY &quot;data\n&quot;                                 or die $!;</span>
<span class="cp">close(MANY)                                         or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># `use strict&#39; complains about this one:</span>
<span class="cp">for $fh (&#39;FH1&#39;, &#39;FH2&#39;, &#39;FH3&#39;)   { print $fh &quot;whatever\n&quot; }</span>
<span class="cp"># but not this one:</span>
<span class="cp">for $fh (*FH1, *FH2, *FH3)      { print $fh &quot;whatever\n&quot; }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open (FH, &quot;| tee file1 file2 file3 &gt;/dev/null&quot;);</span>
<span class="cp">print FH &quot;whatever\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># make STDOUT go to three files, plus original STDOUT</span>
<span class="cp">open (STDOUT, &quot;| tee file1 file2 file3&quot;) or die &quot;Teeing off: $!\n&quot;;</span>
<span class="cp">print &quot;whatever\n&quot;                       or die &quot;Writing: $!\n&quot;;</span>
<span class="cp">close(STDOUT)                            or die &quot;Closing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN416"
>Opening and Closing File Descriptors by Number</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;&lt;&amp;=$FDNUM&quot;);      # open FH to the descriptor itself</span>
<span class="cp">open(FH, &quot;&lt;&amp;$FDNUM&quot;);       # open FH to a copy of the descriptor</span>

<span class="cp">use IO::Handle;</span>

<span class="cp">$fh-&gt;fdopen($FDNUM, &quot;r&quot;);   # open file descriptor 3 for reading</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Handle;</span>
<span class="cp">$fh = IO::Handle-&gt;new();</span>

<span class="cp">$fh-&gt;fdopen(3, &quot;r&quot;);            # open fd 3 for reading</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$fd = $ENV{MHCONTEXTFD};</span>
<span class="cp">open(MHCONTEXT, &quot;&lt;&amp;=$fd&quot;)   or die &quot;couldn&#39;t fdopen $fd: $!&quot;;</span>
<span class="cp"># after processing</span>
<span class="cp">close(MHCONTEXT)            or die &quot;couldn&#39;t close context file: $!&quot;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN419"
>Copying Filehandles</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">*ALIAS = *ORIGINAL;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(OUTCOPY, &quot;&gt;&amp;STDOUT&quot;)   or die &quot;Couldn&#39;t dup STDOUT: $!&quot;;</span>
<span class="cp">open(INCOPY,  &quot;&lt;&amp;STDIN&quot; )   or die &quot;Couldn&#39;t dup STDIN : $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(OUTALIAS, &quot;&gt;&amp;=STDOUT&quot;) or die &quot;Couldn&#39;t alias STDOUT: $!&quot;;</span>
<span class="cp">open(INALIAS,  &quot;&lt;&amp;=STDIN&quot;)  or die &quot;Couldn&#39;t alias STDIN : $!&quot;;</span>
<span class="cp">open(BYNUMBER, &quot;&gt;&amp;=5&quot;)      or die &quot;Couldn&#39;t alias file descriptor 5: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># take copies of the file descriptors</span>
<span class="cp">open(OLDOUT, &quot;&gt;&amp;STDOUT&quot;);</span>
<span class="cp">open(OLDERR, &quot;&gt;&amp;STDERR&quot;);</span>

<span class="cp"># redirect stdout and stderr</span>
<span class="cp">open(STDOUT, &quot;&gt; /tmp/program.out&quot;)  or die &quot;Can&#39;t redirect stdout: $!&quot;;</span>
<span class="cp">open(STDERR, &quot;&gt;&amp;STDOUT&quot;)            or die &quot;Can&#39;t dup stdout: $!&quot;;</span>

<span class="cp"># run the program</span>
<span class="cp">system($joe_random_program);</span>

<span class="cp"># close the redirected filehandles</span>
<span class="cp">close(STDOUT)                       or die &quot;Can&#39;t close STDOUT: $!&quot;;</span>
<span class="cp">close(STDERR)                       or die &quot;Can&#39;t close STDERR: $!&quot;;</span>

<span class="cp"># restore stdout and stderr</span>
<span class="cp">open(STDERR, &quot;&gt;&amp;OLDERR&quot;)            or die &quot;Can&#39;t restore stderr: $!&quot;;</span>
<span class="cp">open(STDOUT, &quot;&gt;&amp;OLDOUT&quot;)            or die &quot;Can&#39;t restore stdout: $!&quot;;</span>

<span class="cp"># avoid leaks by closing the independent copies</span>
<span class="cp">close(OLDOUT)                       or die &quot;Can&#39;t close OLDOUT: $!&quot;;</span>
<span class="cp">close(OLDERR)                       or die &quot;Can&#39;t close OLDERR: $!&quot;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN422"
>Program: netlock</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/drivelock</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># drivelock - demo File::LockDir module</span>
<span class="cp">use strict;</span>
<span class="cp">use File::LockDir;</span>
<span class="cp">$SIG{INT} = sub { die &quot;outta here\n&quot; };</span>
<span class="cp">$File::LockDir::Debug = 1;</span>
<span class="cp">my $path = shift                            or die &quot;usage: $0 &lt;path&gt;\n&quot;;</span>
<span class="cp">unless (nflock($path, 2)) {</span>
<span class="cp">    die &quot;couldn&#39;t lock $path in 2 seconds\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">sleep 100;</span>
<span class="cp">nunflock($path);</span>

<span class="cp">#-----------------------------</span>
<span class="cp">package File::LockDir;</span>
<span class="cp"># module to provide very basic filename-level</span>
<span class="cp"># locks.  No fancy systems calls.  In theory,</span>
<span class="cp"># directory info is sync&#39;d over NFS.  Not</span>
<span class="cp"># stress tested.</span>

<span class="cp">use strict;</span>

<span class="cp">use Exporter;</span>
<span class="cp">use vars qw(@ISA @EXPORT);</span>
<span class="cp">@ISA      = qw(Exporter);</span>
<span class="cp">@EXPORT   = qw(nflock nunflock);</span>

<span class="cp">use vars qw($Debug $Check);</span>
<span class="cp">$Debug  ||= 0;  # may be predefined</span>
<span class="cp">$Check  ||= 5;  # may be predefined</span>

<span class="cp">use Cwd;</span>
<span class="cp">use Fcntl;</span>
<span class="cp">use Sys::Hostname;</span>
<span class="cp">use File::Basename;</span>
<span class="cp">use File::stat;</span>
<span class="cp">use Carp;</span>

<span class="cp">my %Locked_Files = ();</span>

<span class="cp"># usage: nflock(FILE; NAPTILL)</span>
<span class="cp">sub nflock($;$) {</span>
<span class="cp">    my $pathname = shift;</span>
<span class="cp">    my $naptime  = shift || 0;</span>
<span class="cp">    my $lockname = name2lock($pathname);</span>
<span class="cp">    my $whosegot = &quot;$lockname/owner&quot;;</span>
<span class="cp">    my $start    = time();</span>
<span class="cp">    my $missed   = 0;</span>
<span class="cp">    local *OWNER;</span>

<span class="cp">    # if locking what I&#39;ve already locked, return</span>
<span class="cp">    if ($Locked_Files{$pathname}) {</span>
<span class="cp">        carp &quot;$pathname already locked&quot;;</span>
<span class="cp">        return 1</span>
<span class="cp">    }</span>

<span class="cp">    if (!-w dirname($pathname)) {</span>
<span class="cp">        croak &quot;can&#39;t write to directory of $pathname&quot;;</span>
<span class="cp">    }</span>

<span class="cp">    while (1) {</span>
<span class="cp">        last if mkdir($lockname, 0777);</span>
<span class="cp">        confess &quot;can&#39;t get $lockname: $!&quot; if $missed++ &gt; 10</span>
<span class="cp">                        &amp;&amp; !-d $lockname;</span>
<span class="cp">        if ($Debug) {{</span>
<span class="cp">            open(OWNER, &quot;&lt; $whosegot&quot;) || last; # exit &quot;if&quot;!</span>
<span class="cp">            my $lockee = &lt;OWNER&gt;;</span>
<span class="cp">            chomp($lockee);</span>
<span class="cp">            printf STDERR &quot;%s $0\[$$]: lock on %s held by %s\n&quot;,</span>
<span class="cp">                scalar(localtime), $pathname, $lockee;</span>
<span class="cp">            close OWNER;</span>
<span class="cp">        }}</span>
<span class="cp">        sleep $Check;</span>
<span class="cp">        return if $naptime &amp;&amp; time &gt; $start+$naptime;</span>
<span class="cp">    }</span>
<span class="cp">    sysopen(OWNER, $whosegot, O_WRONLY|O_CREAT|O_EXCL)</span>
<span class="cp">                            or croak &quot;can&#39;t create $whosegot: $!&quot;;</span>
<span class="cp">    printf OWNER &quot;$0\[$$] on %s since %s\n&quot;,</span>
<span class="cp">            hostname(), scalar(localtime);</span>
<span class="cp">    close(OWNER)                </span>
<span class="cp">        or croak &quot;close $whosegot: $!&quot;;</span>
<span class="cp">    $Locked_Files{$pathname}++;</span>
<span class="cp">    return 1;</span>
<span class="cp">}</span>

<span class="cp"># free the locked file</span>
<span class="cp">sub nunflock($) {</span>
<span class="cp">    my $pathname = shift;</span>
<span class="cp">    my $lockname = name2lock($pathname);</span>
<span class="cp">    my $whosegot = &quot;$lockname/owner&quot;;</span>
<span class="cp">    unlink($whosegot);</span>
<span class="cp">    carp &quot;releasing lock on $lockname&quot; if $Debug;</span>
<span class="cp">    delete $Locked_Files{$pathname};</span>
<span class="cp">    return rmdir($lockname);</span>
<span class="cp">}</span>

<span class="cp"># helper function</span>
<span class="cp">sub name2lock($) {</span>
<span class="cp">    my $pathname = shift;</span>
<span class="cp">    my $dir  = dirname($pathname);</span>
<span class="cp">    my $file = basename($pathname);</span>
<span class="cp">    $dir = getcwd() if $dir eq &#39;.&#39;;</span>
<span class="cp">    my $lockname = &quot;$dir/$file.LOCKDIR&quot;;</span>
<span class="cp">    return $lockname;</span>
<span class="cp">}</span>

<span class="cp"># anything forgotten?</span>
<span class="cp">END {</span>
<span class="cp">    for my $pathname (keys %Locked_Files) {</span>
<span class="cp">        my $lockname = name2lock($pathname);</span>
<span class="cp">        my $whosegot = &quot;$lockname/owner&quot;;</span>
<span class="cp">        carp &quot;releasing forgotten $lockname&quot;;</span>
<span class="cp">        unlink($whosegot);</span>
<span class="cp">        return rmdir($lockname);</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">1;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN425"
>Program: lockarea</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">4: 18584 was just here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">29: 24652 ZAPPED 24656</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% lockarea 5 &amp;</span>
<span class="cp">#% rep -1 &#39;cat /tmp/lkscreen&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/lockarea</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># lockarea - demo record locking with fcntl</span>

<span class="cp">use strict;</span>

<span class="cp">my $FORKS = shift || 1;</span>
<span class="cp">my $SLEEP = shift || 1;</span>

<span class="cp">use Fcntl;</span>
<span class="cp">use POSIX qw(:unistd_h :errno_h);</span>

<span class="cp">my $COLS = 80;</span>
<span class="cp">my $ROWS = 23;</span>

<span class="cp"># when&#39;s the last time you saw *this* mode used correctly?</span>
<span class="cp">open(FH, &quot;+&gt; /tmp/lkscreen&quot;)            or  die $!;</span>

<span class="cp">select(FH);</span>
<span class="cp">$| = 1;</span>
<span class="cp">select STDOUT;</span>

<span class="cp"># clear screen</span>
<span class="cp">for (1 .. $ROWS) {</span>
<span class="cp">        print FH &quot; &quot; x $COLS, &quot;\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">my $progenitor = $$;</span>
<span class="cp">fork while $FORKS-- &gt; 0;</span>

<span class="cp">print &quot;hello from $$\n&quot;;</span>

<span class="cp">if ($progenitor == $$) {</span>
<span class="cp">        $SIG{INT} = \&amp;genocide;</span>
<span class="cp">} else {</span>
<span class="cp">        $SIG{INT} = sub { die &quot;goodbye from $$&quot; };</span>
<span class="cp">}</span>

<span class="cp">while (1) {</span>
<span class="cp">        my $line_num = int rand($ROWS);</span>
<span class="cp">        my $line;</span>
<span class="cp">        my $n;</span>

<span class="cp">        # move to line</span>
<span class="cp">        seek(FH, $n = $line_num * ($COLS+1), SEEK_SET)              or next;</span>

<span class="cp">        # get lock</span>
<span class="cp">        my $place = tell(FH);</span>
<span class="cp">        my $him;</span>
<span class="cp">        next unless defined($him = lock(*FH, $place, $COLS));</span>

<span class="cp">        # read line</span>
<span class="cp">        read(FH, $line, $COLS) == $COLS                             or next;</span>
<span class="cp">        my $count = ($line =~ /(\d+)/) ? $1 : 0;</span>
<span class="cp">        $count++;</span>

<span class="cp">        # update line</span>
<span class="cp">        seek(FH, $place, 0)                                         or die $!;</span>
<span class="cp">        my $update = sprintf($him</span>
<span class="cp">                            ? &quot;%6d: %d ZAPPED %d&quot;</span>
<span class="cp">                            : &quot;%6d: %d was just here&quot;,</span>
<span class="cp">                        $count, $$, $him);</span>
<span class="cp">        my $start = int(rand($COLS - length($update)));</span>
<span class="cp">        die &quot;XXX&quot; if $start + length($update) &gt; $COLS;</span>
<span class="cp">        printf FH &quot;%*.*s\n&quot;, -$COLS, $COLS, &quot; &quot; x $start . $update;</span>

<span class="cp">        # release lock and go to sleep</span>
<span class="cp">        unlock(*FH, $place, $COLS);</span>
<span class="cp">        sleep $SLEEP if $SLEEP;</span>
<span class="cp">}</span>
<span class="cp">die &quot;NOT REACHED&quot;;                              # just in case</span>

<span class="cp"># lock($handle, $offset, $timeout) - get an fcntl lock</span>
<span class="cp">sub lock {</span>
<span class="cp">        my ($fh, $start, $till) = @_;</span>
<span class="cp">        ##print &quot;$$: Locking $start, $till\n&quot;;</span>
<span class="cp">        my $lock = struct_flock(F_WRLCK, SEEK_SET, $start, $till, 0);</span>
<span class="cp">        my $blocker = 0;</span>
<span class="cp">        unless (fcntl($fh, F_SETLK, $lock)) {</span>
<span class="cp">            die &quot;F_SETLK $$ @_: $!&quot; unless $! == EAGAIN || $! == EDEADLK;</span>
<span class="cp">            fcntl($fh, F_GETLK, $lock)          or die &quot;F_GETLK $$ @_: $!&quot;;</span>
<span class="cp">            $blocker = (struct_flock($lock))[-1];</span>
<span class="cp">            ##print &quot;lock $$ @_: waiting for $blocker\n&quot;;</span>
<span class="cp">            $lock = struct_flock(F_WRLCK, SEEK_SET, $start, $till, 0);</span>
<span class="cp">            unless (fcntl($fh, F_SETLKW, $lock)) {</span>
<span class="cp">                warn &quot;F_SETLKW $$ @_: $!\n&quot;;</span>
<span class="cp">                return;  # undef</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">        return $blocker;</span>
<span class="cp">}</span>

<span class="cp"># unlock($handle, $offset, $timeout) - release an fcntl lock</span>
<span class="cp">sub unlock {</span>
<span class="cp">        my ($fh, $start, $till) = @_;</span>
<span class="cp">        ##print &quot;$$: Unlocking $start, $till\n&quot;;</span>
<span class="cp">        my $lock = struct_flock(F_UNLCK, SEEK_SET, $start, $till, 0);</span>
<span class="cp">        fcntl($fh, F_SETLK, $lock) or die &quot;F_UNLCK $$ @_: $!&quot;;</span>
<span class="cp">}</span>

<span class="cp"># OS-dependent flock structures</span>

<span class="cp"># Linux struct flock</span>
<span class="cp">#   short l_type;</span>
<span class="cp">#   short l_whence;</span>
<span class="cp">#   off_t l_start;</span>
<span class="cp">#   off_t l_len;</span>
<span class="cp">#   pid_t l_pid;</span>
<span class="cp">BEGIN {</span>
<span class="cp">        # c2ph says: typedef=&#39;s2 l2 i&#39;, sizeof=16</span>
<span class="cp">        my $FLOCK_STRUCT = &#39;s s l l i&#39;;</span>

<span class="cp">        sub linux_flock {</span>
<span class="cp">            if (wantarray) {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid) =</span>
<span class="cp">                    unpack($FLOCK_STRUCT, $_[0]);</span>
<span class="cp">                return ($type, $whence, $start, $len, $pid);</span>
<span class="cp">            } else {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid) = @_;</span>
<span class="cp">                return pack($FLOCK_STRUCT,</span>
<span class="cp">                        $type, $whence, $start, $len, $pid);</span>
<span class="cp">            }</span>
<span class="cp">        }</span>

<span class="cp">}</span>

<span class="cp"># SunOS struct flock:</span>
<span class="cp">#   short   l_type;         /* F_RDLCK, F_WRLCK, or F_UNLCK */</span>
<span class="cp">#   short   l_whence;       /* flag to choose starting offset */</span>
<span class="cp">#   long    l_start;        /* relative offset, in bytes */</span>
<span class="cp">#   long    l_len;          /* length, in bytes; 0 means lock to EOF */</span>
<span class="cp">#   short   l_pid;          /* returned with F_GETLK */</span>
<span class="cp">#   short   l_xxx;          /* reserved for future use */</span>
<span class="cp">BEGIN {</span>
<span class="cp">        # c2ph says: typedef=&#39;s2 l2 s2&#39;, sizeof=16</span>
<span class="cp">        my $FLOCK_STRUCT = &#39;s s l l s s&#39;;</span>

<span class="cp">        sub sunos_flock {</span>
<span class="cp">            if (wantarray) {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid, $xxx) =</span>
<span class="cp">                    unpack($FLOCK_STRUCT, $_[0]);</span>
<span class="cp">                return ($type, $whence, $start, $len, $pid);</span>
<span class="cp">            } else {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid) = @_;</span>
<span class="cp">                return pack($FLOCK_STRUCT,</span>
<span class="cp">                        $type, $whence, $start, $len, $pid, 0);</span>
<span class="cp">            }</span>
<span class="cp">        }</span>

<span class="cp">}</span>

<span class="cp"># (Free)BSD struct flock:</span>
<span class="cp">#   off_t   l_start;        /* starting offset */</span>
<span class="cp">#   off_t   l_len;          /* len = 0 means until end of file */</span>
<span class="cp">#   pid_t   l_pid;          /* lock owner */</span>
<span class="cp">#   short   l_type;         /* lock type: read/write, etc. */</span>
<span class="cp">#   short   l_whence;       /* type of l_start */</span>
<span class="cp">BEGIN {</span>
<span class="cp">        # c2ph says: typedef=&quot;q2 i s2&quot;, size=24</span>
<span class="cp">        my $FLOCK_STRUCT = &#39;ll ll i s s&#39;;   # XXX: q is ll</span>

<span class="cp">        sub bsd_flock {</span>
<span class="cp">            if (wantarray) {</span>
<span class="cp">                my ($xxstart, $start, $xxlen, $len, $pid, $type, $whence) =</span>
<span class="cp">                    unpack($FLOCK_STRUCT, $_[0]);</span>
<span class="cp">                return ($type, $whence, $start, $len, $pid);</span>
<span class="cp">            } else {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid) = @_;</span>
<span class="cp">                my ($xxstart, $xxlen) = (0,0);</span>
<span class="cp">                return pack($FLOCK_STRUCT,</span>
<span class="cp">                    $xxstart, $start, $xxlen, $len, $pid, $type, $whence);</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">}</span>

<span class="cp"># alias the fcntl structure at compile time</span>
<span class="cp">BEGIN {</span>
<span class="cp">        for ($^O) {</span>
<span class="cp">            *struct_flock =                do                           {</span>
<span class="cp">                                    /bsd/  &amp;&amp;  \&amp;bsd_flock</span>
<span class="cp">                                           ||</span>
<span class="cp">                                /linux/    &amp;&amp;    \&amp;linux_flock</span>
<span class="cp">                                           ||</span>
<span class="cp">                              /sunos/      &amp;&amp;      \&amp;sunos_flock</span>
<span class="cp">                                           ||</span>
<span class="cp">                      die &quot;unknown operating system $^O, bailing out&quot;;</span>
<span class="cp">            };</span>
<span class="cp">        }</span>
<span class="cp">}</span>

<span class="cp"># install signal handler for children</span>
<span class="cp">BEGIN {</span>
<span class="cp">        my $called = 0;</span>

<span class="cp">        sub genocide {</span>
<span class="cp">            exit if $called++;</span>
<span class="cp">            print &quot;$$: Time to die, kiddies.\n&quot; if $$ == $progenitor;</span>
<span class="cp">            my $job = getpgrp();</span>
<span class="cp">            $SIG{INT} = &#39;IGNORE&#39;;</span>
<span class="cp">            kill -2, $job if $job;  # killpg(SIGINT, job)</span>
<span class="cp">            1 while wait &gt; 0;</span>
<span class="cp">            print &quot;$$: My turn\n&quot; if $$ == $progenitor;</span>
<span class="cp">            exit;</span>
<span class="cp">        }</span>
<span class="cp">}</span>

<span class="cp">END { &amp;genocide }</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="patternmatching.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="filecontents.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Pattern Matching</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>File Contents</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>