<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>File Contents</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Perl"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="File Access"
HREF="fileaccess.html"><LINK
REL="NEXT"
TITLE="Directories"
HREF="directories.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Perl</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="fileaccess.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="directories.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FILECONTENTS"
>8. File Contents</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN430"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">while (defined ($line = &lt;DATAFILE&gt;)) {</span>
<span class="cp">    chomp $line;</span>
<span class="cp">    $size = length $line;</span>
<span class="cp">    print &quot;$size\n&quot;;                # output size of line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;DATAFILE&gt;) {</span>
<span class="cp">    chomp;</span>
<span class="cp">    print length, &quot;\n&quot;;             # output size of line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = &lt;DATAFILE&gt;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">undef $/;</span>
<span class="cp">$whole_file = &lt;FILE&gt;;               # &#39;slurp&#39; mode</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -040 -e &#39;$word = &lt;&gt;; print &quot;First word is $word\n&quot;;&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -ne &#39;BEGIN { $/=&quot;%%\n&quot; } chomp; print if /Unix/i&#39; fortune.dat</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print HANDLE &quot;One&quot;, &quot;two&quot;, &quot;three&quot;; # &quot;Onetwothree&quot;</span>
<span class="cp">print &quot;Baa baa black sheep.\n&quot;;     # Sent to default output handle</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$rv = read(HANDLE, $buffer, 4096)</span>
<span class="cp">        or die &quot;Couldn&#39;t read from HANDLE : $!\n&quot;;</span>
<span class="cp"># $rv is the number of bytes read,</span>
<span class="cp"># $buffer holds the data read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">truncate(HANDLE, $length)</span>
<span class="cp">    or die &quot;Couldn&#39;t truncate: $!\n&quot;;</span>
<span class="cp">truncate(&quot;/tmp/$$.pid&quot;, $length)</span>
<span class="cp">    or die &quot;Couldn&#39;t truncate: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pos = tell(DATAFILE);</span>
<span class="cp">print &quot;I&#39;m $pos bytes from the start of DATAFILE.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">seek(LOGFILE, 0, 2)         or die &quot;Couldn&#39;t seek to the end: $!\n&quot;;</span>
<span class="cp">seek(DATAFILE, $pos, 0)     or die &quot;Couldn&#39;t seek to $pos: $!\n&quot;;</span>
<span class="cp">seek(OUT, -20, 1)           or die &quot;Couldn&#39;t seek back 20 bytes: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$written = syswrite(DATAFILE, $mystring, length($mystring));</span>
<span class="cp">die &quot;syswrite failed: $!\n&quot; unless $written == length($mystring);</span>
<span class="cp">$read = sysread(INFILE, $block, 256, 5);</span>
<span class="cp">warn &quot;only read $read bytes, not 256&quot; if 256 != $read;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pos = sysseek(HANDLE, 0, 1);       # don&#39;t change position</span>
<span class="cp">die &quot;Couldn&#39;t sysseek: $!\n&quot; unless defined $pos;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN433"
>Reading Lines with Continuation Characters</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">while (defined($line = &lt;FH&gt;) ) {</span>
<span class="cp">    chomp $line;</span>
<span class="cp">    if ($line =~ s/\\$//) {</span>
<span class="cp">        $line .= &lt;FH&gt;;</span>
<span class="cp">        redo unless eof(FH);</span>
<span class="cp">    }</span>
<span class="cp">    # process full record in $line here</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) \</span>
<span class="cp">#         $(TEXINFOS) $(INFOS) $(MANS) $(DATA)</span>
<span class="cp"># DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) \</span>
<span class="cp">#         $(TEXINFOS) $(INFO_DEPS) $(MANS) $(DATA) \</span>
<span class="cp">#         $(EXTRA_DIST)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($line =~ s/\\\s*$//) { </span>
<span class="cp">    # as before</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN436"
>Counting Lines (or Paragraphs or Records) in a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$count = `wc -l &lt; $file`;</span>
<span class="cp">die &quot;wc failed: $?&quot; if $?;</span>
<span class="cp">chomp($count);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FILE, &quot;&lt; $file&quot;) or die &quot;can&#39;t open $file: $!&quot;;</span>
<span class="cp">$count++ while &lt;FILE&gt;;</span>
<span class="cp"># $count now holds the number of lines read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$count += tr/\n/\n/ while sysread(FILE, $_, 2 ** 16);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FILE, &quot;&lt; $file&quot;) or die &quot;can&#39;t open $file: $!&quot;;</span>
<span class="cp">$count++ while &lt;FILE&gt;;</span>
<span class="cp"># $count now holds the number of lines read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FILE, &quot;&lt; $file&quot;) or die &quot;can&#39;t open $file: $!&quot;;</span>
<span class="cp">for ($count=0; &lt;FILE&gt;; $count++) { }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">1 while &lt;FILE&gt;;</span>
<span class="cp">$count = $.;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = &#39;&#39;;            # enable paragraph mode for all reads</span>
<span class="cp">open(FILE, $file) or die &quot;can&#39;t open $file: $!&quot;;</span>
<span class="cp">1 while &lt;FILE&gt;;</span>
<span class="cp">$para_count = $.;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN439"
>Processing Every Word in a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    for $chunk (split) {</span>
<span class="cp">        # do something with $chunk</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    while ( /(\w[\w&#39;-]*)/g ) {  #&#39;</span>
<span class="cp">        # do something with $1</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Make a word frequency count</span>
<span class="cp">%seen = ();</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    while ( /(\w[&#39;\w-]*)/g ) {  #&#39;</span>
<span class="cp">        $seen{lc $1}++;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp"># output hash in a descending numeric sort of its values</span>
<span class="cp">foreach $word ( sort { $seen{$b} &lt;=&gt; $seen{$a} } keys %seen) {</span>
<span class="cp">    printf &quot;%5d %s\n&quot;, $seen{$word}, $word;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Line frequency count</span>
<span class="cp">%seen = ();</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    $seen{lc $_}++;</span>
<span class="cp">}</span>
<span class="cp">foreach $line ( sort { $seen{$b} &lt;=&gt; $seen{$a} } keys %seen ) {</span>
<span class="cp">    printf &quot;%5d %s&quot;, $seen{$line}, $line;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN442"
>Reading a File Backwards by Line or Paragraph</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">@lines = &lt;FILE&gt;;</span>
<span class="cp">while ($line = pop @lines) {</span>
<span class="cp">    # do something with $line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = reverse &lt;FILE&gt;;</span>
<span class="cp">foreach $line (@lines) {</span>
<span class="cp">    # do something with $line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for ($i = $#lines; $i != -1; $i--) {</span>
<span class="cp">    $line = $lines[$i];</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># this enclosing block keeps local $/ temporary</span>
<span class="cp">{           </span>
<span class="cp">    local $/ = &#39;&#39;;</span>
<span class="cp">    @paragraphs = reverse &lt;FILE&gt;;</span>
<span class="cp">}</span>

<span class="cp">foreach $paragraph (@paragraphs) {</span>
<span class="cp">    # do something</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN445"
>Trailing a Growing File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">for (;;) {</span>
<span class="cp">    while (&lt;FH&gt;) { .... }</span>
<span class="cp">    sleep $SOMETIME;</span>
<span class="cp">    seek(FH, 0, 1);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Seekable;</span>

<span class="cp">for (;;) {</span>
<span class="cp">    while (&lt;FH&gt;) { .... }</span>
<span class="cp">    sleep $SOMETIME;</span>
<span class="cp">    FH-&gt;clearerr();</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$naptime = 1;</span>

<span class="cp">use IO::Handle;</span>
<span class="cp">open (LOGFILE, &quot;/tmp/logfile&quot;) or die &quot;can&#39;t open /tmp/logfile: $!&quot;;</span>
<span class="cp">for (;;) {</span>
<span class="cp">    while (&lt;LOGFILE&gt;) { print }     # or appropriate processing</span>
<span class="cp">    sleep $naptime;</span>
<span class="cp">    LOGFILE-&gt;clearerr();            # clear stdio error flag</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for (;;) {</span>
<span class="cp">    for ($curpos = tell(LOGFILE); &lt;LOGFILE&gt;; $curpos = tell(LOGFILE)) {</span>
<span class="cp">        # process $_ here</span>
<span class="cp">    }</span>
<span class="cp">    sleep $naptime;</span>
<span class="cp">    seek(LOGFILE, $curpos, 0);  # seek to where we had been</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">exit if (stat(LOGFILE))[3] == 0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::stat;</span>
<span class="cp">exit if stat(*LOGFILE)-&gt;nlink == 0;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN448"
>Picking a Random Line from a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">srand;</span>
<span class="cp">rand($.) &lt; 1 &amp;&amp; ($line = $_) while &lt;&gt;;</span>
<span class="cp"># $line is the random line</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = &quot;%%\n&quot;;</span>
<span class="cp">@ARGV = qw( /usr/share/games/fortunes );</span>
<span class="cp">srand;</span>
<span class="cp">rand($.) &lt; 1 &amp;&amp; ($adage = $_) while &lt;&gt;;</span>
<span class="cp">print $adage;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN451"
>Randomizing All Lines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp"># assumes the &amp;shuffle sub from Chapter 4</span>
<span class="cp">while (&lt;INPUT&gt;) {</span>
<span class="cp">    push(@lines, $_);</span>
<span class="cp">}</span>
<span class="cp">@reordered = shuffle(@lines);</span>
<span class="cp">foreach (@reordered) {</span>
<span class="cp">    print OUTPUT $_;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN454"
>Reading a Particular Line in a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp"># looking for line number $DESIRED_LINE_NUMBER</span>
<span class="cp">$. = 0;</span>
<span class="cp">do { $LINE = &lt;HANDLE&gt; } until $. == $DESIRED_LINE_NUMBER || eof;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = &lt;HANDLE&gt;;</span>
<span class="cp">$LINE = $lines[$DESIRED_LINE_NUMBER];</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># usage: build_index(*DATA_HANDLE, *INDEX_HANDLE)</span>
<span class="cp">sub build_index {</span>
<span class="cp">    my $data_file  = shift;</span>
<span class="cp">    my $index_file = shift;</span>
<span class="cp">    my $offset     = 0;</span>

<span class="cp">    while (&lt;$data_file&gt;) {</span>
<span class="cp">        print $index_file pack(&quot;N&quot;, $offset);</span>
<span class="cp">        $offset = tell($data_file);</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp"># usage: line_with_index(*DATA_HANDLE, *INDEX_HANDLE, $LINE_NUMBER)</span>
<span class="cp"># returns line or undef if LINE_NUMBER was out of range</span>
<span class="cp">sub line_with_index {</span>
<span class="cp">    my $data_file   = shift;</span>
<span class="cp">    my $index_file  = shift;</span>
<span class="cp">    my $line_number = shift;</span>

<span class="cp">    my $size;               # size of an index entry</span>
<span class="cp">    my $i_offset;           # offset into the index of the entry</span>
<span class="cp">    my $entry;              # index entry</span>
<span class="cp">    my $d_offset;           # offset into the data file</span>

<span class="cp">    $size = length(pack(&quot;N&quot;, 0));</span>
<span class="cp">    $i_offset = $size * ($line_number-1);</span>
<span class="cp">    seek($index_file, $i_offset, 0) or return;</span>
<span class="cp">    read($index_file, $entry, $size);</span>
<span class="cp">    $d_offset = unpack(&quot;N&quot;, $entry);</span>
<span class="cp">    seek($data_file, $d_offset, 0);</span>
<span class="cp">    return scalar(&lt;$data_file&gt;);</span>
<span class="cp">}</span>

<span class="cp"># usage:</span>
<span class="cp">open(FILE, &quot;&lt; $file&quot;)         or die &quot;Can&#39;t open $file for reading: $!\n&quot;;</span>
<span class="cp">open(INDEX, &quot;+&gt;$file.idx&quot;)</span>
<span class="cp">        or die &quot;Can&#39;t open $file.idx for read/write: $!\n&quot;;</span>
<span class="cp">build_index(*FILE, *INDEX);</span>
<span class="cp">$line = line_with_index(*FILE, *INDEX, $seeking);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DB_File;</span>
<span class="cp">use Fcntl;</span>

<span class="cp">$tie = tie(@lines, $FILE, &quot;DB_File&quot;, O_RDWR, 0666, $DB_RECNO) or die </span>
<span class="cp">    &quot;Cannot open file $FILE: $!\n&quot;;</span>
<span class="cp"># extract it</span>
<span class="cp">$line = $lines[$sought - 1];</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/print_line-v1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># print_line-v1 - linear style</span>

<span class="cp">@ARGV == 2 or die &quot;usage: print_line FILENAME LINE_NUMBER\n&quot;;</span>

<span class="cp">($filename, $line_number) = @ARGV;</span>
<span class="cp">open(INFILE, &quot;&lt; $filename&quot;) or die &quot;Can&#39;t open $filename for reading: $!\n&quot;;</span>
<span class="cp">while (&lt;INFILE&gt;) {</span>
<span class="cp">    $line = $_;</span>
<span class="cp">    last if $. == $line_number;</span>
<span class="cp">}</span>
<span class="cp">if ($. != $line_number) {</span>
<span class="cp">    die &quot;Didn&#39;t find line $line_number in $filename\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">print;</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/print_line-v2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># print_line-v2 - index style</span>
<span class="cp"># build_index and line_with_index from above</span>
<span class="cp">@ARGV == 2 or</span>
<span class="cp">    die &quot;usage: print_line FILENAME LINE_NUMBER&quot;;</span>

<span class="cp">($filename, $line_number) = @ARGV;</span>
<span class="cp">open(ORIG, &quot;&lt; $filename&quot;) </span>
<span class="cp">        or die &quot;Can&#39;t open $filename for reading: $!&quot;;</span>

<span class="cp"># open the index and build it if necessary</span>
<span class="cp"># there&#39;s a race condition here: two copies of this</span>
<span class="cp"># program can notice there&#39;s no index for the file and</span>
<span class="cp"># try to build one.  This would be easily solved with</span>
<span class="cp"># locking</span>
<span class="cp">$indexname = &quot;$filename.index&quot;;</span>
<span class="cp">sysopen(IDX, $indexname, O_CREAT|O_RDWR)</span>
<span class="cp">         or die &quot;Can&#39;t open $indexname for read/write: $!&quot;;</span>
<span class="cp">build_index(*ORIG, *IDX) if -z $indexname;  # XXX: race unless lock</span>

<span class="cp">$line = line_with_index(*ORIG, *IDX, $line_number);</span>
<span class="cp">die &quot;Didn&#39;t find line $line_number in $filename&quot; unless defined $line;</span>
<span class="cp">print $line;</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/print_line-v3</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># print_line-v3 - DB_File style</span>
<span class="cp">use DB_File;</span>
<span class="cp">use Fcntl;</span>

<span class="cp">@ARGV == 2 or</span>
<span class="cp">    die &quot;usage: print_line FILENAME LINE_NUMBER\n&quot;;</span>

<span class="cp">($filename, $line_number) = @ARGV;</span>
<span class="cp">$tie = tie(@lines, &quot;DB_File&quot;, $filename, O_RDWR, 0666, $DB_RECNO)</span>
<span class="cp">        or die &quot;Cannot open file $filename: $!\n&quot;;</span>

<span class="cp">unless ($line_number &lt; $tie-&gt;length) {</span>
<span class="cp">    die &quot;Didn&#39;t find line $line_number in $filename\n&quot;</span>
<span class="cp">}</span>

<span class="cp">print $lines[$line_number-1];                        # easy, eh?</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN457"
>Processing Variable-Length Text Fields</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp"># given $RECORD with field separated by PATTERN,</span>
<span class="cp"># extract @FIELDS.</span>
<span class="cp">@FIELDS = split(/PATTERN/, $RECORD);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">split(/([+-])/, &quot;3+5-2&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">(3, &#39;+&#39;, 5, &#39;-&#39;, 2)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@fields = split(/:/, $RECORD);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@fields = split(/\s+/, $RECORD);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@fields = split(&quot; &quot;, $RECORD);</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN460"
>Removing the Last Line of a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">open (FH, &quot;+&lt; $file&quot;)               or die &quot;can&#39;t update $file: $!&quot;;</span>
<span class="cp">while ( &lt;FH&gt; ) {</span>
<span class="cp">    $addr = tell(FH) unless eof(FH);</span>
<span class="cp">}</span>
<span class="cp">truncate(FH, $addr)                 or die &quot;can&#39;t truncate $file: $!&quot;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN463"
>Processing Binary Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">binmode(HANDLE);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$gifname = &quot;picture.gif&quot;;</span>
<span class="cp">open(GIF, $gifname)         or die &quot;can&#39;t open $gifname: $!&quot;;</span>

<span class="cp">binmode(GIF);               # now DOS won&#39;t mangle binary input from GIF</span>
<span class="cp">binmode(STDOUT);            # now DOS won&#39;t mangle binary output to STDOUT</span>

<span class="cp">while (read(GIF, $buff, 8 * 2**10)) {</span>
<span class="cp">    print STDOUT $buff;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN466"
>Using Random-Access I/O</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$ADDRESS = $RECSIZE * $RECNO;</span>
<span class="cp">seek(FH, $ADDRESS, 0) or die &quot;seek:$!&quot;;</span>
<span class="cp">read(FH, $BUFFER, $RECSIZE);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ADDRESS = $RECSIZE * ($RECNO-1);</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN469"
>Updating a Random-Access File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;                          # for SEEK_SET and SEEK_CUR</span>

<span class="cp">$ADDRESS = $RECSIZE * $RECNO;</span>
<span class="cp">seek(FH, $ADDRESS, SEEK_SET)        or die &quot;Seeking: $!&quot;;</span>
<span class="cp">read(FH, $BUFFER, $RECSIZE) == $RECSIZE</span>
<span class="cp">                                    or die &quot;Reading: $!&quot;;</span>
<span class="cp">@FIELDS = unpack($FORMAT, $BUFFER);</span>
<span class="cp"># update fields, then</span>
<span class="cp">$BUFFER = pack($FORMAT, @FIELDS);</span>
<span class="cp">seek(FH, -$RECSIZE, SEEK_CUR)       or die &quot;Seeking: $!&quot;;</span>
<span class="cp">print FH $BUFFER;</span>
<span class="cp">close FH                            or die &quot;Closing: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/weekearly</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># weekearly -- set someone&#39;s login date back a week</span>
<span class="cp">use User::pwent;</span>
<span class="cp">use IO::Seekable;</span>

<span class="cp">$typedef = &#39;L A12 A16&#39;;         # linux fmt; sunos is &quot;L A8 A16&quot;</span>
<span class="cp">$sizeof  = length(pack($typedef, ()));</span>
<span class="cp">$user    = shift(@ARGV) || $ENV{USER} || $ENV{LOGNAME};</span>

<span class="cp">$address = getpwnam($user)-&gt;uid * $sizeof;</span>

<span class="cp">open (LASTLOG, &quot;+&lt;/var/log/lastlog&quot;)</span>
<span class="cp">    or die &quot;can&#39;t update /usr/adm/lastlog: $!&quot;;</span>
<span class="cp">seek(LASTLOG, $address, SEEK_SET)</span>
<span class="cp">    or die &quot;seek failed: $!&quot;;</span>
<span class="cp">read(LASTLOG, $buffer, $sizeof) == $sizeof</span>
<span class="cp">    or die &quot;read failed: $!&quot;;</span>

<span class="cp">($time, $line, $host) = unpack($typedef, $buffer);</span>
<span class="cp">$time  -= 24 * 7 * 60 * 60;         # back-date a week</span>
<span class="cp">$buffer = pack($typedef, $time, $line, $time);</span>

<span class="cp">seek(LASTLOG, -$sizeof, SEEK_CUR)   # backup one record</span>
<span class="cp">    or die &quot;seek failed: $!&quot;;</span>
<span class="cp">print LASTLOG $record;</span>
<span class="cp">    </span>
<span class="cp">close(LASTLOG)</span>
<span class="cp">    or die &quot;close failed: $!&quot;;</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN472"
>Reading a String from a Binary File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$old_rs = $/;                       # save old $/</span>
<span class="cp">$/ = &quot;\0&quot;;                          # NULL</span>
<span class="cp">seek(FH, $addr, SEEK_SET)           or die &quot;Seek error: $!\n&quot;;</span>
<span class="cp">$string = &lt;FH&gt;;                     # read string</span>
<span class="cp">chomp $string;                      # remove NULL</span>
<span class="cp">$/ = $old_rs;                       # restore old $/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{</span>
<span class="cp">    local $/ = &quot;\0&quot;;</span>
<span class="cp">    # ...</span>
<span class="cp">}                           # $/ is automatically restored</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/bgets</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl </span>
<span class="cp"># bgets - get a string from an address in a binary file</span>
<span class="cp">use IO::Seekable;</span>
<span class="cp">($file, @addrs) = @ARGV             or die &quot;usage: $0 addr ...&quot;;</span>
<span class="cp">open(FH, $file)                     or die &quot;cannot open $file: $!&quot;;</span>
<span class="cp">$/ = &quot;\000&quot;;</span>

<span class="cp">foreach $addr (@addrs) {</span>
<span class="cp">    $addr = oct $addr if $addr =~ /^0/;</span>
<span class="cp">    seek(FH, $addr, SEEK_SET)</span>
<span class="cp">        or die &quot;can&#39;t seek to $addr in $file: $!&quot;;</span>
<span class="cp">    printf qq{%#x %#o %d &quot;%s&quot;\n}, $addr, $addr, $addr, scalar &lt;&gt;;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/strings</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># strings - pull strings out of a binary file</span>
<span class="cp">$/ = &quot;\0&quot;;</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    while (/([\040-\176\s]{4,})/g) {</span>
<span class="cp">        print $1, &quot;\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN475"
>Reading Fixed-Length Records</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp"># $RECORDSIZE is the length of a record, in bytes.</span>
<span class="cp"># $TEMPLATE is the unpack template for the record</span>
<span class="cp"># FILE is the file to read from</span>
<span class="cp"># @FIELDS is an array, one element per field</span>

<span class="cp">until ( eof(FILE) ) {</span>
<span class="cp">    read(FILE, $record, $RECORDSIZE) == $RECORDSIZE</span>
<span class="cp">        or die &quot;short read\n&quot;;</span>
<span class="cp">    @FIELDS = unpack($TEMPLATE, $record);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#define UT_LINESIZE           12</span>
<span class="cp">#define UT_NAMESIZE           8</span>
<span class="cp">#define UT_HOSTSIZE           16</span>

<span class="cp">struct utmp {                       /* here are the pack template codes */</span>
<span class="cp">    short ut_type;                  /* s for short, must be padded      */</span>
<span class="cp">    pid_t ut_pid;                   /* i for integer                    */</span>
<span class="cp">    char ut_line[UT_LINESIZE];      /* A12 for 12-char string           */</span>
<span class="cp">    char ut_id[2];                  /* A2, but need x2 for alignment    */</span>
<span class="cp">    time_t ut_time;                 /* l for long                       */</span>
<span class="cp">    char ut_user[UT_NAMESIZE];      /* A8 for 8-char string             */</span>
<span class="cp">    char ut_host[UT_HOSTSIZE];      /* A16 for 16-char string           */</span>
<span class="cp">    long ut_addr;                   /* l for long                       */</span>
<span class="cp">};</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN478"
>Reading Configuration Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;CONFIG&gt;) {</span>
<span class="cp">    chomp;                  # no newline</span>
<span class="cp">    s/#.*//;                # no comments</span>
<span class="cp">    s/^\s+//;               # no leading white</span>
<span class="cp">    s/\s+$//;               # no trailing white</span>
<span class="cp">    next unless length;     # anything left?</span>
<span class="cp">    my ($var, $value) = split(/\s*=\s*/, $_, 2);</span>
<span class="cp">    $User_Preferences{$var} = $value;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">do &quot;$ENV{HOME}/.progrc&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># set class C net</span>
<span class="cp">NETMASK = 255.255.255.0</span>
<span class="cp">MTU     = 296</span>
<span class="cp">    </span>
<span class="cp">DEVICE  = cua1</span>
<span class="cp">RATE    = 115200</span>
<span class="cp">MODE    = adaptive</span>
<span class="cp">#-----------------------------</span>
<span class="cp">no strict &#39;refs&#39;;</span>
<span class="cp">$$var = $value;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># set class C net</span>
<span class="cp">$NETMASK = &#39;255.255.255.0&#39;;</span>
<span class="cp">$MTU     = 0x128;</span>
<span class="cp"># Brent, please turn on the modem</span>
<span class="cp">$DEVICE  = &#39;cua1&#39;;</span>
<span class="cp">$RATE    = 115_200;</span>
<span class="cp">$MODE    = &#39;adaptive&#39;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($DEVICE =~ /1$/) {</span>
<span class="cp">    $RATE =  28_800;</span>
<span class="cp">} else {</span>
<span class="cp">    $RATE = 115_200;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$APPDFLT = &quot;/usr/local/share/myprog&quot;;</span>

<span class="cp">do &quot;$APPDFLT/sysconfig.pl&quot;;</span>
<span class="cp">do &quot;$ENV{HOME}/.myprogrc&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">do &quot;$ENV{HOME}/.myprogrc&quot;;</span>
<span class="cp">    or</span>
<span class="cp">do &quot;$APPDFLT/sysconfig.pl&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{ package Settings; do &quot;$ENV{HOME}/.myprogrc&quot; }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval `cat $ENV{HOME}/.myprogrc`;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file = &quot;someprog.pl&quot;;</span>
<span class="cp">unless ($return = do $file) {</span>
<span class="cp">    warn &quot;couldn&#39;t parse $file: $@&quot;         if $@;</span>
<span class="cp">    warn &quot;couldn&#39;t do $file: $!&quot;            unless defined $return;</span>
<span class="cp">    warn &quot;couldn&#39;t run $file&quot;               unless $return;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN481"
>Testing a File for Trustworthiness</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">( $dev, $ino, $mode, $nlink, </span>
<span class="cp">  $uid, $gid, $rdev, $size, </span>
<span class="cp">  $atime, $mtime, $ctime, </span>
<span class="cp">  $blksize, $blocks )       = stat($filename)</span>
<span class="cp">        or die &quot;no $filename: $!&quot;;</span>

<span class="cp">$mode &amp;= 07777;             # discard file type info</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$info = stat($filename)     or die &quot;no $filename: $!&quot;;</span>
<span class="cp">if ($info-&gt;uid == 0) {</span>
<span class="cp">    print &quot;Superuser owns $filename\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">if ($info-&gt;atime &gt; $info-&gt;mtime) {</span>
<span class="cp">    print &quot;$filename has been read since it was written.\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::stat;</span>

<span class="cp">sub is_safe {</span>
<span class="cp">    my $path = shift;</span>
<span class="cp">    my $info = stat($path);</span>
<span class="cp">    return unless $info;</span>

<span class="cp">    # owner neither superuser nor me </span>
<span class="cp">    # the real uid is in stored in the $&lt; variable</span>
<span class="cp">    if (($info-&gt;uid != 0) &amp;&amp; ($info-&gt;uid != $&lt;)) {</span>
<span class="cp">        return 0;</span>
<span class="cp">    }</span>

<span class="cp">    # check whether group or other can write file.</span>
<span class="cp">    # use 066 to detect either reading or writing</span>
<span class="cp">    if ($info-&gt;mode &amp; 022) {   # someone else can write this</span>
<span class="cp">        return 0 unless -d _;  # non-directories aren&#39;t safe</span>
<span class="cp">            # but directories with the sticky bit (01000) are</span>
<span class="cp">        return 0 unless $info-&gt;mode &amp; 01000;        </span>
<span class="cp">    }</span>
<span class="cp">    return 1;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Cwd;</span>
<span class="cp">use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);</span>
<span class="cp">sub is_verysafe {</span>
<span class="cp">    my $path = shift;</span>
<span class="cp">    return is_safe($path) if sysconf(_PC_CHOWN_RESTRICTED);</span>
<span class="cp">    $path = getcwd() . &#39;/&#39; . $path if $path !~ m{^/};</span>
<span class="cp">    do {</span>
<span class="cp">        return unless is_safe($path);</span>
<span class="cp">        $path =~ s#([^/]+|/)$##;               # dirname</span>
<span class="cp">        $path =~ s#/$## if length($path) &gt; 1;  # last slash</span>
<span class="cp">    } while length $path;</span>

<span class="cp">    return 1;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file = &quot;$ENV{HOME}/.myprogrc&quot;;</span>
<span class="cp">readconfig($file) if is_safe($file);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file = &quot;$ENV{HOME}/.myprogrc&quot;;</span>
<span class="cp">if (open(FILE, &quot;&lt; $file&quot;)) { </span>
<span class="cp">    readconfig(*FILE) if is_safe(*FILE);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN484"
>Program: tailwtmp</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/tailwtmp</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># tailwtmp - watch for logins and logouts; </span>
<span class="cp"># uses linux utmp structure, from utmp(5)</span>
<span class="cp">$typedef = &#39;s x2 i A12 A4 l A8 A16 l&#39;;</span>
<span class="cp">$sizeof = length pack($typedef, () );</span>
<span class="cp">use IO::File;</span>
<span class="cp">open(WTMP, &#39;/var/log/wtmp&#39;) or die &quot;can&#39;t open /var/log/wtmp: $!&quot;;</span>
<span class="cp">seek(WTMP, 0, SEEK_END);</span>
<span class="cp">for (;;) { </span>
<span class="cp">        while (read(WTMP, $buffer, $sizeof) == $sizeof) {</span>
<span class="cp">        ($type, $pid,  $line, $id, $time, $user, $host, $addr) </span>
<span class="cp">            = unpack($typedef, $buffer);</span>
<span class="cp">        next unless $user &amp;&amp; ord($user) &amp;&amp; $time;</span>
<span class="cp">        printf &quot;%1d %-8s %-12s %2s %-24s %-16s %5d %08x\n&quot;, </span>
<span class="cp">            $type,$user,$line,$id,scalar(localtime($time)), </span>
<span class="cp">            $host,$pid,$addr;</span>
<span class="cp">    } </span>
<span class="cp">    for ($size = -s WTMP; $size == -s WTMP; sleep 1) {}</span>
<span class="cp">    WTMP-&gt;clearerr();</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN487"
>Program: tctee</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">#% someprog | tee /tmp/output | Mail -s &#39;check this&#39; user@host.org</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% someprog | tctee f1 &quot;|cat -n&quot; f2 &quot;&gt;&gt;f3&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/tctee</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># tctee - clone that groks process tees </span>
<span class="cp"># perl3 compatible, or better.</span>

<span class="cp">while ($ARGV[0] =~ /^-(.+)/ &amp;&amp; (shift, ($_ = $1), 1)) {</span>
<span class="cp">    next if /^$/;</span>
<span class="cp">    s/i// &amp;&amp; (++$ignore_ints, redo);</span>
<span class="cp">    s/a// &amp;&amp; (++$append,      redo);</span>
<span class="cp">    s/u// &amp;&amp; (++$unbuffer,    redo);</span>
<span class="cp">    s/n// &amp;&amp; (++$nostdout,    redo);</span>
<span class="cp">    die &quot;usage tee [-aiun] [filenames] ...\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">if ($ignore_ints) {</span>
<span class="cp">    for $sig (&#39;INT&#39;, &#39;TERM&#39;, &#39;HUP&#39;, &#39;QUIT&#39;) { $SIG{$sig} = &#39;IGNORE&#39;; }</span>

<span class="cp">}</span>
<span class="cp">$SIG{&#39;PIPE&#39;} = &#39;PLUMBER&#39;;</span>
<span class="cp">$mode = $append ? &#39;&gt;&gt;&#39; : &#39;&gt;&#39;;</span>
<span class="cp">$fh = &#39;FH000&#39;;</span>

<span class="cp">unless ($nostdout) {</span>
<span class="cp">    %fh = (&#39;STDOUT&#39;, &#39;standard output&#39;); # always go to stdout</span>
<span class="cp">    }</span>

<span class="cp">$| = 1 if $unbuffer;</span>

<span class="cp">for (@ARGV) {</span>
<span class="cp">    if (!open($fh, (/^[^&gt;|]/ &amp;&amp; $mode) . $_)) {</span>
<span class="cp">        warn &quot;$0: cannot open $_: $!\n&quot;; # like sun&#39;s; i prefer die</span>
<span class="cp">        $status++;</span>
<span class="cp">        next;</span>
<span class="cp">    }</span>
<span class="cp">    select((select($fh), $| = 1)[0]) if $unbuffer;</span>
<span class="cp">    $fh{$fh++} = $_;</span>
<span class="cp">}</span>

<span class="cp">while (&lt;STDIN&gt;) {</span>
<span class="cp">    for $fh (keys %fh) {</span>
<span class="cp">        print $fh $_;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">for $fh (keys %fh) {</span>
<span class="cp">    next if close($fh) || !defined $fh{$fh};</span>
<span class="cp">    warn &quot;$0: couldnt close $fh{$fh}: $!\n&quot;;</span>
<span class="cp">    $status++;</span>
<span class="cp">}</span>

<span class="cp">exit $status;</span>

<span class="cp">sub PLUMBER {</span>
<span class="cp">    warn &quot;$0: pipe to \&quot;$fh{$fh}\&quot; broke!\n&quot;;</span>
<span class="cp">    $status++;</span>
<span class="cp">    delete $fh{$fh};</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN490"
>Program: laston</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">#% laston gnat</span>
<span class="cp">#gnat  UID 314 at Mon May 25 08:32:52 1998 on ttyp0 from below.perl.com</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/laston</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># laston - find out when given user last logged on</span>
<span class="cp">use User::pwent;</span>
<span class="cp">use IO::Seekable qw(SEEK_SET);</span>

<span class="cp">open (LASTLOG, &quot;/var/log/lastlog&quot;) or die &quot;can&#39;t open /usr/adm/lastlog: $!&quot;;</span>

<span class="cp">$typedef = &#39;L A12 A16&#39;;  # linux fmt; sunos is &quot;L A8 A16&quot;</span>
<span class="cp">$sizeof  = length(pack($typedef, ()));</span>

<span class="cp">for $user (@ARGV) {</span>
<span class="cp">    $U = ($user =~ /^\d+$/) ? getpwuid($user) : getpwnam($user);</span>
<span class="cp">    unless ($U) { warn &quot;no such uid $user\n&quot;; next; }</span>
<span class="cp">    seek(LASTLOG, $U-&gt;uid * $sizeof, SEEK_SET) or die &quot;seek failed: $!&quot;;</span>
<span class="cp">    read(LASTLOG, $buffer, $sizeof) == $sizeof	or next;</span>
<span class="cp">    ($time, $line, $host) = unpack($typedef, $buffer);</span>
<span class="cp">    printf &quot;%-8s UID %5d %s%s%s\n&quot;, $U-&gt;name, $U-&gt;uid,</span>
<span class="cp">          $time ? (&quot;at &quot; . localtime($time)) : &quot;never logged in&quot;,</span>
<span class="cp">          $line &amp;&amp; &quot; on $line&quot;, </span>
<span class="cp">          $host &amp;&amp; &quot; from $host&quot;;</span>
<span class="cp">} </span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="fileaccess.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="directories.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>File Access</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Directories</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>