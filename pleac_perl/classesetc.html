<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Classes, Objects, and Ties</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Perl"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Packages, Libraries, and Modules"
HREF="packagesetc.html"><LINK
REL="NEXT"
TITLE="Database Access"
HREF="dbaccess.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Perl</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="packagesetc.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="dbaccess.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CLASSESETC"
>13. Classes, Objects, and Ties</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN704"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$object = {};                       # hash reference</span>
<span class="cp">bless($object, &quot;Data::Encoder&quot;);    # bless $object into Data::Encoder class</span>
<span class="cp">bless($object);                     # bless $object into current package</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj = [3,5];</span>
<span class="cp">print ref($obj), &quot; &quot;, $obj-&gt;[1], &quot;\n&quot;;</span>
<span class="cp">bless($obj, &quot;Human::Cannibal&quot;);</span>
<span class="cp">print ref($obj), &quot; &quot;, $obj-&gt;[1], &quot;\n&quot;;</span>

<span class="cp">ARRAY 5</span>

<span class="cp">Human::Cannibal 5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;{Stomach} = &quot;Empty&quot;;   # directly accessing an object&#39;s contents</span>
<span class="cp">$obj-&gt;{NAME}    = &quot;Thag&quot;;        # uppercase field name to make it stand out (optional)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$encoded = $object-&gt;encode(&quot;data&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$encoded = Data::Encoder-&gt;encode(&quot;data&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $self  = {};         # allocate new hash for object</span>
<span class="cp">    bless($self, $class);</span>
<span class="cp">    return $self;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$object = Class-&gt;new();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$object = Class::new(&quot;Class&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub class_only_method {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    die &quot;class method called on object&quot; if ref $class;</span>
<span class="cp">    # more code here</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub instance_only_method {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    die &quot;instance method called on class&quot; unless ref $self;</span>
<span class="cp">    # more code here</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$lector = new Human::Cannibal;</span>
<span class="cp">feed $lector &quot;Zak&quot;;</span>
<span class="cp">move $lector &quot;New York&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$lector = Human::Cannibal-&gt;</span>
<span class="cp">new();</span>

<span class="cp">$lector-&gt;feed(&quot;Zak&quot;);</span>
<span class="cp">$lector-&gt;move(&quot;New York&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">printf STDERR &quot;stuff here\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">move $obj-&gt;{FIELD};                 # probably wrong</span>
<span class="cp">move $ary[$i];                      # probably wrong</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;move-&gt;{FIELD};                # Surprise!</span>
<span class="cp">$ary-&gt;move-&gt;[$i];                   # Surprise!</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;{FIELD}-&gt;</span>
<span class="cp">move()</span>
<span class="cp">;              # Nope, you wish</span>
<span class="cp">$ary[$i]-&gt;</span>
<span class="cp">move;</span>
<span class="cp">                     # Nope, you wish</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN707"
>Constructing an Object</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $self  = { };</span>
<span class="cp">    bless($self, $class);</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new { bless( { }, shift ) }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new { bless({}) }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $self = { };  # allocate anonymous hash</span>
<span class="cp">    bless($self);</span>
<span class="cp">    # init two sample attributes/data members/fields</span>
<span class="cp">    $self-&gt;{START} = time();  </span>
<span class="cp">    $self-&gt;{AGE}   = 0;</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $classname  = shift;         # What class are we constructing?</span>
<span class="cp">    my $self      = {};             # Allocate new memory</span>
<span class="cp">    bless($self, $classname);       # Mark it of the right type</span>
<span class="cp">    $self-&gt;{START}  = </span>
<span class="cp">time();</span>
<span class="cp">       # init data fields</span>
<span class="cp">    $self-&gt;{AGE}    = </span>
<span class="cp">0;</span>

<span class="cp">    return $self;                   # And give it back</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $classname  = shift;         # What class are we constructing?</span>
<span class="cp">    my $self      = {};             # Allocate new memory</span>
<span class="cp">    bless($self, $classname);       # Mark it of the right type</span>
<span class="cp">    $self-&gt;_init(@_);               # Call _init with remaining args</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>

<span class="cp"># &quot;private&quot; method to initialize fields.  It always sets START to</span>
<span class="cp"># the current time, and AGE to 0.  If called with arguments, _init</span>
<span class="cp"># interprets them as key+value pairs to initialize the object with.</span>
<span class="cp">sub _init {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{START} = </span>
<span class="cp">time();</span>

<span class="cp">    $self-&gt;{AGE}   = 0;</span>
<span class="cp">    if (@_) {</span>
<span class="cp">        my %extra = @_;</span>
<span class="cp">        @$self{keys %extra} = values %extra;</span>
<span class="cp">    } </span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN710"
>Destroying an Object</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">sub DESTROY {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    printf(&quot;$self dying at %s\n&quot;, scalar localtime);</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$self-&gt;{WHATEVER} = $self;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN713"
>Managing Instance Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">sub get_name {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return $self-&gt;{NAME};</span>
<span class="cp">} </span>

<span class="cp">sub set_name {</span>
<span class="cp">    my $self      = shift;</span>
<span class="cp">    $self-&gt;{NAME} = shift;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub name {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    if (@_) { $self-&gt;{NAME} = shift } </span>
<span class="cp">    return $self-&gt;{NAME};</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub age {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    my $prev = $self-&gt;{AGE};</span>
<span class="cp">    if (@_) { $self-&gt;{AGE} = shift } </span>
<span class="cp">    return $prev;</span>
<span class="cp">} </span>
<span class="cp"># sample call of get and set: happy birthday!</span>
<span class="cp">$obj-&gt;age( 1 + $obj-&gt;age );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$him = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$him-&gt;{NAME} = &quot;Sylvester&quot;;</span>
<span class="cp">$him-&gt;{AGE}  = 23;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Carp;</span>
<span class="cp">sub name {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return $self-&gt;{NAME} unless @_;</span>
<span class="cp">    local $_ = shift;</span>
<span class="cp">    croak &quot;too many arguments&quot; if @_;</span>
<span class="cp">    if ($^W) {</span>
<span class="cp">        /[^\s\w&#39;-]/         &amp;&amp; carp &quot;funny characters in name&quot;; #&#39;</span>
<span class="cp">        /\d/                &amp;&amp; carp &quot;numbers in name&quot;;</span>
<span class="cp">        /\S+(\s+\S+)+/      || carp &quot;prefer multiword name&quot;;</span>
<span class="cp">        /\S/                || carp &quot;name is blank&quot;;</span>
<span class="cp">    } </span>
<span class="cp">    s/(\w+)/\u\L$1/g;       # enforce capitalization</span>
<span class="cp">    $self-&gt;{NAME} = $_;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>

<span class="cp"># this is the same as before...</span>
<span class="cp">sub new {</span>
<span class="cp">     my $that  = shift;</span>
<span class="cp">     my $class = ref($that) || $that;</span>
<span class="cp">     my $self = {</span>
<span class="cp">           NAME  =&gt; undef,</span>
<span class="cp">           AGE   =&gt; undef,</span>
<span class="cp">           PEERS =&gt; [],</span>
<span class="cp">    };</span>
<span class="cp">    bless($self, $class);</span>
<span class="cp">    return $self;</span>
<span class="cp">}</span>

<span class="cp">use Alias qw(attr);</span>
<span class="cp">use vars qw($NAME $AGE @PEERS);</span>

<span class="cp">sub name {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    if (@_) { $NAME = shift; }</span>
<span class="cp">    return    $NAME;</span>
<span class="cp">};</span>

<span class="cp">sub age {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    if (@_) { $AGE = shift; }</span>
<span class="cp">    return    $AGE;</span>
<span class="cp">}</span>

<span class="cp">sub peers {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    if (@_) { @PEERS = @_; }</span>
<span class="cp">    return    @PEERS;</span>
<span class="cp">}</span>

<span class="cp">sub exclaim {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    return sprintf &quot;Hi, I&#39;m %s, age %d, working with %s&quot;,</span>
<span class="cp">            $NAME, $AGE, join(&quot;, &quot;, @PEERS);</span>
<span class="cp">}</span>

<span class="cp">sub happy_birthday {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    return ++$AGE;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN716"
>Managing Class Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>

<span class="cp">$Body_Count = 0; </span>

<span class="cp">sub population { return $Body_Count }</span>

<span class="cp">sub new {                                   # constructor</span>
<span class="cp">    $Body_Count++;</span>
<span class="cp">    return bless({}, shift);</span>
<span class="cp">}</span>

<span class="cp">sub DESTROY { --$BodyCount }                # destructor</span>

<span class="cp"># later, the user can say this:</span>
<span class="cp">package main;</span>

<span class="cp">for (1..10) { push @people, Person-&gt;new }</span>
<span class="cp">printf &quot;There are %d people alive.\n&quot;, Person-&gt;population();</span>

<span class="cp">There are 10 people alive.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$him = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$him-&gt;gender(&quot;male&quot;);</span>

<span class="cp">$her = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$her-&gt;gender(&quot;female&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">FixedArray-&gt;Max_Bounds(100);                # set for whole class</span>
<span class="cp">$alpha = FixedArray-&gt;new();</span>
<span class="cp">printf &quot;Bound on alpha is %d\n&quot;, $alpha-&gt;Max_Bounds();</span>
<span class="cp">100</span>

<span class="cp">$beta = FixedArray-&gt;new();</span>
<span class="cp">$beta-&gt;Max_Bounds(50);                      # still sets for whole class</span>
<span class="cp">printf &quot;Bound on alpha is %d\n&quot;, $alpha-&gt;Max_Bounds();</span>
<span class="cp">50</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package FixedArray;</span>
<span class="cp">$Bounds = 7;  # default</span>
<span class="cp">sub new { bless( {}, shift ) }</span>
<span class="cp">sub Max_Bounds {</span>
<span class="cp">    my $proto  = shift;</span>
<span class="cp">    $Bounds    = shift if @_;          # allow updates</span>
<span class="cp">    return $Bounds;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub Max_Bounds { $Bounds }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $self = bless({}, $class);</span>
<span class="cp">    $self-&gt;{Max_Bounds_ref} = \$Bounds;</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN719"
>Using Classes as Structs</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">use Class::Struct;          # load struct-building module</span>

<span class="cp">struct Person =&gt; {          # create a definition for a &quot;Person&quot;</span>
<span class="cp">    name   =&gt; &#39;$&#39;,          #    name field is a scalar</span>
<span class="cp">    age    =&gt; &#39;$&#39;,          #    age field is also a scalar</span>
<span class="cp">    peers  =&gt; &#39;@&#39;,          #    but peers field is an array (reference)</span>
<span class="cp">};</span>

<span class="cp">my $p = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;      # allocate an empty Person struct</span>

<span class="cp">$p-&gt;name(&quot;Jason Smythe&quot;);                   # set its name field</span>
<span class="cp">$p-&gt;age(13);                                # set its age field</span>
<span class="cp">$p-&gt;peers( [&quot;Wilbur&quot;, &quot;Ralph&quot;, &quot;Fred&quot; ] );  # set its peers field</span>

<span class="cp"># or this way:</span>
<span class="cp">@{$p-&gt;peers} = (&quot;Wilbur&quot;, &quot;Ralph&quot;, &quot;Fred&quot;);</span>

<span class="cp"># fetch various values, including the zeroth friend</span>
<span class="cp">printf &quot;At age %d, %s&#39;s first friend is %s.\n&quot;,</span>
<span class="cp">    $p-&gt;age, $p-&gt;name, $p-&gt;peers(0);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Class::Struct;</span>

<span class="cp">struct Person =&gt; {name =&gt; &#39;$&#39;,      age  =&gt; &#39;$&#39;};  #&#39;</span>
<span class="cp">struct Family =&gt; {head =&gt; &#39;Person&#39;, address =&gt; &#39;$&#39;, members =&gt; &#39;@&#39;};  #&#39;</span>

<span class="cp">$folks  = Family-&gt;</span>
<span class="cp">new();</span>

<span class="cp">$dad    = $folks-&gt;head;</span>
<span class="cp">$dad-&gt;name(&quot;John&quot;);</span>
<span class="cp">$dad-&gt;age(34);</span>

<span class="cp">printf(&quot;%s&#39;s age is %d\n&quot;, $folks-&gt;head-&gt;name, $folks-&gt;head-&gt;age);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub Person::age {</span>
<span class="cp">    use Carp;</span>
<span class="cp">    my ($self, $age) = @_;</span>
<span class="cp">    if    (@_  &gt; 2) {  confess &quot;too many arguments&quot; } </span>
<span class="cp">    elsif (@_ == 1) {  return $struct-&gt;{&#39;age&#39;}      }</span>
<span class="cp">    elsif (@_ == 2) {</span>
<span class="cp">        carp &quot;age `$age&#39; isn&#39;t numeric&quot;   if $age !~ /^\d+/;</span>
<span class="cp">        carp &quot;age `$age&#39; is unreasonable&quot; if $age &gt; 150;</span>
<span class="cp">        $self-&gt;{&#39;age&#39;} = $age;</span>
<span class="cp">    } </span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($^W) { </span>
<span class="cp">    carp &quot;age `$age&#39; isn&#39;t numeric&quot;   if $age !~ /^\d+/;</span>
<span class="cp">    carp &quot;age `$age&#39; is unreasonable&quot; if $age &gt; 150;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $gripe = $^W ? \&amp;carp : \&amp;croak;</span>
<span class="cp">$gripe-&gt;(&quot;age `$age&#39; isn&#39;t numeric&quot;)   if $age !~ /^\d+/;</span>
<span class="cp">$gripe-&gt;(&quot;age `$age&#39; is unreasonable&quot;) if $age &gt; 150;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">struct Family =&gt; [head =&gt; &#39;Person&#39;, address =&gt; &#39;$&#39;, members =&gt; &#39;@&#39;];  #&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">struct Card =&gt; { </span>
<span class="cp">    name    =&gt; &#39;$&#39;,</span>
<span class="cp">    color   =&gt; &#39;$&#39;,</span>
<span class="cp">    cost    =&gt; &#39;$&#39;,</span>
<span class="cp">    type    =&gt; &#39;$&#39;,</span>
<span class="cp">    release =&gt; &#39;$&#39;,</span>
<span class="cp">    text    =&gt; &#39;$&#39;,</span>
<span class="cp">};</span>
<span class="cp">#-----------------------------</span>
<span class="cp">struct Card =&gt; map { $_ =&gt; &#39;$&#39; } qw(name color cost type release text); #&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">struct hostent =&gt; { reverse qw{</span>
<span class="cp">    $ name</span>
<span class="cp">    @ aliases</span>
<span class="cp">    $ addrtype</span>
<span class="cp">    $ length</span>
<span class="cp">    @ addr_list</span>
<span class="cp">}};</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#define h_type h_addrtype</span>
<span class="cp">#define h_addr h_addr_list[0]</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># make (hostent object)-&gt;</span>
<span class="cp">type()</span>
<span class="cp"> same as (hostent object)-&gt;</span>
<span class="cp">addrtype()</span>

<span class="cp">*hostent::type = \&amp;hostent::addrtype;</span>

<span class="cp"># make (hostenv object)-&gt;</span>
<span class="cp">addr()</span>
<span class="cp"> same as (hostenv object)-&gt;addr_list(0)</span>
<span class="cp">sub hostent::addr { shift-&gt;addr_list(0,@_) }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Extra::hostent;</span>
<span class="cp">use Net::hostent;</span>
<span class="cp">@ISA = qw(hostent);</span>
<span class="cp">sub addr { shift-&gt;addr_list(0,@_) } </span>
<span class="cp">1;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN722"
>Cloning Objects</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">my $proto  = shift;</span>
<span class="cp">my $class  = ref($proto) || $proto;</span>
<span class="cp">my $parent = ref($proto) &amp;&amp; $proto;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ob1 = SomeClass-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp"># later on</span>
<span class="cp">$ob2 = (ref $ob1)-&gt;</span>
<span class="cp">new();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ob1 = Widget-&gt;new();</span>
<span class="cp">$ob2 = $ob1-&gt;new();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $proto  = shift;</span>
<span class="cp">    my $class  = ref($proto) || $proto;</span>
<span class="cp">    my $parent = ref($proto) &amp;&amp; $proto;</span>

<span class="cp">    my $self;</span>
<span class="cp">    # check whether we&#39;re shadowing a new from @ISA</span>
<span class="cp">    if (@ISA &amp;&amp; $proto-&gt;SUPER::can(&#39;new&#39;) ) {</span>
<span class="cp">        $self = $proto-&gt;SUPER::new(@_);</span>
<span class="cp">    } else { </span>
<span class="cp">        $self = {};</span>
<span class="cp">        bless ($self, $proto);</span>
<span class="cp">    }</span>
<span class="cp">    bless($self, $class);</span>

<span class="cp">    $self-&gt;{PARENT}  = $parent;</span>
<span class="cp">    $self-&gt;{START}   = time();   # init data fields</span>
<span class="cp">    $self-&gt;{AGE}     = 0;</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN725"
>Calling Methods Indirectly</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$methname = &quot;flicker&quot;;</span>
<span class="cp">$obj-&gt;$methname(10);         # calls $obj-&gt;flicker(10);</span>

<span class="cp"># call three methods on the object, by name</span>
<span class="cp">foreach $m ( qw(start run stop) ) {</span>
<span class="cp">    $obj-&gt;</span>
<span class="cp">$m();</span>

<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">@methods = qw(name rank serno);</span>
<span class="cp">%his_info = map { $_ =&gt; $ob-&gt;$_() } @methods;</span>

<span class="cp"># same as this:</span>

<span class="cp">%his_info = (</span>
<span class="cp">    &#39;name&#39;  =&gt; $ob-&gt;</span>
<span class="cp">name()</span>
<span class="cp">,</span>
<span class="cp">    &#39;rank&#39;  =&gt; $ob-&gt;</span>
<span class="cp">rank()</span>
<span class="cp">,</span>
<span class="cp">    &#39;serno&#39; =&gt; $ob-&gt;</span>
<span class="cp">serno()</span>
<span class="cp">,</span>
<span class="cp">);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $fnref = sub { $ob-&gt;method(@_) };</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$fnref-&gt;(10, &quot;fred&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;method(10, &quot;fred&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;can(&#39;method_name&#39;)-&gt;($obj_target, @arguments)</span>
<span class="cp">   if $obj_target-&gt;isa( ref $obj );</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN728"
>Determining Subclass Membership</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;isa(&quot;HTTP::Message&quot;);                  # as object method</span>
<span class="cp">HTTP::Response-&gt;isa(&quot;HTTP::Message&quot;);       # as class method</span>

<span class="cp">if ($obj-&gt;can(&quot;method_name&quot;)) { .... }       # check method validity</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$has_io = $fd-&gt;isa(&quot;IO::Handle&quot;);</span>
<span class="cp">$itza_handle = IO::Socket-&gt;isa(&quot;IO::Handle&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$his_print_method = $obj-&gt;can(&#39;as_string&#39;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">Some_Module-&gt;VERSION(3.0);</span>
<span class="cp">$his_vers = $obj-&gt;</span>
<span class="cp">VERSION()</span>
<span class="cp">;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Some_Module 3.0;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use vars qw($VERSION);</span>
<span class="cp">$VERSION = &#39;1.01&#39;;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN731"
>Writing an Inheritable Class</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $self  = { };</span>
<span class="cp">    return bless $self, $class;</span>
<span class="cp">} </span>
<span class="cp">sub name {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{NAME} = shift if @_;</span>
<span class="cp">    return $self-&gt;{NAME};</span>
<span class="cp">} </span>
<span class="cp">sub age {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{AGE} = shift if @_;</span>
<span class="cp">    return $self-&gt;{AGE};</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Person;</span>
<span class="cp">my $dude = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$dude-&gt;name(&quot;Jason&quot;);</span>
<span class="cp">$dude-&gt;age(23);</span>
<span class="cp">printf &quot;%s is age %d.\n&quot;, $dude-&gt;name, $dude-&gt;age;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Employee;</span>
<span class="cp">use Person;</span>
<span class="cp">@ISA = (&quot;Person&quot;);</span>
<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Employee;</span>
<span class="cp">my $empl = Employee-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$empl-&gt;name(&quot;Jason&quot;);</span>
<span class="cp">$empl-&gt;age(23);</span>
<span class="cp">printf &quot;%s is age %d.\n&quot;, $empl-&gt;name, $empl-&gt;age;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$him = Person::</span>
<span class="cp">new()</span>
<span class="cp">;               # WRONG</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN734"
>Accessing Overridden Methods</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">sub meth { </span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;SUPER::</span>
<span class="cp">meth()</span>
<span class="cp">;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$self-&gt;</span>
<span class="cp">meth();</span>
<span class="cp">                # Call wherever first meth is found</span>
<span class="cp">$self-&gt;Where::</span>
<span class="cp">meth();</span>
<span class="cp">         # Start looking in package &quot;Where&quot;</span>
<span class="cp">$self-&gt;SUPER::</span>
<span class="cp">meth(); </span>
<span class="cp">        # Call overridden version</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $classname  = shift;         # What class are we constructing?</span>
<span class="cp">    my $self       = $classname-&gt;SUPER::new(@_);</span>
<span class="cp">    $self-&gt;_init(@_);</span>
<span class="cp">    return $self;                   # And give it back</span>
<span class="cp">} </span>

<span class="cp">sub _init {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{START}   = time();   # init data fields</span>
<span class="cp">    $self-&gt;{AGE}     = 0;</span>
<span class="cp">    $self-&gt;{EXTRA}   = { @_ };   # anything extra</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj = Widget-&gt;new( haircolor =&gt; red, freckles =&gt; 121 );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $self = bless {}, $class;</span>
<span class="cp">for my $class (@ISA) {</span>
<span class="cp">    my $meth = $class . &quot;::_init&quot;;</span>
<span class="cp">    $self-&gt;$meth(@_) if $class-&gt;can(&quot;_init&quot;);</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN737"
>Generating Attribute Methods Using AUTOLOAD</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>
<span class="cp">use strict;</span>
<span class="cp">use Carp;</span>
<span class="cp">use vars qw($AUTOLOAD %ok_field);</span>

<span class="cp"># Authorize four attribute fields</span>
<span class="cp">for my $attr ( qw(name age peers parent) ) { $ok_field{$attr}++; } </span>

<span class="cp">sub AUTOLOAD {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    my $attr = $AUTOLOAD;</span>
<span class="cp">    $attr =~ s/.*:://;</span>
<span class="cp">    return unless $attr =~ /[^A-Z]/;  # skip DESTROY and all-cap methods</span>
<span class="cp">    croak &quot;invalid attribute method: -&gt;</span>
<span class="cp">$attr()&quot;</span>
<span class="cp"> unless $ok_field{$attr};</span>
<span class="cp">    $self-&gt;{uc $attr} = shift if @_;</span>
<span class="cp">    return $self-&gt;{uc $attr};</span>
<span class="cp">}</span>
<span class="cp">sub new {</span>
<span class="cp">    my $proto  = shift;</span>
<span class="cp">    my $class  = ref($proto) || $proto;</span>
<span class="cp">    my $parent = ref($proto) &amp;&amp; $proto;</span>
<span class="cp">    my $self = {};</span>
<span class="cp">    bless($self, $class);</span>
<span class="cp">    $self-&gt;parent($parent);</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Person;</span>
<span class="cp">my ($dad, $kid);</span>
<span class="cp">$dad = Person-&gt;new;</span>
<span class="cp">$dad-&gt;name(&quot;Jason&quot;);</span>
<span class="cp">$dad-&gt;age(23);</span>
<span class="cp">$kid = $dad-&gt;new;</span>
<span class="cp">$kid-&gt;name(&quot;Rachel&quot;);</span>
<span class="cp">$kid-&gt;age(2);</span>
<span class="cp">printf &quot;Kid&#39;s parent is %s\n&quot;, $kid-&gt;parent-&gt;name;</span>
<span class="cp">#Kid&#39;s parent is Jason</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub AUTOLOAD {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    my $attr = $AUTOLOAD;</span>
<span class="cp">    $attr =~ s/.*:://;</span>
<span class="cp">    return if $attr eq &#39;DESTROY&#39;;   </span>

<span class="cp">    if ($ok_field{$attr}) {</span>
<span class="cp">        $self-&gt;{uc $attr} = shift if @_;</span>
<span class="cp">        return $self-&gt;{uc $attr};</span>
<span class="cp">    } else {</span>
<span class="cp">        my $superior = &quot;SUPER::$attr&quot;;</span>
<span class="cp">        $self-&gt;$superior(@_);</span>
<span class="cp">    } </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN740"
>Solving the Data Inheritance Problem</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">sub Employee::age {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{Employee_age} = shift if @_;</span>
<span class="cp">    return $self-&gt;{Employee_age};</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>
<span class="cp">use Class::Attributes;  # see explanation below</span>
<span class="cp">mkattr qw(name age peers parent);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Employee;</span>
<span class="cp">@ISA = qw(Person);</span>
<span class="cp">use Class::Attributes;</span>
<span class="cp">mkattr qw(salary age boss);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Class::Attributes;</span>
<span class="cp">use strict;</span>
<span class="cp">use Carp;</span>
<span class="cp">use Exporter ();</span>
<span class="cp">use vars qw(@ISA @EXPORT);</span>
<span class="cp">@ISA = qw(Exporter);</span>
<span class="cp">@EXPORT = qw(mkattr);</span>
<span class="cp">sub mkattr {</span>
<span class="cp">    my $hispack = caller();</span>
<span class="cp">    for my $attr (@_) {</span>
<span class="cp">        my($field, $method);</span>
<span class="cp">        $method = &quot;${hispack}::$attr&quot;;</span>
<span class="cp">        ($field = $method) =~ s/:/_/g; </span>
<span class="cp">        no strict &#39;refs&#39;; # here comes the kluglich bit</span>
<span class="cp">        *$method = sub {</span>
<span class="cp">            my $self = shift;</span>
<span class="cp">            confess &quot;too many arguments&quot; if @_ &gt; 1;</span>
<span class="cp">            $self-&gt;{$field} = shift if @_;</span>
<span class="cp">            return $self-&gt;{$field};   </span>
<span class="cp">        };</span>
<span class="cp">    } </span>
<span class="cp">} </span>
<span class="cp">1;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN743"
>Coping with Circular Data Structures</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">$node-&gt;{NEXT} = $node;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Ring;</span>

<span class="cp"># return an empty ring structure</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $node  = { };</span>
<span class="cp">    $node-&gt;{NEXT} = $node-&gt;{PREV} = $node;</span>
<span class="cp">    my $self  = { DUMMY =&gt; $node, COUNT =&gt; 0 };</span>
<span class="cp">    bless $self, $class;</span>
<span class="cp">    return $self;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Ring;</span>

<span class="cp">$COUNT = 1000;</span>
<span class="cp">for (1 .. 20) { </span>
<span class="cp">    my $r = Ring-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">    for ($i = 0; $i &lt; $COUNT; $i++) { $r-&gt;insert($i) } </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># when a Ring is destroyed, destroy the ring structure it contains </span>
<span class="cp">sub DESTROY {</span>
<span class="cp">    my $ring = shift;</span>
<span class="cp">    my $node;</span>
<span class="cp">    for ( $node  =  $ring-&gt;{DUMMY}-&gt;{NEXT};</span>
<span class="cp">          $node !=  $ring-&gt;{DUMMY}; </span>
<span class="cp">          $node  =  $node-&gt;{NEXT} )</span>
<span class="cp">    {</span>
<span class="cp">             $ring-&gt;delete_node($node);</span>
<span class="cp">    } </span>
<span class="cp">    $node-&gt;{PREV} = $node-&gt;{NEXT} = undef;</span>
<span class="cp">} </span>

<span class="cp"># delete a node from the ring structure</span>
<span class="cp">sub delete_node {</span>
<span class="cp">    my ($ring, $node) = @_;</span>
<span class="cp">    $node-&gt;{PREV}-&gt;{NEXT} = $node-&gt;{NEXT};</span>
<span class="cp">    $node-&gt;{NEXT}-&gt;{PREV} = $node-&gt;{PREV};</span>
<span class="cp">    --$ring-&gt;{COUNT};</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># $node = $ring-&gt;search( $value ) : find $value in the ring</span>
<span class="cp"># structure in $node</span>
<span class="cp">sub search {</span>
<span class="cp">    my ($ring, $value) = @_;</span>
<span class="cp">    my $node = $ring-&gt;{DUMMY}-&gt;{NEXT};</span>
<span class="cp">    while ($node != $ring-&gt;{DUMMY} &amp;&amp; $node-&gt;{VALUE} != $value) {</span>
<span class="cp">          $node = $node-&gt;{NEXT};</span>
<span class="cp">    }</span>
<span class="cp">    return $node;</span>
<span class="cp">} </span>

<span class="cp"># $ring-&gt;insert( $value ) : insert $value into the ring structure</span>
<span class="cp">sub insert {</span>
<span class="cp">    my ($ring, $value) = @_;</span>
<span class="cp">    my $node = { VALUE =&gt; $value };</span>
<span class="cp">    $node-&gt;{NEXT} = $ring-&gt;{DUMMY}-&gt;{NEXT};</span>
<span class="cp">    $ring-&gt;{DUMMY}-&gt;{NEXT}-&gt;{PREV} = $node;</span>
<span class="cp">    $ring-&gt;{DUMMY}-&gt;{NEXT} = $node;</span>
<span class="cp">    $node-&gt;{PREV} = $ring-&gt;{DUMMY};</span>
<span class="cp">    ++$ring-&gt;{COUNT};</span>
<span class="cp">} </span>

<span class="cp"># $ring-&gt;delete_value( $value ) : delete a node from the ring</span>
<span class="cp"># structure by value</span>
<span class="cp">sub delete_value {</span>
<span class="cp">    my ($ring, $value) = @_;</span>
<span class="cp">    my $node = $ring-&gt;search($value);</span>
<span class="cp">    return if $node == $ring-&gt;{DUMMY};</span>
<span class="cp">    $ring-&gt;delete_node($node);</span>
<span class="cp">}</span>


<span class="cp">1;</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN746"
>Overloading Operators</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">use overload (&#39;&lt;=&gt;&#39; =&gt; \&amp;threeway_compare);</span>
<span class="cp">sub threeway_compare {</span>
<span class="cp">    my ($s1, $s2) = @_;</span>
<span class="cp">    return uc($s1-&gt;{NAME}) cmp uc($s2-&gt;{NAME});</span>
<span class="cp">} </span>

<span class="cp">use overload ( &#39;&quot;&quot;&#39;  =&gt; \&amp;stringify );</span>
<span class="cp">sub stringify {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return sprintf &quot;%s (%05d)&quot;, </span>
<span class="cp">            ucfirst(lc($self-&gt;{NAME})),</span>
<span class="cp">            $self-&gt;{IDNUM};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package TimeNumber;</span>
<span class="cp">use overload &#39;+&#39; =&gt; \&amp;my_plus,</span>
<span class="cp">             &#39;-&#39; =&gt; \&amp;my_minus,</span>
<span class="cp">             &#39;*&#39; =&gt; \&amp;my_star,</span>
<span class="cp">             &#39;/&#39; =&gt; \&amp;my_slash;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub my_plus {</span>
<span class="cp">    my($left, $right) = @_;</span>
<span class="cp">    my $answer = $left-&gt;</span>
<span class="cp">new();</span>

<span class="cp">    $answer-&gt;{SECONDS} = $left-&gt;{SECONDS} + $right-&gt;{SECONDS};</span>
<span class="cp">    $answer-&gt;{MINUTES} = $left-&gt;{MINUTES} + $right-&gt;{MINUTES};</span>
<span class="cp">    $answer-&gt;{HOURS}   = $left-&gt;{HOURS}   + $right-&gt;{HOURS};</span>

<span class="cp">    if ($answer-&gt;{SECONDS} &gt;= 60) {</span>
<span class="cp">        $answer-&gt;{SECONDS} %= 60;</span>
<span class="cp">        $answer-&gt;{MINUTES} ++;</span>
<span class="cp">    } </span>

<span class="cp">    if ($answer-&gt;{MINUTES} &gt;= 60) {</span>
<span class="cp">        $answer-&gt;{MINUTES} %= 60;</span>
<span class="cp">        $answer-&gt;{HOURS}   ++;</span>
<span class="cp">    } </span>

<span class="cp">    return $answer;</span>

<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># show_strnum - demo operator overloading</span>
<span class="cp">use StrNum;           </span>
<span class="cp">    </span>
<span class="cp">$x = StrNum(&quot;Red&quot;); $y = StrNum(&quot;Black&quot;);</span>
<span class="cp">$z = $x + $y; $r = $z * 3;</span>
<span class="cp">print &quot;values are $x, $y, $z, and $r\n&quot;;</span>
<span class="cp">print &quot;$x is &quot;, $x &lt; $y ? &quot;LT&quot; : &quot;GE&quot;, &quot; $y\n&quot;;</span>

<span class="cp"># values are Red, Black, RedBlack, and RedBlackRedBlackRedBlack</span>
<span class="cp"># Red is GE Black</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/StrNum</span>">download the following standalone program</a></font>
<span class="cp">package StrNum;</span>

<span class="cp">use Exporter ();</span>
<span class="cp">@ISA = &#39;Exporter&#39;;</span>
<span class="cp">@EXPORT = qw(StrNum);  # unusual</span>

<span class="cp">use overload        (</span>
<span class="cp">        &#39;&lt;=&gt;&#39;   =&gt; \&amp;spaceship,</span>
<span class="cp">        &#39;cmp&#39;   =&gt; \&amp;spaceship,</span>
<span class="cp">        &#39;&quot;&quot;&#39;    =&gt; \&amp;stringify,</span>
<span class="cp">        &#39;bool&#39;  =&gt; \&amp;boolify,</span>
<span class="cp">        &#39;0+&#39;    =&gt; \&amp;numify,</span>
<span class="cp">        &#39;+&#39;     =&gt; \&amp;concat,</span>
<span class="cp">        &#39;*&#39;     =&gt; \&amp;repeat,</span>
<span class="cp">);</span>

<span class="cp"># constructor</span>
<span class="cp">sub StrNum($) { </span>
<span class="cp">    my ($value) = @_; </span>
<span class="cp">    return bless \$value; </span>
<span class="cp">} </span>

<span class="cp">sub stringify { ${ $_[0] } } </span>
<span class="cp">sub numify    { ${ $_[0] } } </span>
<span class="cp">sub boolify   { ${ $_[0] } } </span>

<span class="cp"># providing &lt;=&gt; gives us &lt;, ==, etc. for free.</span>
<span class="cp">sub spaceship { </span>
<span class="cp">    my ($s1, $s2, $inverted) = @_;</span>
<span class="cp">    return $inverted ? $$s2 cmp $$s1 : $$s1 cmp $$s2;</span>
<span class="cp">} </span>

<span class="cp"># this uses stringify</span>
<span class="cp">sub concat { </span>
<span class="cp">    my ($s1, $s2, $inverted) = @_;</span>
<span class="cp">    return StrNum $inverted ? ($s2 . $s1) : ($s1 . $s2);</span>
<span class="cp">} </span>

<span class="cp"># this uses stringify</span>
<span class="cp">sub repeat { </span>
<span class="cp">    my ($s1, $s2, $inverted) = @_;</span>
<span class="cp">    return StrNum $inverted ? ($s2 x $s1) : ($s1 x $s2);</span>
<span class="cp">}</span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># demo_fixnum - show operator overloading</span>
<span class="cp">use FixNum;</span>

<span class="cp">FixNum-&gt;places(5);</span>

<span class="cp">$x = FixNum-&gt;new(40);</span>
<span class="cp">$y = FixNum-&gt;new(12);</span>

<span class="cp">print &quot;sum of $x and $y is &quot;, $x + $y, &quot;\n&quot;;</span>
<span class="cp">print &quot;product of $x and $y is &quot;, $x * $y, &quot;\n&quot;;</span>

<span class="cp">$z = $x / $y;</span>
<span class="cp">printf &quot;$z has %d places\n&quot;, $z-&gt;places;</span>
<span class="cp">$z-&gt;places(2) unless $z-&gt;places;</span>
<span class="cp">print &quot;div of $x by $y is $z\n&quot;;</span>
<span class="cp">print &quot;square of that is &quot;, $z * $z, &quot;\n&quot;;</span>

<span class="cp">sum of STRFixNum: 40 and STRFixNum: 12 is STRFixNum: 52</span>

<span class="cp">product of STRFixNum: 40 and STRFixNum: 12 is STRFixNum: 480</span>

<span class="cp">STRFixNum: 3 has 0 places</span>

<span class="cp">div of STRFixNum: 40 by STRFixNum: 12 is STRFixNum: 3.33</span>

<span class="cp">square of that is STRFixNum: 11.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/FixNum</span>">download the following standalone program</a></font>
<span class="cp">package FixNum;</span>

<span class="cp">use strict;</span>

<span class="cp">my $PLACES = 0;</span>

<span class="cp">sub new {</span>
<span class="cp">    my $proto   = shift;</span>
<span class="cp">    my $class   = ref($proto) || $proto;</span>
<span class="cp">    my $parent  = ref($proto) &amp;&amp; $proto;</span>

<span class="cp">    my $v = shift;</span>
<span class="cp">    my $self = {</span>
<span class="cp">        VALUE  =&gt; $v,</span>
<span class="cp">        PLACES =&gt; undef,</span>
<span class="cp">    }; </span>
<span class="cp">    if ($parent &amp;&amp; defined $parent-&gt;{PLACES}) {</span>
<span class="cp">        $self-&gt;{PLACES} = $parent-&gt;{PLACES};</span>
<span class="cp">    } elsif ($v =~ /(\.\d*)/) {</span>
<span class="cp">        $self-&gt;{PLACES} = length($1) - 1;</span>
<span class="cp">    }  else {</span>
<span class="cp">        $self-&gt;{PLACES} = 0;</span>
<span class="cp">    } </span>
<span class="cp">    return bless $self, $class;</span>
<span class="cp">} </span>

<span class="cp">sub places {</span>
<span class="cp">    my $proto = shift;</span>
<span class="cp">    my $self  = ref($proto) &amp;&amp; $proto;</span>
<span class="cp">    my $type  = ref($proto) || $proto;</span>

<span class="cp">    if (@_) {</span>
<span class="cp">        my $places = shift;</span>
<span class="cp">        ($self ? $self-&gt;{PLACES} : $PLACES) = $places;</span>
<span class="cp">    } </span>
<span class="cp">    return $self ? $self-&gt;{PLACES} : $PLACES;</span>
<span class="cp">} </span>

<span class="cp">sub _max { $_[0] &gt; $_[1] ? $_[0] : $_[1] } </span>

<span class="cp">use overload &#39;+&#39;    =&gt; \&amp;add,</span>
<span class="cp">             &#39;*&#39;    =&gt; \&amp;multiply,</span>
<span class="cp">             &#39;/&#39;    =&gt; \&amp;divide,</span>
<span class="cp">             &#39;&lt;=&gt;&#39;  =&gt; \&amp;spaceship,</span>
<span class="cp">             &#39;&quot;&quot;&#39;   =&gt; \&amp;as_string,</span>
<span class="cp">             &#39;0+&#39;   =&gt; \&amp;as_number;</span>

<span class="cp">sub add {</span>
<span class="cp">    my ($this, $that, $flipped) = @_;</span>
<span class="cp">    my $result = $this-&gt;new( $this-&gt;{VALUE} + $that-&gt;{VALUE} );</span>
<span class="cp">    $result-&gt;places( _max($this-&gt;{PLACES}, $that-&gt;{PLACES} ));</span>
<span class="cp">    return $result;</span>
<span class="cp">} </span>

<span class="cp">sub multiply {</span>
<span class="cp">    my ($this, $that, $flipped) = @_;</span>
<span class="cp">    my $result = $this-&gt;new( $this-&gt;{VALUE} * $that-&gt;{VALUE} );</span>
<span class="cp">    $result-&gt;places( _max($this-&gt;{PLACES}, $that-&gt;{PLACES} ));</span>
<span class="cp">    return $result;</span>
<span class="cp">} </span>

<span class="cp">sub divide {</span>
<span class="cp">    my ($this, $that, $flipped) = @_;</span>
<span class="cp">    my $result = $this-&gt;new( $this-&gt;{VALUE} / $that-&gt;{VALUE} );</span>
<span class="cp">    $result-&gt;places( _max($this-&gt;{PLACES}, $that-&gt;{PLACES} ));</span>
<span class="cp">    return $result;</span>
<span class="cp">} </span>

<span class="cp">sub as_string {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return sprintf(&quot;STR%s: %.*f&quot;, ref($self), </span>
<span class="cp">        defined($self-&gt;{PLACES}) ? $self-&gt;{PLACES} : $PLACES, </span>
<span class="cp">            $self-&gt;{VALUE});</span>
<span class="cp">} </span>

<span class="cp">sub as_number {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return $self-&gt;{VALUE};</span>
<span class="cp">} </span>
<span class="cp">    </span>
<span class="cp">sub spaceship {</span>
<span class="cp">    my ($this, $that, $flipped) = @_;</span>
<span class="cp">    $this-&gt;{VALUE} &lt;=&gt; $that-&gt;{VALUE};</span>
<span class="cp">} </span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN749"
>Creating Magic Variables with tie</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">tie $s, &quot;SomeClass&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">SomeClass-&gt;</span>
<span class="cp">TIESCALAR()</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$p = $s</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$p = $obj-&gt;</span>
<span class="cp">FETCH()</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$s = 10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;STORE(10)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># demo_valuering - show tie class</span>
<span class="cp">use ValueRing;</span>
<span class="cp">tie $color, &#39;ValueRing&#39;, qw(red blue);</span>
<span class="cp">print &quot;$color $color $color $color $color $color\n&quot;;</span>
<span class="cp">red blue red blue red blue</span>


<span class="cp">$color = &#39;green&#39;;</span>
<span class="cp">print &quot;$color $color $color $color $color $color\n&quot;;</span>
<span class="cp">green red blue green red blue</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/ValueRing</span>">download the following standalone program</a></font>
<span class="cp">package ValueRing;</span>

<span class="cp"># this is the constructor for scalar ties</span>
<span class="cp">sub TIESCALAR {</span>
<span class="cp">    my ($class, @values) = @_;</span>
<span class="cp">    bless  \@values, $class;</span>
<span class="cp">    return \@values;</span>
<span class="cp">} </span>

<span class="cp"># this intercepts read accesses</span>
<span class="cp">sub FETCH {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    push(@$self, shift(@$self));</span>
<span class="cp">    return $self-&gt;[-1];</span>
<span class="cp">} </span>

<span class="cp"># this intercepts write accesses</span>
<span class="cp">sub STORE {</span>
<span class="cp">    my ($self, $value) = @_;</span>
<span class="cp">    unshift @$self, $value;</span>
<span class="cp">    return $value;</span>
<span class="cp">} </span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">no UnderScore;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># nounder_demo - show how to ban $_ from your program</span>
<span class="cp">no UnderScore;</span>
<span class="cp">@tests = (</span>
<span class="cp">    &quot;Assignment&quot;  =&gt; sub { $_ = &quot;Bad&quot; },</span>
<span class="cp">    &quot;Reading&quot;     =&gt; sub { print }, </span>
<span class="cp">    &quot;Matching&quot;    =&gt; sub { $x = /badness/ },</span>
<span class="cp">    &quot;Chop&quot;        =&gt; sub { chop },</span>
<span class="cp">    &quot;Filetest&quot;    =&gt; sub { -x }, </span>
<span class="cp">    &quot;Nesting&quot;     =&gt; sub { for (1..3) { print } },</span>
<span class="cp">);</span>

<span class="cp">while ( ($name, $code) = splice(@tests, 0, 2) ) {</span>
<span class="cp">    print &quot;Testing $name: &quot;;</span>
<span class="cp">    eval { &amp;$code };</span>
<span class="cp">    print $@ ? &quot;detected&quot; : &quot;missed!&quot;;</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">Testing Assignment: detected</span>

<span class="cp">Testing Reading: detected</span>

<span class="cp">Testing Matching: detected</span>

<span class="cp">Testing Chop: detected</span>

<span class="cp">Testing Filetest: detected</span>

<span class="cp">Testing Nesting: 123missed!</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/UnderScore</span>">download the following standalone program</a></font>
<span class="cp">package UnderScore;</span>
<span class="cp">use Carp;</span>
<span class="cp">sub TIESCALAR {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $dummy;</span>
<span class="cp">    return bless \$dummy =&gt; $class;</span>
<span class="cp">} </span>
<span class="cp">sub FETCH { croak &quot;Read access to \$_ forbidden&quot;  } </span>
<span class="cp">sub STORE { croak &quot;Write access to \$_ forbidden&quot; } </span>
<span class="cp">sub unimport { tie($_, _     _PACKAGE_     _) }</span>
<span class="cp">sub import { untie $_ } </span>
<span class="cp">tie($_, _     _PACKAGE_     _) unless tied $_;</span>
<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl </span>
<span class="cp"># appendhash_demo - show magic hash that autoappends</span>
<span class="cp">use Tie::AppendHash;</span>
<span class="cp">tie %tab, &#39;Tie::AppendHash&#39;;</span>

<span class="cp">$tab{beer} = &quot;guinness&quot;;</span>
<span class="cp">$tab{food} = &quot;potatoes&quot;;</span>
<span class="cp">$tab{food} = &quot;peas&quot;;</span>

<span class="cp">while (my($k, $v) = each %tab) {</span>
<span class="cp">    print &quot;$k =&gt; [@$v]\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">food =&gt; [potatoes peas]</span>

<span class="cp">beer =&gt; [guinness]</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Tie/AppendHash.pm</span>">download the following standalone program</a></font>
<span class="cp">package Tie::AppendHash;</span>
<span class="cp">use strict;</span>
<span class="cp">use Tie::Hash;</span>
<span class="cp">use Carp;</span>
<span class="cp">use vars qw(@ISA);</span>
<span class="cp">@ISA = qw(Tie::StdHash);</span>
<span class="cp">sub STORE {</span>
<span class="cp">    my ($self, $key, $value) = @_;</span>
<span class="cp">    push @{$self-&gt;{key}}, $value;</span>
<span class="cp">} </span>
<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl </span>
<span class="cp"># folded_demo - demo hash that magically folds case</span>
<span class="cp">use Tie::Folded;</span>
<span class="cp">tie %tab, &#39;Tie::Folded&#39;;</span>

<span class="cp">$tab{VILLAIN}  = &quot;big &quot;; </span>
<span class="cp">$tab{herOine}  = &quot;red riding hood&quot;;</span>
<span class="cp">$tab{villain} .= &quot;bad wolf&quot;;   </span>

<span class="cp">while ( my($k, $v) = each %tab ) {</span>
<span class="cp">    print &quot;$k is $v\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">heroine is red riding hood</span>

<span class="cp">villain is big bad wolf</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Tie/Folded.pm</span>">download the following standalone program</a></font>
<span class="cp">package Tie::Folded;</span>
<span class="cp">use strict;</span>
<span class="cp">use Tie::Hash;</span>
<span class="cp">use vars qw(@ISA);</span>
<span class="cp">@ISA = qw(Tie::StdHash);</span>
<span class="cp">sub STORE {</span>
<span class="cp">    my ($self, $key, $value) = @_;</span>
<span class="cp">    return $self-&gt;{lc $key} = $value;</span>
<span class="cp">    } </span>
<span class="cp">sub FETCH {</span>
<span class="cp">    my ($self, $key) = @_;</span>
<span class="cp">    return $self-&gt;{lc $key};</span>
<span class="cp">} </span>
<span class="cp">sub EXISTS {</span>
<span class="cp">    my ($self, $key) = @_;</span>
<span class="cp">    return exists $self-&gt;{lc $key};</span>
<span class="cp">} </span>
<span class="cp">sub DEFINED {</span>
<span class="cp">    my ($self, $key) = @_;</span>
<span class="cp">    return defined $self-&gt;{lc $key};</span>
<span class="cp">} </span>
<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># revhash_demo - show hash that permits key *or* value lookups</span>
<span class="cp">use strict;</span>
<span class="cp">use Tie::RevHash;</span>
<span class="cp">my %tab;</span>
<span class="cp">tie %tab, &#39;Tie::RevHash&#39;;</span>
<span class="cp">%tab = qw{</span>
<span class="cp">    Red         Rojo</span>
<span class="cp">    Blue        Azul</span>
<span class="cp">    Green       Verde</span>
<span class="cp">};</span>
<span class="cp">$tab{EVIL} = [ &quot;No way!&quot;, &quot;Way!!&quot; ];</span>

<span class="cp">while ( my($k, $v) = each %tab ) {</span>
<span class="cp">    print ref($k) ? &quot;[@$k]&quot; : $k, &quot; =&gt; &quot;,</span>
<span class="cp">        ref($v) ? &quot;[@$v]&quot; : $v, &quot;\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">[No way! Way!!] =&gt; EVIL</span>

<span class="cp">EVIL =&gt; [No way! Way!!]</span>

<span class="cp">Blue =&gt; Azul</span>

<span class="cp">Green =&gt; Verde</span>

<span class="cp">Rojo =&gt; Red</span>

<span class="cp">Red =&gt; Rojo</span>

<span class="cp">Azul =&gt; Blue</span>

<span class="cp">Verde =&gt; Green</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Tie/RevHash.pm</span>">download the following standalone program</a></font>
<span class="cp">package Tie::RevHash;</span>
<span class="cp">use Tie::RefHash;</span>
<span class="cp">use vars qw(@ISA);</span>
<span class="cp">@ISA = qw(Tie::RefHash);</span>
<span class="cp">sub STORE {</span>
<span class="cp">    my ($self, $key, $value) = @_;</span>
<span class="cp">    $self-&gt;SUPER::STORE($key, $value);</span>
<span class="cp">    $self-&gt;SUPER::STORE($value, $key);</span>
<span class="cp">}</span>

<span class="cp">sub DELETE {</span>
<span class="cp">    my ($self, $key) = @_;</span>
<span class="cp">    my $value = $self-&gt;SUPER::FETCH($key);</span>
<span class="cp">    $self-&gt;SUPER::DELETE($key);</span>
<span class="cp">    $self-&gt;SUPER::DELETE($value);</span>
<span class="cp">}</span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">use Counter;</span>
<span class="cp">tie *CH, &#39;Counter&#39;;</span>
<span class="cp">while (&lt;CH&gt;) {</span>
<span class="cp">    print &quot;Got $_\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Counter</span>">download the following standalone program</a></font>
<span class="cp">package Counter;</span>
<span class="cp">sub TIEHANDLE {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $start = shift;</span>
<span class="cp">    return bless \$start =&gt; $class;</span>
<span class="cp">} </span>
<span class="cp">sub READLINE {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return ++$$self;</span>
<span class="cp">} </span>
<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">use Tie::Tee;</span>
<span class="cp">tie *TEE, &#39;Tie::Tee&#39;, *STDOUT, *STDERR;</span>
<span class="cp">print TEE &quot;This line goes both places.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># demo_tietee</span>
<span class="cp">use Tie::Tee;</span>
<span class="cp">use Symbol;</span>

<span class="cp">@handles = (*STDOUT);</span>
<span class="cp">for $i ( 1 .. 10 ) {</span>
<span class="cp">    push(@handles, $handle = gensym());</span>
<span class="cp">    open($handle, &quot;&gt;/tmp/teetest.$i&quot;);</span>
<span class="cp">} </span>

<span class="cp">tie *TEE, &#39;Tie::Tee&#39;, @handles;</span>
<span class="cp">print TEE &quot;This lines goes many places.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Tie/Tee.pm</span>">download the following standalone program</a></font>
<span class="cp">package Tie::Tee;</span>

<span class="cp">sub TIEHANDLE {</span>
<span class="cp">    my $class   = shift;</span>
<span class="cp">    my $handles = [@_];</span>

<span class="cp">    bless $handles, $class;</span>
<span class="cp">    return $handles;</span>
<span class="cp">}</span>

<span class="cp">sub PRINT {</span>
<span class="cp">    my $href = shift;</span>
<span class="cp">    my $handle;</span>
<span class="cp">    my $success = 0;</span>

<span class="cp">    foreach $handle (@$href) {</span>
<span class="cp">        $success += print $handle @_;</span>
<span class="cp">    }</span>

<span class="cp">    return $success == @$href;</span>
<span class="cp">}                                     </span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="packagesetc.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="dbaccess.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Packages, Libraries, and Modules</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Database Access</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>