<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Strings</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Clojure"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="PLEAC-Clojure"
HREF="index.html"><LINK
REL="NEXT"
TITLE="Numbers"
HREF="numbers.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Clojure</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="numbers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="STRINGS"
>1. Strings</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN14"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="c1">;; ---------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;\\n&quot;</span><span class="p">)</span>                 <span class="c1">; two characters, \ and an n</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;Jon &#39;Maddog&#39; Orwant&quot;</span><span class="p">)</span> <span class="c1">; literal single quotes</span>
<span class="c1">;; ---------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span>                    <span class="c1">; &quot;newline&quot; character</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;Jon \&quot;Maddog\&quot; Orwant&quot;</span><span class="p">)</span> <span class="c1">; literal double quotes</span>

<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="s">&quot;</span>
<span class="s">    This is a multiline here document</span>
<span class="s">    terminated by one double quote.</span>
<span class="s">    &quot;</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN17"
>Accessing Substrings</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="k">def </span><span class="nv">value</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="nv">offset</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">offset</span> <span class="nv">count</span><span class="p">)))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">value</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="nv">offset</span> <span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)))</span>

<span class="c1">;; or</span>
<span class="p">(</span><span class="k">def </span><span class="nv">value</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="nv">offset</span><span class="p">))</span>

<span class="c1">;; Clojure strings are immutable Java strings, so while you cannot</span>
<span class="c1">;; modify an existing string, you can build a new one with part of it</span>
<span class="c1">;; replaced by another.</span>

<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="nv">offset</span><span class="p">)</span> <span class="nv">newstring</span>
                 <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">offset</span> <span class="nv">count</span><span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="nv">offset</span><span class="p">)</span> <span class="nv">newtail</span><span class="p">))</span>

<span class="c1">;; -----------------------------</span>
<span class="c1">;; get a 5-byte string, skip 3, then grab 2 8-byte strings, then the rest</span>

<span class="c1">;; split at &#39;sz&#39; byte boundaries</span>
<span class="c1">;; jli for mbac: partition is the bomb for this</span>
<span class="c1">;; mbac for jli: hell yeah!</span>
<span class="c1">;; jli for mbac: I meant, &quot;partition&quot; is old and tired. all the cool</span>
<span class="c1">;;               kids are using &quot;partition-all&quot;. see commify-hipster.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">split-every-n-chars</span> <span class="p">[</span><span class="nv">sz</span> <span class="nv">string</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">string</span><span class="p">)</span>
    <span class="p">()</span>
    <span class="p">(</span><span class="nf">try</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">beg</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="nv">sz</span><span class="p">)</span>
            <span class="nb">rest </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="nv">sz</span><span class="p">)]</span>
        <span class="p">(</span><span class="nb">cons </span><span class="nv">beg</span> <span class="p">(</span><span class="nf">split-every-n-chars</span> <span class="nv">sz</span> <span class="nv">rest</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">catch</span> <span class="nv">Exception</span> <span class="nv">_e</span> <span class="p">[</span><span class="nv">string</span><span class="p">]))))</span>

<span class="c1">;; or the more idiomatic version</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">split-every-n-chars</span> <span class="p">[</span><span class="nv">sz</span> <span class="nv">string</span><span class="p">]</span>
  <span class="c1">;; the map turns vector of char vector into vector of string</span>
  <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">apply str </span><span class="nv">x</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">partition</span> <span class="mi">5</span> <span class="mi">5</span> <span class="nv">nil</span> <span class="nv">string</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">fivers</span> <span class="p">(</span><span class="nf">split-every-n-chars</span> <span class="mi">5</span> <span class="nv">string</span><span class="p">))</span>

<span class="c1">;; chop string into individual characters</span>
<span class="p">(</span><span class="k">def </span><span class="nv">chars</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">string</span><span class="p">))</span>

<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;This is what you have&quot;</span><span class="p">)</span>
<span class="c1">;; Indexes are left to right. There is no possibility to index</span>
<span class="c1">;; directly from right to left</span>
<span class="c1">;; &quot;T&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nb">first </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">;; &quot;is&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">start</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">))</span>
<span class="c1">;; &quot;you have&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nb">rest </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">13</span><span class="p">))</span>
<span class="c1">;; &quot;e&quot; *)</span>
<span class="p">(</span><span class="k">def </span><span class="nb">last </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">len</span> <span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)]</span>
            <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">1</span><span class="p">))))</span>
<span class="c1">;; &quot;have&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">theend</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">len</span> <span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)]</span>
              <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">4</span><span class="p">))))</span>
<span class="c1">;; &quot;you&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">piece</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">len</span> <span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)]</span>
             <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">5</span><span class="p">))))</span>

<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;This is what you have&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s&quot;</span> <span class="s">&quot;string&quot;</span><span class="p">)</span>

<span class="c1">;; Change &quot;is&quot; to &quot;wasn&#39;t&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nf">str</span>
             <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="mi">5</span><span class="p">)</span>
             <span class="s">&quot;wasn&#39;t&quot;</span>
             <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">7</span><span class="p">)))</span>
<span class="c1">;; This wasn&#39;t what you have</span>

<span class="c1">;; This wasn&#39;t wonderous</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span>
     <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)</span> <span class="mi">12</span><span class="p">))</span> <span class="s">&quot;ondrous&quot;</span><span class="p">))</span>

<span class="c1">;; delete first character</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">;; his wasn&#39;t wondrous</span>

<span class="c1">;; delete last 10 characters</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)</span> <span class="mi">10</span><span class="p">)))</span>
<span class="c1">;; his wasn&#39;</span>
<span class="c1">;; -----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN20"
>Establishing a Default Value</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="c1">;; While Perl treats undef, 0, and &quot;&quot; as false, Clojure treats the</span>
<span class="c1">;; values false and nil as false, but 0 and &quot;&quot; as true.</span>

<span class="c1">;; -----------------------------</span>
<span class="c1">;; use b if b is true, else c</span>
<span class="c1">;; Note that if b has never been defined or had a value bound to it,</span>
<span class="c1">;; then unlike Perl this will give an error that the value is</span>
<span class="c1">;; undefined.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nb">or </span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>

<span class="c1">;; re-define x with the value y, unless x is already true</span>
<span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nb">when-not </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="c1">;; use b if b is defined, otherwise c</span>
<span class="c1">;; This correctly tests whether b is bound to a value or not, but</span>
<span class="c1">;; if it is not, then it throws an exception because of the last</span>
<span class="c1">;; occurrence of b not having a value.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">find </span><span class="p">(</span><span class="nb">ns-interns </span><span class="nv">*ns*</span><span class="p">)</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="c1">;; This is closer:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">find </span><span class="p">(</span><span class="nb">ns-interns </span><span class="nv">*ns*</span><span class="p">)</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval </span><span class="ss">&#39;b</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span>

<span class="c1">;; But note that if b is only bound in a let, or as a function</span>
<span class="c1">;; argument, but not at the top level with def or something similar,</span>
<span class="c1">;; then this code will go with the value of c.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="s">&quot;c-value&quot;</span>
      <span class="nv">b</span> <span class="s">&quot;b-value&quot;</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">find </span><span class="p">(</span><span class="nb">ns-interns </span><span class="nv">*ns*</span><span class="p">)</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval </span><span class="ss">&#39;b</span><span class="p">)</span> <span class="nv">c</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;a=%s&quot;</span> <span class="nv">a</span><span class="p">)))</span>
<span class="c1">;; a=c-value</span>

<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">foo</span> <span class="p">(</span><span class="nb">or </span><span class="nv">bar</span> <span class="s">&quot;DEFAULT VALUE&quot;</span><span class="p">))</span>

<span class="c1">;; Clojure data structures are immutable.  The code below does not</span>
<span class="c1">;; change the value of *command-line-args*, whereas Perl</span>
<span class="c1">;; &#39;shift(@ARGV)&#39; does modify @ARGV by removing its first element.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">dir</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">count </span><span class="nv">*command-line-args*</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">nth </span><span class="nv">*command-line-args*</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;/tmp&quot;</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN23"
>Exchanging Values Without Using Temporary Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;; -----------------------------</span>

<span class="c1">;; This Clojure code does _not_ exchange values of var1 and var2</span>
<span class="c1">;; without a temporary.  It binds var1 to the value of var2, then</span>
<span class="c1">;; binds var2 to the new value of var1, so they both end up with the</span>
<span class="c1">;; original value of var2.</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">var1</span> <span class="nv">var2</span>
      <span class="nv">var2</span> <span class="nv">var1</span><span class="p">])</span>

<span class="c1">;; This will achieve the desired effect.  It creates a vector of the</span>
<span class="c1">;; values of var2 and var1, then binds them using a technique called</span>
<span class="c1">;; &#39;destructuring&#39; to var1 and var2.</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">var1</span> <span class="nv">var2</span><span class="p">]</span> <span class="p">[</span><span class="nv">var2</span> <span class="nv">var1</span><span class="p">]])</span>


<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">temp</span> <span class="nv">a</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="nv">temp</span><span class="p">)</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="s">&quot;alpha&quot;</span>
      <span class="nv">b</span> <span class="s">&quot;omega&quot;</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">[</span><span class="nv">b</span> <span class="nv">a</span><span class="p">]]</span>
    <span class="c1">;; the first shall be last -- and versa vice</span>
    <span class="p">))</span>

<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">alpha</span> <span class="s">&quot;January&quot;</span>
      <span class="nv">beta</span> <span class="s">&quot;March&quot;</span>
      <span class="nv">production</span> <span class="s">&quot;August&quot;</span><span class="p">]</span>
<span class="c1">;; move beta to alpha</span>
<span class="c1">;; move production to beta</span>
<span class="c1">;; move alpha to production</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">alpha</span> <span class="nv">beta</span> <span class="nv">production</span><span class="p">]</span> <span class="p">[</span><span class="nv">beta</span> <span class="nv">production</span> <span class="nv">alpha</span><span class="p">]]</span>

    <span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN26"
>Converting Between ASCII Characters and Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">num</span> <span class="p">(</span><span class="nb">int </span><span class="sc">\a</span><span class="p">))</span>     <span class="c1">; =&gt; ASCII code 97</span>
<span class="p">(</span><span class="k">def </span><span class="nb">char </span><span class="p">(</span><span class="nb">char </span><span class="mi">97</span><span class="p">))</span>   <span class="c1">; =&gt; \a</span>
<span class="c1">;; -----------------------------</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-ascii-code-for-char</span> <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Number %d is character &#39;%c&#39;\n&quot;</span> <span class="p">(</span><span class="nb">int </span><span class="nv">c</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span>

<span class="c1">;; (print-ascii-code-for-char \a)</span>
<span class="c1">;; Number 97 is the ASCII character a</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN29"
>Processing a String One Character at a Time</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;; Strings in Clojure can be treated as sequences, so the usual</span>
<span class="c1">;; map, reduce, doseq functions apply.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">one-char-at-a-time</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">string</span><span class="p">]</span> <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">b</span> <span class="nv">string</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">b</span><span class="p">)))</span>

<span class="c1">;; =&gt; (one-char-at-a-time</span>
<span class="c1">;;       (fn [b] (printf &quot;do something with: %c\n&quot; b))</span>
<span class="c1">;;       &quot;abc&quot;)</span>
<span class="c1">;; do something with: a</span>
<span class="c1">;; do something with: b</span>
<span class="c1">;; do something with: c</span>
<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-uniq-chars</span> <span class="p">[</span><span class="nv">string</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;unique chars are: %s\n&quot;</span>
          <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">set </span><span class="nv">string</span><span class="p">))))</span>
<span class="c1">;; =&gt; (print-uniq-chars &quot;an apple a day&quot;)</span>
<span class="c1">;; unique chars are: (\space \a \d \e \l \n \p \y)</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">print-ascii-value-sum</span> <span class="p">[</span><span class="nv">string</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;sum is %s\n&quot;</span> <span class="p">(</span><span class="nb">apply + </span><span class="p">(</span><span class="nb">map int </span><span class="nv">string</span><span class="p">))))</span>
<span class="c1">;; =&gt; (print-ascii-value-sum &quot;an apple a day&quot;)</span>
<span class="c1">;; sum is 1248</span>
<span class="c1">;; -----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32"
>Reversing a String by Word or Character</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;; -----------------------------</span>
<span class="c1">;; Make namespace clojure.string usable with the abbreviated name</span>
<span class="c1">;; &#39;str&#39;.</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">revbytes</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">string</span><span class="p">))</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; TBD: Verify whether the split call below matches the behavior of</span>
<span class="c1">;; Perl split with a &quot; &quot; as first arg.  Should we use the regular</span>
<span class="c1">;; expression #&quot;\s+&quot; to match Perl behavior more closely?  Does that</span>
<span class="c1">;; even match exactly?  What about white space before first word or</span>
<span class="c1">;; after last word in the string to be split?</span>
<span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nf">str/split</span> <span class="nb">str </span><span class="o">#</span><span class="s">&quot;\s+&quot;</span><span class="p">)))</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">gnirts</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">string</span><span class="p">))</span>    <span class="c1">; str/reverse reverses letters in string</span>

<span class="p">(</span><span class="k">def </span><span class="nv">sdrow</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">words</span><span class="p">))</span>          <span class="c1">; reverse reverses elements in sequence</span>

<span class="c1">;; TBD: What corresponds to following Perl?</span>
<span class="c1">;; $confused = reverse(@words);        # reverse letters in join(&quot;&quot;, @words)</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; reverse word order</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;Yoda said, \&quot;can you see this?\&quot;&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">allwords</span> <span class="p">(</span><span class="nf">str/split</span> <span class="nv">string</span> <span class="o">#</span><span class="s">&quot;\s+&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">revwords</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">allwords</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">revwords</span><span class="p">)</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; There is no shortcut in Clojure like in Perl for the last arg of</span>
<span class="c1">;; str/split equal to &quot; &quot; meaning the same thing as matching on the</span>
<span class="c1">;; regular expression #&quot;\s+&quot;</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">revwords</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nf">str/split</span> <span class="nb">str </span><span class="o">#</span><span class="s">&quot;\s+&quot;</span><span class="p">))))</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">word</span> <span class="s">&quot;reviver&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">is-palindrome</span> <span class="p">(</span><span class="nb">= </span><span class="nv">word</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">word</span><span class="p">)))</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; No Clojure program I know of equivalent to Perl&#39;s for finding</span>
<span class="c1">;; palindromes of length 5 or larger conveniently fits into a single</span>
<span class="c1">;; line.  Better to create a file with this program.</span>

<span class="p">(</span><span class="kd">ns </span><span class="nv">print-palindromes</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>

<span class="c1">;; mbac for jafingerhut: don&#39;t you need to close the file handle returned by io/reader?</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">filename</span> <span class="nv">*command-line-args*</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">filename</span><span class="p">))]</span>
    <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">line</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">line</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">count </span><span class="nv">line</span><span class="p">)</span> <span class="mi">5</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">line</span><span class="p">))))</span>

<span class="c1">;; Save the above in a file print-palindromes.clj, then run from</span>
<span class="c1">;; command prompt (replace path to wherever your clojure-1.3.0.jar</span>
<span class="c1">;; file is located):</span>

<span class="c1">;; % java -cp /Users/jafinger/lein/clj-1.3.0/lib/clojure-1.3.0.jar clojure.main print-palindromes.clj /usr/share/dict/words</span>

<span class="c1">;; Alternately, on Linux/*BSD/Mac OS X, create a shell script like</span>
<span class="c1">;; this:</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; #! /bin/sh</span>
<span class="c1">;;</span>
<span class="c1">;; # Replace the path below to refer to the Clojure jar file on your system.</span>
<span class="c1">;; CLJ_JAR=$HOME/lein/clj-1.3.0/lib/clojure-1.3.0.jar</span>
<span class="c1">;; scriptname=&quot;$1&quot;</span>
<span class="c1">;; shift</span>
<span class="c1">;; java -cp $CLJ_JAR:. clojure.main &quot;$scriptname&quot; &quot;$@&quot;</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; If you save that as the file &#39;clj&#39; somewhere in your command path</span>
<span class="c1">;; and make it executable (remove the &#39;;; &#39; before each line), and add</span>
<span class="c1">;; this line to the beginning of print-palindromes.clj:</span>
<span class="c1">;;</span>
<span class="c1">;; #! /usr/bin/env clj</span>
<span class="c1">;;</span>
<span class="c1">;; Then you can use the command line:</span>
<span class="c1">;;</span>
<span class="c1">;; % ./print-palindromes.clj /usr/share/dict/words</span>
<span class="c1">;;</span>
<span class="c1">;; or if print-palindromes.clj is in your command path (perhaps</span>
<span class="c1">;; because . is in your command path, although I wouldn&#39;t recommend it</span>
<span class="c1">;; for security reasons):</span>
<span class="c1">;;</span>
<span class="c1">;; % print-palindromes.clj /usr/share/dict/words</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN35"
>Expanding and Compressing Tabs</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; Clojure&#39;s built-in regexp matching functions have something like</span>
<span class="c1">;; Perl&#39;s $&amp; that returns everything that a regexp matched within a</span>
<span class="c1">;; string, and also like Perl&#39;s $1, $2, $3, etc. that match</span>
<span class="c1">;; parenthesized groups.  However, it seems to require calls to Java</span>
<span class="c1">;; methods to get something like Perl&#39;s $` and $&#39; that return the</span>
<span class="c1">;; strings that are before and after the regexp match.</span>

<span class="c1">;; The Clojure function expand-str below is most closely analagous to</span>
<span class="c1">;; the following Perl code:</span>

<span class="c1">;; sub expand_str {</span>
<span class="c1">;;     my $s = shift;</span>
<span class="c1">;;     while (1) {</span>
<span class="c1">;;         if ($s =~ /\t+/) {</span>
<span class="c1">;;             $s = $` . (&#39; &#39; x (length($&amp;) * 8 - length($`) % 8)) . $&#39;;</span>
<span class="c1">;;         } else {</span>
<span class="c1">;;             return $s;</span>
<span class="c1">;;         }</span>
<span class="c1">;;     }</span>
<span class="c1">;; }</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">s</span> <span class="nv">s</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">m</span> <span class="p">(</span><span class="nb">re-matcher </span><span class="o">#</span><span class="s">&quot;\t+&quot;</span> <span class="nv">s</span><span class="p">)</span>
          <span class="nv">tabs</span> <span class="p">(</span><span class="nb">re-find </span><span class="nv">m</span><span class="p">)]</span>         <span class="c1">; Like Perl&#39;s $&amp;</span>
      <span class="p">(</span><span class="k">if </span><span class="nv">tabs</span>
        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">before-tabs</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="mi">0</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">start</span><span class="p">)))</span>  <span class="c1">; Like Perl&#39;s $`</span>
              <span class="nv">after-tabs</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">end</span><span class="p">)))]</span>      <span class="c1">; $&#39;</span>
          <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">str </span><span class="nv">before-tabs</span>
                      <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">)</span>
                                            <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">before-tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">))</span>
                                         <span class="s">&quot; &quot;</span><span class="p">))</span>
                      <span class="nv">after-tabs</span><span class="p">)))</span>
        <span class="nv">s</span><span class="p">))))</span>

<span class="c1">;; Performance note: The code above will recompile the regexp #&quot;\t+&quot;</span>
<span class="c1">;; each time through the loop.  If you want it to be compiled only</span>
<span class="c1">;; once, wrap the function body in a (let [pat #&quot;\t+&quot;] ...) and use</span>
<span class="c1">;; pat in place of #&quot;\t+&quot; in the body.</span>

<span class="c1">;; Another way is to use the regexp &quot;^([^\t]*)(\t+)&quot; instead of simply</span>
<span class="c1">;; &quot;\t+&quot;.  The ([^\t]*) will explicitly match everything before the</span>
<span class="c1">;; first tabs.  Warning: using (.*) instead would greedily match as</span>
<span class="c1">;; much of the beginning of the string as possible, including tabs, so</span>
<span class="c1">;; would not correctly cause (\t+) to match the _first_ tabs in the</span>
<span class="c1">;; string.</span>

<span class="c1">;; According to http://dev.clojure.org/jira/browse/CLJ-753 there is a</span>
<span class="c1">;; bug in str/replace-first where it returns nil instead of the</span>
<span class="c1">;; unmodified string s if the regexp pattern is not found to match</span>
<span class="c1">;; anywhere in s.</span>

<span class="c1">;; replace-first-fixed is a modified version of str/replace-first that</span>
<span class="c1">;; behaves as the corrected version should.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">replace-first-fixed</span> <span class="p">[</span><span class="nv">s</span> <span class="nv">pat</span> <span class="nv">fn</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">new-s</span> <span class="p">(</span><span class="nf">str/replace-first</span> <span class="nv">s</span> <span class="nv">pat</span> <span class="nv">fn</span><span class="p">)]</span>
    <span class="nv">new-s</span>
    <span class="nv">s</span><span class="p">))</span>

<span class="c1">;; The last argument to str/replace-first is a fn that takes a vector</span>
<span class="c1">;; of strings as an argument.  The first of these strings is</span>
<span class="c1">;; everything that was matched by the regexp pattern.  The rest are</span>
<span class="c1">;; the strings matched by parenthesized groups inside the regexp.  We</span>
<span class="c1">;; use Clojure&#39;s destructuring on function arguments to break up the</span>
<span class="c1">;; vector argument to replace-tabs and give names to its elements.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">replace-tabs</span> <span class="p">[[</span><span class="nv">all-matched</span> <span class="nv">before-tabs</span> <span class="nv">tabs</span><span class="p">]]</span>
  <span class="p">(</span><span class="nb">str </span><span class="nv">before-tabs</span>
       <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">before-tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">))</span>
                          <span class="s">&quot; &quot;</span><span class="p">))))</span>

<span class="c1">;; Repeatedly call replace-first-fixed until the string does not</span>
<span class="c1">;; change, indicating that no match was found.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">s</span> <span class="nv">s</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">next-s</span> <span class="p">(</span><span class="nf">replace-first-fixed</span> <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;^([^\t]*)(\t+)&quot;</span> <span class="nv">replace-tabs</span><span class="p">)]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">s</span> <span class="nv">next-s</span><span class="p">)</span>
        <span class="nv">s</span>
        <span class="p">(</span><span class="nf">recur</span> <span class="nv">next-s</span><span class="p">)))))</span>

<span class="c1">;; Performance note: Same as above about the regexp being recompiled</span>
<span class="c1">;; every time through the loop.  Bind the regexp to a symbol using</span>
<span class="c1">;; let, outside of the loop, to compile it only once.</span>

<span class="c1">;; My favorite version of this requires defining slightly modified</span>
<span class="c1">;; versions of clojure.core/re-groups and clojure.string/replace-first</span>

<span class="c1">;; The modified re-groups+ returns a vector like (re-groups) does,</span>
<span class="c1">;; except it always returns a vector, even if there are no</span>
<span class="c1">;; parenthesized subexpressions in the regexp, and it always returns</span>
<span class="c1">;; the part of the string before the match (Perl&#39;s $`) as the first</span>
<span class="c1">;; element, and the part of the string after the match (Perl&#39;s $&#39;) as</span>
<span class="c1">;; the last element.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">re-groups+</span> <span class="p">[</span><span class="o">^</span><span class="nv">java.util.regex.Matcher</span> <span class="nv">m</span> <span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">gc</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">groupCount</span><span class="p">))</span>
        <span class="nv">pre</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="mi">0</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">start</span><span class="p">)))</span>
        <span class="nv">post</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">end</span><span class="p">)))]</span>
    <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">v</span> <span class="p">[</span><span class="nv">pre</span><span class="p">]</span> <span class="nv">c</span> <span class="mi">0</span><span class="p">]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">c</span> <span class="nv">gc</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">group</span> <span class="nv">c</span><span class="p">)))</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">c</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="nv">post</span><span class="p">)))))</span>

<span class="c1">;; replace-first+ is based on Clojure&#39;s hidden internal function</span>
<span class="c1">;; replace-first-by, except that it calls the user-supplied fn f for</span>
<span class="c1">;; calculating the replcement string with the return value of</span>
<span class="c1">;; re-groups+ instead of re-groups, so f can use those additional</span>
<span class="c1">;; strings to calculate the replacement.</span>

<span class="c1">;; The other difference is that it returns a vector of two elements:</span>
<span class="c1">;; the first is the string matched, or nil if there was no match.  The</span>
<span class="c1">;; second is the string after replacement on a match, or the original</span>
<span class="c1">;; string if no match.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">replace-first+</span>
  <span class="p">[</span><span class="o">^</span><span class="nv">CharSequence</span> <span class="nv">s</span> <span class="o">^</span><span class="nv">java.util.regex.Pattern</span> <span class="nv">re</span> <span class="nv">f</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">m</span> <span class="p">(</span><span class="nb">re-matcher </span><span class="nv">re</span> <span class="nv">s</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">buffer</span> <span class="p">(</span><span class="nf">StringBuffer.</span> <span class="p">(</span><span class="nf">.length</span> <span class="nv">s</span><span class="p">))]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">.find</span> <span class="nv">m</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">groups</span> <span class="p">(</span><span class="nf">re-groups+</span> <span class="nv">m</span> <span class="nv">s</span><span class="p">)</span>
              <span class="nv">rep</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">groups</span><span class="p">)]</span>
          <span class="p">(</span><span class="nf">.appendReplacement</span> <span class="nv">m</span> <span class="nv">buffer</span> <span class="nv">rep</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">.appendTail</span> <span class="nv">m</span> <span class="nv">buffer</span><span class="p">)</span>
          <span class="p">[(</span><span class="nb">second </span><span class="nv">groups</span><span class="p">)</span> <span class="p">(</span><span class="nb">str </span><span class="nv">buffer</span><span class="p">)])</span>
        <span class="p">[</span><span class="nv">nil</span> <span class="nv">s</span><span class="p">]))))</span>

<span class="c1">;; Assuming the above are added to Clojure, or some user-defined</span>
<span class="c1">;; library of commonly-used utilities, the &quot;new code&quot; is as follows:</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[[</span><span class="nv">found-match</span> <span class="nv">s</span><span class="p">]</span> <span class="p">[</span><span class="nv">true</span> <span class="nv">s</span><span class="p">]]</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">found-match</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">replace-first+</span> <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;\t+&quot;</span>
                             <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">pre</span> <span class="nv">tabs</span> <span class="nv">post</span><span class="p">]]</span>
                               <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">)</span>
                                                     <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">pre</span><span class="p">)</span> <span class="mi">8</span><span class="p">))</span>
                                                  <span class="s">&quot; &quot;</span><span class="p">)))))</span>
      <span class="nv">s</span><span class="p">)))</span>

<span class="c1">;; Performance note: As before, assign the regexp #&quot;\t+&quot; to a symbol</span>
<span class="c1">;; using let, outside of the loop, to compile it only once, instead of</span>
<span class="c1">;; every time through the loop.</span>

<span class="c1">;; Test cases:</span>

<span class="c1">;; (let [t1 (= &quot;No tabs here&quot; (expand-str &quot;No tabs here&quot;))</span>
<span class="c1">;;       t2 (= &quot;Expand          this&quot; (expand-str &quot;Expand\t\tthis&quot;))</span>
<span class="c1">;;       t3 (= &quot;Expand          this    please&quot; (expand-str &quot;Expand\t\tthis\tplease&quot;))]</span>
<span class="c1">;;   [t1 t2 t3])</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; I am not aware of any Clojure library similar to Perl&#39;s Text::Tabs</span>

<span class="c1">;; The expand-str Clojure functions above work on individual strings.</span>
<span class="c1">;; This works on a string or a collection of strings, similar to how</span>
<span class="c1">;; Perl&#39;s does:</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
   <span class="p">(</span><span class="nb">instance? </span><span class="nv">String</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">expand-str</span> <span class="nv">x</span><span class="p">)</span>
   <span class="ss">:else</span> <span class="p">(</span><span class="nb">map </span><span class="nv">expand-str</span> <span class="nv">x</span><span class="p">)))</span>


<span class="p">(</span><span class="kd">defn </span><span class="nv">unexpand-line</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nf">expand</span> <span class="nv">s</span><span class="p">)</span>
        <span class="nv">len</span> <span class="p">(</span><span class="nb">count </span><span class="nv">s</span><span class="p">)</span>
        <span class="nv">tabstop</span> <span class="nv">*tabstop*</span>
        <span class="nv">sections</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="nv">%</span> <span class="p">(</span><span class="nb">min </span><span class="nv">len</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="nv">tabstop</span><span class="p">)))</span>
                      <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="nv">len</span> <span class="nv">tabstop</span><span class="p">))</span>
        <span class="c1">;; last section must be handled differently than earlier ones</span>
        <span class="nv">lastbit</span> <span class="p">(</span><span class="nb">last </span><span class="nv">sections</span><span class="p">)</span>
        <span class="nv">sections</span> <span class="p">(</span><span class="nb">butlast </span><span class="nv">sections</span><span class="p">)</span>
        <span class="nv">lastbit</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">lastbit</span><span class="p">)</span> <span class="nv">tabstop</span><span class="p">)</span>
                         <span class="p">(</span><span class="nf">str/blank?</span> <span class="nv">lastbit</span><span class="p">))</span>
                  <span class="s">&quot;\t&quot;</span>
                  <span class="nv">lastbit</span><span class="p">)</span>
        <span class="nv">sections</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">str/replace</span> <span class="nv">%</span> <span class="o">#</span><span class="s">&quot;  +$&quot;</span> <span class="s">&quot;\t&quot;</span><span class="p">)</span> <span class="nv">sections</span><span class="p">)</span>
        <span class="nv">sections</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">vec</span> <span class="nv">sections</span><span class="p">)</span> <span class="nv">lastbit</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot;&quot;</span> <span class="nv">sections</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">unexpand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot;\n&quot;</span> <span class="p">(</span><span class="nb">map </span><span class="nv">unexpand-line</span> <span class="p">(</span><span class="nf">str/split</span> <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span> <span class="mi">-1</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">unexpand</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
   <span class="p">(</span><span class="nb">instance? </span><span class="nv">String</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">unexpand-str</span> <span class="nv">x</span><span class="p">)</span>
   <span class="ss">:else</span> <span class="p">(</span><span class="nb">map </span><span class="nv">unexpand-str</span> <span class="nv">x</span><span class="p">)))</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">expand</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>

<span class="c1">;; Use your preferred version of expand here.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">filename</span> <span class="nv">*command-line-args*</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">filename</span><span class="p">))]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">expand</span> <span class="nv">line</span><span class="p">))))</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; Below is a version of expand-str that takes an optional argument</span>
<span class="c1">;; tabstop.  It is based upon the last version of expand-str given</span>
<span class="c1">;; above, but the others could easily be generalized in a similar way.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span>
  <span class="p">([</span><span class="nv">s</span> <span class="nv">tabstop</span><span class="p">]</span>
     <span class="p">(</span><span class="k">loop </span><span class="p">[[</span><span class="nv">found-match</span> <span class="nv">s</span><span class="p">]</span> <span class="p">[</span><span class="nv">true</span> <span class="nv">s</span><span class="p">]]</span>
       <span class="p">(</span><span class="k">if </span><span class="nv">found-match</span>
         <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">replace-first+</span>
                 <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;\t+&quot;</span>
                 <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">pre</span> <span class="nv">tabs</span> <span class="nv">post</span><span class="p">]]</span>
                   <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="nv">tabstop</span><span class="p">)</span>
                                         <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">pre</span><span class="p">)</span> <span class="nv">tabstop</span><span class="p">))</span>
                                      <span class="s">&quot; &quot;</span><span class="p">)))))</span>
         <span class="nv">s</span><span class="p">)))</span>
  <span class="p">([</span><span class="nv">s</span><span class="p">]</span> <span class="p">(</span><span class="nf">expand-str</span> <span class="nv">s</span> <span class="mi">8</span><span class="p">)))</span>

<span class="c1">;; If one wished for a version of expand-str that could use a tabstop</span>
<span class="c1">;; supplied by a &quot;global variable&quot;, then a dynamic var named *tabstop*</span>
<span class="c1">;; that was used inside of expand-str would be a good way to do it.</span>

<span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">*tabstop*</span> <span class="mi">8</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[[</span><span class="nv">found-match</span> <span class="nv">s</span><span class="p">]</span> <span class="p">[</span><span class="nv">true</span> <span class="nv">s</span><span class="p">]]</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">found-match</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">replace-first+</span>
              <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;\t+&quot;</span>
              <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">pre</span> <span class="nv">tabs</span> <span class="nv">post</span><span class="p">]]</span>
                <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="nv">*tabstop*</span><span class="p">)</span>
                                      <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">pre</span><span class="p">)</span> <span class="nv">*tabstop*</span><span class="p">))</span>
                                   <span class="s">&quot; &quot;</span><span class="p">)))))</span>
      <span class="nv">s</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">expand-str</span> <span class="s">&quot;Expand\t\tthis&quot;</span><span class="p">)</span> <span class="c1">; expands to tabstop 8</span>
<span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">*tabstop*</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="nf">expand-str</span> <span class="s">&quot;Expand\t\tthis&quot;</span><span class="p">)</span> <span class="c1">; expands to tabstop 4 this time</span>

<span class="c1">;; Performance note: Besides the repeated one about avoiding</span>
<span class="c1">;; recompilation of the regexp, a new performance issue here is that</span>
<span class="c1">;; accessing dynamic vars like *tabstop* is slower than accessing a</span>
<span class="c1">;; local binding like those introduced via let or loop.  Wrapping the</span>
<span class="c1">;; entire function body in something like (let [tabstop *tabstop*]</span>
<span class="c1">;; ... ) and using tabstop in place of *tabstop* inside the body</span>
<span class="c1">;; incurs this cost only once, instead of every time through the loop.</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">unexpand</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>

<span class="c1">;; Use your preferred version of expand and unexpand here.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">filename</span> <span class="nv">*command-line-args*</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">filename</span><span class="p">))]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">unexpand</span> <span class="nv">line</span><span class="p">))))</span>
<span class="c1">;; -----------------------------</span>

<span class="c1">;; 1.8 Expanding and Compressing Tabs</span>

<span class="c1">;; 1.9 Expanding Variables in User Input</span>

<span class="c1">;; @PLEAC@@_1.10 Controlling Case</span>
<span class="p">(</span><span class="nf">.toUpperCase</span> <span class="s">&quot;foo&quot;</span><span class="p">)</span> <span class="c1">;; -&gt; &quot;FOO&quot;</span>
<span class="p">(</span><span class="nf">.toLowerCase</span> <span class="s">&quot;FOO&quot;</span><span class="p">)</span> <span class="c1">;; -&gt; &quot;foo&quot;</span>

<span class="c1">;; 1.11 Interpolating Functions and Expressions Within Strings</span>

<span class="c1">;; 1.12 Indenting Here Documents</span>

<span class="c1">;; 1.13 Reformatting Paragraphs</span>

<span class="c1">;; 1.14 Escaping Characters</span>

<span class="c1">;; 1.15 Trimming Blanks from the Ends of a String</span>

<span class="p">(</span><span class="nf">.trim</span> <span class="nv">string</span><span class="p">)</span>
<span class="c1">;; (.trim &quot;  foo  &quot;) =&gt; &quot;foo&quot;</span>

<span class="c1">;; 1.16 Parsing Comma-Separated Data</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN38"
>Expanding Variables in User Input</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41"
>Controlling Case</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44"
>Interpolating Functions and Expressions Within Strings</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN47"
>Indenting Here Documents</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN50"
>Reformatting Paragraphs</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN53"
>Escaping Characters</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56"
>Trimming Blanks from the Ends of a String</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN59"
>Parsing Comma-Separated Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN62"
>Soundex Matching</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN65"
>Program: fixstyle</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN68"
>Program: psgrep</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="numbers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>PLEAC-Clojure</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Numbers</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>