<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Arrays</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Clojure"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Dates and Times"
HREF="datesandtimes.html"><LINK
REL="NEXT"
TITLE="Hashes"
HREF="hashes.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Clojure</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="datesandtimes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="hashes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ARRAYS"
>4. Arrays</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN170"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; vectors</span>
<span class="p">(</span><span class="k">def </span><span class="nv">simple</span> <span class="p">[</span><span class="s">&quot;this&quot;</span> <span class="s">&quot;that&quot;</span> <span class="s">&quot;the&quot;</span> <span class="s">&quot;other&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">nested</span> <span class="p">[</span><span class="s">&quot;this&quot;</span> <span class="s">&quot;that&quot;</span> <span class="p">[</span><span class="s">&quot;the&quot;</span> <span class="s">&quot;other&quot;</span><span class="p">]])</span>

<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">simple</span><span class="p">)</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">nested</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">nth </span><span class="nv">nested</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">tune</span> <span class="p">[</span><span class="s">&quot;The&quot;</span> <span class="s">&quot;Star-Spangled&quot;</span> <span class="s">&quot;Banner&quot;</span><span class="p">])</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN173"
>Specifying a List In Your Program</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">[</span><span class="s">&quot;quick&quot;</span> <span class="s">&quot;brown&quot;</span> <span class="s">&quot;fox&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">qw</span>
  <span class="s">&quot;Split string on whitespace. Returns a seq.&quot;</span>
  <span class="p">[</span><span class="nv">s</span><span class="p">]</span> <span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nf">.split</span> <span class="nv">s</span> <span class="s">&quot;\\s&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a2</span> <span class="p">(</span><span class="nf">qw</span> <span class="s">&quot;Why are you teasing me?&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">lines</span>
  <span class="p">(</span><span class="nf">.replaceAll</span> <span class="s">&quot;    The boy stood on the burning deck,</span>
<span class="s">    It was as hot as glass.&quot;</span>
               <span class="s">&quot;\\ +&quot;</span> <span class="s">&quot;&quot;</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">bigvector</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>

<span class="p">(</span><span class="nf">try</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">bigvector</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="s">&quot;mydatafile&quot;</span><span class="p">)))]</span>
    <span class="c1">;; rest of code to do something with bigvector</span>
    <span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="nv">java.io.FileNotFoundException</span> <span class="nv">e</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">e</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">flush</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">System/exit</span> <span class="mi">1</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN176"
>Printing a List with Commas</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">commify-series</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">case</span> <span class="p">(</span><span class="nb">count </span><span class="nv">coll</span><span class="p">)</span>
        <span class="mi">0</span> <span class="s">&quot;&quot;</span>
        <span class="mi">1</span> <span class="p">(</span><span class="nb">first </span><span class="nv">coll</span><span class="p">)</span>
        <span class="mi">2</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; and &quot;</span> <span class="nv">coll</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot;, &quot;</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">butlast </span><span class="nv">coll</span><span class="p">)</span>
                               <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;and &quot;</span> <span class="p">(</span><span class="nb">last </span><span class="nv">coll</span><span class="p">)))))))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="s">&quot;red&quot;</span> <span class="s">&quot;yellow&quot;</span> <span class="s">&quot;green&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="nb">print </span><span class="s">&quot;I have&quot;</span> <span class="nv">array</span> <span class="s">&quot;marbles.\n&quot;</span><span class="p">)</span>
<span class="c1">;; Clojure does not have string interpolation.</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;I have %s marbles.\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">array</span><span class="p">))</span>
<span class="nv">I</span> <span class="nv">have</span> <span class="p">[</span><span class="nv">red</span> <span class="nv">yellow</span> <span class="nv">green</span><span class="p">]</span> <span class="nv">marbles.</span>

<span class="nv">I</span> <span class="nv">have</span> <span class="nv">red</span> <span class="nv">yellow</span> <span class="nv">green</span> <span class="nv">marbles.</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN179"
>Changing Array Size</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure vectors cannot be modified, but we can create new vectors</span>
<span class="c1">;; from existing ones, with differences between the existing and new</span>
<span class="c1">;; ones.</span>

<span class="c1">;; create smaller array that is a subset of an existing one.  Unlike</span>
<span class="c1">;; Perl&#39;s $#ARRAY = $NEW_LAST_ELEMENT_INDEX_NUMBER, you must use the</span>
<span class="c1">;; new number of elements with subvec, which is one larger than the</span>
<span class="c1">;; new last element index number.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">newv</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="nv">newv-number-of-elements</span><span class="p">))</span>
<span class="c1">;; In general you can give an arbitrary start (inclusive) and end</span>
<span class="c1">;; (exclusive) index to subvec.  It only takes O(1) time.  The new</span>
<span class="c1">;; vector&#39;s index i has the same value as the original vector&#39;s index</span>
<span class="c1">;; (start+i).</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; We can create a new Clojure vector one larger in size than an</span>
<span class="c1">;; existing one using assoc or conj.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">newv</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">v</span> <span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">newv</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="nv">value</span><span class="p">))</span>
<span class="c1">;; I believe there is no way to expand a vector by an arbitrary amount</span>
<span class="c1">;; using a single Clojure built-in function.  One could achieve that</span>
<span class="c1">;; effect by repeatedly using conj to add individual elements to the</span>
<span class="c1">;; end, one at a time, until the desired vector size was reached.</span>
<span class="c1">;; However, if you want a sparsely populated array with elements</span>
<span class="c1">;; indexed by integer, you are likely to be more satisfied using a map</span>
<span class="c1">;; with integer keys than a vector.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">what-about-that-vector</span> <span class="p">[</span><span class="nv">v</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;The vector now has %d elements.\n&quot;</span> <span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;The index of the last element is %d.\n&quot;</span> <span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Element #3 is `%s&#39;.\n&quot;</span> <span class="p">(</span><span class="nf">v</span> <span class="mi">3</span><span class="p">)))</span>
<span class="c1">;; Note that qw returns a sequence of elements that is not a Clojure</span>
<span class="c1">;; vector.  Here we use vec to create a vector containing the same</span>
<span class="c1">;; elements as the sequence.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">people</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">qw</span> <span class="s">&quot;Crosby Stills Nash Young&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">what-about-that-vector</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="nv">The</span> <span class="nb">vector </span><span class="nv">now</span> <span class="nv">has</span> <span class="mi">4</span> <span class="nv">elements.</span>
<span class="nv">The</span> <span class="nb">index </span><span class="nv">of</span> <span class="nv">the</span> <span class="nb">last </span><span class="nv">element</span> <span class="nv">is</span> <span class="mi">3</span><span class="nv">.</span>
<span class="nv">Element</span> <span class="o">#</span><span class="mi">3</span> <span class="nv">is</span> <span class="o">`</span><span class="nv">Young</span><span class="ss">&#39;.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">people</span> <span class="p">(</span><span class="nb">pop </span><span class="nv">people</span><span class="p">))</span>
<span class="c1">;; The following has equivalent behavior for vectors to pop, but not</span>
<span class="c1">;; sure if the efficiency is the same.</span>
<span class="c1">;;(def people (subvec people 0 (dec (count people))))</span>
<span class="p">(</span><span class="nf">what-about-that-vector</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="nv">IndexOutOfBoundsException</span>   <span class="nv">clojure.lang.PersistentVector.arrayFor</span> <span class="p">(</span><span class="nf">PersistentVector.java</span><span class="ss">:106</span><span class="p">)</span>
<span class="nv">The</span> <span class="nb">vector </span><span class="nv">now</span> <span class="nv">has</span> <span class="mi">3</span> <span class="nv">elements.</span>
<span class="nv">The</span> <span class="nb">index </span><span class="nv">of</span> <span class="nv">the</span> <span class="nb">last </span><span class="nv">element</span> <span class="nv">is</span> <span class="mi">2</span><span class="nv">.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; As mentioned above, there is no single builtin function to extend a</span>
<span class="c1">;; vector by an arbitrarily large number of elements.  We&#39;ll do it</span>
<span class="c1">;; here with a loop.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">people</span>
     <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">people</span> <span class="nv">people</span><span class="p">]</span>
       <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">count </span><span class="nv">people</span><span class="p">)</span> <span class="mi">10001</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">people</span> <span class="nv">nil</span><span class="p">))</span>
         <span class="c1">;; else</span>
         <span class="nv">people</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">what-about-that-vector</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="nv">The</span> <span class="nb">vector </span><span class="nv">now</span> <span class="nv">has</span> <span class="mi">10001</span> <span class="nv">elements.</span>
<span class="nv">The</span> <span class="nb">index </span><span class="nv">of</span> <span class="nv">the</span> <span class="nb">last </span><span class="nv">element</span> <span class="nv">is</span> <span class="mi">10000</span><span class="nv">.</span>
<span class="nv">Element</span> <span class="o">#</span><span class="mi">3</span> <span class="nv">is</span> <span class="o">`</span><span class="nv">null</span><span class="ss">&#39;.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Assigning a value to element 10000 of vector people will not change</span>
<span class="c1">;; its size, even if that new value is nil.  To make a vector with a</span>
<span class="c1">;; smaller size, use subvec or pop as described above.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN182"
>Doing Something with Every Element in a List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>

<span class="c1">;; Clojure is often written in a functional style, meaning that you</span>
<span class="c1">;; calculate output value from input values.  So Clojure&#39;s &#39;for&#39; is</span>
<span class="c1">;; actually a way to take one or more input sequences and produce an</span>
<span class="c1">;; output sequence, and in fact this is done in a lazy fashion,</span>
<span class="c1">;; meaning that no actual computation occurs unless some other code</span>
<span class="c1">;; _uses_ elements of the output sequence.</span>

<span class="c1">;; If you use Clojure&#39;s REPL to try out code before using it in a</span>
<span class="c1">;; program, this can easily confuse you, because at the REPL, every</span>
<span class="c1">;; expression you enter is read, executed, and the result is printed.</span>
<span class="c1">;; The fact that the result is printed often forces lazy expressions</span>
<span class="c1">;; to calculate their entire result, but if you use that lazy</span>
<span class="c1">;; expression as part of a larger expression or program, it won&#39;t be.</span>

<span class="c1">;; Here are a couple of quick examples:</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1">;; i iterates over the elements of the sequence (range 0 5).  The for</span>
<span class="c1">;; expression as a whole returns a sequence containing (inc i) for</span>
<span class="c1">;; each input sequence element.  It does this lazily, but because we</span>
<span class="c1">;; are typing it at the REPL, the output value is used in order to</span>
<span class="c1">;; print it.</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)]</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1">;; Here we add some debug print statements, and its output gets</span>
<span class="c1">;; mingled with the printed output value.</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)]</span> <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;i=%d\n&quot;</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">i=0</span>
<span class="nv">i=1</span>
<span class="nv">i=2</span>
<span class="nv">i=3</span>
<span class="nv">i=4</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">;; Here we assign the value of the for expression to a var.  Note that</span>
<span class="c1">;; the only output printed is the output value of the def statement,</span>
<span class="c1">;; which is #&#39;user/a1.  Why don&#39;t the printf&#39;s get executed?  Because</span>
<span class="c1">;; the for is lazy, and nothing has used any part of its output value</span>
<span class="c1">;; yet.</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">a1</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)]</span> <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;i=%d\n&quot;</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))))</span>
<span class="o">#</span><span class="ss">&#39;user/a1</span>

<span class="c1">;; When we ask for the value of a1, then the output value of the for</span>
<span class="c1">;; expression is required, and so its body is executed now.</span>
<span class="nv">user=&gt;</span> <span class="nv">a1</span>
<span class="p">(</span><span class="nf">i=0</span>
<span class="nv">i=1</span>
<span class="nv">i=2</span>
<span class="nv">i=3</span>
<span class="nv">i=4</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1">;; If you want to force the iteration to occur when it is evaluated,</span>
<span class="c1">;; use doseq instead.  It does not return any useful value (only nil),</span>
<span class="c1">;; and is intended to be used when the body contains side effects.</span>
<span class="c1">;; Here the (inc i) is superfluous, since it simply returns a value</span>
<span class="c1">;; that is ignored by the rest of the expression around it.</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">a1</span> <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)]</span> <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;i=%d\n&quot;</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)))</span>
<span class="nv">i=0</span>
<span class="nv">i=1</span>
<span class="nv">i=2</span>
<span class="nv">i=3</span>
<span class="nv">i=4</span>
<span class="o">#</span><span class="ss">&#39;user/a1</span>

<span class="c1">;; As mentioned above, doseq always returns nil.</span>
<span class="nv">user=&gt;</span> <span class="nv">a1</span>
<span class="nv">nil</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">user</span> <span class="nv">bad-users</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">comlain</span> <span class="nv">user</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="k">var </span><span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">keys </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s=%s\n&quot;</span> <span class="k">var </span><span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">user</span> <span class="nv">all-users</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">disk-space</span> <span class="p">(</span><span class="nf">get-usage</span> <span class="nv">user</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">disk-space</span> <span class="nv">MAX-QUOTA</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">))))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.shell</span> <span class="ss">:as</span> <span class="nv">shell</span><span class="p">])</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nf">str/split</span> <span class="p">(</span><span class="ss">:out</span> <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;who&quot;</span><span class="p">))</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span><span class="p">)]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">re-find </span><span class="o">#</span><span class="s">&quot;tchrist&quot;</span> <span class="nv">line</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">line</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Unlike in Perl, there is nothing in Clojure similar to the $_ and</span>
<span class="c1">;; @_ default variables for iterating over lines of an input file or</span>
<span class="c1">;; elements of a list.</span>

<span class="c1">;; rdr implements interface java.io.BufferedReader in this example,</span>
<span class="c1">;; and so can be used with line-seq.</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="nv">rdr</span><span class="p">)]</span>
  <span class="c1">;; line-seq is a sequence of strings, one for each line in the input</span>
  <span class="c1">;; file, and they never have a trailing \n</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">word</span> <span class="p">(</span><span class="nf">str/split</span> <span class="nv">line</span> <span class="o">#</span><span class="s">&quot;\s+&quot;</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s&quot;</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">word</span><span class="p">))))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; In Clojure, every for or doseq has variables that are like Perl&#39;s</span>
<span class="c1">;; &quot;my&quot;, i.e. their scope is local to the body of the loop, and any</span>
<span class="c1">;; value the symbol had outside the loop is not visible inside, and</span>
<span class="c1">;; any change made inside has no affect on the symbol&#39;s value outside</span>
<span class="c1">;; the loop.</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">item</span> <span class="nv">array</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;i = %s\n&quot;</span> <span class="nv">item</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure&#39;s native vectors are immutable, so there is no way to</span>
<span class="c1">;; modify their elements, although it is easy to create new vectors</span>
<span class="c1">;; that are the same as old ones except that a single element has been</span>
<span class="c1">;; replaced with a new one.</span>

<span class="c1">;; This is a clunky way to do it that loops over the elements of the</span>
<span class="c1">;; array explicitly.  Note that we first bind the symbol array to the</span>
<span class="c1">;; value [1 2 3], then to the value returned by the loop expression.</span>
<span class="c1">;; The first value of array is then lost.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
      <span class="nv">array</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">a</span> <span class="nv">array</span>
                   <span class="nv">i</span> <span class="mi">0</span><span class="p">]</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">a</span><span class="p">))</span>
                <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">a</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nf">a</span> <span class="nv">i</span><span class="p">)))</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))</span>
                <span class="nv">a</span><span class="p">))]</span>
  <span class="p">(</span><span class="nb">println </span><span class="nv">array</span><span class="p">))</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>

<span class="c1">;; A much more functional style for doing this is to use map.  Here we</span>
<span class="c1">;; use vec on the result of map to convert the list that is returned</span>
<span class="c1">;; by map, which is different than a vector in Clojure, to a vector</span>
<span class="c1">;; with the same elements.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map dec </span><span class="nv">array</span><span class="p">))]</span>
  <span class="p">(</span><span class="nb">println </span><span class="nv">array</span><span class="p">))</span>

<span class="c1">;; Again, this example achieves a similar effect as the Perl code, but</span>
<span class="c1">;; it does not modify a and b in place -- it creates new values and</span>
<span class="c1">;; assigns those new values to a and b.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">[</span><span class="mf">0.5</span> <span class="mi">3</span><span class="p">]</span>
      <span class="nv">b</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">]</span>
      <span class="nv">a</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="mi">7</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
      <span class="nv">b</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="mi">7</span><span class="p">)</span> <span class="nv">b</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s %s\n&quot;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="p">[</span><span class="mf">3.5</span> <span class="mi">21</span><span class="p">]</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">7</span><span class="p">]</span>

<span class="c1">;; Note that you can use native Java arrays in a straightforward way</span>
<span class="c1">;; from Clojure, and these are mutable data structures, like Java&#39;s</span>
<span class="c1">;; and Perl&#39;s mutable arrays.  Java arrays cannot be grown or shrunk</span>
<span class="c1">;; after creation, except by copying their contents into a new array</span>
<span class="c1">;; and abandoning the old one.</span>

<span class="c1">;; into-array creates a Java array with values initialized to the</span>
<span class="c1">;; elements of a sequence.  If you don&#39;t give an explicit type for the</span>
<span class="c1">;; array elements, they default to the type of the first element of</span>
<span class="c1">;; the sequence.  I&#39;ll create Java arrays of java.lang.Object&#39;s below,</span>
<span class="c1">;; so that the elements can be a mix of different subclasses of</span>
<span class="c1">;; Object.</span>

<span class="c1">;; You can use loop, doseq, or dotimes to iterate over the indices of</span>
<span class="c1">;; the array.</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">into-array </span><span class="nv">Object</span> <span class="p">[</span><span class="mf">0.5</span> <span class="mi">3</span><span class="p">])</span>
      <span class="nv">b</span> <span class="p">(</span><span class="nb">into-array </span><span class="nv">Object</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">])]</span>
  <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">alength </span><span class="nv">a</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">aset </span><span class="nv">a</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">aget </span><span class="nv">a</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">7</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">alength </span><span class="nv">b</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">aset </span><span class="nv">b</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">aget </span><span class="nv">b</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">7</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s %s\n&quot;</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">b</span><span class="p">)))</span>  <span class="c1">; seq used to create sequence</span>
                                       <span class="c1">; of values in arrays a and b</span>
<span class="p">(</span><span class="mf">3.5</span> <span class="mi">21</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">7</span><span class="p">)</span>

<span class="c1">;; Clojure&#39;s amap creates new Java arrays, by copying the given one,</span>
<span class="c1">;; then iterating over its elements and replacing each one with the</span>
<span class="c1">;; result of evaluating a given expression.</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">into-array </span><span class="nv">Object</span> <span class="p">[</span><span class="mf">0.5</span> <span class="mi">3</span><span class="p">])</span>
      <span class="nv">b</span> <span class="p">(</span><span class="nb">into-array </span><span class="nv">Object</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">])</span>
      <span class="nv">a</span> <span class="p">(</span><span class="nf">amap</span> <span class="nv">a</span> <span class="nv">i</span> <span class="nv">temp</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">aget </span><span class="nv">a</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">7</span><span class="p">))</span>
      <span class="nv">b</span> <span class="p">(</span><span class="nf">amap</span> <span class="nv">b</span> <span class="nv">i</span> <span class="nv">temp</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">aget </span><span class="nv">b</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">7</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s %s\n&quot;</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">b</span><span class="p">)))</span>
<span class="p">(</span><span class="mf">3.5</span> <span class="mi">21</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; Because Clojure doesn&#39;t provide a way to modify its collections in</span>
<span class="c1">;; place, but instead encourages you to create new versions of</span>
<span class="c1">;; existing data structures, it doesn&#39;t really provide a way to</span>
<span class="c1">;; iterate over several different collections in a single loop.</span>

<span class="c1">;; clojure.string/trim returns a string the same as the string you</span>
<span class="c1">;; give it, except with white space at the beginning and end removed.</span>

<span class="c1">;; do-to-map was written by Brian Carper, and he also wrote the</span>
<span class="c1">;; explanation for how it works that I have copied below.  Original</span>
<span class="c1">;; source is at the following URL:</span>

<span class="c1">;; http://stackoverflow.com/questions/1638854/clojure-how-do-i-apply-a-function-to-a-subset-of-the-entries-in-a-hash-map</span>

<span class="c1">;; It helps to look at it inside-out.  In Clojure, hash-maps act like</span>
<span class="c1">;; functions; if you call them like a function with a key as an</span>
<span class="c1">;; argument, the value associated with that key is returned.  So given</span>
<span class="c1">;; a single key, the current value for that key can be obtained via:</span>

<span class="c1">;; (some-map some-key)</span>

<span class="c1">;; We want to take old values, and change them to new values by</span>
<span class="c1">;; calling some function f on them.  So given a single key, the new</span>
<span class="c1">;; value will be:</span>

<span class="c1">;; (f (some-map some-key))</span>

<span class="c1">;; We want to associate this new value with this key in our hash-map,</span>
<span class="c1">;; &quot;replacing&quot; the old value.  This is what assoc does:</span>

<span class="c1">;; (assoc some-map some-key (f (some-map some-key)))</span>

<span class="c1">;; (&quot;Replace&quot; is in scare-quotes because we&#39;re not mutating a single</span>
<span class="c1">;; hash-map object; we&#39;re returning new, immutable, altered hash-map</span>
<span class="c1">;; objects each time we call assoc.  This is still fast and efficient</span>
<span class="c1">;; in Clojure because hash-maps are persistent and share structure</span>
<span class="c1">;; when you assoc them.)</span>

<span class="c1">;; We need to repeatedly assoc new values onto our map, one key at a</span>
<span class="c1">;; time.  So we need some kind of looping construct.  What we want is</span>
<span class="c1">;; to start with our original hash-map and a single key, and then</span>
<span class="c1">;; &quot;update&quot; the value for that key.  Then we take that new hash-map</span>
<span class="c1">;; and the next key, and &quot;update&quot; the value for that next key.  And we</span>
<span class="c1">;; repeat this for every key, one at a time, and finally return the</span>
<span class="c1">;; hash-map we&#39;ve &quot;accumulated&quot;.  This is what reduce does.</span>

<span class="c1">;; * The first argument to reduce is a function that takes two</span>
<span class="c1">;;   arguments: an &quot;accumulator&quot; value, which is the value we keep</span>
<span class="c1">;;   &quot;updating&quot; over and over; and a single argument used in one</span>
<span class="c1">;;   iteration to do some of the accumulating.</span>
<span class="c1">;; * The second argument to reduce is the initial value passed as the</span>
<span class="c1">;;   first argument to this fn.</span>
<span class="c1">;; * The third argument to reduce is a collection of arguments to be</span>
<span class="c1">;;   passed as the second argument to this fn, one at a time.</span>

<span class="c1">;; So:</span>

<span class="c1">;; (reduce fn-to-update-values-in-our-map</span>
<span class="c1">;;         initial-value-of-our-map</span>
<span class="c1">;;         collection-of-keys)</span>

<span class="c1">;; fn-to-update-values-in-our-map is just the assoc statement from</span>
<span class="c1">;; above, wrapped in an anonymous function:</span>

<span class="c1">;; (fn [map-so-far some-key]</span>
<span class="c1">;;   (assoc map-so-far some-key (f (map-so-far some-key))))</span>

<span class="c1">;; So plugging it into reduce:</span>

<span class="c1">;; (reduce (fn [map-so-far some-key]</span>
<span class="c1">;;           (assoc map-so-far some-key (f (map-so-far some-key))))</span>
<span class="c1">;;         amap</span>
<span class="c1">;;         keyseq)</span>

<span class="c1">;; In Clojure, there&#39;s a shorthand for writing anonymous functions:</span>
<span class="c1">;; #(...) is an anonymous fn consisting of a single form, in which %1</span>
<span class="c1">;; is bound to the first argument to the anonymous function, %2 to the</span>
<span class="c1">;; second, etc.  So our fn from above can be written equivalently as:</span>

<span class="c1">;; #(assoc %1 %2 (f (%1 %2)))</span>

<span class="c1">;; This gives us:</span>

<span class="c1">;; (reduce #(assoc %1 %2 (f (%1 %2))) amap keyseq)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">do-to-map</span> <span class="p">[</span><span class="nv">amap</span> <span class="nv">keyseq</span> <span class="nv">f</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">%1</span> <span class="nv">%2</span><span class="p">)))</span> <span class="nv">amap</span> <span class="nv">keyseq</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">scalar</span> <span class="p">(</span><span class="nf">str/trim</span> <span class="nv">scalar</span><span class="p">)</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="nv">str/trim</span> <span class="nv">array</span><span class="p">))</span> <span class="c1">; skip the vec if a list result is OK</span>
      <span class="nv">hash</span> <span class="p">(</span><span class="nf">do-to-map</span> <span class="nv">hash</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">hash</span><span class="p">)</span> <span class="nv">str/trim</span><span class="p">)]</span>
  <span class="p">)</span>

<span class="c1">;;-----------------------------</span>
<span class="c1">;; No foreach/for synonym in Clojure.  I believe the existing common</span>
<span class="c1">;; alternatives are all mentioned above.</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN185"
>Iterating Over an Array by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure does not have Perl&#39;s distinction between an array and an</span>
<span class="c1">;; array ref.  Clojure lists, vectors, maps, etc. can all contain</span>
<span class="c1">;; instances of each other as values, and in maps any of these data</span>
<span class="c1">;; structures can be used as keys, too.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">fruits</span> <span class="p">[</span> <span class="s">&quot;Apple&quot;</span> <span class="s">&quot;Blackberry&quot;</span> <span class="p">])</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">fruit</span> <span class="nv">fruits</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s tastes good in a pie.\n&quot;</span> <span class="nv">fruit</span><span class="p">))</span>
<span class="nv">Apple</span> <span class="nv">tastes</span> <span class="nv">good</span> <span class="nv">in</span> <span class="nv">a</span> <span class="nv">pie.</span>
<span class="nv">Blackberry</span> <span class="nv">tastes</span> <span class="nv">good</span> <span class="nv">in</span> <span class="nv">a</span> <span class="nv">pie.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">fruits</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s tastes good in a pie.\n&quot;</span> <span class="p">(</span><span class="nf">fruits</span> <span class="nv">i</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">namelist</span> <span class="p">{</span> <span class="p">})</span>
<span class="p">(</span><span class="k">def </span><span class="nv">rogue-cats</span> <span class="p">[</span> <span class="s">&quot;YellowFang&quot;</span> <span class="s">&quot;BrokenTail&quot;</span> <span class="s">&quot;Clawface&quot;</span> <span class="p">])</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">namelist</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">namelist</span> <span class="ss">:felines</span> <span class="nv">rogue-cats</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">cat</span> <span class="p">(</span><span class="nf">namelist</span> <span class="ss">:felines</span><span class="p">)]</span>   <span class="c1">; (:felines namelist) gives same result</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s purrs hypnotically..\n&quot;</span> <span class="nv">cat</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;--More--\nYou are controlled.\n&quot;</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">namelist</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">namelist</span> <span class="ss">:felines</span> <span class="nv">rogue-cats</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nf">namelist</span> <span class="ss">:felines</span><span class="p">))]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s purrs hypnotically..\n&quot;</span> <span class="p">((</span><span class="nf">namelist</span> <span class="ss">:felines</span><span class="p">)</span> <span class="nv">i</span><span class="p">))))</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN188"
>Extracting Unique Elements from a List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="c1">;; Iterative style -- requires a fair amount of verbiage.</span>
<span class="c1">;; TBD: My use of seq/first/rest might be nonstandard here.  Is it</span>
<span class="c1">;; correct for all cases?  If not, what case causes it to break?</span>
<span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">seen</span> <span class="p">{}</span>
       <span class="nv">uniq</span> <span class="p">[]</span>
       <span class="nv">l</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">list</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">item</span> <span class="p">(</span><span class="nb">first </span><span class="nv">l</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">seen</span> <span class="nv">item</span><span class="p">))</span>   <span class="c1">;; (seen item) is nil if item is not a key</span>
                            <span class="c1">;; in the map seen, and nil is treated as false</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">seen</span> <span class="nv">item</span> <span class="mi">1</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">conj </span><span class="nv">uniq</span> <span class="nv">item</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">rest </span><span class="nv">l</span><span class="p">))</span>
      <span class="c1">;; else</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="nv">seen</span> <span class="nv">uniq</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">l</span><span class="p">)))</span>
    <span class="c1">;; return a final value from loop statement here, perhaps seen and</span>
    <span class="c1">;; uniq</span>
    <span class="p">))</span>

<span class="c1">;; Functional style.  If reduce call is confusing, try first reading</span>
<span class="c1">;; explanation of do-to-map above.  This is a bit simpler than that.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span> <span class="nv">list</span><span class="p">)</span>
      <span class="nv">uniq</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">seen</span><span class="p">))]</span>   <span class="c1">; leave out vec if a list is good enough</span>
  <span class="c1">;; use seen and/or uniq here</span>
  <span class="p">)</span>

<span class="c1">;; Clojure also has sets as a built-in data structure.  They make it</span>
<span class="c1">;; easy to find unique items in a collection.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">uniq</span> <span class="p">(</span><span class="nb">set </span><span class="nv">list</span><span class="p">)]</span>    <span class="c1">; use (vec (set list)) if you want a vector instead</span>
  <span class="c1">;; use uniq here</span>
  <span class="p">)</span>

<span class="c1">;;-----------------------------</span>
<span class="c1">;; This is nearly the same as functional style above, except this time</span>
<span class="c1">;; we want to count occurrences of items.</span>

<span class="c1">;; First we&#39;ll define a tiny helper function to increment the entry.</span>
<span class="c1">;; In Perl, if you increment an undefined entry in a hash, it treats</span>
<span class="c1">;; it as a 0 and increments it to 1.  In Clojure, trying to do (inc</span>
<span class="c1">;; nil) throws an exception.  What we want is a function that when</span>
<span class="c1">;; given nil, returns 1, and when given a number, increments it.</span>
<span class="c1">;; We&#39;ll call it incn.  Clojure evaluates all values except false and</span>
<span class="c1">;; nil as true, when the value is used as the test in an if</span>
<span class="c1">;; expression.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">incn</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">x</span>
    <span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">)</span>
    <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="p">(</span><span class="nf">incn</span> <span class="p">(</span><span class="nf">%1</span> <span class="nv">%2</span><span class="p">)))</span>
                   <span class="p">{}</span> <span class="nv">list</span><span class="p">)</span>
      <span class="nv">uniq</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">seen</span><span class="p">))]</span>   <span class="c1">; leave out vec if a list is good enough</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; fnil can help us in cases like the above, when we want a function</span>
<span class="c1">;; like inc, except it doesn&#39;t work when passed nil.  (fnil f</span>
<span class="c1">;; default-input) returns a function that works just like f does,</span>
<span class="c1">;; except when it is given an argument of nil, it evaluates (f</span>
<span class="c1">;; default-input) instead.  So incn above is the same as (fnil inc 0).</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="p">((</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">%1</span> <span class="nv">%2</span><span class="p">)))</span>
                   <span class="p">{}</span> <span class="nv">list</span><span class="p">)</span>
      <span class="nv">uniq</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">seen</span><span class="p">))]</span>   <span class="c1">; leave out vec if a list is good enough</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; This expression (assoc map key (f (map key))) is so common that</span>
<span class="c1">;; there is a function update-in that can shorten it a bit, as</span>
<span class="c1">;; (update-in map [key] f).  It can also help update nested maps</span>
<span class="c1">;; within maps, but we won&#39;t use it for that until later.  This</span>
<span class="c1">;; generality is the reason that it takes a vector of key values,</span>
<span class="c1">;; instead of only a single key value, and that is why the [] are</span>
<span class="c1">;; there around key in the call to update-in.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nf">update-in</span> <span class="nv">%1</span> <span class="p">[</span><span class="nv">%2</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">))</span>
                   <span class="p">{}</span> <span class="nv">list</span><span class="p">)</span>
      <span class="nv">uniq</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">seen</span><span class="p">))]</span>   <span class="c1">; leave out vec if a list is good enough</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;seen=&#39;%s&#39;\n&quot;</span> <span class="nv">seen</span><span class="p">)</span>
  <span class="p">)</span>

<span class="c1">;;-----------------------------</span>
<span class="c1">;; Here we call function (some-func item) the first time a new item is</span>
<span class="c1">;; encountered in the sequence &#39;list&#39;, but never if it is seen a 2nd</span>
<span class="c1">;; or larger time later in the list.  This function is presumably</span>
<span class="c1">;; called for its side effects, since there is no return value being</span>
<span class="c1">;; used.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">n</span> <span class="p">(</span><span class="nf">%1</span> <span class="nv">%2</span><span class="p">)]</span>
                                   <span class="p">(</span><span class="nb">inc </span><span class="nv">n</span><span class="p">)</span>
                                   <span class="p">(</span><span class="nf">do</span>
                                     <span class="p">(</span><span class="nf">some-func</span> <span class="nv">%2</span><span class="p">)</span>
                                     <span class="mi">1</span><span class="p">)))</span>
                   <span class="p">{}</span> <span class="nv">list</span><span class="p">)]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Here the Perl version is closer to the functional style examples</span>
<span class="c1">;; given above.  No reason to repeat the Clojure code for them here.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The Perl code here is very much like a functional style, except its</span>
<span class="c1">;; condition mutates the hash &#39;seen&#39;.  I&#39;m not going to try to write a</span>
<span class="c1">;; Clojure version that emulates this, since to match its behavior</span>
<span class="c1">;; closely would require using a mutable Java hash table.</span>

<span class="c1">;; %seen = ();</span>
<span class="c1">;; @uniqu = grep { ! $seen{$_} ++ } @list;</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Here is a functional style version of the Perl code.  Let&#39;s make a</span>
<span class="c1">;; function &#39;tally&#39; to create a map of occurrence counts of items in a</span>
<span class="c1">;; collection.</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">])</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.shell</span> <span class="ss">:as</span> <span class="nv">shell</span><span class="p">])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">tally</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nf">update-in</span> <span class="nv">%1</span> <span class="p">[</span><span class="nv">%2</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">))</span>
          <span class="p">{}</span> <span class="nv">coll</span><span class="p">))</span>

<span class="c1">;; Note that we use the regex #&quot;\s.*$&quot; as opposed to the one #&quot;\s.*\n&quot;</span>
<span class="c1">;; in Perl, because the strings in the sequence lines do not have \n</span>
<span class="c1">;; at the end of each one.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">lines</span> <span class="p">(</span><span class="nf">str/split</span> <span class="p">(</span><span class="ss">:out</span> <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;who&quot;</span><span class="p">))</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span><span class="p">)</span>
      <span class="nv">usernames</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">str/replace-first</span> <span class="nv">%</span> <span class="o">#</span><span class="s">&quot;\s.*$&quot;</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="nv">lines</span><span class="p">)</span>
      <span class="nv">ucnt</span> <span class="p">(</span><span class="nf">tally</span> <span class="nv">usernames</span><span class="p">)</span>
      <span class="nv">users</span> <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">keys </span><span class="nv">ucnt</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;users logged in: %s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">users</span><span class="p">)))</span>

<span class="c1">;; If the count of how many times each username occurred is not</span>
<span class="c1">;; important, just the unique ones, then Clojure sets are more</span>
<span class="c1">;; straightforward.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">lines</span> <span class="p">(</span><span class="nf">str/split</span> <span class="p">(</span><span class="ss">:out</span> <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;who&quot;</span><span class="p">))</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span><span class="p">)</span>
      <span class="nv">usernames</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">str/replace-first</span> <span class="nv">%</span> <span class="o">#</span><span class="s">&quot;\s.*$&quot;</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="nv">lines</span><span class="p">)</span>
      <span class="nv">users</span> <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">set </span><span class="nv">usernames</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;users logged in: %s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">users</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN191"
>Finding Elements in One Array but Not Another</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="c1">;; First we&#39;ll do it in a similar style to the Perl version.</span>
<span class="c1">;; seen is a map, and we produce a vector aonly.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">A</span> <span class="p">[</span><span class="s">&quot;a&quot;</span> <span class="s">&quot;b&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;d&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;b&quot;</span> <span class="s">&quot;a&quot;</span> <span class="s">&quot;e&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">B</span> <span class="p">[</span><span class="s">&quot;b&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;d&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;b&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span> <span class="nv">B</span><span class="p">)</span>
      <span class="nv">aonly</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">seen</span> <span class="nv">%</span><span class="p">))</span> <span class="nv">A</span><span class="p">))]</span>  <span class="c1">; no vec, if vector not needed</span>
 <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">aonly</span><span class="p">)))</span>
<span class="nv">a</span> <span class="nv">a</span> <span class="nv">e</span>

<span class="c1">;; Then we&#39;ll use Clojure sets to simplify it.</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.set</span> <span class="ss">:as</span> <span class="nv">set</span><span class="p">])</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">set </span><span class="nv">B</span><span class="p">)</span>
      <span class="nv">aonly</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">seen</span> <span class="nv">%</span><span class="p">))</span> <span class="nv">A</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">aonly</span><span class="p">)))</span>
<span class="nv">a</span> <span class="nv">a</span> <span class="nv">e</span>

<span class="c1">;; We can simplify even further if aonly can be a set of unique</span>
<span class="c1">;; elements in A that are not also in B, and the order of the elements</span>
<span class="c1">;; does not matter.  Note that the original Perl code contains</span>
<span class="c1">;; elements of A not also in B in the same order as they occur in A,</span>
<span class="c1">;; and if there are duplicates of such elements in A, they will also</span>
<span class="c1">;; be duplicated in aonly.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">aonly</span> <span class="p">(</span><span class="nf">set/difference</span> <span class="p">(</span><span class="nb">set </span><span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nb">set </span><span class="nv">B</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">aonly</span><span class="p">)))</span>
<span class="nv">a</span> <span class="nv">e</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; I can&#39;t think of any direct correspondence in Clojure of the Perl</span>
<span class="c1">;; techniques used in this code.  The Clojure set examples above are</span>
<span class="c1">;; quite concise.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; This version has a different behavior than the previous one.  It</span>
<span class="c1">;; adds an item to @aonly at most one time, without duplicates, but</span>
<span class="c1">;; the order is the same as the order the items appear in A.</span>

<span class="c1">;; If order does not matter, then the set/difference example above is</span>
<span class="c1">;; shorter and clearer.</span>

<span class="c1">;; If order in aonly does matter, then here is one way to do it.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">aonly</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">aonly</span> <span class="p">[]</span>
                   <span class="nv">s</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">A</span><span class="p">)</span>
                   <span class="nv">seen</span> <span class="o">#</span><span class="p">{}]</span>  <span class="c1">; If we want to use a previously calculated</span>
                              <span class="c1">; set in seen, replace #{} with seen.</span>
              <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">item</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">)]</span>
                <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">seen</span> <span class="nv">item</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">recur</span> <span class="nv">aonly</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">)</span> <span class="nv">seen</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">aonly</span> <span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">seen</span> <span class="nv">item</span><span class="p">)))</span>
                <span class="nv">aonly</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">aonly</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">hash</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">hash</span> <span class="s">&quot;key1&quot;</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nv">hash</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">hash</span> <span class="s">&quot;key2&quot;</span> <span class="mi">2</span><span class="p">)]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">hash</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">hash</span> <span class="s">&quot;key1&quot;</span> <span class="mi">1</span> <span class="s">&quot;key2&quot;</span> <span class="mi">2</span><span class="p">)]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; TBD: What does this Perl code do?</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; TBD: What does this Perl code do?</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN194"
>Computing Union, Intersection, or Difference of Unique Lists</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">])</span>
<span class="c1">;; All initializations of union, isect, diff will be done in each</span>
<span class="c1">;; example below.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; This time I&#39;ll do it using Clojure sets first.</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.set</span> <span class="ss">:as</span> <span class="nv">set</span><span class="p">])</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">set-a</span> <span class="p">(</span><span class="nb">set </span><span class="nv">a</span><span class="p">)</span>   <span class="c1">; if a is a non-set collection, create one</span>
      <span class="nv">set-b</span> <span class="p">(</span><span class="nb">set </span><span class="nv">b</span><span class="p">)</span>
      <span class="nb">union </span><span class="p">(</span><span class="nf">set/union</span> <span class="nv">set-a</span> <span class="nv">set-b</span><span class="p">)</span>
      <span class="nv">isect</span> <span class="p">(</span><span class="nf">set/intersection</span> <span class="nv">set-a</span> <span class="nv">set-b</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">)))</span>
<span class="nv">union=1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
<span class="nv">isect=3</span> <span class="mi">5</span> <span class="mi">7</span>

<span class="c1">;; Now a way more like the style of the Perl examples.</span>
<span class="c1">;;</span>
<span class="c1">;; Warning: The Perl code has a bug, if the input array b contains</span>
<span class="c1">;; duplicates.  In this case, the duplicate elements in b will become</span>
<span class="c1">;; part of isect, even if the elements are not also in a.  The code</span>
<span class="c1">;; below emulates this behavior of the Perl examples.  The code using</span>
<span class="c1">;; Clojure sets above does not.</span>
<span class="c1">;;</span>
<span class="c1">;; To see this behavior, try out the code below with these values for</span>
<span class="c1">;; a and b:</span>
<span class="c1">;;</span>
<span class="c1">;; (def a [1 3 5 6 7 8])</span>
<span class="c1">;; (def b [2 3 5 7 9 2])  ; 2 is duplicated, and will appear in isect</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">union </span><span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span> <span class="nv">a</span><span class="p">)</span>
      <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span><span class="p">]</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nb">union </span><span class="nv">union</span>
                           <span class="nv">isect</span> <span class="p">{}</span>
                           <span class="nv">s</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">b</span><span class="p">)]</span>
                      <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">e</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">)]</span>
                        <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">assoc union </span><span class="nv">e</span> <span class="mi">1</span><span class="p">)</span>
                               <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">union </span><span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">isect</span> <span class="nv">e</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">isect</span><span class="p">)</span>
                               <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">))</span>
                        <span class="c1">;; return a vector of 2 values from the loop</span>
                        <span class="c1">;; expression, which will be bound to union</span>
                        <span class="c1">;; and isect in the outer let expression.</span>
                        <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span><span class="p">]))</span>
      <span class="c1">;; Note that unlike Perl, the map called union becomes</span>
      <span class="c1">;; inaccessible after the following line.  Give the map and</span>
      <span class="c1">;; sequence different names if you want them both accessible</span>
      <span class="c1">;; later.</span>
      <span class="nb">union </span><span class="p">(</span><span class="nb">keys </span><span class="nv">union</span><span class="p">)</span>
      <span class="nv">isect</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">isect</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">)))</span>
<span class="nv">union=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="nv">isect=7</span> <span class="mi">5</span> <span class="mi">3</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The only way I know to write Clojure code that closely emulates</span>
<span class="c1">;; this Perl example is to use thread-local mutable variables,</span>
<span class="c1">;; introduced using with-local-vars.  These require using var-set to</span>
<span class="c1">;; change the value, and var-get to examine the value, which is a bit</span>
<span class="c1">;; clunky.  (var-get union) can be abbreviated @union, which helps</span>
<span class="c1">;; somewhat.  If you really want to write something in imperative</span>
<span class="c1">;; style, with-local-vars may be your best bet.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nb">union </span><span class="nv">isect</span><span class="p">]</span>
      <span class="p">(</span><span class="nb">with-local-vars </span><span class="p">[</span><span class="nb">union </span><span class="p">{}</span>
                        <span class="nv">isect</span> <span class="p">{}]</span>
        <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">e</span> <span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nb">concat </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))]</span>
          <span class="c1">;; The next let statement behaves as Perl&#39;s $union{$e}++,</span>
          <span class="c1">;; incrementing $union{$e}, but returning the value of</span>
          <span class="c1">;; $union{$e} before the increment occurs.  This is nil in</span>
          <span class="c1">;; Clojure rather than Perl&#39;s undef, but both evaluate to</span>
          <span class="c1">;; false by Clojure &#39;and&#39; or Perl &amp;&amp;.</span>
          <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">in-union</span> <span class="p">(</span><span class="o">@</span><span class="nb">union </span><span class="nv">e</span><span class="p">)]</span>
                 <span class="p">(</span><span class="nb">var-set union </span><span class="p">(</span><span class="nf">update-in</span> <span class="o">@</span><span class="nb">union </span><span class="p">[</span><span class="nv">e</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">)))</span>
                 <span class="nv">in-union</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">var-set </span><span class="nv">isect</span> <span class="p">(</span><span class="nf">update-in</span> <span class="o">@</span><span class="nv">isect</span> <span class="p">[</span><span class="nv">e</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">)))))</span>
        <span class="p">[</span><span class="o">@</span><span class="nb">union </span><span class="o">@</span><span class="nv">isect</span><span class="p">])</span>
      <span class="nb">union </span><span class="p">(</span><span class="nb">keys </span><span class="nv">union</span><span class="p">)</span>
      <span class="nv">isect</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">isect</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">)))</span>
<span class="nv">union=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="nv">isect=7</span> <span class="mi">5</span> <span class="mi">3</span>

<span class="c1">;; The example using set/union and set/difference is really the best</span>
<span class="c1">;; way to go in Clojure, though.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; First the clojure.set way:</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">set-a</span> <span class="p">(</span><span class="nb">set </span><span class="nv">a</span><span class="p">)</span>
      <span class="nv">set-b</span> <span class="p">(</span><span class="nb">set </span><span class="nv">b</span><span class="p">)</span>
      <span class="nb">union </span><span class="p">(</span><span class="nf">set/union</span> <span class="nv">set-a</span> <span class="nv">set-b</span><span class="p">)</span>
      <span class="nv">isect</span> <span class="p">(</span><span class="nf">set/intersection</span> <span class="nv">set-a</span> <span class="nv">set-b</span><span class="p">)</span>
      <span class="nv">diff</span> <span class="p">(</span><span class="nf">set/difference</span> <span class="nb">union </span><span class="nv">isect</span><span class="p">)</span>
      <span class="c1">;; Or, if you want to find the &#39;symmetric difference&#39; without</span>
      <span class="c1">;; explicitly calculation the union and intersection first,</span>
      <span class="c1">;; another way is:</span>
      <span class="c1">;; diff (set/union (set/difference set-a set-b)</span>
      <span class="c1">;;                 (set/difference set-b set-a))</span>
      <span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;diff=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">diff</span><span class="p">)))</span>
<span class="nv">union=1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
<span class="nv">isect=3</span> <span class="mi">5</span> <span class="mi">7</span>
<span class="nv">diff=1</span> <span class="mi">2</span> <span class="mi">6</span> <span class="mi">8</span> <span class="mi">9</span>

<span class="c1">;; Next a way closer to the Perl code, but without with-local-vars.</span>
<span class="c1">;; Function tally copied from an earlier example, repeated for easier</span>
<span class="c1">;; reference.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">tally</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nf">update-in</span> <span class="nv">%1</span> <span class="p">[</span><span class="nv">%2</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">))</span>
          <span class="p">{}</span> <span class="nv">coll</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">count </span><span class="p">(</span><span class="nf">tally</span> <span class="p">(</span><span class="nb">concat </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
      <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span> <span class="nv">diff</span><span class="p">]</span>
      <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nb">union </span><span class="p">[]</span>
             <span class="nv">isect</span> <span class="p">[]</span>
             <span class="nv">diff</span> <span class="p">[]</span>
             <span class="nv">s</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">count</span><span class="p">)]</span>
        <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">e</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">)]</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">== </span><span class="p">(</span><span class="nb">count </span><span class="nv">e</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj union </span><span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">isect</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">diff</span>          <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj union </span><span class="nv">e</span><span class="p">)</span> <span class="nv">isect</span>          <span class="p">(</span><span class="nb">conj </span><span class="nv">diff</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">)))</span>
          <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span> <span class="nv">diff</span><span class="p">]))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;diff=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">diff</span><span class="p">)))</span>
<span class="nv">union=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="nv">isect=7</span> <span class="mi">5</span> <span class="mi">3</span>
<span class="nv">diff=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">6</span> <span class="mi">1</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; A similar trick as used in the Perl example can be made to work</span>
<span class="c1">;; with Clojure local mutable vars, if you really want to do it.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">count </span><span class="p">(</span><span class="nf">tally</span> <span class="p">(</span><span class="nb">concat </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
      <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span> <span class="nv">diff</span><span class="p">]</span>
      <span class="p">(</span><span class="nb">with-local-vars </span><span class="p">[</span><span class="nb">union </span><span class="p">[]</span>
                        <span class="nv">isect</span> <span class="p">[]</span>
                        <span class="nv">diff</span> <span class="p">[]]</span>
        <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">e</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">count</span><span class="p">)]</span>
          <span class="p">(</span><span class="nb">var-set union </span><span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">var-get </span><span class="nv">union</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
          <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">target</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">== </span><span class="p">(</span><span class="nb">count </span><span class="nv">e</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">isect</span> <span class="nv">diff</span><span class="p">)]</span>
            <span class="p">(</span><span class="nb">var-set </span><span class="nv">target</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">var-get </span><span class="nv">target</span><span class="p">)</span> <span class="nv">e</span><span class="p">))))</span>
        <span class="p">[(</span><span class="nb">var-get </span><span class="nv">union</span><span class="p">)</span> <span class="p">(</span><span class="nb">var-get </span><span class="nv">isect</span><span class="p">)</span> <span class="p">(</span><span class="nb">var-get </span><span class="nv">diff</span><span class="p">)])]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;diff=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">diff</span><span class="p">)))</span>
<span class="nv">union=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="nv">isect=7</span> <span class="mi">5</span> <span class="mi">3</span>
<span class="nv">diff=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">6</span> <span class="mi">1</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN197"
>Appending One Array to Another</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="c1">;; No vec call needed if the result can be a list.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ARRAY1</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="nv">ARRAY1</span> <span class="nv">ARRAY2</span><span class="p">))]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; I don&#39;t know of any Clojure code that looks like that in the Perl</span>
<span class="c1">;; example for combining two lists.  The example above using concat</span>
<span class="c1">;; will do the job.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">members</span> <span class="p">[</span><span class="s">&quot;Time&quot;</span> <span class="s">&quot;Flies&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">initiates</span> <span class="p">[</span><span class="s">&quot;An&quot;</span> <span class="s">&quot;Arrow&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">members</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="nv">members</span> <span class="nv">initiates</span><span class="p">))]</span>
  <span class="c1">;; members is now [&quot;Time&quot; &quot;Flies&quot; &quot;An&quot; &quot;Arrow&quot;]</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure data structures are immutable, so we can&#39;t write a splice</span>
<span class="c1">;; function that modifies these data structures, but we can write a</span>
<span class="c1">;; split that will return a new data structure that is similar in its</span>
<span class="c1">;; value to the Perl one, after splice modifies it.</span>

<span class="c1">;; First, we&#39;ll write a simpler version that only works with an offset</span>
<span class="c1">;; in the range [0, n] where n is the length of the vector, and a</span>
<span class="c1">;; non-negative length such that offset+length is also in the range</span>
<span class="c1">;; [0,n].</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">splice</span> <span class="p">[</span><span class="nv">v</span> <span class="nv">offset</span> <span class="nv">length</span> <span class="nv">coll-to-insert</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="nv">offset</span><span class="p">)</span>
               <span class="nv">coll-to-insert</span>
               <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">offset</span> <span class="nv">length</span><span class="p">)))))</span>

<span class="c1">;; Since the example below uses a splice with negative offset, I&#39;ll go</span>
<span class="c1">;; ahead and give what I think is a full implementation of all cases</span>
<span class="c1">;; of positive, 0, or negaitve arguments to Perl&#39;s splice (and also</span>
<span class="c1">;; substr) for offset and length.  This helper function converts Perl</span>
<span class="c1">;; offset and length arguments to Clojure start and end arguments for</span>
<span class="c1">;; subvec (and also subs).  It is a bit of a mess because of all of</span>
<span class="c1">;; the conditions to check.  There is likely code much like this</span>
<span class="c1">;; buried inside of Perl&#39;s implementation of subs and splice.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">ps-start-end</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">offset</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">offset</span><span class="p">)</span> <span class="p">[(</span><span class="nb">max </span><span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="nv">offset</span><span class="p">))</span> <span class="nv">n</span><span class="p">]</span>
           <span class="p">(</span><span class="nb">&gt; </span><span class="nv">offset</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">nil</span>
           <span class="ss">:else</span> <span class="p">[</span><span class="nv">offset</span> <span class="nv">n</span><span class="p">]))</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">offset</span> <span class="nv">c</span><span class="p">]</span>
     <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">start</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">offset</span><span class="p">)</span>
                   <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="nv">offset</span><span class="p">)</span>
                   <span class="nv">offset</span><span class="p">)</span>
           <span class="nv">end</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">c</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="nv">c</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">+ </span><span class="nv">start</span> <span class="nv">c</span><span class="p">))]</span>
       <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">start</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">end</span><span class="p">)</span>
                            <span class="nv">nil</span>
                            <span class="p">[</span><span class="mi">0</span> <span class="p">(</span><span class="nb">min </span><span class="nv">n</span> <span class="nv">end</span><span class="p">)])</span>
             <span class="p">(</span><span class="nb">&gt; </span><span class="nv">start</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">nil</span>
             <span class="ss">:else</span> <span class="p">[</span><span class="nv">start</span> <span class="p">(</span><span class="nb">min </span><span class="nv">n</span> <span class="p">(</span><span class="nb">max </span><span class="nv">start</span> <span class="nv">end</span><span class="p">))]))))</span>

<span class="c1">;; Here we implement splice that takes a vector and either just an</span>
<span class="c1">;; offset, an offset and a length, or offset, length, and collection</span>
<span class="c1">;; of items to splice in.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">splice-helper</span> <span class="p">[</span><span class="nv">v</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">coll-to-insert</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="nv">start</span><span class="p">)</span>
               <span class="nv">coll-to-insert</span>
               <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="nv">end</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">splice</span>
  <span class="p">([</span><span class="nv">v</span> <span class="nv">offset</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">when-let </span><span class="p">[[</span><span class="nv">start</span> <span class="nv">end</span><span class="p">]</span> <span class="p">(</span><span class="nf">ps-start-end</span> <span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span> <span class="nv">offset</span><span class="p">)]</span>
       <span class="p">(</span><span class="nf">splice-helper</span> <span class="nv">v</span> <span class="nv">start</span> <span class="nv">end</span> <span class="p">[])))</span>
  <span class="p">([</span><span class="nv">v</span> <span class="nv">offset</span> <span class="nv">length</span><span class="p">]</span>
     <span class="p">(</span><span class="nf">splice</span> <span class="nv">v</span> <span class="nv">offset</span> <span class="nv">length</span> <span class="p">[]))</span>
  <span class="p">([</span><span class="nv">v</span> <span class="nv">offset</span> <span class="nv">length</span> <span class="nv">coll-to-insert</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">when-let </span><span class="p">[[</span><span class="nv">start</span> <span class="nv">end</span><span class="p">]</span> <span class="p">(</span><span class="nf">ps-start-end</span> <span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span> <span class="nv">offset</span> <span class="nv">length</span><span class="p">)]</span>
       <span class="p">(</span><span class="nf">splice-helper</span> <span class="nv">v</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">coll-to-insert</span><span class="p">))))</span>


<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">members</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">members</span> <span class="mi">2</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;Like&quot;</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">initiates</span><span class="p">)))</span>
      <span class="nv">_</span> <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">members</span><span class="p">))</span>
      <span class="nv">members</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">members</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">[</span><span class="s">&quot;Fruit&quot;</span><span class="p">])</span>
      <span class="nv">members</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">members</span> <span class="mi">-2</span> <span class="mi">2</span> <span class="p">[</span><span class="s">&quot;A&quot;</span> <span class="s">&quot;Banana&quot;</span><span class="p">])</span>
      <span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">members</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="nv">Time</span> <span class="nv">Flies</span> <span class="nv">Like</span> <span class="nv">An</span> <span class="nv">Arrow</span>
<span class="nv">Fruit</span> <span class="nv">Flies</span> <span class="nv">Like</span> <span class="nv">A</span> <span class="nv">Banana</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN200"
>Reversing an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">reversed</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">array</span><span class="p">)))</span>  <span class="c1">; remove vec call if sequence result OK</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nb">count </span><span class="nv">ARRAY</span><span class="p">))]</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">i</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1">;; do something with (ARRAY i)</span>
    <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">i</span><span class="p">))))</span>

<span class="c1">;; alternate version</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nb">count </span><span class="nv">ARRAY</span><span class="p">))</span> <span class="mi">-1</span> <span class="mi">-1</span><span class="p">)]</span>
  <span class="c1">;; do something with (ARRAY i)</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">ascending</span> <span class="p">(</span><span class="nb">sort </span><span class="nv">users</span><span class="p">))</span>

<span class="c1">;; If you want to make the comparison function explicit, you can use</span>
<span class="c1">;; this, which is equivalent to the above.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">ascending</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare</span> <span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span> <span class="nv">users</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">descending</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">ascending</span><span class="p">))</span>

<span class="c1">;; one-step: sort with reverse comparison</span>
<span class="p">(</span><span class="k">def </span><span class="nv">descending</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare</span> <span class="nv">%2</span> <span class="nv">%1</span><span class="p">)</span> <span class="nv">users</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN203"
>Processing Multiple Elements of an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="c1">;; The Perl code @FRONT = splice(@ARRAY, 0, $N); has the side effect</span>
<span class="c1">;; of modifying @ARRAY, removing the first $N elements from it, and</span>
<span class="c1">;; simultaneously assigning an array of those first $N elements to</span>
<span class="c1">;; @FRONT.</span>

<span class="c1">;; To get a similar effect in Clojure can be done as follows:</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">FRONT</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">array</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">)</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">array</span> <span class="nv">n</span><span class="p">)]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; The Perl code @END = splice(@ARRAY, -$N); also has two side</span>
<span class="c1">;; effects: removing the last $N elements from @ARRAY, and assigning</span>
<span class="c1">;; an array containing those last $N elements to @END.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">END</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">array</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">)</span> <span class="nv">n</span><span class="p">))</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">array</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">)</span> <span class="nv">n</span><span class="p">))]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; or if you want to use the Clojure splice function defined earlier:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">n</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">END</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">array</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span><span class="p">))</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">array</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;array=%s   END=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">array</span><span class="p">)</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">END</span><span class="p">))</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; It is not really possible to write a Clojure function that mutates</span>
<span class="c1">;; an immutable data structure, like Perl&#39;s shift2 and pop2 do.</span>

<span class="c1">;; We could write a function that takes a vector v and return a vector</span>
<span class="c1">;; of the two things: (1) a vector of the first two elements of v, and</span>
<span class="c1">;; (2) a vector of all but the first two elements of v.  The caller of</span>
<span class="c1">;; that function could then choose to use one or both of those values</span>
<span class="c1">;; and bind them to symbols of its choice.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">shift2</span> <span class="p">[</span><span class="nv">v</span><span class="p">]</span>
  <span class="p">[(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">2</span><span class="p">)])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">pop2</span> <span class="p">[</span><span class="nv">v</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="nv">i</span><span class="p">)]))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure qw defined far above.  Reuse it here.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">friends</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">qw</span> <span class="s">&quot;Peter Paul Mary Jim Tim&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[[</span><span class="nv">this</span> <span class="nv">that</span><span class="p">]</span> <span class="nv">friends</span><span class="p">]</span> <span class="p">(</span><span class="nf">shift2</span> <span class="nv">friends</span><span class="p">)]</span>
  <span class="c1">;; this contains &quot;Peter&quot;, that has &quot;Paul&quot;, and friends has &quot;Mary&quot;,</span>
  <span class="c1">;; &quot;Jim&quot;, and &quot;Tim&quot;.</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;this=%s  that=%s  friends=%s\n&quot;</span> <span class="nv">this</span> <span class="nv">that</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">friends</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">beverages</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">qw</span> <span class="s">&quot;Dew Jolt Cola Sprite Fresca&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">pair</span> <span class="nv">beverages</span><span class="p">]</span> <span class="p">(</span><span class="nf">pop2</span> <span class="nv">beverages</span><span class="p">)]</span>
  <span class="c1">;; (pair 0) contains Sprite, (pair 1) has Fresca, and beverages has</span>
  <span class="c1">;; [&quot;Dew&quot; &quot;Jolt&quot; &quot;Cola&quot;]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;(pair 0)=%s  (pair 1)=%s  beverages=%s\n&quot;</span>
          <span class="p">(</span><span class="nf">pair</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">pair</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">beverages</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure doesn&#39;t have references exactly like Perl&#39;s.  It does have</span>
<span class="c1">;; something called refs, but in Clojure they are intended primarily</span>
<span class="c1">;; for handling coordinated concurrent changes to multiple refs with</span>
<span class="c1">;; transactions.</span>
<span class="c1">;;</span>
<span class="c1">;; TBD: It isn&#39;t clear to me whether Clojure has a way to implement</span>
<span class="c1">;; the behavior in this Perl code.</span>
<span class="c1">;;</span>
<span class="c1">;; $line[5] = \@list;</span>
<span class="c1">;; @got = pop2( @{ $line[5] } );</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN206"
>Finding the First List Element That Passes a Test</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="c1">;; If we know that the matching item cannot possibly have a value that</span>
<span class="c1">;; Clojure would evaluate as false, i.e. false or nil, then we can</span>
<span class="c1">;; write the following.  Note that filter is lazy, so since we only</span>
<span class="c1">;; ask for the first element, the rest of the elements after the</span>
<span class="c1">;; first, if any, will not be computed.  (Exception: If array is a</span>
<span class="c1">;; chunked sequence, the predicate function will be evaluated on all</span>
<span class="c1">;; elements of array in the same chunk as the first one that returns a</span>
<span class="c1">;; logical true value.)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">15</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">15</span><span class="p">])</span>
<span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">match</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="nv">array</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="nv">match</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">))</span>

<span class="c1">;; Be careful!  That code will do the wrong thing if the value false</span>
<span class="c1">;; or nil is in the array, and the criterion we are checking for is</span>
<span class="c1">;; true for such a value.  For example:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="nv">nil</span> <span class="mi">13</span> <span class="mi">15</span><span class="p">])</span>
<span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">match</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">filter nil? </span><span class="nv">array</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="nv">match</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">))</span>
<span class="nv">No</span> <span class="nv">matching</span> <span class="nv">item</span> <span class="nv">found</span>

<span class="c1">;; In this case, nil? returned true for the value nil in array, so</span>
<span class="c1">;; filter did include nil in its output sequence.  However, this</span>
<span class="c1">;; causes first to return the first element of the sequence, nil.  if</span>
<span class="c1">;; and if-let treat nil as false, and thus does the else case.</span>

<span class="c1">;; If we want to avoid that possibility, we can use the function some,</span>
<span class="c1">;; and have a predicate function that returns something besides</span>
<span class="c1">;; nil/false in the matching case.  One way to do that is to bundle up</span>
<span class="c1">;; the matching value in a vector, because if and if-let treat [nil]</span>
<span class="c1">;; and [false] as true.  After all, they are not the same as the</span>
<span class="c1">;; values nil or false.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="nv">nil</span> <span class="mi">13</span> <span class="mi">15</span><span class="p">])</span>
<span class="p">(</span><span class="nb">if-let </span><span class="p">[[</span><span class="nv">match</span><span class="p">]</span> <span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">%</span><span class="p">)</span> <span class="p">[</span><span class="nv">%</span><span class="p">])</span> <span class="nv">array</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="nv">match</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">))</span>
<span class="nv">Found</span> <span class="nv">matching</span> <span class="nv">item</span> <span class="nv">null</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The previous examples will work, of course.  If you want the index</span>
<span class="c1">;; of the matching element, though, they won&#39;t do.  We could do it</span>
<span class="c1">;; with loop.  Note that this works with vectors, but not with other</span>
<span class="c1">;; collections, whereas earlier examples work with all kinds of</span>
<span class="c1">;; collections.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">match-idx</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span> <span class="mi">0</span><span class="p">]</span>
                  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
                    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">even?</span> <span class="p">(</span><span class="nf">array</span> <span class="nv">i</span><span class="p">))</span>
                      <span class="nv">i</span>
                      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)))</span>
                    <span class="nv">nil</span><span class="p">))]</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">match-idx</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="p">(</span><span class="nf">array</span> <span class="nv">match-idx</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; TBD: Read more about what this example is intended to do.  Should</span>
<span class="c1">;; Clojure example create a new class?  Seems like overkill.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure loops like loop, dotimes, doseq all bind symbols locally,</span>
<span class="c1">;; i.e. within their body, only.  They do not have any accessible</span>
<span class="c1">;; value after the body of the loop is complete.  If you really want</span>
<span class="c1">;; to do it in the way the Perl code is written, it seems you must</span>
<span class="c1">;; write imperative style code, like this.</span>
<span class="p">(</span><span class="nb">with-local-vars </span><span class="p">[</span><span class="nv">i</span> <span class="mi">0</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="o">@</span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">even?</span> <span class="p">(</span><span class="nf">array</span> <span class="o">@</span><span class="nv">i</span><span class="p">))</span>
        <span class="nv">true</span>   <span class="c1">; stop the loop</span>
        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">var-set </span><span class="nv">i</span> <span class="p">(</span><span class="nb">inc </span><span class="o">@</span><span class="nv">i</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">recur</span><span class="p">)))))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="o">@</span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="p">(</span><span class="nf">array</span> <span class="o">@</span><span class="nv">i</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">)))</span>

<span class="c1">;; Another way is almost exactly like one of the examples above, where</span>
<span class="c1">;; you return the loop index as the value of the loop expression.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span> <span class="mi">0</span><span class="p">]</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">even?</span> <span class="p">(</span><span class="nf">array</span> <span class="nv">i</span><span class="p">))</span>
              <span class="nv">i</span>
              <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)))</span>
            <span class="nv">i</span><span class="p">))]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="p">(</span><span class="nf">array</span> <span class="nv">i</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN209"
>Finding All Elements in an Array Matching Certain Criteria</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">matching</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">test </span><span class="nv">%</span><span class="p">)</span> <span class="nv">collection</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; You can write Clojure code that works much like this Perl code, but</span>
<span class="c1">;; filter is shorter to write in Clojure, much like grep is in Perl.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">matching</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">matching</span> <span class="p">[]</span>
                      <span class="nv">s</span> <span class="nv">collection</span><span class="p">]</span>
                 <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">s</span><span class="p">)]</span>
                   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">test </span><span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">matching</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">))</span> <span class="p">(</span><span class="nb">next </span><span class="nv">s</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">recur</span> <span class="nv">matching</span> <span class="p">(</span><span class="nb">next </span><span class="nv">s</span><span class="p">)))</span>
                   <span class="nv">matching</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;matching=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">matching</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">nums</span> <span class="p">[</span><span class="mi">5</span> <span class="mi">1000000</span> <span class="mi">1000001</span> <span class="mi">-2</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">bigs</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">%</span> <span class="mi">1000000</span><span class="p">)</span> <span class="nv">nums</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">bigs</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nf">users</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">10000000</span><span class="p">)</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">users</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">matching</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">re-find </span><span class="o">#</span><span class="s">&quot;^gnat &quot;</span> <span class="nv">%</span><span class="p">)</span>
                      <span class="p">(</span><span class="nf">str/split</span> <span class="p">(</span><span class="ss">:out</span> <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;who&quot;</span><span class="p">))</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Just calling function position on elements of employees, not</span>
<span class="c1">;; treating them as objects.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">engineers</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">position</span> <span class="nv">%</span><span class="p">)</span> <span class="s">&quot;Engineer&quot;</span><span class="p">)</span> <span class="nv">employees</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">secondary-assistance</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nf">income</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">26000</span><span class="p">)</span>
                                        <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">income</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">30000</span><span class="p">))</span>
                                  <span class="nv">applicants</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN212"
>Sorting an Array Numerically</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">sorted</span> <span class="p">(</span><span class="nb">sort </span><span class="nv">unsorted</span><span class="p">))</span>
<span class="c1">;; Or if you want to do an explicit comparison function:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">sorted</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare.</span> <span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span> <span class="nv">unsorted</span><span class="p">))</span>
<span class="c1">;; Note that Clojure does not have the distinction between Perl&#39;s &lt;=&gt;</span>
<span class="c1">;; for comparing scalars as numbers vs. cmp for comparing scalars as</span>
<span class="c1">;; strings, because Clojure does not auto-convert value between types</span>
<span class="c1">;; the way Perl does.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.shell</span> <span class="ss">:as</span> <span class="nv">shell</span><span class="p">])</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">pid</span> <span class="p">(</span><span class="nb">sort </span><span class="nv">pids</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%d\n&quot;</span> <span class="nv">pid</span><span class="p">))</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Select a process ID to kill:\n&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">flush</span><span class="p">)</span>  <span class="c1">; println does an automatic flush, but printf does not</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">pid</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)]</span>
  <span class="c1">;; Note that re-matches only returns true if the whole string</span>
  <span class="c1">;; matches the regexp.  It is the same as (re-find #&quot;^\d+$&quot; pid).</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">re-matches </span><span class="o">#</span><span class="s">&quot;\d+&quot;</span> <span class="nv">pid</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Exiting...\n&quot;</span><span class="p">)</span>  <span class="c1">; prints to *out*, which is likely not stderr</span>
    <span class="p">(</span><span class="nf">flush</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">System/exit</span> <span class="mi">1</span><span class="p">))</span>
  <span class="c1">;; TBD: Is there a &#39;platform-independent&#39; API for killing a process</span>
  <span class="c1">;; available from Clojure or Java?  If so, use it here.  The</span>
  <span class="c1">;; following depends upon a process named &quot;kill&quot; being available on</span>
  <span class="c1">;; the system, so probably won&#39;t work on Windows, whereas Perl&#39;s</span>
  <span class="c1">;; subroutine kill would.</span>
  <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;kill&quot;</span> <span class="s">&quot;-TERM&quot;</span> <span class="p">(</span><span class="nb">str </span><span class="nv">pid</span><span class="p">))</span>
  <span class="c1">;; TBD: Similar question for sleep.  I&#39;m almost sure Java must have</span>
  <span class="c1">;; something here.</span>
  <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;sleep&quot;</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;kill&quot;</span> <span class="s">&quot;-KILL&quot;</span> <span class="p">(</span><span class="nb">str </span><span class="nv">pid</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">System/exit</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">descending</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare.</span> <span class="nv">%2</span> <span class="nv">%1</span><span class="p">)</span> <span class="nv">unsorted</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; TBD: Put sort function in separate Clojure namespace</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">all</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare.</span> <span class="nv">%2</span> <span class="nv">%1</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">19</span> <span class="mi">8</span> <span class="mi">3</span><span class="p">]))</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN215"
>Sorting a List by Computable Field</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN218"
>Implementing a Circular List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN221"
>Randomizing an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN224"
>Program: words</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN227"
>Program: permute</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="datesandtimes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="hashes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Dates and Times</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Hashes</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>