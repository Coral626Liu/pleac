<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Hashes</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Clojure"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Arrays"
HREF="arrays.html"><LINK
REL="NEXT"
TITLE="Pattern Matching"
HREF="patternmatching.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Clojure</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="arrays.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="patternmatching.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="HASHES"
>5. Hashes</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN232"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">pleac-section-5</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">string</span><span class="p">]))</span>

<span class="c1">;; The commas are whitespace and optional. Maps are printed with them</span>
<span class="c1">;; at the REPL for readability.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">{</span><span class="s">&quot;Nat&quot;</span> <span class="mi">24</span>, <span class="s">&quot;Jules&quot;</span> <span class="mi">25</span>, <span class="s">&quot;Josh&quot;</span> <span class="mi">17</span><span class="p">})</span>

<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Nat&quot;</span> <span class="mi">24</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Jules&quot;</span> <span class="mi">25</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Josh&quot;</span> <span class="mi">17</span><span class="p">))</span>

<span class="c1">;; Commas omitted here.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">{</span><span class="s">&quot;Apple&quot;</span>  <span class="s">&quot;red&quot;</span>
                 <span class="s">&quot;Banana&quot;</span> <span class="s">&quot;yellow&quot;</span>
                 <span class="s">&quot;Lemon&quot;</span>  <span class="s">&quot;yellow&quot;</span>
                 <span class="s">&quot;Carrot&quot;</span> <span class="s">&quot;orange&quot;</span><span class="p">})</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN235"
>Adding an Element to a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="c1">;; Maps, like all core Clojure data structures, are immutable.</span>
<span class="c1">;; Functions for &quot;changing&quot; maps just return new maps.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">food-color</span> <span class="s">&quot;Raspberry&quot;</span> <span class="s">&quot;pink&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nb">println </span><span class="s">&quot;Known foods:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">food</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">println </span><span class="nv">food</span><span class="p">))</span>
<span class="c1">;; Known foods:</span>
<span class="c1">;; Carrot</span>
<span class="c1">;; Banana</span>
<span class="c1">;; Raspberry</span>
<span class="c1">;; Lemon</span>
<span class="c1">;; Apple</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN238"
>Testing for the Presence of a Key in a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">contains? </span><span class="nv">food-color</span> <span class="s">&quot;key&quot;</span><span class="p">)</span>
  <span class="s">&quot;exists&quot;</span>
  <span class="s">&quot;doesn&#39;t exist&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nb">name </span><span class="p">[</span><span class="s">&quot;Banana&quot;</span> <span class="s">&quot;Martini&quot;</span><span class="p">]]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">contains? </span><span class="nv">food-color</span> <span class="nv">name</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">println name </span><span class="s">&quot;is a food.&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">println name </span><span class="s">&quot;is a drink.&quot;</span><span class="p">)))</span>

<span class="c1">;; Banana is a food.</span>
<span class="c1">;; Martini is a drink.</span>

<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">{})</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Toddler&quot;</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Unborn&quot;</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Phantasm&quot;</span> <span class="nv">nil</span><span class="p">))</span>

<span class="c1">;; Maps are functions from keys to values, and can be called exactly</span>
<span class="c1">;; like functions, taking a key as an argument. The function call</span>
<span class="c1">;; returns nil if the key doesn&#39;t exist. This works just like using</span>
<span class="c1">;; the function &quot;get&quot;.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">thing</span> <span class="p">[</span><span class="s">&quot;Toddler&quot;</span> <span class="s">&quot;Unborn&quot;</span> <span class="s">&quot;Phantasm&quot;</span> <span class="s">&quot;Relic&quot;</span><span class="p">]]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s: &quot;</span> <span class="nv">thing</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">contains? </span><span class="nv">age</span> <span class="nv">thing</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Exists &quot;</span><span class="p">))</span>
  <span class="c1">;; get returns nil when the key isn&#39;t in the map, and when the key</span>
  <span class="c1">;; does exist and the value is nil.</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">get </span><span class="nv">age</span> <span class="nv">thing</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Defined &quot;</span><span class="p">))</span>
  <span class="c1">;; This works just like the above. Output differs from Perl because</span>
  <span class="c1">;; 0 is not falsy.</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">age</span> <span class="nv">thing</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;True &quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="c1">;; Toddler: Exists Defined True</span>
<span class="c1">;; Unborn: Exists Defined True</span>
<span class="c1">;; Phantasm: Exists</span>
<span class="c1">;; Relic:</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">file-sizes</span> <span class="p">[</span><span class="nv">files</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">map </span><span class="nv">file</span><span class="p">]</span>
            <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">file</span> <span class="p">(</span><span class="nf">.trim</span> <span class="nv">file</span><span class="p">)]</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">contains? map </span><span class="nv">file</span><span class="p">)</span>
                <span class="nv">map</span>
                <span class="p">(</span><span class="nb">assoc map </span><span class="nv">file</span> <span class="p">(</span><span class="nf">.length</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="nv">file</span><span class="p">))))))</span>
          <span class="p">{}</span>
          <span class="nv">files</span><span class="p">))</span>

<span class="p">(</span><span class="nf">file-sizes</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">*in*</span><span class="p">)))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN241"
>Deleting from a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="c1">;; dissoc is used to &quot;remove&quot; (return a new map without the key)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-foods</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Keys:&quot;</span> <span class="p">(</span><span class="nf">string/join</span> <span class="s">&quot; &quot;</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Values: &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">food</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">food-color</span> <span class="nv">food</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s &quot;</span> <span class="p">(</span><span class="nf">food-color</span> <span class="nv">food</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">print </span><span class="s">&quot;(undef) &quot;</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;Initially:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;\nWith Banana undef&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">food-color</span> <span class="s">&quot;Banana&quot;</span> <span class="nv">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;\nWith Banana deleted&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">(</span><span class="nb">dissoc </span><span class="nv">food-color</span> <span class="s">&quot;Banana&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="c1">;; Initially:</span>
<span class="c1">;; Keys: Carrot Banana Lemon Apple</span>
<span class="c1">;; Values: orange yellow yellow red</span>

<span class="c1">;; With Banana undef</span>
<span class="c1">;; Keys: Carrot Banana Lemon Apple</span>
<span class="c1">;; Values: orange (undef) yellow red</span>

<span class="c1">;; With Banana deleted</span>
<span class="c1">;; Keys: Carrot Lemon Apple</span>
<span class="c1">;; Values: orange yellow red</span>

<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">(</span><span class="nb">dissoc </span><span class="nv">food-color</span> <span class="s">&quot;Banana&quot;</span> <span class="s">&quot;Apple&quot;</span> <span class="s">&quot;Cabbage&quot;</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN244"
>Traversing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[[</span><span class="nb">key </span><span class="nv">value</span><span class="p">]</span> <span class="nv">food-color</span><span class="p">]</span>
  <span class="c1">;; do something</span>
  <span class="p">)</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nb">key </span><span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">value</span> <span class="p">(</span><span class="nf">food-color</span> <span class="nv">key</span><span class="p">)]</span>
    <span class="c1">;; do something</span>
    <span class="p">))</span>

<span class="c1">;; food-color per the introduction</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[[</span><span class="nv">food</span> <span class="nv">color</span><span class="p">]</span> <span class="nv">food-color</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s is %s.\n&quot;</span> <span class="nv">food</span> <span class="nv">color</span><span class="p">))</span>
<span class="c1">;; Carrot is orange.</span>
<span class="c1">;; Banana is yellow.</span>
<span class="c1">;; Lemon is yellow.</span>
<span class="c1">;; Apple is red.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">food</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">color</span> <span class="p">(</span><span class="nf">food-color</span> <span class="nv">food</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s is %s.\n&quot;</span> <span class="nv">food</span> <span class="nv">color</span><span class="p">)))</span>
<span class="c1">;; Carrot is orange.</span>
<span class="c1">;; Banana is yellow.</span>
<span class="c1">;; Lemon is yellow.</span>
<span class="c1">;; Apple is red.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">food</span> <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">))]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">color</span> <span class="p">(</span><span class="nf">food-color</span> <span class="nv">food</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s is %s.\n&quot;</span> <span class="nv">food</span> <span class="nv">color</span><span class="p">)))</span>
<span class="c1">;; Apple is red.</span>
<span class="c1">;; Banana is yellow.</span>
<span class="c1">;; Carrot is orange.</span>
<span class="c1">;; Lemon is yellow.</span>

<span class="c1">;; There isn&#39;t an idiomatic way to reset an iteration through a</span>
<span class="c1">;; collection in Clojure.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">countfrom</span> <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">lines</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">file</span><span class="p">))</span>
        <span class="nv">match-sender</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">line</span><span class="p">]</span>
                       <span class="p">(</span><span class="nb">second </span><span class="p">(</span><span class="nb">re-matches </span><span class="o">#</span><span class="s">&quot;^From: (.*)&quot;</span> <span class="nv">line</span><span class="p">)))</span>
        <span class="nv">from</span> <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">map </span><span class="nv">line</span><span class="p">]</span>
                       <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">sender</span> <span class="p">(</span><span class="nf">match-sender</span> <span class="nv">line</span><span class="p">)</span>
                             <span class="nv">cur</span> <span class="p">(</span><span class="nb">get map </span><span class="nv">sender</span> <span class="mi">0</span><span class="p">)]</span>
                         <span class="p">(</span><span class="nb">assoc map </span><span class="nv">sender</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">cur</span><span class="p">))))</span>
                     <span class="p">{}</span>
                     <span class="nv">lines</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">doseq </span><span class="p">[[</span><span class="nv">person</span> <span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nb">sort </span><span class="nv">from</span><span class="p">)]</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s: %d\n&quot;</span> <span class="nv">person</span> <span class="nv">n</span><span class="p">))))</span>
<span class="c1">;; FILE ACCESS</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN247"
>Printing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN250"
>Retrieving from a Hash in Insertion Order</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN253"
>Hashes with Multiple Values Per Key</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN256"
>Inverting a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN259"
>Sorting a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN262"
>Merging Hashes</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN265"
>Finding Common or Different Keys in Two Hashes</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN268"
>Hashing References</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN271"
>Presizing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN274"
>Finding the Most Common Anything</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN277"
>Representing Relationships Between Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN280"
>Program: dutree</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="arrays.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="patternmatching.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Arrays</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Pattern Matching</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>