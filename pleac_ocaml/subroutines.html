<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Subroutines</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Objective CAML "
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Directories"
HREF="directories.html"><LINK
REL="NEXT"
TITLE="References and Records"
HREF="referencesandrecords.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Objective CAML </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SUBROUTINES"
>10. Subroutines</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN536"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span>
<span class="c">(* A function is bound to a variable (as with everything) with the let keyword</span>
<span class="c">*)</span>

<span class="k">let</span> <span class="n">hello</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">incr</span> <span class="n">greeted</span><span class="o">;</span> <span class="c">(* global reference *)</span>
  <span class="n">printf</span> <span class="s2">&quot;hi there!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>

<span class="c">(* Other forms for declaring a function are as follows *)</span>

<span class="k">let</span> <span class="n">hello</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="n">incr</span> <span class="n">greeted</span><span class="o">;</span> <span class="c">(* global reference *)</span>
    <span class="n">printf</span> <span class="s2">&quot;hi there!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">hello</span> <span class="o">=</span>
  <span class="k">function</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="n">incr</span> <span class="n">greeted</span><span class="o">;</span> <span class="c">(* global reference *)</span>
    <span class="n">printf</span> <span class="s2">&quot;hi there!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span>

<span class="c">(* The typical way of calling this function is *)</span>

<span class="n">hello</span> <span class="bp">()</span><span class="o">;;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN539"
>Accessing Subroutine Arguments</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span>
<span class="c">(* All values passed to a function must be named in the paramater list to the</span>
<span class="c"> * function *)</span>

<span class="k">let</span> <span class="n">hypotenuse</span> <span class="n">side1</span> <span class="n">side2</span> <span class="o">=</span>
  <span class="n">sqrt</span> <span class="o">((</span><span class="n">side1</span> <span class="o">**</span> <span class="mi">2</span><span class="o">.)</span> <span class="o">+.</span> <span class="o">(</span><span class="n">side2</span> <span class="o">**</span> <span class="mi">2</span><span class="o">.));;</span>

<span class="c">(* Note, however, that if the parameters are defined/sent as a tuple then they</span>
<span class="c"> * can be accessed in one of two equivalent ways *)</span>

<span class="k">let</span> <span class="n">hypotenuse</span> <span class="o">(</span><span class="n">side1</span><span class="o">,</span><span class="n">side2</span><span class="o">)</span> <span class="o">=</span>
  <span class="n">sqrt</span> <span class="o">((</span><span class="n">side1</span> <span class="o">**</span> <span class="mi">2</span><span class="o">.)</span> <span class="o">+.</span> <span class="o">(</span><span class="n">side2</span> <span class="o">**</span> <span class="mi">2</span><span class="o">.));;</span>

<span class="k">let</span> <span class="n">hypotenuse</span> <span class="n">sides</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">side1</span><span class="o">,</span><span class="n">side2</span> <span class="o">=</span> <span class="n">sides</span> <span class="k">in</span>
  <span class="n">sqrt</span> <span class="o">((</span><span class="n">side1</span> <span class="o">**</span> <span class="mi">2</span><span class="o">.)</span> <span class="o">+.</span> <span class="o">(</span><span class="n">side2</span> <span class="o">**</span> <span class="mi">2</span><span class="o">.));;</span>

<span class="c">(* In both of these cases, however, we must pass the arguments as a tuple *)</span>

<span class="n">print_float</span> <span class="n">hypotenuse</span> <span class="o">(</span><span class="mi">3</span><span class="o">.,</span><span class="mi">4</span><span class="o">.);;</span>

<span class="c">(* since most data structures are immutable, one generally does not need to copy</span>
<span class="c"> * the parameters into local variables *)</span>

<span class="k">let</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">.</span><span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">.</span><span class="mi">7</span><span class="o">];;</span>
<span class="k">let</span> <span class="n">int_all</span> <span class="n">l</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">int_of_float</span> <span class="n">l</span><span class="o">;;</span>

<span class="c">(*</span>
<span class="c"># let ints = int_all nums;;</span>
<span class="c">val ints : int list = [1; 3; 6]</span>

<span class="c"># nums;;</span>
<span class="c">- : float list = [1.4; 3.5; 6.7]</span>
<span class="c">*)</span>

<span class="c">(* However, one needs to be careful when mutable data is passed in and</span>
<span class="c"> * operations that alter that data are used *)</span>

<span class="k">let</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">1</span><span class="o">.</span><span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">.</span><span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">.</span><span class="mi">7</span> <span class="o">|];;</span>
<span class="k">let</span> <span class="n">int_all2</span> <span class="n">a</span> <span class="o">=</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">iteri</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="mi">10</span><span class="o">.</span> <span class="o">*.</span> <span class="n">x</span><span class="o">)</span> <span class="n">a</span><span class="o">;</span>
  <span class="n">a</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">int_all3</span> <span class="n">a</span> <span class="o">=</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="n">int_of_float</span> <span class="n">a</span><span class="o">;;</span>

<span class="c">(*</span>
<span class="c"># let a2 = int_all2 nums;;</span>
<span class="c">val a2 : int array = [|1; 3; 6|]</span>

<span class="c"># nums;;</span>
<span class="c">- : float array = [|1.4; 3.5; 6.7|]</span>

<span class="c"># let a3 = times10 nums;;</span>
<span class="c">val a3 : float array = [|14.; 35.; 67.|]</span>

<span class="c"># nums;;</span>
<span class="c">- : float array = [|14.; 35.; 67.|]</span>
<span class="c">*)</span>

<span class="c">(* To write functions that change their caller&#39;s variables, those variables must</span>
<span class="c"> * be mutable structures, such as references *)</span>
<span class="k">let</span> <span class="n">nums</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">.</span><span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">.</span><span class="mi">7</span><span class="o">];;</span>
<span class="k">let</span> <span class="n">trunc_em</span> <span class="n">l</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">:=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">floor</span> <span class="o">!</span><span class="n">l</span><span class="o">;</span>
  <span class="o">!</span><span class="n">l</span><span class="o">;;</span>

<span class="c">(*</span>

<span class="c"># let n2 = trunc_em nums;;</span>
<span class="c">val n2 : float list = [1.; 3.; 6.]</span>

<span class="c"># !nums;;</span>
<span class="c">- : float list = [1.; 3.; 6.]</span>
<span class="c">*)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN542"
>Making Variables Private to a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span>
<span class="c">(* to declare a variable local to a function, simply use let inside the function</span>
<span class="c"> * body *)</span>

<span class="k">let</span> <span class="n">somefunc</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">variable</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">another</span><span class="o">,</span><span class="n">anarray</span><span class="o">,</span><span class="n">ahash</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="o">...</span> <span class="o">;;</span>

<span class="k">let</span> <span class="n">check_x</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;whatever&quot;</span> <span class="k">in</span>
  <span class="n">run_check</span> <span class="bp">()</span><span class="o">;</span>
  <span class="k">if</span> <span class="n">condition</span> <span class="k">then</span> <span class="n">printf</span> <span class="s2">&quot;got %s&quot;</span> <span class="n">x</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">save_array</span> <span class="n">arguments</span> <span class="o">=</span>
  <span class="n">global_list</span> <span class="o">:=</span> <span class="n">arguments</span> <span class="o">@</span> <span class="o">!</span><span class="n">global_list</span><span class="o">;;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN545"
>Creating Persistent Private Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span>
<span class="k">let</span> <span class="n">mysub</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">variable</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="k">fun</span> <span class="n">args</span> <span class="o">-&gt;</span> <span class="o">...</span> <span class="o">;;</span>

<span class="c">(* To write a counter *)</span>
<span class="k">let</span> <span class="n">next_counter</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="n">incr</span> <span class="n">counter</span><span class="o">;</span>
    <span class="o">!</span><span class="n">counter</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">next_counter</span><span class="o">,</span><span class="n">prev_counter</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">42</span> <span class="k">in</span>
  <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">incr</span> <span class="n">counter</span><span class="o">;</span> <span class="o">!</span><span class="n">counter</span><span class="o">),</span>
  <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">decr</span> <span class="n">counter</span><span class="o">;</span> <span class="o">!</span><span class="n">counter</span><span class="o">);;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN548"
>Determining Current Function Name</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* The names of functions are not available at runtime. However, using the</span>
<span class="c">   camlp4 preprocessor, we can expose various pieces of static information.</span>

<span class="c">   The &quot;macro&quot; parser provides the current file and location as __FILE__ and</span>
<span class="c">   __LOCATION__, respectively. With a bit more customization, we can expose</span>
<span class="c">   the current function name as well.</span>

<span class="c">   To do this, we&#39;ll make a copy of camlp4/Camlp4Filters/Camlp4Profiler.ml</span>
<span class="c">   from the OCaml sources and rename it to &quot;Camlp4FuncNamer.ml&quot;. Then,</span>
<span class="c">   we&#39;ll change the definition of &quot;decorate_this_expr&quot; to the following: *)</span>

<span class="c">(*---------------------------*)</span>

<span class="k">value</span> <span class="n">decorate_this_expr</span> <span class="n">e</span> <span class="n">id</span> <span class="o">=</span>
  <span class="k">let</span> <span class="o">_</span><span class="n">loc</span> <span class="o">=</span> <span class="nn">Ast</span><span class="p">.</span><span class="n">loc_of_expr</span> <span class="n">e</span> <span class="k">in</span>
  <span class="o">&lt;:</span><span class="n">expr</span><span class="o">&lt;</span> <span class="k">let</span> <span class="o">__</span><span class="n">FUNC__</span> <span class="o">=</span> <span class="o">$`</span><span class="n">str</span><span class="o">:</span><span class="n">id</span><span class="o">$</span> <span class="k">in</span> <span class="o">$</span><span class="n">e</span><span class="o">$</span> <span class="o">&gt;&gt;;</span>

<span class="c">(*---------------------------*)</span>

<span class="c">(* This has the effect of exposing the current function name as the</span>
<span class="c">   string, __FUNC__, which we can use just like __FILE__. To build this</span>
<span class="c">   syntax extension, use a command like the following: *)</span>

<span class="n">ocamlc</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">pp</span> <span class="n">camlp4rf</span> <span class="o">-</span><span class="nc">I</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">camlp4</span> <span class="nn">Camlp4FuncNamer</span><span class="p">.</span><span class="n">ml</span>

<span class="c">(*---------------------------*)</span>

<span class="c">(* Now, we&#39;ll write a simple test program called &quot;main.ml&quot;: *)</span>

<span class="c">(* Comment out this line to silence log messages. *)</span>
<span class="nc">DEFINE</span> <span class="nc">DEBUG</span>

<span class="c">(* Default function name if Camlp4FuncNamer doesn&#39;t provide one. *)</span>
<span class="k">let</span> <span class="o">__</span><span class="n">FUNC__</span> <span class="o">=</span> <span class="s2">&quot;&lt;toplevel&gt;&quot;</span>

<span class="c">(* Log macro with Printf formatting. *)</span>
<span class="nc">DEFINE</span> <span class="nc">LOG</span> <span class="o">=</span>
  <span class="nc">IFDEF</span> <span class="nc">DEBUG</span> <span class="nc">THEN</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">kprintf</span>
      <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">eprintf</span> <span class="s2">&quot;%s[%s]: %s</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="o">__</span><span class="n">FUNC__</span> <span class="o">__</span><span class="n">FILE__</span><span class="o">)</span>
  <span class="nc">ELSE</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">kprintf</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">)</span>
  <span class="nc">END</span>

<span class="c">(* An example named function. *)</span>
<span class="k">let</span> <span class="n">test_function</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">str</span> <span class="o">=</span> <span class="s2">&quot;Hello, world!&quot;</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">42</span> <span class="k">in</span>
  <span class="nc">LOG</span> <span class="s2">&quot;str=</span><span class="se">\&quot;</span><span class="s2">%s</span><span class="se">\&quot;</span><span class="s2">, num=%d&quot;</span> <span class="n">str</span> <span class="n">num</span><span class="o">;</span>
  <span class="n">print_endline</span> <span class="s2">&quot;test complete&quot;</span>

<span class="c">(* Some code to run at the toplevel. *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nc">LOG</span> <span class="s2">&quot;not in a function&quot;</span><span class="o">;</span>
  <span class="n">test_function</span> <span class="bp">()</span>

<span class="c">(*---------------------------*)</span>

<span class="c">(* We can compile this program as follows: *)</span>

<span class="n">ocamlc</span> <span class="o">-</span><span class="n">pp</span> <span class="s2">&quot;camlp4of Camlp4FuncNamer.cmo&quot;</span> <span class="err">\</span>
    <span class="o">-</span><span class="nc">I</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">camlp4</span> <span class="err">\</span>
    <span class="o">-</span><span class="n">o</span> <span class="n">main</span> <span class="n">main</span><span class="o">.</span><span class="n">ml</span>

<span class="c">(* Running it, we get this output: *)</span>

<span class="o">&lt;</span><span class="n">toplevel</span><span class="o">&gt;[</span><span class="n">main</span><span class="o">.</span><span class="n">ml</span><span class="o">]:</span> <span class="n">not</span> <span class="k">in</span> <span class="n">a</span> <span class="k">function</span>
<span class="n">test_function</span><span class="o">[</span><span class="n">main</span><span class="o">.</span><span class="n">ml</span><span class="o">]:</span> <span class="n">str</span><span class="o">=</span><span class="s2">&quot;Hello, world!&quot;</span><span class="o">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">42</span>
<span class="n">test</span> <span class="n">complete</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN551"
>Passing Arrays and Hashes by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Because all OCaml variables represent pointers to their data, all function</span>
<span class="c"> * arguments are implicitly passed by reference *)</span>

<span class="n">array_diff</span> <span class="n">array1</span> <span class="n">array2</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="o">[|</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span> <span class="o">|];;</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="o">[|</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">8</span> <span class="o">|];;</span>
<span class="k">let</span> <span class="n">add_vec_pair</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">.(</span><span class="n">i</span><span class="o">));;</span>

<span class="c">(*</span>
<span class="c"># let c = add_vec_pair a b;;</span>
<span class="c">val c : int array = [|6; 10|]</span>
<span class="c">*)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN554"
>Detecting Return Context</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* OCaml&#39;s type safety doesn&#39;t allow this kind of shenanigans unless you bring</span>
<span class="c"> * union types into play -- but you still need to ensure that the return type of</span>
<span class="c"> * all three contexts is the same *)</span>

<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">lORs</span> <span class="o">=</span>
    <span class="nc">List</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span>
  <span class="o">|</span> <span class="nc">Scalar</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span>
  <span class="o">|</span> <span class="nc">Void</span> <span class="k">of</span> <span class="kt">unit</span> <span class="o">;;</span>

<span class="k">let</span> <span class="n">mysub</span> <span class="n">arg</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">arg</span> <span class="k">with</span>
    <span class="nc">List</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="c">(* list context, do something with l *)</span>
  <span class="o">|</span> <span class="nc">Scalar</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="c">(* scalar context, do something with s *)</span>
  <span class="o">|</span> <span class="nc">Void</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="c">(* void context, do something with nothing *)</span><span class="o">;;</span>

<span class="c">(* or equivalently *)</span>
<span class="k">let</span> <span class="n">mysub</span> <span class="o">=</span> <span class="k">function</span>
    <span class="nc">List</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="c">(* list context, do something with l *)</span>
  <span class="o">|</span> <span class="nc">Scalar</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="c">(* scalar context, do something with s *)</span>
  <span class="o">|</span> <span class="nc">Void</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="c">(* void context, do something with nothing *)</span><span class="o">;;</span>

<span class="n">mysub</span> <span class="o">(</span><span class="nc">Void</span> <span class="bp">()</span><span class="o">);;</span>         <span class="c">(* void context *)</span>
<span class="n">mysub</span> <span class="o">(</span><span class="nc">Scalar</span> <span class="n">arg</span><span class="o">);;</span>      <span class="c">(* scalar context *)</span>
<span class="n">mysub</span> <span class="o">(</span><span class="nc">List</span> <span class="n">arg</span><span class="o">);;</span>        <span class="c">(* list context *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN557"
>Passing by Named Parameter</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* To name the arguments of a function, use labels *)</span>
<span class="k">let</span> <span class="n">thefunc</span> <span class="o">~</span><span class="n">increment</span> <span class="o">~</span><span class="n">finish</span> <span class="o">~</span><span class="n">start</span> <span class="o">=</span>
  <span class="o">...</span> <span class="o">;;</span>

<span class="c">(* It can be called like *)</span>
<span class="n">thefunc</span> <span class="o">~</span><span class="n">increment</span><span class="o">:</span><span class="s2">&quot;20s&quot;</span> <span class="o">~</span><span class="n">start</span><span class="o">:</span><span class="s2">&quot;+5m&quot;</span> <span class="o">~</span><span class="n">finish</span><span class="o">:</span><span class="s2">&quot;+30m&quot;</span><span class="o">;;</span>

<span class="c">(* Note that you can use different names for the labels and variables, and if</span>
<span class="c"> * the application is total, the labels can be omitted *)</span>
<span class="k">let</span> <span class="n">divide</span> <span class="o">~</span><span class="n">numerator</span><span class="o">:</span><span class="n">x</span> <span class="o">~</span><span class="n">denominator</span><span class="o">:</span><span class="n">y</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">;;</span>

<span class="c">(*</span>
<span class="c"># divide ~denominator:2 ~numerator:100;;</span>
<span class="c"> - : int = 50</span>

<span class="c"># divide 20 4;;</span>
<span class="c"> - : int = 5</span>
<span class="c">*)</span>

<span class="c">(* If you want to provide default values, you need to use optional arguments,</span>
<span class="c"> * but this requires at least one unlabelled argument *)</span>

<span class="k">let</span> <span class="n">fraction</span> <span class="o">?(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">;;</span>

<span class="c">(*</span>
<span class="c">fraction 30 ~y:3;;</span>
<span class="c"> - : int = 10</span>

<span class="c">fraction 30;;</span>
<span class="c"> - : int = 15</span>
<span class="c">*)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN560"
>Skipping Selected Return Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Use _, which matches any pattern and throws away the value it matches *)</span>

<span class="k">let</span> <span class="n">a</span><span class="o">,_,</span><span class="n">c</span> <span class="o">=</span> <span class="n">func</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">let</span> <span class="o">_,_,</span><span class="n">d</span> <span class="o">=</span> <span class="n">func</span> <span class="bp">()</span><span class="o">;;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN563"
>Returning More Than One Array or Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Just stick all of the values in a tuple and return it *)</span>
<span class="k">let</span> <span class="n">somefunc</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">...</span> <span class="k">in</span>
    <span class="o">...</span>
    <span class="o">(</span><span class="n">arr</span><span class="o">,</span><span class="n">hash</span><span class="o">);;</span>

<span class="k">let</span> <span class="n">a</span><span class="o">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">somefunc</span> <span class="bp">()</span><span class="o">;;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN566"
>Returning Failure</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Use an appropriate exception *)</span>

<span class="k">let</span> <span class="n">failing_routine</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="o">...</span>
  <span class="k">raise</span> <span class="nc">Failure</span> <span class="s2">&quot;Bad things happened...&quot;</span><span class="o">;;</span>

<span class="k">try</span> <span class="n">failing_routine</span> <span class="bp">()</span> <span class="k">with</span>
  <span class="nc">Failure</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">printf</span> <span class="s2">&quot;failing_routine failed because: %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">s</span><span class="o">;;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN569"
>Prototyping Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span>
<span class="c">(* This is pretty much unnecessary due to OCaml&#39;s type inference -- you will</span>
<span class="c"> * know at compile time if you try to pass invalid arguments to a function *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN572"
>Handling Exceptions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* To handle exceptions, which are thrown with the raise keword, wrap the</span>
<span class="c"> * possibly exceptional call in a try ... with block.  You only need to do this</span>
<span class="c"> * where appropriate *)</span>

<span class="k">let</span> <span class="n">slurp_to_list</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="c">(* Note, if filename does not exist in the current directory, it will raise a</span>
<span class="c">   * Sys_error exception *)</span>
  <span class="k">let</span> <span class="n">ic</span> <span class="o">=</span> <span class="n">open_in</span> <span class="n">filename</span> <span class="ow">and</span>
  <span class="n">l</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">line</span> <span class="o">=</span> <span class="n">input_line</span> <span class="n">ic</span> <span class="k">in</span>
    <span class="n">l</span> <span class="o">:=</span> <span class="n">line</span><span class="o">::!</span><span class="n">l</span><span class="o">;</span>
    <span class="n">loop</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">try</span> <span class="n">loop</span> <span class="bp">()</span> <span class="k">with</span> <span class="nc">End_of_file</span> <span class="o">-&gt;</span> <span class="n">close_in</span> <span class="n">ic</span><span class="o">;</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">!</span><span class="n">l</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">lfind</span> <span class="n">name</span> <span class="n">l</span> <span class="o">=</span>
  <span class="c">(* Note, if no elements in the list satisfy the predicate, List.find will</span>
<span class="c">   * raise the Not_found exception *)</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">find</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">Str</span><span class="p">.</span><span class="n">string_match</span> <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">regexp</span> <span class="o">(</span><span class="s2">&quot;$&quot;</span> <span class="o">^</span> <span class="n">name</span><span class="o">))</span> <span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="n">l</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">findSmurfette</span> <span class="o">=</span>
  <span class="k">try</span>
    <span class="n">print_endline</span> <span class="o">(</span><span class="n">lfind</span> <span class="s2">&quot;Smurfette&quot;</span> <span class="o">(</span><span class="n">slurp_to_list</span> <span class="s2">&quot;smurfs&quot;</span><span class="o">))</span>
  <span class="k">with</span>
    <span class="nc">Sys_error</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">prerr_endline</span> <span class="o">(</span><span class="s2">&quot;Dammit! - &quot;</span> <span class="o">^</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">|</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="n">prerr_endline</span> <span class="s2">&quot;Hmmm... Smurfette is not in smurfs&quot;</span><span class="o">;;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN575"
>Saving Global Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* To do this in OCaml -- which doesn&#39;t like global state in the first place --</span>
<span class="c"> * you need to manually store the old value and replace it before exiting the</span>
<span class="c"> * block *)</span>

<span class="k">let</span> <span class="n">age</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">18</span><span class="o">;;</span>
<span class="k">if</span> <span class="n">condition</span> <span class="k">then</span>
  <span class="o">(</span>
    <span class="k">let</span> <span class="n">org_age</span> <span class="o">=</span> <span class="o">!</span><span class="n">age</span> <span class="k">in</span>
    <span class="n">age</span> <span class="o">:=</span> <span class="mi">23</span><span class="o">;</span>
    <span class="n">func</span> <span class="bp">()</span><span class="o">;</span>
    <span class="n">age</span> <span class="o">:=</span> <span class="n">org_age</span>
  <span class="o">);;</span>

<span class="c">(* for local handles, just create a new channel inside your block *)</span>
<span class="k">let</span> <span class="n">get_motd</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">motd</span> <span class="o">=</span> <span class="n">open_in</span> <span class="s2">&quot;/etc/motd&quot;</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">retval</span> <span class="o">=</span>
    <span class="o">...</span> <span class="k">in</span>
  <span class="n">close_in</span> <span class="n">motd</span><span class="o">;</span>
  <span class="n">retval</span><span class="o">;;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN578"
>Redefining a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span>
<span class="c">(* If you want to redefine a function... go ahead.  Functions are first class</span>
<span class="c"> * members in OCaml *)</span>

<span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;;</span>

<span class="n">f</span> <span class="mi">5</span> <span class="mi">7</span><span class="o">;;</span>
<span class="c">(*  - : int = 12 *)</span>

<span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">;;</span>

<span class="n">f</span> <span class="mi">5</span> <span class="mi">7</span><span class="o">;;</span>

<span class="c">(*  - : int = -2 *)</span>

<span class="c">(* to do it temporarily, either save to old value and then restore it, or just</span>
<span class="c"> * redefine it in the current block.  The old value will be restored when you</span>
<span class="c"> * exit the scope of that block *)</span>

<span class="k">let</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span>
<span class="ow">and</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">;;</span>

<span class="n">f</span> <span class="mi">5</span> <span class="mi">7</span><span class="o">;;</span>

<span class="c">(*  - : int = 35 *)</span>

<span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">g</span><span class="o">;;</span>

<span class="n">f</span> <span class="mi">5</span> <span class="mi">7</span><span class="o">;;</span>

<span class="c">(*  - : int = -2 *)</span>

<span class="k">let</span> <span class="n">g</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">/</span> <span class="n">y</span> <span class="k">in</span>
  <span class="n">f</span> <span class="mi">5</span> <span class="mi">7</span><span class="o">;;</span>

<span class="n">g</span> <span class="bp">()</span><span class="o">;;</span>

<span class="c">(*  - : int = 0 *)</span>

<span class="n">f</span> <span class="mi">5</span> <span class="mi">7</span><span class="o">;;</span>

<span class="c">(*  - : int = -2 *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN581"
>Trapping Undefined Function Calls with AUTOLOAD</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Since OCaml is statically typed, any attempt to call an undefined</span>
<span class="c">   function will result in a compiler error. There is no way to capture</span>
<span class="c">   and handle this event at runtime. *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN584"
>Nesting Subroutines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span>
<span class="c">(* Just define the inner function within the outer one *)</span>
<span class="k">let</span> <span class="n">outer</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">35</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">inner</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">*</span> <span class="mi">19</span> <span class="k">in</span>
  <span class="n">x</span> <span class="o">+</span> <span class="n">inner</span> <span class="bp">()</span><span class="o">;;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN587"
>Program: Sorting Your Mail</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span>
<span class="k">let</span> <span class="n">slurp_to_string</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">ic</span> <span class="o">=</span> <span class="n">open_in</span> <span class="n">filename</span> <span class="ow">and</span>
  <span class="n">buf</span> <span class="o">=</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">create</span> <span class="mi">4096</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">line</span> <span class="o">=</span> <span class="n">input_line</span> <span class="n">ic</span> <span class="k">in</span>
    <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_string</span> <span class="n">buf</span> <span class="n">line</span><span class="o">;</span>
    <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_string</span> <span class="n">buf</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;</span>
    <span class="n">loop</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">try</span> <span class="n">loop</span> <span class="bp">()</span> <span class="k">with</span> <span class="nc">End_of_file</span> <span class="o">-&gt;</span> <span class="n">close_in</span> <span class="n">ic</span><span class="o">;</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">contents</span> <span class="n">buf</span><span class="o">;;</span>

<span class="c">(* Note: The following function does something slightly different than the Perl</span>
<span class="c"> * version, as it returns a subject,message #,refrence to the message tuple</span>
<span class="c"> * sorted by subject -&gt; message number instead of just a list of messages sorted</span>
<span class="c"> * by subject -&gt; message number -- it&#39;s trivial to get just what the Perl</span>
<span class="c"> * version does from this... *)</span>

<span class="k">let</span> <span class="n">sortedMail</span> <span class="n">fn</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">msglist</span> <span class="o">=</span>
    <span class="c">(* I had to add this filtering step due to some wierd structure in my mbox</span>
<span class="c">     * file. go figure... *)</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">sub</span> <span class="n">s</span> <span class="mi">0</span> <span class="mi">5</span> <span class="o">=</span> <span class="s2">&quot;From:&quot;</span><span class="o">)</span>
      <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="s2">&quot;From&quot;</span> <span class="o">^</span> <span class="n">x</span><span class="o">)</span>
        <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">split</span> <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">regexp</span> <span class="s2">&quot;^From&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">slurp_to_string</span> <span class="n">fn</span><span class="o">)))</span>
  <span class="ow">and</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(-</span><span class="mi">1</span><span class="o">)</span> <span class="k">in</span>
<span class="c">(*  let subjList = *)</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span>
      <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span>
        <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span>
          <span class="n">ignore</span> <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">search_forward</span>
            <span class="c">(* Not positive this regex is equivalent to the Perl version, but it</span>
<span class="c">             * seems to work -- you can use the third party PCRE module if you</span>
<span class="c">             * want to be positive *)</span>
            <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">regexp</span> <span class="s2">&quot;^Subject:[ </span><span class="se">\t</span><span class="s2">]*</span><span class="err">\</span><span class="s2">(:?[Rr][Ee]:[ </span><span class="se">\t</span><span class="s2">]*</span><span class="err">\</span><span class="s2">)*</span><span class="err">\</span><span class="s2">(.*</span><span class="err">\</span><span class="s2">)&quot;</span><span class="o">)</span> <span class="n">s</span> <span class="mi">0</span><span class="o">);</span>
          <span class="n">incr</span> <span class="n">counter</span><span class="o">;</span>
          <span class="o">(</span><span class="k">try</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">lowercase</span> <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">matched_group</span> <span class="mi">2</span> <span class="n">s</span><span class="o">))</span> <span class="k">with</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span><span class="o">),</span>
           <span class="o">!</span><span class="n">counter</span><span class="o">,</span>
           <span class="n">ref</span> <span class="n">s</span><span class="o">)</span>
        <span class="n">msglist</span><span class="o">);;</span>

<span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(_,_,</span><span class="n">rm</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">print_endline</span> <span class="o">!</span><span class="n">rm</span><span class="o">)</span> <span class="o">(</span><span class="n">sortedMail</span> <span class="s2">&quot;mbox&quot;</span><span class="o">);;</span>

<span class="c">(* To sort by using a hashtable *)</span>

<span class="k">let</span> <span class="n">keys</span> <span class="n">h</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">fold</span> <span class="o">(</span><span class="k">fun</span> <span class="n">k</span> <span class="n">v</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">::</span><span class="n">b</span><span class="o">)</span> <span class="n">h</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="c">(* filter out duplicates *)</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">b</span> <span class="k">then</span> <span class="n">b</span> <span class="k">else</span> <span class="n">x</span><span class="o">::</span><span class="n">b</span><span class="o">)</span> <span class="bp">[]</span> <span class="n">k</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">sortedMailByHash</span> <span class="n">fn</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">msglist</span> <span class="o">=</span>
    <span class="c">(* I had to add this filtering step due to some wierd structure in my mbox</span>
<span class="c">     * file. go figure... *)</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">sub</span> <span class="n">s</span> <span class="mi">0</span> <span class="mi">5</span> <span class="o">=</span> <span class="s2">&quot;From:&quot;</span><span class="o">)</span>
      <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="s2">&quot;From&quot;</span> <span class="o">^</span> <span class="n">x</span><span class="o">)</span>
        <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">split</span> <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">regexp</span> <span class="s2">&quot;^From&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">slurp_to_string</span> <span class="n">fn</span><span class="o">)))</span>
  <span class="ow">and</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(-</span><span class="mi">1</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">msglist</span><span class="o">)</span> <span class="k">in</span>
<span class="c">(*  let subjList = *)</span>
<span class="c">(*    List.sort compare *)</span>
      <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">iter</span>
        <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span>
          <span class="n">ignore</span> <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">search_forward</span>
            <span class="c">(* Not positive this regex is equivalent to the Perl version, but it</span>
<span class="c">             * seems to work -- you can use the third party PCRE module if you</span>
<span class="c">             * want to be positive *)</span>
            <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">regexp</span> <span class="s2">&quot;^Subject:[ </span><span class="se">\t</span><span class="s2">]*</span><span class="err">\</span><span class="s2">(:?[Rr][Ee]:[ </span><span class="se">\t</span><span class="s2">]*</span><span class="err">\</span><span class="s2">)*</span><span class="err">\</span><span class="s2">(.*</span><span class="err">\</span><span class="s2">)&quot;</span><span class="o">)</span> <span class="n">s</span> <span class="mi">0</span><span class="o">);</span>
          <span class="n">incr</span> <span class="n">counter</span><span class="o">;</span>
          <span class="k">let</span> <span class="n">sub</span> <span class="o">=</span>
            <span class="k">try</span>
              <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">lowercase</span> <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">matched_group</span> <span class="mi">2</span> <span class="n">s</span><span class="o">))</span>
          <span class="k">with</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span> <span class="k">in</span>
          <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">h</span> <span class="n">sub</span> <span class="n">s</span><span class="o">))</span>
        <span class="n">msglist</span><span class="o">;</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">flatten</span>
        <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find_all</span> <span class="n">h</span> <span class="n">x</span><span class="o">))</span>
          <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="o">(</span><span class="n">keys</span> <span class="n">h</span><span class="o">)));;</span>

<span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="n">print_endline</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">sortedMailByHash</span> <span class="s2">&quot;mbox&quot;</span><span class="o">);;</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Directories</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>References and Records</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>