<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Packages, Libraries, and Modules</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Objective CAML "
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="References and Records"
HREF="referencesandrecords.html"><LINK
REL="NEXT"
TITLE="Classes, Objects, and Ties"
HREF="classesetc.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Objective CAML </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="referencesandrecords.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="classesetc.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PACKAGESETC"
>12. Packages, Libraries, and Modules</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN642"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* When an OCaml source file is compiled, it becomes a module. The name</span>
<span class="c">   of the module is the capitalized form of the filename. For example,</span>
<span class="c">   if the source file is &quot;my_module.ml&quot;, the module name is &quot;My_module&quot;.</span>

<span class="c">   Modules can also be created explicitly within a source file. If</span>
<span class="c">   &quot;my_module.ml&quot; contains &quot;module Foo = struct ... end&quot;, a module named</span>
<span class="c">   &quot;My_module.Foo&quot; will be created.</span>

<span class="c">   Here is an example of the definition and use of two modules within a</span>
<span class="c">   single source file: *)</span>

<span class="k">module</span> <span class="nc">Alpha</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Omega</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;last&quot;</span>
<span class="k">end</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Alpha is %s, Omega is %s.</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="nn">Alpha</span><span class="p">.</span><span class="n">name</span> <span class="nn">Omega</span><span class="p">.</span><span class="n">name</span>

<span class="c">(* Alpha is first, Omega is last. *)</span>

<span class="c">(*-----------------------------*)</span>

<span class="c">(* The &quot;#use&quot; and &quot;#load&quot; commands are known as toplevel directives.</span>
<span class="c">   They can only be used while interacting with the interpreter or from</span>
<span class="c">   scripts that are run using the &quot;ocaml&quot; program. *)</span>

<span class="c">(* &quot;#use&quot; loads a source file into the current scope. *)</span>
<span class="o">#</span><span class="n">use</span> <span class="s2">&quot;FileHandle.ml&quot;</span><span class="o">;;</span>

<span class="c">(* &quot;#load&quot; loads a module from a compiled bytecode file. This has the</span>
<span class="c">   same effect as including this file during bytecode compilation. *)</span>
<span class="o">#</span><span class="n">load</span> <span class="s2">&quot;FileHandle.cmo&quot;</span><span class="o">;;</span>

<span class="c">(* &quot;#load&quot; can be used with libraries as well as modules. Bytecode</span>
<span class="c">   libraries use an extension of &quot;.cma&quot;. *)</span>
<span class="o">#</span><span class="n">load</span> <span class="s2">&quot;library.cma&quot;</span><span class="o">;;</span>

<span class="c">(* The &quot;open&quot; statement can be used in any source file. It allows any</span>
<span class="c">   values defined within a module to be used without being prefixed by</span>
<span class="c">   the module name. *)</span>
<span class="k">open</span> <span class="nc">FileHandle</span>

<span class="c">(* Modules form a hierarchy; submodules can be opened in a similar</span>
<span class="c">   fashion by prefixing them with the parent module&#39;s name. *)</span>
<span class="k">open</span> <span class="nn">Cards</span><span class="p">.</span><span class="nc">Poker</span>

<span class="c">(* It is often convenient to use Gerd Stolpmann&#39;s &quot;findlib&quot; system,</span>
<span class="c">   which makes it considerably easier to load libraries into the</span>
<span class="c">   interpreter. *)</span>

<span class="o">#</span> <span class="o">#</span><span class="n">use</span> <span class="s2">&quot;topfind&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="nc">Findlib</span> <span class="n">has</span> <span class="n">been</span> <span class="n">successfully</span> <span class="n">loaded</span><span class="o">.</span> <span class="nc">Additional</span> <span class="n">directives</span><span class="o">:</span>
  <span class="o">#</span><span class="n">require</span> <span class="s2">&quot;package&quot;</span><span class="o">;;</span>      <span class="k">to</span> <span class="n">load</span> <span class="n">a</span> <span class="n">package</span>
  <span class="o">#</span><span class="kt">list</span><span class="o">;;</span>                   <span class="k">to</span> <span class="kt">list</span> <span class="n">the</span> <span class="n">available</span> <span class="n">packages</span>
  <span class="o">#</span><span class="n">camlp4o</span><span class="o">;;</span>                <span class="k">to</span> <span class="n">load</span> <span class="n">camlp4</span> <span class="o">(</span><span class="n">standard</span> <span class="n">syntax</span><span class="o">)</span>
  <span class="o">#</span><span class="n">camlp4r</span><span class="o">;;</span>                <span class="k">to</span> <span class="n">load</span> <span class="n">camlp4</span> <span class="o">(</span><span class="n">revised</span> <span class="n">syntax</span><span class="o">)</span>
  <span class="o">#</span><span class="n">predicates</span> <span class="s2">&quot;p,q,...&quot;</span><span class="o">;;</span>   <span class="k">to</span> <span class="n">set</span> <span class="n">these</span> <span class="n">predicates</span>
  <span class="nn">Topfind</span><span class="p">.</span><span class="n">reset</span><span class="bp">()</span><span class="o">;;</span>         <span class="k">to</span> <span class="n">force</span> <span class="n">that</span> <span class="n">packages</span> <span class="n">will</span> <span class="n">be</span> <span class="n">reloaded</span>
  <span class="o">#</span><span class="n">thread</span><span class="o">;;</span>                 <span class="k">to</span> <span class="n">enable</span> <span class="n">threads</span>

<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">&quot;extlib&quot;</span><span class="o">;;</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">extlib</span><span class="o">:</span> <span class="n">added</span> <span class="k">to</span> <span class="n">search</span> <span class="n">path</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">extlib</span><span class="o">/</span><span class="n">extLib</span><span class="o">.</span><span class="n">cma</span><span class="o">:</span> <span class="n">loaded</span>

<span class="c">(* The above use of &quot;#require&quot; has the same effect as typing the</span>
<span class="c">   following: *)</span>

<span class="o">#</span><span class="n">directory</span> <span class="s2">&quot;+extlib&quot;</span><span class="o">;;</span>
<span class="o">#</span><span class="n">load</span> <span class="s2">&quot;extLib.cma&quot;</span><span class="o">;;</span>

<span class="c">(* More information on the &quot;findlib&quot; system is available here:</span>
<span class="c">   http://projects.camlcity.org/projects/findlib.html</span>

<span class="c">   The &quot;#directory&quot; directive above is built into OCaml and allows</span>
<span class="c">   you to add additional directories to the path that is searched</span>
<span class="c">   when loading modules. You can use a prefix of &#39;+&#39; to indicate that</span>
<span class="c">   the directory is under the standard library path, which is usually</span>
<span class="c">   something like &quot;/usr/lib/ocaml/3.10.2/&quot;.</span>

<span class="c">   Modules can be easily aliased using assignment. This will also</span>
<span class="c">   cause the interpreter to output the module&#39;s signature, which</span>
<span class="c">   can be used as a quick reference. *)</span>

<span class="o">#</span> <span class="k">module</span> <span class="nc">S</span> <span class="o">=</span> <span class="nn">ExtString</span><span class="p">.</span><span class="nc">String</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">S</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">val</span> <span class="n">init</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">char</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kt">string</span>
    <span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">int</span>
    <span class="k">val</span> <span class="n">split</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">string</span>
    <span class="k">val</span> <span class="n">nsplit</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span>
    <span class="k">val</span> <span class="n">join</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="nn">S</span><span class="p">.</span><span class="n">join</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>

<span class="c">(* Many useful libraries can be found at The Caml Hump:</span>
<span class="c">   http://caml.inria.fr/cgi-bin/hump.cgi *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN645"
>Defining a Module's Interface</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Interfaces, also known as module types or signatures, are usually</span>
<span class="c">   saved in files with the same name as the corresponding module but</span>
<span class="c">   with a &quot;.mli&quot; extension. For instance, if the module is defined in</span>
<span class="c">   &quot;YourModule.ml&quot;, the interface will be in &quot;YourModule.mli&quot;. *)</span>

<span class="c">(* YourModule.mli *)</span>
<span class="k">val</span> <span class="n">version</span> <span class="o">:</span> <span class="kt">string</span>

<span class="c">(* YourModule.ml *)</span>
<span class="k">let</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.00&quot;</span>

<span class="c">(* As with modules, interfaces can also be defined explicitly inside</span>
<span class="c">   of a source file. *)</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">YourModuleSignature</span> <span class="o">=</span>
<span class="k">sig</span>
  <span class="k">val</span> <span class="n">version</span> <span class="o">:</span> <span class="kt">string</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">YourModule</span> <span class="o">:</span> <span class="nc">YourModuleSignature</span> <span class="o">=</span>
<span class="k">struct</span>
  <span class="k">let</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.00&quot;</span>
<span class="k">end</span>

<span class="c">(* Signatures can also be anonymous. *)</span>

<span class="k">module</span> <span class="nc">YourModule</span> <span class="o">:</span>
<span class="k">sig</span>
  <span class="k">val</span> <span class="n">version</span> <span class="o">:</span> <span class="kt">string</span>
<span class="k">end</span> <span class="o">=</span>
<span class="k">struct</span>
  <span class="k">let</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.00&quot;</span>
<span class="k">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN648"
>Trapping Errors in require or use</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Due to static typing, missing modules are detected at compilation</span>
<span class="c">   time, so this is not normally an error you can catch (or need to).</span>
<span class="c">   When using ocaml interactively or as an interpreter, the &quot;#load&quot;</span>
<span class="c">   directive can fail, resulting in a message like the following:</span>

<span class="c">       Cannot find file &lt;filename&gt;.</span>

<span class="c">   being printed to standard output. This is also not an error you can</span>
<span class="c">   catch, and its occurrence will not stop the script from executing.</span>
<span class="c">   It is possible to dynamically load modules and detect the failure of</span>
<span class="c">   this operation with Dynlink. An example is given in the next recipe. *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN651"
>Delaying use Until Run Time</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Registry.ml *)</span>
<span class="k">let</span> <span class="o">(</span><span class="n">registry</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span><span class="o">,</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">32</span>

<span class="c">(* SomeModule.ml *)</span>
<span class="k">let</span> <span class="n">say_hello</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">print_endline</span> <span class="s2">&quot;Hello, world!&quot;</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">replace</span> <span class="nn">Registry</span><span class="p">.</span><span class="n">registry</span> <span class="s2">&quot;say_hello&quot;</span> <span class="n">say_hello</span>

<span class="c">(* Main program *)</span>
<span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;SomeModule.cmo&quot;</span>
<span class="k">let</span> <span class="n">funcname</span> <span class="o">=</span> <span class="s2">&quot;say_hello&quot;</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Dynlink</span><span class="p">.</span><span class="n">init</span> <span class="bp">()</span><span class="o">;</span>
  <span class="o">(</span><span class="k">try</span> <span class="nn">Dynlink</span><span class="p">.</span><span class="n">loadfile</span> <span class="n">filename</span>
   <span class="k">with</span> <span class="nn">Dynlink</span><span class="p">.</span><span class="nc">Error</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="o">(</span><span class="nn">Dynlink</span><span class="p">.</span><span class="n">error_message</span> <span class="n">e</span><span class="o">));</span>
  <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="nn">Registry</span><span class="p">.</span><span class="n">registry</span> <span class="n">funcname</span><span class="o">)</span> <span class="bp">()</span>

<span class="c">(* Note that the Dynlink module currently supports dynamic loading of</span>
<span class="c">   bytecode modules only. There is a project to add support for dynamic</span>
<span class="c">   loading of native code which has been merged with OCaml&#39;s CVS HEAD.</span>
<span class="c">   Details are available at http://alain.frisch.fr/natdynlink.html *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN654"
>Making Variables Private to a Module</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="o">#</span><span class="n">load</span> <span class="s2">&quot;str.cma&quot;</span><span class="o">;;</span>
<span class="k">module</span> <span class="nc">Flipper</span> <span class="o">:</span>
<span class="k">sig</span>
  <span class="k">val</span> <span class="n">flip_boundary</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span>
  <span class="k">val</span> <span class="n">flip_words</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">string</span>
<span class="k">end</span> <span class="o">=</span>
<span class="k">struct</span>
  <span class="k">let</span> <span class="n">separatrix</span> <span class="o">=</span> <span class="n">ref</span> <span class="s2">&quot; &quot;</span>  <span class="c">(* hidden by signature *)</span>
  <span class="k">let</span> <span class="n">flip_boundary</span> <span class="n">sep</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">prev_sep</span> <span class="o">=</span> <span class="o">!</span><span class="n">separatrix</span> <span class="k">in</span>
    <span class="n">separatrix</span> <span class="o">:=</span> <span class="n">sep</span><span class="o">;</span>
    <span class="n">prev_sep</span>
  <span class="k">let</span> <span class="n">flip_words</span> <span class="n">line</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">words</span> <span class="o">=</span> <span class="nn">Str</span><span class="p">.</span><span class="n">split</span> <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">regexp_string</span> <span class="o">!</span><span class="n">separatrix</span><span class="o">)</span> <span class="n">line</span> <span class="k">in</span>
    <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="o">!</span><span class="n">separatrix</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">words</span><span class="o">)</span>
<span class="k">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN657"
>Determining the Caller's Package</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* This is very difficult to do in OCaml due to the lack of reflection</span>
<span class="c">   capabilities. Determining the current module name is reasonably easy,</span>
<span class="c">   however, by using the __FILE__ constant exposed by camlp4&#39;s macro</span>
<span class="c">   extensions. *)</span>

<span class="c">(*pp camlp4of *)</span>
<span class="k">let</span> <span class="o">__</span><span class="n">MODULE__</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">capitalize</span> <span class="o">(</span><span class="nn">Filename</span><span class="p">.</span><span class="n">chop_extension</span> <span class="o">__</span><span class="n">FILE__</span><span class="o">)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;I am in module %s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">__</span><span class="n">MODULE__</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN660"
>Automating Module Clean-Up</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Use the built-in function, &quot;at_exit&quot;, to schedule clean-up handlers</span>
<span class="c">   to run when the main program exits. *)</span>

<span class="o">#</span><span class="n">load</span> <span class="s2">&quot;unix.cma&quot;</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">logfile</span> <span class="o">=</span> <span class="s2">&quot;/tmp/mylog&quot;</span>
<span class="k">let</span> <span class="n">lf</span> <span class="o">=</span> <span class="n">open_out</span> <span class="n">logfile</span>

<span class="k">let</span> <span class="n">logmsg</span> <span class="n">msg</span> <span class="o">=</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">fprintf</span> <span class="n">lf</span> <span class="s2">&quot;%s %d: %s</span><span class="se">\n</span><span class="s2">%!&quot;</span>
    <span class="nn">Sys</span><span class="p">.</span><span class="n">argv</span><span class="o">.(</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="nn">Unix</span><span class="p">.</span><span class="n">getpid</span> <span class="bp">()</span><span class="o">)</span> <span class="n">msg</span>

<span class="c">(* Setup code. *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">logmsg</span> <span class="s2">&quot;startup&quot;</span>

<span class="c">(* Clean-up code. *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">at_exit</span>
    <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
       <span class="n">logmsg</span> <span class="s2">&quot;shutdown&quot;</span><span class="o">;</span>
       <span class="n">close_out</span> <span class="n">lf</span><span class="o">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN663"
>Keeping Your Own Module Directory</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* To add a directory to the module include path, pass the &quot;-I&quot; option</span>
<span class="c">   to any of the compiler tools. For example, if you have a module in</span>
<span class="c">   ~/ocamllib called Utils with a filename of utils.cmo, you can build</span>
<span class="c">   against this module with the following: *)</span>

<span class="o">$</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="nc">I</span> <span class="o">~/</span><span class="n">ocamllib</span> <span class="n">utils</span><span class="o">.</span><span class="n">cmo</span> <span class="n">test</span><span class="o">.</span><span class="n">ml</span> <span class="o">-</span><span class="n">o</span> <span class="n">test</span>

<span class="c">(* Within the toplevel interpreter, and from ocaml scripts, you can use</span>
<span class="c">   the &quot;#directory&quot; directive to add directories to the include path: *)</span>

<span class="o">#</span><span class="n">directory</span> <span class="s2">&quot;/home/myuser/ocamllib&quot;</span><span class="o">;;</span>
<span class="o">#</span><span class="n">load</span> <span class="s2">&quot;utils.cmo&quot;</span><span class="o">;;</span>

<span class="c">(* In both cases, prefixing the include directory with a &#39;+&#39; indicates</span>
<span class="c">   that the directory should be found relative to the standard include</span>
<span class="c">   path. *)</span>

<span class="o">#</span><span class="n">directory</span> <span class="s2">&quot;+pcre&quot;</span><span class="o">;;</span>
<span class="o">#</span><span class="n">load</span> <span class="s2">&quot;pcre.cma&quot;</span><span class="o">;;</span>

<span class="c">(* If you have findlib installed, you can print out the include path by</span>
<span class="c">   typing &quot;ocamlfind printconf path&quot; at the command line. *)</span>

<span class="o">$</span> <span class="n">ocamlfind</span> <span class="n">printconf</span> <span class="n">path</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="nc">METAS</span>

<span class="c">(* Instead of keeping a directory of &quot;.cmo&quot; (or &quot;.cmx&quot;) files, you may</span>
<span class="c">   prefer to build a library (&quot;.cma&quot; for bytecode, &quot;.cmxa&quot; for native).</span>
<span class="c">   This will pack all of your modules into a single file that is easy to</span>
<span class="c">   use during compilation: *)</span>

<span class="o">$</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="n">a</span> <span class="n">slicer</span><span class="o">.</span><span class="n">cmo</span> <span class="n">dicer</span><span class="o">.</span><span class="n">cmo</span> <span class="o">-</span><span class="n">o</span> <span class="n">tools</span><span class="o">.</span><span class="n">cma</span>
<span class="o">$</span> <span class="n">ocamlc</span> <span class="n">tools</span><span class="o">.</span><span class="n">cma</span> <span class="n">myprog</span><span class="o">.</span><span class="n">ml</span> <span class="o">-</span><span class="n">o</span> <span class="n">myprog</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN666"
>Preparing a Module for Distribution</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* The easiest way to prepare a library for distribution is to build with</span>
<span class="c">   OCamlMakefile and include a META file for use with findlib.</span>

<span class="c">   OCamlMakefile is available here:</span>
<span class="c">   http://www.ocaml.info/home/ocaml_sources.html#OCamlMakefile</span>

<span class="c">   findlib is available here:</span>
<span class="c">   http://projects.camlcity.org/projects/findlib.html *)</span>

<span class="c">(* Put the following in a file called &quot;Makefile&quot; and edit to taste: *)</span>

<span class="nc">OCAMLMAKEFILE</span> <span class="o">=</span> <span class="nc">OCamlMakefile</span>

<span class="nc">RESULT</span> <span class="o">=</span> <span class="n">mylibrary</span>
<span class="nc">SOURCES</span> <span class="o">=</span> <span class="n">mylibrary</span><span class="o">.</span><span class="n">mli</span> <span class="n">mylibrary</span><span class="o">.</span><span class="n">ml</span>
<span class="nc">PACKS</span> <span class="o">=</span> <span class="n">pcre</span>

<span class="n">all</span><span class="o">:</span> <span class="n">native</span><span class="o">-</span><span class="n">code</span><span class="o">-</span><span class="n">library</span> <span class="n">byte</span><span class="o">-</span><span class="n">code</span><span class="o">-</span><span class="n">library</span>
<span class="n">install</span><span class="o">:</span> <span class="n">libinstall</span>
<span class="n">uninstall</span><span class="o">:</span> <span class="n">libuninstall</span>

<span class="k">include</span> <span class="o">$(</span><span class="nc">OCAMLMAKEFILE</span><span class="o">)</span>

<span class="c">(* Put the following in a file called &quot;META&quot; and edit to taste: *)</span>

<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;mylibrary&quot;</span>
<span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0.0&quot;</span>
<span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;My library&quot;</span>
<span class="n">requires</span> <span class="o">=</span> <span class="s2">&quot;pcre&quot;</span>
<span class="n">archive</span><span class="o">(</span><span class="n">byte</span><span class="o">)</span> <span class="o">=</span> <span class="s2">&quot;mylibrary.cma&quot;</span>
<span class="n">archive</span><span class="o">(</span><span class="n">native</span><span class="o">)</span> <span class="o">=</span> <span class="s2">&quot;mylibrary.cmxa&quot;</span>

<span class="c">(* Now you can build bytecode and native libraries with &quot;make&quot; and</span>
<span class="c">   install them into the standard library location with &quot;make install&quot;.</span>
<span class="c">   If you make a change, you will have to &quot;make uninstall&quot; before you</span>
<span class="c">   can &quot;make install&quot; again. Once a library is installed, it&#39;s simple</span>
<span class="c">   to use: *)</span>

<span class="o">$</span> <span class="n">ledit</span> <span class="n">ocaml</span>
        <span class="nc">Objective</span> <span class="nc">Caml</span> <span class="n">version</span> <span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span>

<span class="o">#</span> <span class="o">#</span><span class="n">use</span> <span class="s2">&quot;topfind&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="nc">Findlib</span> <span class="n">has</span> <span class="n">been</span> <span class="n">successfully</span> <span class="n">loaded</span><span class="o">.</span> <span class="nc">Additional</span> <span class="n">directives</span><span class="o">:</span>
  <span class="o">#</span><span class="n">require</span> <span class="s2">&quot;package&quot;</span><span class="o">;;</span>      <span class="k">to</span> <span class="n">load</span> <span class="n">a</span> <span class="n">package</span>
  <span class="o">#</span><span class="kt">list</span><span class="o">;;</span>                   <span class="k">to</span> <span class="kt">list</span> <span class="n">the</span> <span class="n">available</span> <span class="n">packages</span>
  <span class="o">#</span><span class="n">camlp4o</span><span class="o">;;</span>                <span class="k">to</span> <span class="n">load</span> <span class="n">camlp4</span> <span class="o">(</span><span class="n">standard</span> <span class="n">syntax</span><span class="o">)</span>
  <span class="o">#</span><span class="n">camlp4r</span><span class="o">;;</span>                <span class="k">to</span> <span class="n">load</span> <span class="n">camlp4</span> <span class="o">(</span><span class="n">revised</span> <span class="n">syntax</span><span class="o">)</span>
  <span class="o">#</span><span class="n">predicates</span> <span class="s2">&quot;p,q,...&quot;</span><span class="o">;;</span>   <span class="k">to</span> <span class="n">set</span> <span class="n">these</span> <span class="n">predicates</span>
  <span class="nn">Topfind</span><span class="p">.</span><span class="n">reset</span><span class="bp">()</span><span class="o">;;</span>         <span class="k">to</span> <span class="n">force</span> <span class="n">that</span> <span class="n">packages</span> <span class="n">will</span> <span class="n">be</span> <span class="n">reloaded</span>
  <span class="o">#</span><span class="n">thread</span><span class="o">;;</span>                 <span class="k">to</span> <span class="n">enable</span> <span class="n">threads</span>

<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">&quot;mylibrary&quot;</span><span class="o">;;</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">pcre</span><span class="o">:</span> <span class="n">added</span> <span class="k">to</span> <span class="n">search</span> <span class="n">path</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">pcre</span><span class="o">/</span><span class="n">pcre</span><span class="o">.</span><span class="n">cma</span><span class="o">:</span> <span class="n">loaded</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">mylibrary</span><span class="o">:</span> <span class="n">added</span> <span class="k">to</span> <span class="n">search</span> <span class="n">path</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">mylibrary</span><span class="o">/</span><span class="n">mylibrary</span><span class="o">.</span><span class="n">cma</span><span class="o">:</span> <span class="n">loaded</span>

<span class="c">(* To compile against your new library, use the &quot;ocamlfind&quot; tool as a</span>
<span class="c">   front-end to &quot;ocamlc&quot; and &quot;ocamlopt&quot;: *)</span>

<span class="o">$</span> <span class="n">ocamlfind</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="n">package</span> <span class="n">mylibrary</span> <span class="n">myprogram</span><span class="o">.</span><span class="n">ml</span> <span class="o">-</span><span class="n">o</span> <span class="n">myprogram</span>
<span class="o">$</span> <span class="n">ocamlfind</span> <span class="n">ocamlopt</span> <span class="o">-</span><span class="n">package</span> <span class="n">mylibrary</span> <span class="n">myprogram</span><span class="o">.</span><span class="n">ml</span> <span class="o">-</span><span class="n">o</span> <span class="n">myprogram</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN669"
>Speeding Module Loading with SelfLoader</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* OCaml supports native compilation. If module load time is an issue,</span>
<span class="c">   it&#39;s hard to find a better solution than &quot;ocamlopt&quot;. If compilation</span>
<span class="c">   is slow as well, try &quot;ocamlopt.opt&quot;, which is the natively-compiled</span>
<span class="c">   native compiler. *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN672"
>Speeding Up Module Loading with Autoloader</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* This recipe is not relevant or applicable to OCaml. *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN675"
>Overriding Built-In Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="o">#</span><span class="n">load</span> <span class="s2">&quot;unix.cma&quot;</span><span class="o">;;</span>

<span class="c">(* The Unix module returns the time as a float. Using a local module</span>
<span class="c">   definition and an &quot;include&quot;, we can override this function to return</span>
<span class="c">   an int32 instead. (This is a bit silly, but it illustrates the basic</span>
<span class="c">   technique. *)</span>
<span class="k">module</span> <span class="nc">Unix</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">include</span> <span class="nc">Unix</span>
  <span class="k">let</span> <span class="n">time</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">of_float</span> <span class="o">(</span><span class="n">time</span> <span class="bp">()</span><span class="o">)</span>
<span class="k">end</span>

<span class="c">(* Use the locally modified Unix.time function. *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Unix</span><span class="p">.</span><span class="n">time</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">while</span> <span class="bp">true</span> <span class="k">do</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%ld</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">Int32</span><span class="p">.</span><span class="n">sub</span> <span class="o">(</span><span class="nn">Unix</span><span class="p">.</span><span class="n">time</span> <span class="bp">()</span><span class="o">)</span> <span class="n">start</span><span class="o">)</span>
  <span class="k">done</span>

<span class="c">(* Operators can also be locally modified. Here, we&#39;ll temporarily</span>
<span class="c">   define &#39;-&#39; as int32 subtraction. *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="o">(</span> <span class="o">-</span> <span class="o">)</span> <span class="o">=</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">sub</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Unix</span><span class="p">.</span><span class="n">time</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">while</span> <span class="bp">true</span> <span class="k">do</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%ld</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">Unix</span><span class="p">.</span><span class="n">time</span> <span class="bp">()</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span>
  <span class="k">done</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN678"
>Reporting Errors and Warnings Like Built-Ins</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* There are two built-in functions that raise standard exceptions.</span>
<span class="c">   Many standard library functions use these. &quot;invalid_arg&quot; raises</span>
<span class="c">   an Invalid_argument exception, which takes a string parameter: *)</span>
<span class="k">let</span> <span class="n">even_only</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="ow">land</span> <span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="c">(* one way to test *)</span>
  <span class="k">then</span> <span class="n">invalid_arg</span> <span class="o">(</span><span class="n">string_of_int</span> <span class="n">n</span><span class="o">);</span>
  <span class="c">(* ... *)</span>
  <span class="bp">()</span>

<span class="c">(* &quot;failwith&quot; raises a Failure exception, which also takes a string</span>
<span class="c">   parameter (though it is typically used to identify the name of</span>
<span class="c">   the function as opposed to the argument). *)</span>
<span class="k">let</span> <span class="n">even_only</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="c">(* here&#39;s another *)</span>
  <span class="k">then</span> <span class="n">failwith</span> <span class="s2">&quot;even_only&quot;</span><span class="o">;</span>
  <span class="c">(* ... *)</span>
  <span class="bp">()</span>

<span class="c">(* In most cases, it is preferable to define your own exceptions. *)</span>
<span class="k">exception</span> <span class="nc">Not_even</span> <span class="k">of</span> <span class="kt">int</span>
<span class="k">let</span> <span class="n">even_only</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="ow">land</span> <span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Not_even</span> <span class="n">n</span><span class="o">);</span>
  <span class="c">(* ... *)</span>
  <span class="bp">()</span>

<span class="c">(* OCaml does not provide a facility for emitting warnings. You can</span>
<span class="c">   write to stderr, which may be an acceptable substitute. *)</span>
<span class="k">let</span> <span class="n">even_only</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">land</span> <span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="c">(* test whether odd number *)</span>
    <span class="k">then</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">eprintf</span> <span class="s2">&quot;%d is not even, continuing</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">n</span><span class="o">;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">else</span> <span class="n">n</span> <span class="k">in</span>
  <span class="c">(* ... *)</span>
  <span class="bp">()</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN681"
>Referring to Packages Indirectly</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Generally, it is best to use tables of functions, possibly with</span>
<span class="c">   Dynlink, to delay the choice of module and function until runtime.</span>
<span class="c">   It is however possible--though inelegant--to (ab)use the toplevel</span>
<span class="c">   for this purpose. *)</span>

<span class="k">open</span> <span class="nc">Printf</span>

<span class="c">(* Toplevel evaluator. Not type-safe. *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Toploop</span><span class="p">.</span><span class="n">initialize_toplevel_env</span> <span class="bp">()</span>
<span class="k">let</span> <span class="n">eval</span> <span class="n">text</span> <span class="o">=</span> <span class="k">let</span> <span class="n">lexbuf</span> <span class="o">=</span> <span class="o">(</span><span class="nn">Lexing</span><span class="p">.</span><span class="n">from_string</span> <span class="n">text</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">phrase</span> <span class="o">=</span> <span class="o">!</span><span class="nn">Toploop</span><span class="p">.</span><span class="n">parse_toplevel_phrase</span> <span class="n">lexbuf</span> <span class="k">in</span>
  <span class="n">ignore</span> <span class="o">(</span><span class="nn">Toploop</span><span class="p">.</span><span class="n">execute_phrase</span> <span class="bp">false</span> <span class="nn">Format</span><span class="p">.</span><span class="n">std_formatter</span> <span class="n">phrase</span><span class="o">)</span>
<span class="k">let</span> <span class="n">get</span> <span class="n">name</span> <span class="o">=</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">obj</span> <span class="o">(</span><span class="nn">Toploop</span><span class="p">.</span><span class="n">getvalue</span> <span class="n">name</span><span class="o">)</span>
<span class="k">let</span> <span class="n">set</span> <span class="n">name</span> <span class="k">value</span> <span class="o">=</span> <span class="nn">Toploop</span><span class="p">.</span><span class="n">setvalue</span> <span class="n">name</span> <span class="o">(</span><span class="nn">Obj</span><span class="p">.</span><span class="n">repr</span> <span class="k">value</span><span class="o">)</span>

<span class="c">(* Some module and value names, presumably not known until runtime. *)</span>
<span class="k">let</span> <span class="n">modname</span> <span class="o">=</span> <span class="s2">&quot;Sys&quot;</span>
<span class="k">let</span> <span class="n">varname</span> <span class="o">=</span> <span class="s2">&quot;ocaml_version&quot;</span>
<span class="k">let</span> <span class="n">aryname</span> <span class="o">=</span> <span class="s2">&quot;argv&quot;</span>
<span class="k">let</span> <span class="n">funcname</span> <span class="o">=</span> <span class="s2">&quot;getenv&quot;</span>

<span class="c">(* Use the toplevel to evaluate module lookups dynamically. *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">eval</span> <span class="o">(</span><span class="n">sprintf</span> <span class="s2">&quot;let (value : string) = %s.%s;;&quot;</span> <span class="n">modname</span> <span class="n">varname</span><span class="o">);</span>
  <span class="n">print_endline</span> <span class="o">(</span><span class="n">get</span> <span class="s2">&quot;value&quot;</span><span class="o">);</span>
  <span class="n">eval</span> <span class="o">(</span><span class="n">sprintf</span> <span class="s2">&quot;let (values : string array) = %s.%s;;&quot;</span> <span class="n">modname</span> <span class="n">aryname</span><span class="o">);</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="o">(</span><span class="n">get</span> <span class="s2">&quot;values&quot;</span><span class="o">);</span>
  <span class="n">eval</span> <span class="o">(</span><span class="n">sprintf</span> <span class="s2">&quot;let (func : string -&gt; string) = %s.%s;;&quot;</span> <span class="n">modname</span> <span class="n">funcname</span><span class="o">);</span>
  <span class="n">print_endline</span> <span class="o">((</span><span class="n">get</span> <span class="s2">&quot;func&quot;</span><span class="o">)</span> <span class="s2">&quot;HOME&quot;</span><span class="o">);</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN684"
>Using h2ph to Translate C #include Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* There are several tools for translating C header files to OCaml</span>
<span class="c">   bindings, many of which can be found at The Caml Hump:</span>

<span class="c">   http://caml.inria.fr/cgi-bin/hump.en.cgi?sort=0&amp;browse=42</span>

<span class="c">   Of the available tools, &quot;ocamlffi&quot; (also known as simply &quot;FFI&quot;) seems</span>
<span class="c">   to work best at accomplishing the task of parsing header files, but</span>
<span class="c">   it has not been maintained in many years and cannot handle the deep</span>
<span class="c">   use of preprocessor macros in today&#39;s Unix headers. As a result, it is</span>
<span class="c">   often necessary to create a header file by hand, and so long as this</span>
<span class="c">   is required, better results can be achieved with Xavier Leroy&#39;s</span>
<span class="c">   CamlIDL tool. CamlIDL can be found here:</span>

<span class="c">   http://caml.inria.fr/pub/old_caml_site/camlidl/</span>

<span class="c">   The following recipes will use CamlIDL. First, we&#39;ll wrap the Unix</span>
<span class="c">   &quot;gettimeofday&quot; system call by writing the following to a file named</span>
<span class="c">   &quot;time.idl&quot;: *)</span>

<span class="n">quote</span><span class="o">(</span><span class="nc">C</span><span class="o">,</span><span class="s2">&quot;#include &lt;sys/time.h&gt;&quot;</span><span class="o">);</span>

<span class="k">struct</span> <span class="n">timeval</span> <span class="o">{</span>
    <span class="o">[</span><span class="n">int32</span><span class="o">]</span> <span class="kt">int</span> <span class="n">tv_sec</span><span class="o">;</span>
    <span class="o">[</span><span class="n">int32</span><span class="o">]</span> <span class="kt">int</span> <span class="n">tv_usec</span><span class="o">;</span>
<span class="o">};</span>

<span class="k">struct</span> <span class="n">timezone</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">tz_minuteswest</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">tz_dsttime</span><span class="o">;</span>
<span class="o">};</span>

<span class="kt">int</span> <span class="n">gettimeofday</span><span class="o">([</span><span class="n">out</span><span class="o">]</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tv</span><span class="o">,</span> <span class="o">[</span><span class="k">in</span><span class="o">]</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tz</span><span class="o">);</span>

<span class="c">(* We can now build three files, &quot;time.ml&quot;, &quot;time.mli&quot;, and</span>
<span class="c">   &quot;time_stubs.c&quot;, corresponding to the OCaml implementation, OCaml</span>
<span class="c">   interface, and OCaml-to-C stubs, by running the following command: *)</span>

<span class="o">$</span> <span class="n">camlidl</span> <span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="k">include</span> <span class="n">time</span><span class="o">.</span><span class="n">idl</span>

<span class="c">(* CamlIDL automatically translates the two structs defined in the IDL</span>
<span class="c">   into OCaml record types and builds an external function reference</span>
<span class="c">   for &quot;gettimeofday&quot;, resulting in the following generated OCaml</span>
<span class="c">   implementation in &quot;time.ml&quot;: *)</span>

<span class="c">(* File generated from time.idl *)</span>

<span class="k">type</span> <span class="n">timeval</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">tv_sec</span><span class="o">:</span> <span class="n">int32</span><span class="o">;</span>
  <span class="n">tv_usec</span><span class="o">:</span> <span class="n">int32</span><span class="o">;</span>
<span class="o">}</span>
<span class="ow">and</span> <span class="n">timezone</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">tz_minuteswest</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
  <span class="n">tz_dsttime</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
<span class="o">}</span>

<span class="k">external</span> <span class="n">gettimeofday</span> <span class="o">:</span> <span class="n">timezone</span> <span class="n">option</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">timeval</span>
	<span class="o">=</span> <span class="s2">&quot;camlidl_time_gettimeofday&quot;</span>

<span class="c">(* Now, we can use &quot;ocamlc -c&quot; as a front-end to the C compiler to build</span>
<span class="c">   the stubs, producing time_stubs.o. *)</span>

<span class="o">$</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="n">c</span> <span class="n">time_stubs</span><span class="o">.</span><span class="n">c</span>

<span class="c">(* The OCaml source can be built and packed into a library along with</span>
<span class="c">   the compiled stubs using &quot;ocamlc -a&quot;: *)</span>

<span class="o">$</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">custom</span> <span class="o">-</span><span class="n">o</span> <span class="n">time</span><span class="o">.</span><span class="n">cma</span> <span class="n">time</span><span class="o">.</span><span class="n">mli</span> <span class="n">time</span><span class="o">.</span><span class="n">ml</span> <span class="n">time_stubs</span><span class="o">.</span><span class="n">o</span> <span class="err">\</span>
		<span class="o">-</span><span class="n">cclib</span> <span class="o">-</span><span class="n">lcamlidl</span>

<span class="c">(* Finally, we can write a simple test program to use our newly-exposed</span>
<span class="c">   &quot;gettimeofday&quot; function. *)</span>

<span class="c">(* test.ml *)</span>
<span class="k">let</span> <span class="n">time</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">res</span><span class="o">,</span> <span class="o">{</span><span class="nn">Time</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">=</span><span class="n">seconds</span><span class="o">;</span> <span class="n">tv_usec</span><span class="o">=</span><span class="n">microseconds</span><span class="o">}</span> <span class="o">=</span>
    <span class="nn">Time</span><span class="p">.</span><span class="n">gettimeofday</span> <span class="nc">None</span> <span class="k">in</span>
  <span class="nn">Int32</span><span class="p">.</span><span class="n">to_float</span> <span class="n">seconds</span> <span class="o">+.</span> <span class="o">(</span><span class="nn">Int32</span><span class="p">.</span><span class="n">to_float</span> <span class="n">microseconds</span> <span class="o">/.</span> <span class="mi">1_000_000</span><span class="o">.)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">time</span> <span class="bp">()</span><span class="o">)</span>

<span class="c">(* Compiling this test program is straightforward. *)</span>

<span class="o">$</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="n">o</span> <span class="n">test</span> <span class="n">time</span><span class="o">.</span><span class="n">cma</span> <span class="n">test</span><span class="o">.</span><span class="n">ml</span>

<span class="c">(* Running it produces the current time with millisecond precision. *)</span>

<span class="o">$</span> <span class="o">./</span><span class="n">test</span>
<span class="mi">1217173408</span><span class="o">.</span><span class="mi">931277</span>

<span class="c">(*---------------------------*)</span>

<span class="c">(* The next two recipes will wrap the Unix &quot;ioctl&quot; function, allowing</span>
<span class="c">   us to make a few low-level I/O system calls. To make things easier,</span>
<span class="c">   we&#39;ll use the following Makefile (make sure you use tabs, not spaces,</span>
<span class="c">   if you cut and paste this code): *)</span>

<span class="n">all</span><span class="o">:</span> <span class="n">jam</span> <span class="n">winsz</span>

<span class="n">jam</span><span class="o">:</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">cma</span> <span class="n">jam</span><span class="o">.</span><span class="n">ml</span>
	<span class="n">ocamlc</span> <span class="o">-</span><span class="n">o</span> <span class="n">jam</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">cma</span> <span class="n">jam</span><span class="o">.</span><span class="n">ml</span>

<span class="n">winsz</span><span class="o">:</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">cma</span> <span class="n">winsz</span><span class="o">.</span><span class="n">ml</span>
	<span class="n">ocamlc</span> <span class="o">-</span><span class="n">o</span> <span class="n">winsz</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">cma</span> <span class="n">winsz</span><span class="o">.</span><span class="n">ml</span>

<span class="n">ioctl</span><span class="o">.</span><span class="n">cma</span><span class="o">:</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">mli</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">ml</span> <span class="n">ioctl_stubs</span><span class="o">.</span><span class="n">o</span>
	<span class="n">ocamlc</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">custom</span> <span class="o">-</span><span class="n">o</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">cma</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">mli</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">ml</span> <span class="n">ioctl_stubs</span><span class="o">.</span><span class="n">o</span> <span class="err">\</span>
		<span class="o">-</span><span class="n">cclib</span> <span class="o">-</span><span class="n">lcamlidl</span>

<span class="n">ioctl_stubs</span><span class="o">.</span><span class="n">o</span><span class="o">:</span> <span class="n">ioctl_stubs</span><span class="o">.</span><span class="n">c</span>
	<span class="n">ocamlc</span> <span class="o">-</span><span class="n">c</span> <span class="n">ioctl_stubs</span><span class="o">.</span><span class="n">c</span>

<span class="n">ioctl</span><span class="o">.</span><span class="n">mli</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">ml</span> <span class="n">ioctl_stubs</span><span class="o">.</span><span class="n">c</span><span class="o">:</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">idl</span>
	<span class="n">camlidl</span> <span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="k">include</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">idl</span>

<span class="n">clean</span><span class="o">:</span>
	<span class="n">rm</span> <span class="o">-</span><span class="n">f</span> <span class="o">*.</span><span class="n">cma</span> <span class="o">*.</span><span class="n">cmi</span> <span class="o">*.</span><span class="n">cmo</span> <span class="o">*.</span><span class="n">c</span> <span class="o">*.</span><span class="n">o</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">ml</span> <span class="n">ioctl</span><span class="o">.</span><span class="n">mli</span> <span class="n">jam</span> <span class="n">winsz</span>

<span class="c">(*---------------------------*)</span>

<span class="c">(* ioctl.idl: *)</span>

<span class="n">quote</span><span class="o">(</span><span class="nc">C</span><span class="o">,</span><span class="s2">&quot;#include &lt;sys/ioctl.h&gt;&quot;</span><span class="o">);</span>

<span class="n">enum</span> <span class="n">ioctl</span> <span class="o">{</span>
    <span class="nc">TIOCSTI</span><span class="o">,</span>
    <span class="nc">TIOCGWINSZ</span><span class="o">,</span>
<span class="o">};</span>

<span class="kt">int</span> <span class="n">ioctl</span><span class="o">([</span><span class="k">in</span><span class="o">]</span> <span class="kt">int</span> <span class="n">fd</span><span class="o">,</span>
          <span class="o">[</span><span class="k">in</span><span class="o">]</span> <span class="n">enum</span> <span class="n">ioctl</span> <span class="n">request</span><span class="o">,</span>
          <span class="o">[</span><span class="k">in</span><span class="o">,</span> <span class="n">out</span><span class="o">,</span> <span class="kt">string</span><span class="o">]</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argp</span><span class="o">);</span>

<span class="c">(*---------------------------*)</span>

<span class="c">(* jam - stuff characters down STDIN&#39;s throat *)</span>

<span class="c">(* Simulate input on a given terminal. *)</span>
<span class="k">let</span> <span class="n">jam</span> <span class="o">?(</span><span class="n">tty</span><span class="o">=</span><span class="mi">0</span><span class="o">)</span> <span class="n">s</span> <span class="o">=</span>
  <span class="nn">String</span><span class="p">.</span><span class="n">iter</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">ignore</span> <span class="o">(</span><span class="nn">Ioctl</span><span class="p">.</span><span class="n">ioctl</span> <span class="n">tty</span> <span class="nn">Ioctl</span><span class="p">.</span><span class="nc">TIOCSTI</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="mi">1</span> <span class="n">c</span><span class="o">)))</span> <span class="n">s</span>

<span class="c">(* Stuff command-line arguments into STDIN. *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">jam</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="s2">&quot; &quot;</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">tl</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">to_list</span> <span class="o">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">argv</span><span class="o">))))</span>

<span class="c">(*---------------------------*)</span>

<span class="c">(* winsz - find x and y for chars and pixels *)</span>

<span class="c">(* Decode a little-endian short integer from a string and offset. *)</span>
<span class="k">let</span> <span class="n">decode_short</span> <span class="n">s</span> <span class="n">i</span> <span class="o">=</span>
  <span class="nn">Char</span><span class="p">.</span><span class="n">code</span> <span class="n">s</span><span class="o">.[</span><span class="n">i</span><span class="o">]</span> <span class="ow">lor</span> <span class="nn">Char</span><span class="p">.</span><span class="n">code</span> <span class="n">s</span><span class="o">.[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="ow">lsl</span> <span class="mi">8</span>

<span class="c">(* Read and display the window size. *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">winsize</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="mi">8</span> <span class="sc">&#39;\000&#39;</span> <span class="k">in</span>
  <span class="n">ignore</span> <span class="o">(</span><span class="nn">Ioctl</span><span class="p">.</span><span class="n">ioctl</span> <span class="mi">0</span> <span class="nn">Ioctl</span><span class="p">.</span><span class="nc">TIOCGWINSZ</span> <span class="n">winsize</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">row</span> <span class="o">=</span> <span class="n">decode_short</span> <span class="n">winsize</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">col</span> <span class="o">=</span> <span class="n">decode_short</span> <span class="n">winsize</span> <span class="mi">2</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">xpixel</span> <span class="o">=</span> <span class="n">decode_short</span> <span class="n">winsize</span> <span class="mi">4</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ypixel</span> <span class="o">=</span> <span class="n">decode_short</span> <span class="n">winsize</span> <span class="mi">6</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;(row,col) = (%d,%d)&quot;</span> <span class="n">row</span> <span class="n">col</span><span class="o">;</span>
  <span class="k">if</span> <span class="n">xpixel</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ypixel</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span>
  <span class="k">then</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;  (xpixel,ypixel) = (%d,%d)&quot;</span> <span class="n">xpixel</span> <span class="n">ypixel</span><span class="o">;</span>
  <span class="n">print_newline</span> <span class="bp">()</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN687"
>Using h2xs to Make a Module with C Code</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Building libraries with C code is much easier with the aid of</span>
<span class="c">   OCamlMakefile. The following Makefile is all it takes to build</span>
<span class="c">   the &quot;time&quot; library from the previous recipe: *)</span>

<span class="nc">OCAMLMAKEFILE</span> <span class="o">=</span> <span class="nc">OCamlMakefile</span>

<span class="nc">RESULT</span> <span class="o">=</span> <span class="n">time</span>
<span class="nc">SOURCES</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">idl</span>
<span class="nc">NOIDLHEADER</span> <span class="o">=</span> <span class="n">yes</span>

<span class="n">all</span><span class="o">:</span> <span class="n">byte</span><span class="o">-</span><span class="n">code</span><span class="o">-</span><span class="n">library</span> <span class="n">native</span><span class="o">-</span><span class="n">code</span><span class="o">-</span><span class="n">library</span>

<span class="k">include</span> <span class="o">$(</span><span class="nc">OCAMLMAKEFILE</span><span class="o">)</span>

<span class="c">(* Now, a simple &quot;make&quot; will perform the code generation with camlidl</span>
<span class="c">   and produce static and dynamic libraries for bytecode and native</span>
<span class="c">   compilation. Furthermore, &quot;make top&quot; will build a custom toplevel</span>
<span class="c">   interpreter called &quot;time.top&quot; with the Time module built in: *)</span>

<span class="o">$</span> <span class="o">./</span><span class="n">time</span><span class="o">.</span><span class="n">top</span>
        <span class="nc">Objective</span> <span class="nc">Caml</span> <span class="n">version</span> <span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span>

<span class="o">#</span> <span class="nn">Time</span><span class="p">.</span><span class="n">gettimeofday</span> <span class="nc">None</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="nn">Time</span><span class="p">.</span><span class="n">timeval</span> <span class="o">=</span>
<span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">{</span><span class="nn">Time</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">1217483550</span><span class="n">l</span><span class="o">;</span> <span class="nn">Time</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">645204</span><span class="n">l</span><span class="o">})</span>

<span class="c">(* With the addition of a &quot;META&quot; file combined with the &quot;libinstall&quot;</span>
<span class="c">   and &quot;libuninstall&quot; targets, this library can be installed to the</span>
<span class="c">   standard location for use in other projects. See recipe 12.8,</span>
<span class="c">   &quot;Preparing a Module for Distribution&quot;, for an example. *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN690"
>Documenting Your Module with Pod</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(** Documentation for OCaml programs can be generated with the ocamldoc</span>
<span class="c">    tool, included in the standard distribution. Special comments like</span>
<span class="c">    this one begin with two asterisks which triggers ocamldoc to</span>
<span class="c">    include them in the documentation. The first special comment in a</span>
<span class="c">    module becomes the main description for that module. *)</span>

<span class="c">(** Comments can be placed before variables... *)</span>
<span class="k">val</span> <span class="n">version</span> <span class="o">:</span> <span class="kt">string</span>

<span class="c">(** ...functions... *)</span>
<span class="k">val</span> <span class="n">cons</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span>

<span class="c">(** ...types... *)</span>
<span class="k">type</span> <span class="n">choice</span> <span class="o">=</span> <span class="nc">Yes</span> <span class="o">|</span> <span class="nc">No</span> <span class="o">|</span> <span class="nc">Maybe</span> <span class="k">of</span> <span class="kt">string</span>

<span class="c">(* ... and other constructs like classes, class types, modules, and</span>
<span class="c">   module types. Simple comments like this one are ignored. *)</span>

<span class="c">(** {2 Level-two headings look like this} *)</span>

<span class="c">(** Text in [square brackets] will be formatted using a monospace font,</span>
<span class="c">    ideal for identifiers and other bits of code. Text written in curly</span>
<span class="c">    braces with a bang in front {!Like.this} will be hyperlinked to the</span>
<span class="c">    corresponding definition. *)</span>

<span class="c">(* To generate HTML documentation, use a command like the following: *)</span>

<span class="o">$</span> <span class="n">ocamldoc</span> <span class="o">-</span><span class="n">html</span> <span class="o">-</span><span class="n">d</span> <span class="n">destdir</span> <span class="nn">Module1</span><span class="p">.</span><span class="n">mli</span> <span class="nn">Module1</span><span class="p">.</span><span class="n">ml</span> <span class="o">...</span>

<span class="c">(* To generate Latex documentation, use a command like the following: *)</span>

<span class="o">$</span> <span class="n">ocamldoc</span> <span class="o">-</span><span class="n">latex</span> <span class="o">-</span><span class="n">d</span> <span class="n">destdir</span> <span class="nn">Module1</span><span class="p">.</span><span class="n">mli</span> <span class="nn">Module1</span><span class="p">.</span><span class="n">ml</span> <span class="o">...</span>

<span class="c">(* If you use OCamlMakefile, you can type &quot;make doc&quot; to build HTML and</span>
<span class="c">   PDF documentation for your entire project. You may want to customize</span>
<span class="c">   the OCAMLDOC and DOC_FILES variables to suit your needs. *)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN693"
>Building and Installing a CPAN Module</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Installing a module from The Caml Hump differs from project to</span>
<span class="c">   project, since it is not as standardized as CPAN. However, in most</span>
<span class="c">   cases, &quot;make&quot; and &quot;make install&quot; do what you expect. Here&#39;s how to</span>
<span class="c">   install easy-format, which can be found on the Hump at the following</span>
<span class="c">   URL: http://caml.inria.fr/cgi-bin/hump.en.cgi?contrib=651 *)</span>

<span class="o">$</span> <span class="n">tar</span> <span class="n">xzf</span> <span class="n">easy</span><span class="o">-</span><span class="n">format</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
<span class="o">$</span> <span class="n">cd</span> <span class="n">easy</span><span class="o">-</span><span class="n">format</span>
<span class="o">$</span> <span class="n">make</span>
<span class="n">ocamlc</span> <span class="o">-</span><span class="n">c</span> <span class="n">easy_format</span><span class="o">.</span><span class="n">mli</span>
<span class="n">ocamlc</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">dtypes</span> <span class="n">easy_format</span><span class="o">.</span><span class="n">ml</span>
<span class="n">touch</span> <span class="n">bytecode</span>
<span class="n">ocamlc</span> <span class="o">-</span><span class="n">c</span> <span class="n">easy_format</span><span class="o">.</span><span class="n">mli</span>
<span class="n">ocamlopt</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">dtypes</span> <span class="n">easy_format</span><span class="o">.</span><span class="n">ml</span>
<span class="n">touch</span> <span class="n">nativecode</span>

<span class="o">$</span> <span class="n">sudo</span> <span class="n">make</span> <span class="n">install</span>
<span class="o">[</span><span class="n">sudo</span><span class="o">]</span> <span class="n">password</span> <span class="k">for</span> <span class="n">root</span><span class="o">:</span> <span class="o">........</span>
<span class="n">echo</span> <span class="s2">&quot;version = </span><span class="se">\&quot;</span><span class="s2">1.0.0</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">&gt;</span> <span class="nc">META</span><span class="o">;</span> <span class="n">cat</span> <span class="nn">META</span><span class="p">.</span><span class="n">tpl</span> <span class="o">&gt;&gt;</span> <span class="nc">META</span>
<span class="nc">INSTALL_FILES</span><span class="o">=</span><span class="s2">&quot;META easy_format.cmi easy_format.mli&quot;</span><span class="o">;</span> <span class="err">\</span>
                <span class="k">if</span> <span class="n">test</span> <span class="o">-</span><span class="n">f</span> <span class="n">bytecode</span><span class="o">;</span> <span class="k">then</span> <span class="err">\</span>
                  <span class="nc">INSTALL_FILES</span><span class="o">=</span><span class="s2">&quot;$INSTALL_FILES easy_format.cmo &quot;</span><span class="o">;</span> <span class="err">\</span>
                <span class="n">fi</span><span class="o">;</span> <span class="err">\</span>
                <span class="k">if</span> <span class="n">test</span> <span class="o">-</span><span class="n">f</span> <span class="n">nativecode</span><span class="o">;</span> <span class="k">then</span> <span class="err">\</span>
                  <span class="nc">INSTALL_FILES</span><span class="o">=</span><span class="s2">&quot;$INSTALL_FILES easy_format.cmx easy_format.o&quot;</span><span class="o">;</span> <span class="err">\</span>
                <span class="n">fi</span><span class="o">;</span> <span class="err">\</span>
                <span class="n">ocamlfind</span> <span class="n">install</span> <span class="n">easy</span><span class="o">-</span><span class="n">format</span> <span class="o">$</span><span class="nc">INSTALL_FILES</span>
<span class="nc">Installed</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">easy</span><span class="o">-</span><span class="n">format</span><span class="o">/</span><span class="n">easy_format</span><span class="o">.</span><span class="n">o</span>
<span class="nc">Installed</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">easy</span><span class="o">-</span><span class="n">format</span><span class="o">/</span><span class="n">easy_format</span><span class="o">.</span><span class="n">cmx</span>
<span class="nc">Installed</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">easy</span><span class="o">-</span><span class="n">format</span><span class="o">/</span><span class="n">easy_format</span><span class="o">.</span><span class="n">cmo</span>
<span class="nc">Installed</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">easy</span><span class="o">-</span><span class="n">format</span><span class="o">/</span><span class="n">easy_format</span><span class="o">.</span><span class="n">mli</span>
<span class="nc">Installed</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">easy</span><span class="o">-</span><span class="n">format</span><span class="o">/</span><span class="n">easy_format</span><span class="o">.</span><span class="n">cmi</span>
<span class="nc">Installed</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ocaml</span><span class="o">/</span><span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span><span class="o">/</span><span class="n">easy</span><span class="o">-</span><span class="n">format</span><span class="o">/</span><span class="nc">META</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN696"
>Example: Module Template</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Some.ml *)</span>
<span class="k">module</span> <span class="nc">Module</span> <span class="o">=</span>
<span class="k">struct</span>
  <span class="c">(* set the version for version checking *)</span>
  <span class="k">let</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;0.01&quot;</span>

  <span class="c">(* initialize module globals (accessible as Some.Module.var1 *)</span>
  <span class="k">let</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">ref</span> <span class="s2">&quot;&quot;</span>
  <span class="k">let</span> <span class="n">hashit</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">0</span>

  <span class="c">(* file-private lexicals go here *)</span>
  <span class="k">let</span> <span class="n">priv_var</span> <span class="o">=</span> <span class="n">ref</span> <span class="s2">&quot;&quot;</span>
  <span class="k">let</span> <span class="n">secret_hash</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">0</span>

  <span class="c">(* here&#39;s a file-private function *)</span>
  <span class="k">let</span> <span class="n">priv_func</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="c">(* stuff goes here. *)</span>
    <span class="bp">()</span>

  <span class="c">(* make all your functions, whether exported or not *)</span>
  <span class="k">let</span> <span class="n">func1</span> <span class="bp">()</span> <span class="o">=</span> <span class="c">(* ... *)</span> <span class="bp">()</span>
  <span class="k">let</span> <span class="n">func2</span> <span class="bp">()</span> <span class="o">=</span> <span class="c">(* ... *)</span> <span class="bp">()</span>
  <span class="k">let</span> <span class="n">func3</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="c">(* ... *)</span> <span class="bp">()</span>
  <span class="k">let</span> <span class="n">func4</span> <span class="n">h</span> <span class="o">=</span> <span class="c">(* ... *)</span> <span class="bp">()</span>

  <span class="c">(* module clean-up code here *)</span>
  <span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="n">at_exit</span>
      <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
         <span class="c">(* ... *)</span>
         <span class="bp">()</span><span class="o">)</span>
<span class="k">end</span>

<span class="c">(* Some.mli *)</span>
<span class="k">module</span> <span class="nc">Module</span> <span class="o">:</span>
<span class="k">sig</span>
  <span class="k">val</span> <span class="n">version</span> <span class="o">:</span> <span class="kt">string</span>
  <span class="k">val</span> <span class="n">var1</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">ref</span>
  <span class="k">val</span> <span class="n">hashit</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span><span class="o">,</span> <span class="kt">string</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span>
  <span class="c">(* priv_var, secret_hash, and priv_func are omitted,</span>
<span class="c">     making them private and inaccessible... *)</span>
  <span class="k">val</span> <span class="n">func1</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">func2</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">func3</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
  <span class="k">val</span> <span class="n">func4</span> <span class="o">:</span> <span class="o">(</span><span class="kt">string</span><span class="o">,</span> <span class="kt">string</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN699"
>Program: Finding Versions and Descriptions of Installed Modules</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c"></span><span class="c">(* Use &quot;findlib&quot;. You can use the &quot;ocamlfind&quot; program to get a list of</span>
<span class="c">   installed libraries from the command line: *)</span>

<span class="o">$</span> <span class="n">ocamlfind</span> <span class="kt">list</span>
<span class="n">benchmark</span>           <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="mi">0</span><span class="o">.</span><span class="mi">6</span><span class="o">)</span>
<span class="n">bigarray</span>            <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="o">[</span><span class="n">distributed</span> <span class="k">with</span> <span class="nc">Ocaml</span><span class="o">])</span>
<span class="n">cairo</span>               <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="o">)</span>
<span class="n">cairo</span><span class="o">.</span><span class="n">lablgtk2</span>      <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="o">)</span>
<span class="n">calendar</span>            <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">2</span><span class="o">)</span>
<span class="n">camlimages</span>          <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="mi">2</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span>
<span class="n">camlimages</span><span class="o">.</span><span class="n">graphics</span> <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="o">)</span>
<span class="n">camlimages</span><span class="o">.</span><span class="n">lablgtk2</span> <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="o">)</span>
<span class="n">camlp4</span>              <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="o">[</span><span class="n">distributed</span> <span class="k">with</span> <span class="nc">Ocaml</span><span class="o">])</span>
<span class="n">camlp4</span><span class="o">.</span><span class="n">exceptiontracer</span> <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="o">[</span><span class="n">distributed</span> <span class="k">with</span> <span class="nc">Ocaml</span><span class="o">])</span>
<span class="n">camlp4</span><span class="o">.</span><span class="n">extend</span>       <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="o">[</span><span class="n">distributed</span> <span class="k">with</span> <span class="nc">Ocaml</span><span class="o">])</span>
<span class="o">...</span>

<span class="c">(* You can also use the &quot;#list&quot; directive from the interpreter: *)</span>

<span class="o">$</span> <span class="n">ledit</span> <span class="n">ocaml</span>
        <span class="nc">Objective</span> <span class="nc">Caml</span> <span class="n">version</span> <span class="mi">3</span><span class="o">.</span><span class="mi">10</span><span class="o">.</span><span class="mi">2</span>

<span class="o">#</span> <span class="o">#</span><span class="n">use</span> <span class="s2">&quot;topfind&quot;</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="nc">Findlib</span> <span class="n">has</span> <span class="n">been</span> <span class="n">successfully</span> <span class="n">loaded</span><span class="o">.</span> <span class="nc">Additional</span> <span class="n">directives</span><span class="o">:</span>
  <span class="o">#</span><span class="n">require</span> <span class="s2">&quot;package&quot;</span><span class="o">;;</span>      <span class="k">to</span> <span class="n">load</span> <span class="n">a</span> <span class="n">package</span>
  <span class="o">#</span><span class="kt">list</span><span class="o">;;</span>                   <span class="k">to</span> <span class="kt">list</span> <span class="n">the</span> <span class="n">available</span> <span class="n">packages</span>
  <span class="o">#</span><span class="n">camlp4o</span><span class="o">;;</span>                <span class="k">to</span> <span class="n">load</span> <span class="n">camlp4</span> <span class="o">(</span><span class="n">standard</span> <span class="n">syntax</span><span class="o">)</span>
  <span class="o">#</span><span class="n">camlp4r</span><span class="o">;;</span>                <span class="k">to</span> <span class="n">load</span> <span class="n">camlp4</span> <span class="o">(</span><span class="n">revised</span> <span class="n">syntax</span><span class="o">)</span>
  <span class="o">#</span><span class="n">predicates</span> <span class="s2">&quot;p,q,...&quot;</span><span class="o">;;</span>   <span class="k">to</span> <span class="n">set</span> <span class="n">these</span> <span class="n">predicates</span>
  <span class="nn">Topfind</span><span class="p">.</span><span class="n">reset</span><span class="bp">()</span><span class="o">;;</span>         <span class="k">to</span> <span class="n">force</span> <span class="n">that</span> <span class="n">packages</span> <span class="n">will</span> <span class="n">be</span> <span class="n">reloaded</span>
  <span class="o">#</span><span class="n">thread</span><span class="o">;;</span>                 <span class="k">to</span> <span class="n">enable</span> <span class="n">threads</span>

<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">#</span><span class="kt">list</span><span class="o">;;</span>
<span class="n">benchmark</span>           <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="mi">0</span><span class="o">.</span><span class="mi">6</span><span class="o">)</span>
<span class="n">bigarray</span>            <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="o">[</span><span class="n">distributed</span> <span class="k">with</span> <span class="nc">Ocaml</span><span class="o">])</span>
<span class="n">cairo</span>               <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="o">)</span>
<span class="n">cairo</span><span class="o">.</span><span class="n">lablgtk2</span>      <span class="o">(</span><span class="n">version</span><span class="o">:</span> <span class="n">n</span><span class="o">/</span><span class="n">a</span><span class="o">)</span>
<span class="o">...</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="referencesandrecords.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="classesetc.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>References and Records</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Classes, Objects, and Ties</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>