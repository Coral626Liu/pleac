<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Directories</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Ruby"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="File Contents"
HREF="filecontents.html"><LINK
REL="NEXT"
TITLE="Subroutines"
HREF="subroutines.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Ruby</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="filecontents.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="subroutines.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="DIRECTORIES"
>9. Directories</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN495"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">entry = File.stat(&quot;/usr/bin/vi&quot;)</span>
<span class="cp">entry = File.stat(&quot;/usr/bin&quot;)</span>
<span class="cp">entry = File.stat(INFILE)</span>

<span class="cp">entry = File.stat(&quot;/usr/bin/vi&quot;)</span>
<span class="cp">ctime = entry.ctime</span>
<span class="cp">size  = entry.size</span>

<span class="cp">f = File.open(filename, &quot;r&quot;)</span>

<span class="cp">## There is no -T equivalent in Ruby, but we can still test emptiness</span>
<span class="cp">if test(?s, filename)</span>
<span class="cp">  puts &quot;#{filename} doesn&#39;t have text in it.&quot;</span>
<span class="cp">  exit</span>
<span class="cp">end</span>

<span class="cp">Dir.new(&quot;/usr/bin&quot;).each do |filename|</span>
<span class="cp">  puts &quot;Inside /usr/bin is something called #{filename}&quot;</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN498"
>Getting and Setting Timestamps</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">file = File.stat(&quot;filename&quot;)</span>
<span class="cp">readtime, writetime = file.atime, file.mtime</span>
<span class="cp">file.utime(readtime, writetime)  </span>

<span class="cp">SECONDS_PER_DAY = 60 * 60 * 24</span>
<span class="cp">file = File.stat(&quot;filename&quot;)</span>
<span class="cp">atime, mtime = file.atime, file.mtime</span>

<span class="cp">atime -= 7 * SECONDS_PER_DAY</span>
<span class="cp">mtime -= 7 * SECONDS_PER_DAY</span>

<span class="cp">File.utime(atime, mtime, file)</span>
<span class="cp">mtime = File.stat(file).mtime</span>
<span class="cp">File.utime(Time.new, mtime, file)</span>
<span class="cp">File.utime(Time.new, File.stat(&quot;testfile&quot;).mtime, file)</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp">## uvi - vi a file without changing it&#39;s access times</span>

<span class="cp">if ARGV.length != 1</span>
<span class="cp">  puts &quot;usage: uvi filename&quot;</span>
<span class="cp">  exit</span>
<span class="cp">end</span>
<span class="cp">file = ARGV[0]</span>
<span class="cp">atime, mtime = File.stat(file).atime, File.stat(file).mtime</span>
<span class="cp">system(ENV[&quot;EDITOR&quot;] || &quot;vi&quot;, file)</span>
<span class="cp">File.utime(atime, mtime, file)</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN501"
>Deleting a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">File.unlink(FILENAME)</span>

<span class="cp">err_flg = false</span>
<span class="cp">filenames.each do |file|</span>
<span class="cp">  begin</span>
<span class="cp">    File.unlink(file)</span>
<span class="cp">  rescue</span>
<span class="cp">    err_flg = $!</span>
<span class="cp">  end</span>
<span class="cp">end</span>
<span class="cp">err_flg and raise &quot;Couldn&#39;t unlink all of #{filenames.join(&quot; &quot;)}: #{err_flg}&quot;</span>

<span class="cp">File.unlink(file)</span>

<span class="cp">count = filenames.length</span>
<span class="cp">filenames.each do |file|</span>
<span class="cp">  begin</span>
<span class="cp">    File.unlink(file)</span>
<span class="cp">  rescue</span>
<span class="cp">    count -= 1</span>
<span class="cp">  end</span>
<span class="cp">end</span>
<span class="cp">if count != filenames.length</span>
<span class="cp">  STDERR.puts &quot;could only delete #{count} of #{filenames.length} files&quot;</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN504"
>Copying or Moving a File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">require &quot;ftools&quot;</span>
<span class="cp">File.copy(oldfile, newfile)</span>

<span class="cp">infile  = File.open(oldfile, &quot;r&quot;)</span>
<span class="cp">outfile = File.open(newfile, &quot;w&quot;)</span>

<span class="cp">blksize = infile.stat.blksize</span>
<span class="cp"># This doesn&#39;t handle partial writes or ^Z</span>
<span class="cp"># like the Perl version does.</span>
<span class="cp">while (line = infile.read(blksize))</span>
<span class="cp">  outfile.write(line)</span>
<span class="cp">end</span>

<span class="cp">infile.close</span>
<span class="cp">outfile.close</span>

<span class="cp">system(&quot;cp #{oldfile} #{newfile}&quot;)    # unix</span>
<span class="cp">system(&quot;copy #{oldfile} #{newfile}&quot;)  # dos, vms</span>

<span class="cp">require &quot;ftools&quot;</span>
<span class="cp">File.copy(&quot;datafile.dat&quot;, &quot;datafile.bak&quot;)</span>
<span class="cp">File.move(&quot;datafile.new&quot;, &quot;datafile.dat&quot;)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN507"
>Recognizing Two Names for the Same File</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">$seen = {} # must use global var to be seen inside of method below</span>

<span class="cp">def do_my_thing(filename)</span>
<span class="cp">    dev, ino = File.stat(filename).dev, File.stat(filename).ino</span>
<span class="cp">    unless $seen[[dev, ino]]</span>
<span class="cp">        # do something with $filename because we haven&#39;t</span>
<span class="cp">        # seen it before</span>
<span class="cp">    end</span>
<span class="cp">    $seen[[dev, ino]] = $seen[[dev, ino]].to_i + 1</span>
<span class="cp">end</span>

<span class="cp">files.each do |filename|</span>
<span class="cp">    dev, ino = File.stat(filename).dev, File.stat(filename).ino</span>
<span class="cp">    if !$seen.has_key?([dev, ino])</span>
<span class="cp">        $seen[[dev, ino]] = []</span>
<span class="cp">    end</span>
<span class="cp">    $seen[[dev, ino]].push(filename)</span>
<span class="cp">end</span>

<span class="cp">$seen.keys.sort.each do |devino|</span>
<span class="cp">    ino, dev = devino</span>
<span class="cp">    if $seen[devino].length &gt; 1</span>
<span class="cp">        # $seen[devino] is a list of filenames for the same file</span>
<span class="cp">    end</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN510"
>Processing All Files in a Directory</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">Dir.open(dirname) do |dir|</span>
<span class="cp">    dir.each do |file|</span>
<span class="cp">        # do something with dirname/file</span>
<span class="cp">        puts file</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp"># Dir.close is automatic</span>

<span class="cp"># No -T equivalent in Ruby</span>

<span class="cp">dir.each do |file|</span>
<span class="cp">    next if file =~ /^\.\.?$/</span>
<span class="cp">    # ...</span>
<span class="cp">end</span>

<span class="cp">def plainfiles(dir)</span>
<span class="cp">    dh = Dir.open(dir)</span>
<span class="cp">    dh.entries.grep(/^[^.]/).</span>
<span class="cp">        map      {|file| &quot;#{dir}/#{file}&quot;}.</span>
<span class="cp">        find_all {|file| test(?f, file)}.</span>
<span class="cp">        sort</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN513"
>Globbing, or Getting a List of Filenames Matching a Pattern</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">list = Dir.glob(&quot;*.c&quot;)</span>

<span class="cp">dir = Dir.open(path)</span>
<span class="cp">files = dir.entries.grep(/\.c$/)</span>
<span class="cp">dir.close</span>

<span class="cp">files = Dir.glob(&quot;*.c&quot;)</span>
<span class="cp">files = Dir.open(path).entries.grep(/\.[ch]$/i)</span>

<span class="cp">dir = Dir.new(path)</span>
<span class="cp">files = dir.entries.grep(/\.[ch]$/i)</span>

<span class="cp">begin</span>
<span class="cp">  d = Dir.open(dir)</span>
<span class="cp">rescue Errno::ENOENT</span>
<span class="cp">  raise &quot;Couldn&#39;t open #{dir} for reading: #{$!}&quot;</span>
<span class="cp">end</span>

<span class="cp">files = []</span>
<span class="cp">d.each do |file|</span>
<span class="cp">  puts file</span>
<span class="cp">  next unless file =~ /\.[ch]$/i</span>

<span class="cp">  filename = &quot;#{dir}/#{file}&quot;</span>
<span class="cp">  # There is no -T equivalent in Ruby, but we can still test emptiness</span>
<span class="cp">  files.push(filename) if test(?s, filename)</span>
<span class="cp">end</span>

<span class="cp">dirs.entries.grep(/^\d+$/).</span>
<span class="cp">             map    { |file| [file, &quot;#{path}/#{file}&quot;]} .</span>
<span class="cp">             select { |file| test(?d, file[1]) }.</span>
<span class="cp">             sort   { |a,b|  a[0] &lt;=&gt; b[0] }.</span>
<span class="cp">             map    { |file| file[1] }</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN516"
>Processing All Files in a Directory Recursively</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">require &#39;find&#39;</span>
<span class="cp">Find.find(dirlist) do |file|</span>
<span class="cp">  # do whatever</span>
<span class="cp">end</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">Find.find(*argv) do |file|</span>
<span class="cp">  print file, (test(?d, file) ? &quot;/\n&quot; : &quot;\n&quot;)</span>
<span class="cp">end</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">sum = 0</span>
<span class="cp">Find.find(*argv) do |file|</span>
<span class="cp">  size = test(?s, file) || 0</span>
<span class="cp">  sum += size</span>
<span class="cp">end</span>
<span class="cp">puts &quot;#{argv.join(&#39; &#39;)} contains #{sum} bytes&quot;</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">saved_size, saved_name = -1, &quot;&quot;</span>
<span class="cp">Find.find(*argv) do |file|</span>
<span class="cp">  size = test(?s, file) || 0</span>
<span class="cp">  next unless test(?f, file) &amp;&amp; size &gt; saved_size</span>
<span class="cp">  saved_size = size</span>
<span class="cp">  saved_name = file</span>
<span class="cp">end</span>
<span class="cp">puts &quot;Biggest file #{saved_name} in #{argv.join(&#39; &#39;)} is #{saved_size}&quot;</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">age, name = nil</span>
<span class="cp">Find.find(*argv) do |file|</span>
<span class="cp">  mtime = File.stat(file).mtime</span>
<span class="cp">  next if age &amp;&amp; age &gt; mtime</span>
<span class="cp">  age = mtime</span>
<span class="cp">  name = file</span>
<span class="cp">end</span>
<span class="cp">puts &quot;#{name} #{age}&quot;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># fdirs - find all directories</span>
<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">File.find(*argv) { |file| puts file if test(?d, file) }</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN519"
>Removing a Directory and Its Contents</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">require &#39;fileutils&#39;</span>

<span class="cp">puts &quot;Usage #{$0} dir ...&quot; if ARGV.empty?</span>
<span class="cp">ARGV.each do |dir|</span>
<span class="cp">  FileUtils.rmtree(dir)</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN522"
>Renaming Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">require &#39;ftools&#39;</span>
<span class="cp">names.each do |file|</span>
<span class="cp">  newname = file</span>
<span class="cp">  begin</span>
<span class="cp">    File.move(file, newname)</span>
<span class="cp">  rescue Errno::EPERM</span>
<span class="cp">    $stderr.puts &quot;Couldn&#39;t rename #{file} to #{newname}: #{$!}&quot;</span>
<span class="cp">  end</span>
<span class="cp">end</span>

<span class="cp">require &#39;ftools&#39;</span>
<span class="cp">op = ARGV.empty? ? (raise &quot;Usage: rename expr [files]\n&quot;) : ARGV.shift</span>
<span class="cp">argv = ARGV.empty? ? $stdin.readlines.map { |f| f.chomp } : ARGV</span>
<span class="cp">argv.each do |file|</span>
<span class="cp">  was = file</span>
<span class="cp">  file = eval(&quot;file.#{op}&quot;)</span>
<span class="cp">  File.move(was, file) unless was == file</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN525"
>Splitting a Filename into Its Component Parts</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">base = File.basename(path)</span>
<span class="cp">dir  = File.dirname(path)</span>
<span class="cp"># ruby has no fileparse equivalent</span>
<span class="cp">dir, base = File.split(path)</span>
<span class="cp">ext = base.scan(/\..*$/).to_s</span>

<span class="cp">path = &#39;/usr/lib/libc.a&#39;</span>
<span class="cp">file = File.basename(path)</span>
<span class="cp">dir  = File.dirname(path)</span>

<span class="cp">puts &quot;dir is #{dir}, file is #{file}&quot;</span>
<span class="cp"># dir is /usr/lib, file is libc.a</span>

<span class="cp">path = &#39;/usr/lib/libc.a&#39;</span>
<span class="cp">dir, filename = File.split(path)</span>
<span class="cp">name, ext = filename.split(/(?=\.)/)</span>
<span class="cp">puts &quot;dir is #{dir}, name is #{name}, ext is #{ext}&quot;</span>
<span class="cp">#   NOTE: The Ruby code prints</span>
<span class="cp">#   dir is /usr/lib, name is libc, extension is .a</span>
<span class="cp">#     while the Perl code prints a &#39;/&#39; after the directory name</span>
<span class="cp">#   dir is /usr/lib/, name is libc, extension is .a</span>

<span class="cp"># No fileparse_set_fstype() equivalent in ruby</span>

<span class="cp">def extension(path)</span>
<span class="cp">    ext = path.scan(/\..*$/).to_s</span>
<span class="cp">    ext.sub(/^\./, &quot;&quot;)</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN528"
>Program: symirror</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># symirror - build spectral forest of symlinks</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">require &#39;fileutils&#39;</span>

<span class="cp">raise &quot;usage: #{$0} realdir mirrordir&quot; unless ARGV.size == 2</span>

<span class="cp">srcdir,dstdir = ARGV</span>
<span class="cp">srcmode = File::stat(srcdir).mode</span>
<span class="cp">Dir.mkdir(dstdir, srcmode &amp; 07777) unless test(?d, dstdir)</span>

<span class="cp"># fix relative paths</span>
<span class="cp">Dir.chdir(srcdir) {srcdir = Dir.pwd}</span>
<span class="cp">Dir.chdir(dstdir) {dstdir = Dir.pwd}</span>

<span class="cp">Find.find(srcdir) do |srcfile| </span>
<span class="cp">    if test(?d, srcfile)</span>
<span class="cp">        dest = srcfile.sub(/^#{srcdir}/, dstdir)</span>
<span class="cp">        dmode = File::stat(srcfile).mode &amp; 07777</span>
<span class="cp">        Dir.mkdir(dest, dmode) unless test(?d, dest)</span>
<span class="cp">        a = Dir[&quot;#{srcfile}/*&quot;].reject{|f| test(?d, f)}</span>
<span class="cp">        FileUtils.ln_s(a, dest)</span>
<span class="cp">    end</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN531"
>Program: lst</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># we use the Getopt/Declare library here for convenience:</span>
<span class="cp">#   http://raa.ruby-lang.org/project/getoptdeclare/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># lst - list sorted directory contents (depth first)</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">require &#39;etc&#39;</span>
<span class="cp">require &quot;Getopt/Declare&quot;</span>

<span class="cp"># Note: in the option-spec below there must by at least one hard</span>
<span class="cp"># tab in between each -option and its description. For example</span>
<span class="cp">#    -i &lt;tab&gt; read from stdin</span>

<span class="cp">opts = Getopt::Declare.new(&lt;&lt;&#39;EOPARAM&#39;)</span>
<span class="cp">    ============</span>
<span class="cp">    Input Format:</span>
<span class="cp">        -i	read from stdin</span>
<span class="cp">    ============</span>
<span class="cp">    Output Format:</span>
<span class="cp">        -l	long listing</span>
<span class="cp">        -r	reverse listing</span>
<span class="cp">    ============</span>
<span class="cp">    Sort on: (one of)</span>
<span class="cp">        -m	mtime (modify time - default)</span>
<span class="cp">                {$sort_criteria = :mtime}</span>
<span class="cp">        -u	atime (access time)</span>
<span class="cp">                {$sort_criteria = :atime}</span>
<span class="cp">        -c	ctime (inode change time)</span>
<span class="cp">                {$sort_criteria = :ctime}</span>
<span class="cp">        -s	size</span>
<span class="cp">                {$sort_criteria = :size}</span>
<span class="cp">        [mutex: -m -u -c -s]</span>

<span class="cp">EOPARAM</span>

<span class="cp">$sort_criteria ||= :mtime</span>
<span class="cp">files = {}</span>
<span class="cp">DIRS = opts[&#39;-i&#39;] ? $stdin.readlines.map{|f|f.chomp!} : ARGV</span>
<span class="cp">DIRS.each do |dir|</span>
<span class="cp">    Find.find(dir) do |ent|</span>
<span class="cp">        files[ent] = File::stat(ent)</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp">entries = files.keys.sort_by{|f| files[f].send($sort_criteria)}</span>
<span class="cp">entries = entries.reverse unless opts[&#39;-r&#39;]</span>

<span class="cp">entries.each do |ent|</span>
<span class="cp">    unless opts[&#39;-l&#39;]</span>
<span class="cp">        puts ent</span>
<span class="cp">        next</span>
<span class="cp">    end</span>
<span class="cp">    stats = files[ent]</span>
<span class="cp">    ftime = stats.send($sort_criteria == :size ? :mtime : $sort_criteria)</span>
<span class="cp">    printf &quot;%6d %04o %6d %8s %8s %8d %s %s\n&quot;,</span>
<span class="cp">        stats.ino,</span>
<span class="cp">        stats.mode &amp; 07777,</span>
<span class="cp">        stats.nlink,</span>
<span class="cp">        ETC::PASSWD[stats.uid].name,</span>
<span class="cp">        ETC::GROUP[stats.gid].name,</span>
<span class="cp">        stats.size,</span>
<span class="cp">        ftime.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;),</span>
<span class="cp">        ent</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="filecontents.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="subroutines.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>File Contents</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Subroutines</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>