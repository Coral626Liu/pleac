<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Hashes</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Ruby"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Arrays"
HREF="arrays.html"><LINK
REL="NEXT"
TITLE="Pattern Matching"
HREF="patternmatching.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Ruby</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="arrays.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="patternmatching.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="HASHES"
>5. Hashes</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN232"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">age = { &quot;Nat&quot;,   24,</span>
<span class="cp">        &quot;Jules&quot;, 25,</span>
<span class="cp">        &quot;Josh&quot;,  17  }</span>

<span class="cp">age[&quot;Nat&quot;]   = 24</span>
<span class="cp">age[&quot;Jules&quot;] = 25</span>
<span class="cp">age[&quot;Josh&quot;]  = 17</span>

<span class="cp">food_color = {</span>
<span class="cp">    &quot;Apple&quot;  =&gt; &quot;red&quot;,</span>
<span class="cp">    &quot;Banana&quot; =&gt; &quot;yellow&quot;,</span>
<span class="cp">    &quot;Lemon&quot;  =&gt; &quot;yellow&quot;,</span>
<span class="cp">    &quot;Carrot&quot; =&gt; &quot;orange&quot;</span>
<span class="cp">             }</span>

<span class="cp"># In Ruby, you cannot avoid the double or simple quoting</span>
<span class="cp"># while manipulatin hashes</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN235"
>Adding an Element to a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">hash[key] = value</span>

<span class="cp">food_color[&quot;Raspberry&quot;] = &quot;pink&quot;</span>
<span class="cp">puts &quot;Known foods:&quot;, food_color.keys</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN238"
>Testing for the Presence of a Key in a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># does hash have a value for key ?</span>
<span class="cp">if (hash.has_key?(key))</span>
<span class="cp">    # it exists</span>
<span class="cp">else</span>
<span class="cp">    # it doesn&#39;t</span>
<span class="cp">end</span>

<span class="cp">[ &quot;Banana&quot;, &quot;Martini&quot; ].each { |name|</span>
<span class="cp">    print name, &quot; is a &quot;, food_color.has_key?(name) ? &quot;food&quot; : &quot;drink&quot;, &quot;\n&quot;</span>
<span class="cp">}</span>

<span class="cp">age = {}</span>
<span class="cp">age[&#39;Toddler&#39;] = 3</span>
<span class="cp">age[&#39;Unborn&#39;] = 0</span>
<span class="cp">age[&#39;Phantasm&#39;] = nil</span>

<span class="cp">for thing in [&#39;Toddler&#39;, &#39;Unborn&#39;, &#39;Phantasm&#39;, &#39;Relic&#39;]</span>
<span class="cp">    print &quot;#{thing}: &quot;</span>
<span class="cp">    print &quot;Has-key &quot; if age.has_key?(thing)</span>
<span class="cp">    print &quot;True &quot; if age[thing]</span>
<span class="cp">    print &quot;Nonzero &quot; if age[thing] &amp;&amp; age[thing].nonzero?</span>
<span class="cp">    print &quot;\n&quot;</span>
<span class="cp">end</span>

<span class="cp">#=&gt;</span>
<span class="cp"># Toddler: Has-key True Nonzero </span>
<span class="cp"># Unborn: Has-key True </span>
<span class="cp"># Phantasm: Has-key </span>
<span class="cp"># Relic: </span>

<span class="cp"># You use Hash#has_key? when you use Perl&#39;s exists -&gt; it checks</span>
<span class="cp"># for existence of a key in a hash.</span>
<span class="cp"># All Numeric are &quot;True&quot; in ruby, so the test doesn&#39;t have the</span>
<span class="cp"># same semantics as in Perl; you would use Numeric#nonzero? to</span>
<span class="cp"># achieve the same semantics (false if 0, true otherwise).</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN241"
>Deleting from a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">food_color.delete(&quot;Banana&quot;)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN244"
>Traversing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">hash.each { |key, value|</span>
<span class="cp">    # do something with key and value</span>
<span class="cp">}</span>

<span class="cp">hash.each_key { |key|</span>
<span class="cp">    # do something with key</span>
<span class="cp">}</span>

<span class="cp">food_color.each { |food, color|</span>
<span class="cp">    puts &quot;#{food} is #{color}&quot;</span>
<span class="cp">}</span>

<span class="cp">food_color.each_key { |food|</span>
<span class="cp">    puts &quot;#{food} is #{food_color[food]}&quot;</span>
<span class="cp">}</span>

<span class="cp"># IMO this demonstrates that OO style is by far more readable</span>
<span class="cp">food_color.keys.sort.each { |food|</span>
<span class="cp">    puts &quot;#{food} is #{food_color[food]}.&quot;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># countfrom - count number of messages from each sender</span>

<span class="cp"># Default value is 0</span>
<span class="cp">from = Hash.new(0)</span>
<span class="cp">while gets</span>
<span class="cp">    /^From: (.*)/ and from[$1] += 1</span>
<span class="cp">end</span>

<span class="cp"># More useful to sort by number of received mail by person</span>
<span class="cp">from.sort {|a,b| b[1]&lt;=&gt;a[1]}.each { |v|</span>
<span class="cp">    puts &quot;#{v[1]}: #{v[0]}&quot;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN247"
>Printing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># You may use the built-in &#39;inspect&#39; method this way:</span>
<span class="cp">p hash</span>

<span class="cp"># Or do it the Cookbook way:</span>
<span class="cp">hash.each { |k,v| puts &quot;#{k} =&gt; #{v}&quot; }</span>

<span class="cp"># Sorted by keys</span>
<span class="cp">hash.sort.each { |e| puts &quot;#{e[0]} =&gt; #{e[1]}&quot; }</span>
<span class="cp"># Sorted by values</span>
<span class="cp">hash.sort{|a,b| a[1]&lt;=&gt;b[1]}.each { |e| puts &quot;#{e[0]} =&gt; #{e[1]}&quot; }</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN250"
>Retrieving from a Hash in Insertion Order</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># Use the OrderedHash module (part of the GoodLibs RubyGem):</span>
<span class="cp">require &#39;rubygems&#39;</span>
<span class="cp">require &#39;ordered_hash&#39;</span>
<span class="cp">hash = OrderedHash.new;</span>
<span class="cp"># manipulate hash</span>
<span class="cp">keys = hash.keys                # keys is in insertion order</span>

<span class="cp"># initialize</span>
<span class="cp">require &#39;rubygems&#39;</span>
<span class="cp">require &#39;ordered_hash&#39;</span>

<span class="cp">food_color = OrderedHash.new</span>
<span class="cp">food_color[&quot;Banana&quot;] = &quot;Yellow&quot;</span>
<span class="cp">food_color[&quot;Apple&quot;]  = &quot;Green&quot;</span>
<span class="cp">food_color[&quot;Lemon&quot;]  = &quot;Yellow&quot;</span>

<span class="cp">puts &quot;In insertion order, the foods are:&quot;</span>
<span class="cp">food_color.each_key { |food|</span>
<span class="cp">    puts &quot;  #{food}&quot;</span>
<span class="cp">}</span>

<span class="cp">puts &quot;Still in insertion order, the foods&#39; colors are:&quot;</span>
<span class="cp">food_color.each { |food, color|</span>
<span class="cp">    puts &quot;#{food} is colored #{color}.&quot;</span>
<span class="cp">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN253"
>Hashes with Multiple Values Per Key</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">ttys = Hash.new</span>
<span class="cp">for i in `who`</span>
<span class="cp">    user, tty = i.split</span>
<span class="cp">    (ttys[user] ||= []) &lt;&lt; tty               # see problems_ruby for more infos</span>
<span class="cp">end</span>
<span class="cp">ttys.keys.sort.each { |k|</span>
<span class="cp">    puts &quot;#{k}: #{commify_series(ttys[k])}&quot;  # from 4.2</span>
<span class="cp">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN256"
>Inverting a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">surname = { &quot;Mickey&quot; =&gt; &quot;Mantle&quot;, &quot;Babe&quot; =&gt; &quot;Ruth&quot; }</span>
<span class="cp">puts surname.index(&quot;Mantle&quot;)</span>

<span class="cp"># If you really needed to &#39;invert&#39; the whole hash, use Hash#invert</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># foodfind - find match for food or color</span>

<span class="cp">given = ARGV.shift or raise &quot;usage: foodfind food_or_color&quot;</span>

<span class="cp">color = {</span>
<span class="cp">    &quot;Apple&quot;  =&gt; &quot;red&quot;,</span>
<span class="cp">    &quot;Banana&quot; =&gt; &quot;yellow&quot;,</span>
<span class="cp">    &quot;Lemon&quot;  =&gt; &quot;yellow&quot;,</span>
<span class="cp">    &quot;Carrot&quot; =&gt; &quot;orange&quot;,</span>
<span class="cp">}</span>

<span class="cp">if (color.has_key?(given))</span>
<span class="cp">    puts &quot;#{given} is a food with color #{color[given]}.&quot;</span>
<span class="cp">end</span>
<span class="cp">if (color.has_value?(given))</span>
<span class="cp">    puts &quot;#{color.index(given)} is a food with color #{given}.&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN259"
>Sorting a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># Sorted by keys (Hash#sort gives an Array of pairs made of each key,value)</span>
<span class="cp">food_color.sort.each { |f|</span>
<span class="cp">    puts &quot;#{f[0]} is #{f[1]}.&quot;</span>
<span class="cp">}</span>

<span class="cp"># Sorted by values</span>
<span class="cp">food_color.sort { |a,b| a[1] &lt;=&gt; b[1] }.each { |f|</span>
<span class="cp">    puts &quot;#{f[0]} is #{f[1]}.&quot;</span>
<span class="cp">}</span>

<span class="cp"># Sorted by length of values</span>
<span class="cp">food_color.sort { |a,b| a[1].length &lt;=&gt; b[1].length }.each { |f|</span>
<span class="cp">    puts &quot;#{f[0]} is #{f[1]}.&quot;</span>
<span class="cp">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN262"
>Merging Hashes</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">merged = a.clone.update(b)        # because Hash#update changes object in place</span>

<span class="cp">drink_color = { &quot;Galliano&quot;  =&gt; &quot;yellow&quot;, &quot;Mai Tai&quot; =&gt; &quot;blue&quot; }</span>
<span class="cp">ingested_color = drink_color.clone.update(food_color)</span>

<span class="cp">substance_color = {}</span>
<span class="cp">for i in [ food_color, drink_color ]</span>
<span class="cp">    i.each_key { |k|</span>
<span class="cp">        if substance_color.has_key?(k)</span>
<span class="cp">            puts &quot;Warning: #{k} seen twice.  Using the first definition.&quot;</span>
<span class="cp">            next</span>
<span class="cp">        end</span>
<span class="cp">        substance_color[k] = 1</span>
<span class="cp">    }</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN265"
>Finding Common or Different Keys in Two Hashes</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">common = hash1.keys &amp; hash2.keys</span>

<span class="cp">this_not_that = hash1.keys - hash2.keys</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN268"
>Hashing References</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># no problem here, Ruby handles any kind of object for key-ing</span>
<span class="cp"># (it takes Object#hash, which defaults to Object#id)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN271"
>Presizing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># AFAIK, not possible in Ruby</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN274"
>Finding the Most Common Anything</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># Be careful, the following is possible only because Fixnum objects are</span>
<span class="cp"># special (documentation says: there is effectively only one Fixnum object</span>
<span class="cp"># instance for any given integer value).</span>
<span class="cp">count = Hash.new(0)</span>
<span class="cp">array.each { |e|</span>
<span class="cp">    count[e] += 1</span>
<span class="cp">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN277"
>Representing Relationships Between Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">father = {</span>
<span class="cp">    &quot;Cain&quot;      , &quot;Adam&quot;,</span>
<span class="cp">    &quot;Abel&quot;      , &quot;Adam&quot;,</span>
<span class="cp">    &quot;Seth&quot;      , &quot;Adam&quot;,</span>
<span class="cp">    &quot;Enoch&quot;     , &quot;Cain&quot;,</span>
<span class="cp">    &quot;Irad&quot;      , &quot;Enoch&quot;,</span>
<span class="cp">    &quot;Mehujael&quot;  , &quot;Irad&quot;,</span>
<span class="cp">    &quot;Methusael&quot; , &quot;Mehujael&quot;,</span>
<span class="cp">    &quot;Lamech&quot;    , &quot;Methusael&quot;,</span>
<span class="cp">    &quot;Jabal&quot;     , &quot;Lamech&quot;,</span>
<span class="cp">    &quot;Jubal&quot;     , &quot;Lamech&quot;,</span>
<span class="cp">    &quot;Tubalcain&quot; , &quot;Lamech&quot;,</span>
<span class="cp">    &quot;Enos&quot;      , &quot;Seth&quot;,</span>
<span class="cp">}</span>

<span class="cp">while gets</span>
<span class="cp">    chomp</span>
<span class="cp">    begin</span>
<span class="cp">        print $_, &quot; &quot;</span>
<span class="cp">    end while $_ = father[$_]</span>
<span class="cp">    puts</span>
<span class="cp">end</span>

<span class="cp">children = {}</span>
<span class="cp">father.each { |k,v|</span>
<span class="cp">    (children[v] ||= []) &lt;&lt; k</span>
<span class="cp">}</span>
<span class="cp">while gets</span>
<span class="cp">    chomp</span>
<span class="cp">    puts &quot;#{$_} begat #{(children[$_] || [&#39;Nobody&#39;]).join(&#39;, &#39;)}.\n&quot;</span>
<span class="cp">end</span>

<span class="cp">includes = {}</span>
<span class="cp">files.each { |f|</span>
<span class="cp">    begin</span>
<span class="cp">        for l in IO.readlines(f)</span>
<span class="cp">            next unless l =~ /^\s*#\s*include\s*&lt;([^&gt;]+)&gt;/</span>
<span class="cp">            (includes[$1] ||= []) &lt;&lt; f</span>
<span class="cp">        end</span>
<span class="cp">    rescue SystemCallError</span>
<span class="cp">        $stderr.puts &quot;#$! (skipping)&quot;</span>
<span class="cp">    end</span>
<span class="cp">}</span>

<span class="cp">include_free = includes.values.flatten.uniq - includes.keys</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN280"
>Program: dutree</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># dutree - print sorted intented rendition of du output</span>
<span class="cp">#% dutree</span>
<span class="cp">#% dutree /usr</span>
<span class="cp">#% dutree -a</span>
<span class="cp">#% dutree -a /bin</span>

<span class="cp"># The DuNode class collects all information about a directory,</span>
<span class="cp"># and provides some convenience methods</span>
<span class="cp">class DuNode</span>

<span class="cp">    attr_reader :name</span>
<span class="cp">    attr_accessor :size</span>
<span class="cp">    attr_accessor :kids</span>

<span class="cp">    def initialize(name)</span>
<span class="cp">        @name = name</span>
<span class="cp">        @kids = []</span>
<span class="cp">        @size = 0</span>
<span class="cp">    end</span>

<span class="cp">    # support for sorting nodes with side</span>
<span class="cp">    def size_compare(node2)</span>
<span class="cp">        @size &lt;=&gt; node2.size</span>
<span class="cp">    end</span>

<span class="cp">    def basename</span>
<span class="cp">        @name.sub(/.*\//, &quot;&quot;)</span>
<span class="cp">    end</span>

<span class="cp">    #returns substring before last &quot;/&quot;, nil if not there</span>
<span class="cp">    def parent</span>
<span class="cp">        p = @name.sub(/\/[^\/]+$/,&quot;&quot;)</span>
<span class="cp">        if p == @name</span>
<span class="cp">            nil</span>
<span class="cp">        else</span>
<span class="cp">            p</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">end</span>

<span class="cp"># The DuTree does the acdtual work of</span>
<span class="cp"># getting the input, parsing it, builging up a tree</span>
<span class="cp"># and format it for output</span>
<span class="cp">class Dutree</span>

<span class="cp">    attr_reader :topdir</span>

<span class="cp">    def initialize</span>
<span class="cp">        @nodes = Hash.new</span>
<span class="cp">        @dirsizes = Hash.new(0)</span>
<span class="cp">        @kids = Hash.new([])</span>
<span class="cp">    end</span>

<span class="cp">    # get a node by name, create it if it does not exist yet</span>
<span class="cp">    def get_create_node(name)</span>
<span class="cp">        if @nodes.has_key?(name)</span>
<span class="cp">            @nodes[name]</span>
<span class="cp">        else</span>
<span class="cp">            node = DuNode.new(name)</span>
<span class="cp">            @nodes[name] = node</span>
<span class="cp">            node</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">    # run du, read in input, save sizes and kids</span>
<span class="cp">    # stores last directory read in instance variable topdir</span>
<span class="cp">    def input(arguments)</span>
<span class="cp">        name = &quot;&quot;</span>
<span class="cp">        cmd = &quot;du &quot; + arguments.join(&quot; &quot;)</span>
<span class="cp">        IO.popen(cmd) { |pipe|</span>
<span class="cp">            pipe.each { |line|</span>
<span class="cp">                size, name = line.chomp.split(/\s+/, 2)</span>
<span class="cp">                node = get_create_node(name)</span>
<span class="cp">                node.size = size.to_i</span>
<span class="cp">                @nodes[name] = node</span>
<span class="cp">                parent = node.parent</span>
<span class="cp">                if parent</span>
<span class="cp">                    get_create_node(parent).kids.push(node)</span>
<span class="cp">                end</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">        @topdir = @nodes[name]</span>
<span class="cp">    end</span>

<span class="cp">    # figure out how much is taken in each directory</span>
<span class="cp">    # that isn&#39;t stored in the subdirectories. Add a new</span>
<span class="cp">    # fake kid called &quot;.&quot; containing that much.</span>
<span class="cp">    def get_dots(node)</span>
<span class="cp">        cursize = node.size</span>
<span class="cp">        for kid in node.kids</span>
<span class="cp">            cursize -=  kid.size</span>
<span class="cp">            get_dots(kid)</span>
<span class="cp">        end</span>
<span class="cp">        if node.size != cursize</span>
<span class="cp">            newnode = get_create_node(node.name + &quot;/.&quot;)</span>
<span class="cp">            newnode.size = cursize</span>
<span class="cp">            node.kids.push(newnode)</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">    # recursively output everything</span>
<span class="cp">    # passing padding and number width as well</span>
<span class="cp">    # on recursive calls</span>
<span class="cp">    def output(node, prefix=&quot;&quot;, width=0)</span>
<span class="cp">        line = sprintf(&quot;%#{width}d %s&quot;, node.size, node.basename)</span>
<span class="cp">        puts(prefix + line)</span>
<span class="cp">        prefix += line.sub(/\d /, &quot;| &quot;)</span>
<span class="cp">        prefix.gsub!(/[^|]/, &quot; &quot;)</span>
<span class="cp">        if node.kids.length &gt; 0     # not a bachelor node</span>
<span class="cp">            kids = node.kids</span>
<span class="cp">            kids.sort! { |a,b|</span>
<span class="cp">                b.size_compare(a)</span>
<span class="cp">            }</span>
<span class="cp">            width = kids[0].size.to_s.length</span>
<span class="cp">            for kid in kids</span>
<span class="cp">                output(kid, prefix, width)</span>
<span class="cp">            end</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">end</span>

<span class="cp">tree = Dutree.new</span>
<span class="cp">tree.input(ARGV)</span>
<span class="cp">tree.get_dots(tree.topdir)</span>
<span class="cp">tree.output(tree.topdir)</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="arrays.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="patternmatching.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Arrays</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Pattern Matching</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>