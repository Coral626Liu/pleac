<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Arrays</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Ruby"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Dates and Times"
HREF="datesandtimes.html"><LINK
REL="NEXT"
TITLE="Hashes"
HREF="hashes.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Ruby</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="datesandtimes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="hashes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ARRAYS"
>4. Arrays</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN170"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">single_level = [ &quot;this&quot;, &quot;that&quot;, &quot;the&quot;, &quot;other&quot; ]</span>

<span class="cp"># Ruby directly supports nested arrays</span>
<span class="cp">double_level = [ &quot;this&quot;, &quot;that&quot;, [ &quot;the&quot;, &quot;other&quot; ] ]</span>
<span class="cp">still_single_level = [ &quot;this&quot;, &quot;that&quot;, [ &quot;the&quot;, &quot;other&quot; ] ].flatten</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN173"
>Specifying a List In Your Program</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">a = [ &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot; ]</span>
<span class="cp">a = %w(Why are you teasing me?)</span>

<span class="cp">lines = &lt;&lt;&quot;END_OF_HERE_DOC&quot;.gsub(/^\s*(.+)/, &#39;\1&#39;)</span>
<span class="cp">    The boy stood on the burning deck,</span>
<span class="cp">    It was as hot as glass.</span>
<span class="cp">END_OF_HERE_DOC</span>

<span class="cp">bigarray = IO.readlines(&quot;mydatafile&quot;).collect { |l| l.chomp }</span>

<span class="cp">name = &quot;Gandalf&quot;</span>
<span class="cp">banner = %Q(Speak, #{name}, and welcome!)</span>

<span class="cp">host_info  = `host #{his_host}`</span>

<span class="cp">%x(ps #{$$})</span>

<span class="cp">banner = &#39;Costs only $4.95&#39;.split(&#39; &#39;)</span>

<span class="cp">rax = %w! ( ) &lt; &gt; { } [ ] !</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN176"
>Printing a List with Commas</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">def commify_series(arr)</span>
<span class="cp">    return &#39;&#39; if not arr</span>
<span class="cp">    case arr.size</span>
<span class="cp">        when 0 then &#39;&#39;</span>
<span class="cp">        when 1 then arr[0]</span>
<span class="cp">        when 2 then arr.join(&#39; and &#39;)</span>
<span class="cp">        else arr[0..-2].join(&#39;, &#39;) + &#39;, and &#39; + arr[-1]</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">array = [ &quot;red&quot;, &quot;yellow&quot;, &quot;green&quot; ]</span>

<span class="cp">print &quot;I have &quot;, array, &quot; marbles\n&quot;</span>
<span class="cp"># -&gt; I have redyellowgreen marbles</span>

<span class="cp"># But unlike Perl:</span>
<span class="cp">print &quot;I have #{array} marbles\n&quot;</span>
<span class="cp"># -&gt; I have redyellowgreen marbles</span>
<span class="cp"># So, needs:</span>
<span class="cp">print &quot;I have #{array.join(&#39; &#39;)} marbles\n&quot;</span>
<span class="cp"># -&gt; I have red yellow green marbles</span>

<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># communify_series - show proper comma insertion in list output</span>

<span class="cp">def commify_series(arr)</span>
<span class="cp">    return &#39;&#39; if not arr</span>
<span class="cp">    sepchar = arr.find { |p| p =~ /,/ } ? &#39;; &#39; : &#39;, &#39;</span>
<span class="cp">    case arr.size</span>
<span class="cp">        when 0 then &#39;&#39;</span>
<span class="cp">        when 1 then arr[0]</span>
<span class="cp">        when 2 then arr.join(&#39; and &#39;)</span>
<span class="cp">        else arr[0..-2].join(sepchar) + sepchar + &#39;and &#39; + arr[-1]</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">lists = [</span>
<span class="cp">    [ &#39;just one thing&#39; ],</span>
<span class="cp">    %w(Mutt Jeff),</span>
<span class="cp">    %w(Peter Paul Mary),</span>
<span class="cp">    [ &#39;To our parents&#39;, &#39;Mother Theresa&#39;, &#39;God&#39; ],</span>
<span class="cp">    [ &#39;pastrami&#39;, &#39;ham and cheese&#39;, &#39;peanut butter and jelly&#39;, &#39;tuna&#39; ],</span>
<span class="cp">    [ &#39;recycle tired, old phrases&#39;, &#39;ponder big, happy thoughts&#39; ],</span>
<span class="cp">    [ &#39;recycle tired, old phrases&#39;,</span>
<span class="cp">      &#39;ponder big, happy thoughts&#39;,</span>
<span class="cp">      &#39;sleep and dream peacefully&#39; ],</span>
<span class="cp">]</span>

<span class="cp">for list in lists do</span>
<span class="cp">    puts &quot;The list is: #{commify_series(list)}.&quot;</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN179"
>Changing Array Size</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#   (note: AFAIK Ruby doesn&#39;t allow gory change of Array length)</span>
<span class="cp"># grow the array by assigning nil to past the end of array</span>
<span class="cp">ary[new_size-1] = nil</span>
<span class="cp"># shrink the array by slicing it down</span>
<span class="cp">ary.slice!(new_size..-1)</span>
<span class="cp"># init the array with given size</span>
<span class="cp">Array.new(number_of_elems)</span>
<span class="cp"># assign to an element past the original end enlarges the array</span>
<span class="cp">ary[index_new_last_elem] = value</span>

<span class="cp">def what_about_that_array(a)</span>
<span class="cp">    print &quot;The array now has &quot;, a.size, &quot; elements.\n&quot;</span>
<span class="cp">    # Index of last element is not really interesting in Ruby</span>
<span class="cp">    print &quot;Element #3 is `#{a[3]}&#39;.\n&quot;</span>
<span class="cp">end</span>
<span class="cp">people = %w(Crosby Stills Nash Young)</span>
<span class="cp">what_about_that_array(people)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN182"
>Doing Something with Every Element in a List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># OO style</span>
<span class="cp">bad_users.each { |user|</span>
<span class="cp">    complain(user)</span>
<span class="cp">}</span>
<span class="cp"># or, functional style</span>
<span class="cp">for user in bad_users</span>
<span class="cp">    complain(user)</span>
<span class="cp">end</span>

<span class="cp">for var in ENV.keys.sort</span>
<span class="cp">    puts &quot;#{var}=#{ENV[var]}&quot;</span>
<span class="cp">end</span>

<span class="cp">for user in all_users</span>
<span class="cp">    disk_space = get_usage(user)</span>
<span class="cp">    if (disk_space &gt; MAX_QUOTA)</span>
<span class="cp">        complain(user)</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">for l in IO.popen(&quot;who&quot;).readlines</span>
<span class="cp">    print l if l =~ /^gc/ </span>
<span class="cp">end</span>

<span class="cp"># we can mimic the obfuscated Perl way</span>
<span class="cp">while fh.gets               # $_ is set to the line just read</span>
<span class="cp">    chomp                   # $_ has a trailing \n removed, if it had one</span>
<span class="cp">    split.each { |w|        # $_ is split on whitespace</span>
<span class="cp">                            # but $_ is not set to each chunk as in Perl</span>
<span class="cp">        print w.reverse</span>
<span class="cp">    }</span>
<span class="cp">end</span>
<span class="cp"># ...or use a cleaner way</span>
<span class="cp">for l in fh.readlines</span>
<span class="cp">    l.chomp.split.each { |w| print w.reverse }</span>
<span class="cp">end</span>

<span class="cp"># same drawback as in problem 1.4, we can&#39;t mutate a Numeric...</span>
<span class="cp">array.collect! { |v| v - 1 }</span>

<span class="cp">a = [ .5, 3 ]; b = [ 0, 1 ]</span>
<span class="cp">for ary in [ a, b ]</span>
<span class="cp">    ary.collect! { |v| v * 7 }</span>
<span class="cp">end</span>
<span class="cp">puts &quot;#{a.join(&#39; &#39;)} #{b.join(&#39; &#39;)}&quot;</span>

<span class="cp"># we can mutate Strings, cool; we need a trick for the scalar</span>
<span class="cp">for ary in [ [ scalar ], array, hash.values ]</span>
<span class="cp">    ary.each { |v| v.strip! }     # String#strip rules :)</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN185"
>Iterating Over an Array by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># not relevant in Ruby since we have always references</span>
<span class="cp">for item in array</span>
<span class="cp">    # do somethingh with item</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN188"
>Extracting Unique Elements from a List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">unique = list.uniq</span>

<span class="cp"># generate a list of users logged in, removing duplicates</span>
<span class="cp">users = `who`.collect { |l| l =~ /(\w+)/; $1 }.sort.uniq</span>
<span class="cp">puts(&quot;users logged in: #{commify_series(users)}&quot;)  # see 4.2 for commify_series</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN191"
>Finding Elements in One Array but Not Another</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">a - b</span>
<span class="cp"># [ 1, 1, 2, 2, 3, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  -&gt;  [3, 5]</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN194"
>Computing Union, Intersection, or Difference of Unique Lists</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">union = a | b</span>
<span class="cp">intersection = a &amp; b</span>
<span class="cp">difference = a - b</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN197"
>Appending One Array to Another</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">array1.concat(array2)</span>
<span class="cp"># if you will assign to another object, better use:</span>
<span class="cp">new_ary = array1 + array2</span>

<span class="cp">members = [ &quot;Time&quot;, &quot;Flies&quot; ]</span>
<span class="cp">initiates =  [ &quot;An&quot;, &quot;Arrow&quot; ]</span>
<span class="cp">members += initiates</span>

<span class="cp">members = [ &quot;Time&quot;, &quot;Flies&quot; ]</span>
<span class="cp">initiates = [ &quot;An&quot;, &quot;Arrow&quot; ]</span>
<span class="cp">members[2,0] = [ &quot;Like&quot;, initiates ].flatten</span>

<span class="cp">members[0] = &quot;Fruit&quot;</span>
<span class="cp">members[3,2] = &quot;A&quot;, &quot;Banana&quot;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN200"
>Reversing an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">reversed = ary.reverse</span>

<span class="cp">ary.reverse_each { |e|</span>
<span class="cp">    # do something with e</span>
<span class="cp">}</span>

<span class="cp">descending = ary.sort.reverse</span>
<span class="cp">descending = ary.sort { |a,b| b &lt;=&gt; a }</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN203"
>Processing Multiple Elements of an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># remove n elements from front of ary (shift n)</span>
<span class="cp">front = ary.slice!(0, n)</span>

<span class="cp"># remove n elements from the end of ary (pop n)</span>
<span class="cp">end_ = ary.slice!(-n .. -1)</span>

<span class="cp"># let&#39;s extend the Array class, to make that useful</span>
<span class="cp">class Array</span>
<span class="cp">    def shift2()</span>
<span class="cp">        slice!(0 .. 1)     # more symetric with pop2...</span>
<span class="cp">    end</span>
<span class="cp">    def pop2()</span>
<span class="cp">        slice!(-2 .. -1)</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">friends = %w(Peter Paul Mary Jim Tim)</span>
<span class="cp">this, that = friends.shift2</span>

<span class="cp">beverages = %w(Dew Jolt Cola Sprite Fresca)</span>
<span class="cp">pair = beverages.pop2</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN206"
>Finding the First List Element That Passes a Test</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># use Enumerable#detect (or the synonym Enumerable#find)</span>
<span class="cp">highest_eng = employees.detect { |emp| emp.category == &#39;engineer&#39; }</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN209"
>Finding All Elements in an Array Matching Certain Criteria</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># use Enumerable#select (or the synonym Enumerable#find_all)</span>
<span class="cp">bigs = nums.select { |i| i &gt; 1_000_000 }</span>
<span class="cp">pigs = users.keys.select { |k| users[k] &gt; 1e7 }</span>

<span class="cp">matching = `who`.select { |u| u =~ /^gnat / }</span>

<span class="cp">engineers = employees.select { |e| e.position == &#39;Engineer&#39; }</span>

<span class="cp">secondary_assistance = applicants.select { |a|</span>
<span class="cp">    a.income &gt;= 26_000 &amp;&amp; a.income &lt; 30_000</span>
<span class="cp">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN212"
>Sorting an Array Numerically</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># normally you would have an array of Numeric (Float or</span>
<span class="cp"># Fixnum or Bignum), so you would use:</span>
<span class="cp">sorted = unsorted.sort</span>
<span class="cp"># if you have strings representing Integers or Floats</span>
<span class="cp"># you may specify another sort method:</span>
<span class="cp">sorted = unsorted.sort { |a,b| a.to_f &lt;=&gt; b.to_f }</span>

<span class="cp"># let&#39;s use the list of my own PID&#39;s</span>
<span class="cp">`ps ux`.split(&quot;\n&quot;)[1..-1].</span>
<span class="cp">    select { |i| i =~ /^#{ENV[&#39;USER&#39;]}/ }.</span>
<span class="cp">    collect { |i| i.split[1] }.</span>
<span class="cp">    sort { |a,b| a.to_i &lt;=&gt; b.to_i }.each { |i| puts i }</span>
<span class="cp">puts &quot;Select a process ID to kill:&quot;</span>
<span class="cp">pid = gets.chomp</span>
<span class="cp">raise &quot;Exiting ... \n&quot; unless pid &amp;&amp; pid =~ /^\d+$/</span>
<span class="cp">Process.kill(&#39;TERM&#39;, pid.to_i)</span>
<span class="cp">sleep 2</span>
<span class="cp">Process.kill(&#39;KILL&#39;, pid.to_i)</span>

<span class="cp">descending = unsorted.sort { |a,b| b.to_f &lt;=&gt; a.to_f }</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN215"
>Sorting a List by Computable Field</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">ordered = unordered.sort { |a,b| compare(a,b) }</span>

<span class="cp">precomputed = unordered.collect { |e| [compute, e] }</span>
<span class="cp">ordered_precomputed = precomputed.sort { |a,b| a[0] &lt;=&gt; b[0] }</span>
<span class="cp">ordered = ordered_precomputed.collect { |e| e[1] }</span>

<span class="cp">ordered = unordered.collect { |e| [compute, e] }.</span>
<span class="cp">    sort { |a,b| a[0] &lt;=&gt; b[0] }.</span>
<span class="cp">    collect { |e| e[1] }</span>

<span class="cp">for employee in employees.sort { |a,b| a.name &lt;=&gt; b.name }</span>
<span class="cp">    print employee.name, &quot; earns \$ &quot;, employee.salary, &quot;\n&quot;</span>
<span class="cp">end</span>

<span class="cp"># Beware! `0&#39; is true in Ruby.</span>
<span class="cp"># For chaining comparisons, you may use Numeric#nonzero?, which</span>
<span class="cp"># returns num if num is not zero, nil otherwise</span>
<span class="cp">sorted = employees.sort { |a,b| (a.name &lt;=&gt; b.name).nonzero? || b.age &lt;=&gt; a.age }</span>

<span class="cp">users = []</span>
<span class="cp"># getpwent is not wrapped in Ruby... let&#39;s fallback</span>
<span class="cp">IO.readlines(&#39;/etc/passwd&#39;).each { |u| users &lt;&lt; u.split(&#39;:&#39;) }</span>
<span class="cp">users.sort! { |a,b| a[0] &lt;=&gt; b[0] }</span>
<span class="cp">for user in users</span>
<span class="cp">    puts user[0]</span>
<span class="cp">end</span>

<span class="cp">sorted = names.sort { |a,b| a[1, 1] &lt;=&gt; b[1, 1] }</span>
<span class="cp">sorted = strings.sort { |a,b| a.length &lt;=&gt; b.length }</span>

<span class="cp"># let&#39;s show only the compact version</span>
<span class="cp">ordered = strings.collect { |e| [e.length, e] }.</span>
<span class="cp">    sort { |a,b| a[0] &lt;=&gt; b[0] }.</span>
<span class="cp">    collect { |e| e[1] }</span>

<span class="cp">ordered = strings.collect { |e| [/\d+/.match(e)[0].to_i, e] }.</span>
<span class="cp">    sort { |a,b| a[0] &lt;=&gt; b[0] }.</span>
<span class="cp">    collect { |e| e[1] }</span>

<span class="cp">print `cat /etc/passwd`.collect { |e| [e, e.split(&#39;:&#39;).indexes(3,2,0)].flatten }.</span>
<span class="cp">    sort { |a,b| (a[1] &lt;=&gt; b[1]).nonzero? || (a[2] &lt;=&gt; b[2]).nonzero? || a[3] &lt;=&gt; b[3] }.</span>
<span class="cp">    collect { |e| e[0] }</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN218"
>Implementing a Circular List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">circular.unshift(circular.pop)        # the last shall be first</span>
<span class="cp">circular.push(circular.shift)         # and vice versa</span>

<span class="cp">def grab_and_rotate(l)</span>
<span class="cp">    l.push(ret = l.shift)</span>
<span class="cp">    ret</span>
<span class="cp">end</span>

<span class="cp">processes = [1, 2, 3, 4, 5]</span>
<span class="cp">while (1)</span>
<span class="cp">    process = grab_and_rotate(processes)</span>
<span class="cp">    puts &quot;Handling process #{process}&quot;</span>
<span class="cp">    sleep 1</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN221"
>Randomizing an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">def fisher_yates_shuffle(a)</span>
<span class="cp">    (a.size-1).downto(1) { |i|</span>
<span class="cp">        j = rand(i+1)</span>
<span class="cp">        a[i], a[j] = a[j], a[i] if i != j</span>
<span class="cp">    }</span>
<span class="cp">end</span>

<span class="cp">def naive_shuffle(a)</span>
<span class="cp">    for i in 0...a.size</span>
<span class="cp">        j = rand(a.size)</span>
<span class="cp">        a[i], a[j] = a[j], a[i]</span>
<span class="cp">    end</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN224"
>Program: words</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#!/usr/bin/env ruby</span>
<span class="cp"># example 4-2 words</span>
<span class="cp"># words - gather lines, present in colums</span>

<span class="cp"># class to encapsulate the word formatting from the input</span>
<span class="cp">class WordFormatter</span>
<span class="cp">    def initialize(cols)</span>
<span class="cp">        @cols = cols</span>
<span class="cp">    end</span>

<span class="cp">    # helper to return the length of the longest word in the wordlist</span>
<span class="cp">    def maxlen(wordlist)</span>
<span class="cp">        max = 1</span>
<span class="cp">        for word in wordlist</span>
<span class="cp">            if word.length &gt; max</span>
<span class="cp">                max = word.length</span>
<span class="cp">            end</span>
<span class="cp">        end</span>
<span class="cp">        max</span>
<span class="cp">    end</span>

<span class="cp">    # process the wordlist and print it formmated into columns</span>
<span class="cp">    def output(wordlist)</span>
<span class="cp">        collen = maxlen(wordlist) + 1</span>
<span class="cp">        columns = @cols / collen</span>
<span class="cp">        columns = 1 if columns == 0</span>
<span class="cp">        rows = (wordlist.length + columns - 1) / columns</span>
<span class="cp">        # now process each item, picking out proper piece for this position</span>
<span class="cp">        0.upto(rows * columns - 1) { |item|</span>
<span class="cp">            target = (item % columns) * rows + (item / columns)</span>
<span class="cp">            eol = ((item+1) % columns == 0)</span>
<span class="cp">            piece = wordlist[target] || &quot;&quot;</span>
<span class="cp">            piece = piece.ljust(collen) unless eol</span>
<span class="cp">            print piece</span>
<span class="cp">            puts if eol</span>
<span class="cp">        }</span>
<span class="cp">        # no need to finish it up, because eol is always true for the last element</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># get nr of chars that fit in window or console, see PLEAC 15.4</span>
<span class="cp"># not portable -- linux only (?)</span>
<span class="cp">def getWinCharWidth()</span>
<span class="cp">    buf = &quot;\0&quot; * 8</span>
<span class="cp">    $stdout.ioctl(0x5413, buf)</span>
<span class="cp">    ws_row, ws_col, ws_xpixel, ws_ypixel = buf.unpack(&quot;$4&quot;)</span>
<span class="cp">    ws_col || 80</span>
<span class="cp">rescue</span>
<span class="cp">    80</span>
<span class="cp">end</span>

<span class="cp"># main program</span>
<span class="cp">cols = getWinCharWidth()</span>
<span class="cp">formatter = WordFormatter.new(cols)</span>
<span class="cp">words = readlines()</span>
<span class="cp">words.collect! { |line|</span>
<span class="cp">    line.chomp</span>
<span class="cp">}</span>
<span class="cp">formatter.output(words)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN227"
>Program: permute</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># In ruby, Fixnum&#39;s are automatically converted to Bignum&#39;s when</span>
<span class="cp"># needed, so there is no need for an extra module</span>
<span class="cp">def factorial(n)</span>
<span class="cp">    s = 1</span>
<span class="cp">    while n &gt; 0</span>
<span class="cp">        s *= n</span>
<span class="cp">        n -= 1</span>
<span class="cp">    end</span>
<span class="cp">    s</span>
<span class="cp">end</span>

<span class="cp">puts factorial(500)</span>

<span class="cp">#---------------------------------------------------------</span>
<span class="cp"># Example 4-3. tsc-permute</span>
<span class="cp"># tsc_permute: permute each word of input</span>
<span class="cp">def permute(items, perms)</span>
<span class="cp">    unless items.length &gt; 0</span>
<span class="cp">        puts perms.join(&quot; &quot;)</span>
<span class="cp">    else</span>
<span class="cp">        for i in items</span>
<span class="cp">            newitems = items.dup</span>
<span class="cp">            newperms = perms.dup</span>
<span class="cp">            newperms.unshift(newitems.delete(i))</span>
<span class="cp">            permute(newitems, newperms)</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp"># In ruby the main program must be after all definitions it is using</span>
<span class="cp">permute(ARGV, [])</span>

<span class="cp">#---------------------------------------------------------</span>
<span class="cp"># mjd_permute: permute each word of input</span>

<span class="cp">def factorial(n)</span>
<span class="cp">    s = 1</span>
<span class="cp">    while n &gt; 0</span>
<span class="cp">        s *= n</span>
<span class="cp">        n -= 1</span>
<span class="cp">    end</span>
<span class="cp">    s</span>
<span class="cp">end</span>

<span class="cp"># we use a class with a class variable store the private cache</span>
<span class="cp"># for the results of the factorial function.</span>
<span class="cp">class Factorial</span>
<span class="cp">    @@fact = [ 1 ]</span>
<span class="cp">    def Factorial.compute(n)</span>
<span class="cp">        if @@fact[n]</span>
<span class="cp">            @@fact[n]</span>
<span class="cp">        else</span>
<span class="cp">            @@fact[n] = n * Factorial.compute(n - 1)</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">#---------------------------------------------------------</span>
<span class="cp"># Example 4-4- mjd-permute</span>
<span class="cp"># n2pat(n, len): produce the N-th pattern of length len</span>

<span class="cp"># We must use a lower case letter as parameter N, otherwise it is</span>
<span class="cp"># handled as constant Length is the length of the resulting</span>
<span class="cp"># array, not the index of the last element (length -1) like in</span>
<span class="cp"># the perl example.</span>
<span class="cp">def n2pat(n, length)</span>
<span class="cp">    pat = []</span>
<span class="cp">    i = 1</span>
<span class="cp">    while i &lt;= length</span>
<span class="cp">        pat.push(n % i)</span>
<span class="cp">        n /= i</span>
<span class="cp">        i += 1</span>
<span class="cp">    end</span>
<span class="cp">    pat</span>
<span class="cp">end</span>

<span class="cp"># pat2perm(pat): turn pattern returned by n2pat() into</span>
<span class="cp"># permutation of integers.</span>
<span class="cp">def pat2perm(pat)</span>
<span class="cp">    source = (0 .. pat.length - 1).to_a</span>
<span class="cp">    perm = []</span>
<span class="cp">    perm.push(source.slice!(pat.pop)) while pat.length &gt; 0</span>
<span class="cp">    perm</span>
<span class="cp">end</span>

<span class="cp">def n2perm(n, len)</span>
<span class="cp">    pat2perm(n2pat(n,len))</span>
<span class="cp">end</span>

<span class="cp"># In ruby the main program must be after all definitions</span>
<span class="cp">while gets</span>
<span class="cp">    data = split</span>
<span class="cp">    # the perl solution has used $#data, which is length-1</span>
<span class="cp">    num_permutations = Factorial.compute(data.length())</span>
<span class="cp">    0.upto(num_permutations - 1) do |i|</span>
<span class="cp">        # in ruby we can not use an array as selector for an array</span>
<span class="cp">        # but by exchanging the two arrays, we can use the collect method</span>
<span class="cp">        # which returns an array with the result of all block invocations</span>
<span class="cp">        permutation = n2perm(i, data.length).collect {</span>
<span class="cp">            |j| data[j]</span>
<span class="cp">        }</span>
<span class="cp">        puts permutation.join(&quot; &quot;)</span>
<span class="cp">    end</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="datesandtimes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="hashes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Dates and Times</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Hashes</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>