<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Subroutines</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Ruby"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Directories"
HREF="directories.html"><LINK
REL="NEXT"
TITLE="References and Records"
HREF="referencesandrecords.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Ruby</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SUBROUTINES"
>10. Subroutines</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN536"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">def hello</span>
<span class="cp">    $greeted += 1      # in Ruby, a variable beginning with $ is global (can be any type of course)</span>
<span class="cp">    puts &quot;hi there!&quot;</span>
<span class="cp">end</span>

<span class="cp"># We need to initialize $greeted before it can be used, because &quot;+=&quot; is waiting a Numeric object</span>
<span class="cp">$greeted = 0</span>
<span class="cp">hello                  # note that appending () is optional to function calls with no parameters</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN539"
>Accessing Subroutine Arguments</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># In Ruby, parameters are named anyway</span>
<span class="cp">def hypotenuse(side1, side2)</span>
<span class="cp">    Math.sqrt(side1**2 + side2**2)    # the sqrt function comes from the Math module</span>
<span class="cp">end</span>
<span class="cp">diag = hypotenuse(3, 4)</span>

<span class="cp">puts hypotenuse(3, 4)</span>

<span class="cp">a = [3, 4]</span>
<span class="cp">print hypotenuse(*a)                  # the star operator will magically convert an Array into a &quot;tuple&quot;</span>

<span class="cp">both = men + women</span>

<span class="cp"># In Ruby, all objects are references, so the same problem arises; we then return a new object</span>
<span class="cp">nums = [1.4, 3.5, 6.7]</span>
<span class="cp">def int_all(n)</span>
<span class="cp">    n.collect { |v| v.to_i }</span>
<span class="cp">end</span>
<span class="cp">ints = int_all(nums)</span>

<span class="cp">nums = [1.4, 3.5, 6.7]</span>
<span class="cp">def trunc_em(n)</span>
<span class="cp">    n.collect! { |v| v.to_i }         # the bang-version of collect modifies the object</span>
<span class="cp">end</span>
<span class="cp">trunc_em(nums)</span>

<span class="cp"># Ruby has two chomp version:</span>
<span class="cp"># ``chomp&#39;&#39; chomps the record separator and returns what&#39;s expected</span>
<span class="cp"># ``chomp!&#39;&#39; does the same but also modifies the parameter object</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN542"
>Making Variables Private to a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">def somefunc</span>
<span class="cp">    variable = something  # variable is local by default</span>
<span class="cp">end</span>

<span class="cp">name, age = ARGV</span>
<span class="cp">start     = fetch_time</span>

<span class="cp">a, b = pair               # will succeed if pair is an Array object (like ARGV is)</span>
<span class="cp">c = fetch_time</span>

<span class="cp"># In ruby, run_check can&#39;t access a, b, or c until they are</span>
<span class="cp"># explicitely defined global (using leading $), even if they are</span>
<span class="cp"># both defined in the same scope</span>

<span class="cp">def check_x(x)</span>
<span class="cp">    y = &quot;whatever&quot;</span>
<span class="cp">    run_check</span>
<span class="cp">    if $condition</span>
<span class="cp">        puts &quot;got $x&quot;</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># The following will keep a reference to the array, though the</span>
<span class="cp"># results will be slightly different from perl: the last element</span>
<span class="cp"># of $global_array will be itself an array</span>
<span class="cp">def save_array(ary)</span>
<span class="cp">    $global_array &lt;&lt; ary</span>
<span class="cp">end</span>

<span class="cp"># The following gives the same results as in Perl for $global_array,</span>
<span class="cp"># though it doesn&#39;t illustrate anymore the way to keep a reference</span>
<span class="cp"># to an object: $global_array is extended with the elements of ary</span>
<span class="cp">def save_array(ary)</span>
<span class="cp">    $global_array += ary</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN545"
>Creating Persistent Private Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># In Ruby, AFAIK a method cannot access &quot;local variables&quot; defined</span>
<span class="cp"># upper scope; mostly because everything is an object, so you&#39;ll</span>
<span class="cp"># do the same by defining an attribute or a static attribute</span>

<span class="cp"># In Ruby the BEGIN also exists:</span>
<span class="cp">BEGIN { puts &quot;hello from BEGIN&quot; }</span>
<span class="cp">puts &quot;hello from main&quot;</span>
<span class="cp">BEGIN { puts &quot;hello from 2nd BEGIN&quot; }</span>
<span class="cp"># gives:</span>
<span class="cp">#   hello from BEGIN</span>
<span class="cp">#   hello from 2nd BEGIN</span>
<span class="cp">#   hello from main</span>

<span class="cp"># In Ruby, it can be written as a static method and a static</span>
<span class="cp"># variable</span>
<span class="cp">class Counter</span>
<span class="cp">    @@counter = 0</span>
<span class="cp">    def Counter.next_counter; @@counter += 1; end</span>
<span class="cp">end</span>

<span class="cp"># There is no need of BEGIN since the variable will get</span>
<span class="cp"># initialized when parsing</span>
<span class="cp">class Counter</span>
<span class="cp">    @@counter = 42</span>
<span class="cp">    def Counter.next_counter; @@counter += 1; end</span>
<span class="cp">    def Counter.prev_counter; @@counter -= 1; end</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN548"
>Determining Current Function Name</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># You can either get the whole trace as an array of strings, each</span>
<span class="cp"># string telling which file, line and method is calling:</span>
<span class="cp">caller</span>

<span class="cp"># ...or only the last caller</span>
<span class="cp">caller[0]</span>

<span class="cp"># We need to extract just the method name of the backtrace:</span>
<span class="cp">def whoami;  caller()[0] =~ /in `([^&#39;]+)&#39;/ ? $1 : &#39;(anonymous)&#39;; end</span>
<span class="cp">def whowasi; caller()[1] =~ /in `([^&#39;]+)&#39;/ ? $1 : &#39;(anonymous)&#39;; end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN551"
>Passing Arrays and Hashes by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># In Ruby, every value is a reference on an object, thus there is</span>
<span class="cp"># no such problem</span>
<span class="cp">array_diff(array1, array2)</span>

<span class="cp">def add_vecpair(a1, a2)</span>
<span class="cp">    results = []</span>
<span class="cp">    a1.each_index { |i| results &lt;&lt; (a1[i] + a2[i]) }</span>
<span class="cp">    results</span>
<span class="cp">end</span>
<span class="cp">a = [1, 2]</span>
<span class="cp">b = [5, 8]</span>
<span class="cp">c = add_vecpair(a, b)</span>
<span class="cp">p c</span>

<span class="cp"># Add this to the beginning of the function to check if we were</span>
<span class="cp"># given two arrays</span>
<span class="cp">a1.type == Array &amp;&amp; a2.type == Array or</span>
<span class="cp">    raise &quot;usage: add_vecpair array1 array2 (was used with: #{a1.type} #{a2.type})&quot;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN554"
>Detecting Return Context</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># There is no return context in Ruby</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN557"
>Passing by Named Parameter</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># Like in Perl, we need to fake with a hash, but it&#39;s dirty :-(</span>
<span class="cp">def thefunc(param_args)</span>
<span class="cp">    args = { &#39;INCREMENT&#39; =&gt; &#39;10s&#39;, &#39;FINISH&#39; =&gt; &#39;0&#39;, &#39;START&#39; =&gt; 0 }</span>
<span class="cp">    args.update(param_args)</span>
<span class="cp">    if (args[&#39;INCREMENT&#39;]  =~ /m$/ )</span>
<span class="cp">        # .....</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">thefunc({ &#39;INCREMENT&#39; =&gt; &#39;20s&#39;, &#39;START&#39; =&gt; &#39;+5m&#39;, &#39;FINISH&#39; =&gt; &#39;+30m&#39; })</span>
<span class="cp">thefunc({})</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN560"
>Skipping Selected Return Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># there is no &quot;undef&quot; direct equivalent but there is the slice equiv:</span>
<span class="cp">a, c = func.indexes(0, 2)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN563"
>Returning More Than One Array or Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># Ruby has no such limitation:</span>
<span class="cp">def somefunc</span>
<span class="cp">    ary = []</span>
<span class="cp">    hash = {}</span>
<span class="cp">    # ...</span>
<span class="cp">    return ary, hash</span>
<span class="cp">end</span>
<span class="cp">arr, dict = somefunc</span>

<span class="cp">array_of_hashes = fn</span>
<span class="cp">h1, h2, h3      = fn</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN566"
>Returning Failure</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">return</span>
<span class="cp"># or (equivalent)</span>
<span class="cp">return nil</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN569"
>Prototyping Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># You can&#39;t prototype in Ruby regarding types :-(</span>
<span class="cp"># Though, you can force the number of arguments:</span>
<span class="cp">def func_with_no_arg; end</span>
<span class="cp">def func_with_no_arg(); end</span>
<span class="cp">def func_with_one_arg(a1); end</span>
<span class="cp">def func_with_two_args(a1, a2); end</span>
<span class="cp">def func_with_any_number_of_args(*args); end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN572"
>Handling Exceptions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">raise &quot;some message&quot;        # raise exception</span>

<span class="cp">begin</span>
<span class="cp">    val = func</span>
<span class="cp">rescue Exception =&gt; msg</span>
<span class="cp">    $stderr.puts &quot;func raised an exception: #{msg}&quot;</span>
<span class="cp">end</span>

<span class="cp"># In Ruby the rescue statement uses an exception class, every</span>
<span class="cp"># exception which is not matched is still continuing</span>
<span class="cp">begin</span>
<span class="cp">    val = func</span>
<span class="cp">rescue FullMoonError</span>
<span class="cp">    ...</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN575"
>Saving Global Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># Saving Global Values</span>
<span class="cp"># Of course we can just save the value and restore it later:</span>
<span class="cp">def print_age</span>
<span class="cp">    puts &quot;Age is #{$age}&quot;</span>
<span class="cp">end</span>

<span class="cp">$age = 18         # global variable</span>
<span class="cp">print_age()</span>
<span class="cp">if condition</span>
<span class="cp">    safeage = $age</span>
<span class="cp">    $age = 23</span>
<span class="cp">    print_age()</span>
<span class="cp">    $age = safeage</span>
<span class="cp">end</span>

<span class="cp"># We can also use a method that saves the global variable and</span>
<span class="cp"># restores it automatically when the block is left:</span>

<span class="cp">def local(var)</span>
<span class="cp">    eval(&quot;save = #{var.id2name}&quot;)</span>
<span class="cp">    begin</span>
<span class="cp">        result = yield</span>
<span class="cp">    ensure</span>
<span class="cp">        # we want to call this even if we got an exception</span>
<span class="cp">        eval(&quot;#{var.id2name} = save&quot;)</span>
<span class="cp">    end</span>
<span class="cp">    result</span>
<span class="cp">end</span>

<span class="cp">condition = true</span>
<span class="cp">$age = 18</span>
<span class="cp">print_age()</span>
<span class="cp">if condition</span>
<span class="cp">    local(:$age) {</span>
<span class="cp">        $age = 23</span>
<span class="cp">        print_age()</span>
<span class="cp">    }</span>
<span class="cp">end</span>
<span class="cp">print_age()</span>

<span class="cp"># There is no need to use local() for filehandles or directory</span>
<span class="cp"># handles in ruby because filehandles are normal objects.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN578"
>Redefining a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp"># In Ruby you may redefine a method [but not overload it :-(]</span>
<span class="cp"># just by defining again with the same name.</span>
<span class="cp">def foo; puts &#39;foo&#39;; end</span>
<span class="cp">def foo; puts &#39;bar&#39;; end</span>
<span class="cp">foo</span>
<span class="cp">#=&gt; bar</span>

<span class="cp"># You can also take a reference to an existing method before</span>
<span class="cp"># redefining a new one, using the `alias&#39; keyword</span>
<span class="cp">def foo; puts &#39;foo&#39;; end</span>
<span class="cp">alias foo_orig foo</span>
<span class="cp">def foo; puts &#39;bar&#39;; end</span>
<span class="cp">foo_orig</span>
<span class="cp">foo</span>
<span class="cp">#=&gt; foo</span>
<span class="cp">#=&gt; bar</span>

<span class="cp"># AFAIK, there is no direct way to create a new method whose name</span>
<span class="cp"># comes from a variable, so use &quot;eval&quot;</span>
<span class="cp">colors = %w(red blue green yellow orange purple violet)</span>
<span class="cp">colors.each { |c|</span>
<span class="cp">    eval &lt;&lt;-EOS</span>
<span class="cp">    def #{c}(*a)</span>
<span class="cp">        &quot;&lt;FONT COLOR=&#39;#{c}&#39;&gt;&quot; + a.to_s + &quot;&lt;/FONT&gt;&quot;</span>
<span class="cp">    end</span>
<span class="cp">    EOS</span>
<span class="cp">} </span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN581"
>Trapping Undefined Function Calls with AUTOLOAD</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">def method_missing(name, *args)</span>
<span class="cp">    &quot;&lt;FONT COLOR=&#39;#{name}&#39;&gt;&quot; + args.join(&#39; &#39;) + &quot;&lt;/FONT&gt;&quot;</span>
<span class="cp">end</span>
<span class="cp">puts chartreuse(&quot;stuff&quot;)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN584"
>Nesting Subroutines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">def outer(arg)</span>
<span class="cp">    x = arg + 35</span>
<span class="cp">    inner = proc { x * 19 }</span>
<span class="cp">    x + inner.call()</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN587"
>Program: Sorting Your Mail</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="cp"></span><span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># mailsort - sort mbox by different criteria</span>
<span class="cp">require &#39;English&#39;</span>
<span class="cp">require &#39;Date&#39;</span>

<span class="cp"># Objects of class Mail represent a single mail.</span>
<span class="cp">class Mail</span>
<span class="cp">    attr_accessor :no</span>
<span class="cp">    attr_accessor :subject</span>
<span class="cp">    attr_accessor :fulltext</span>
<span class="cp">    attr_accessor :date</span>

<span class="cp">    def initialize</span>
<span class="cp">        @fulltext = &quot;&quot;</span>
<span class="cp">        @subject = &quot;&quot;</span>
<span class="cp">    end</span>

<span class="cp">    def append(para)</span>
<span class="cp">        @fulltext &lt;&lt; para</span>
<span class="cp">    end</span>

<span class="cp">    # this is called if you call puts(mail)</span>
<span class="cp">    def to_s</span>
<span class="cp">        @fulltext</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># represents a list of mails.</span>
<span class="cp">class Mailbox &lt; Array</span>

<span class="cp">    Subjectpattern = Regexp.new(&#39;Subject:\s*(?:Re:\s*)*(.*)\n&#39;)</span>
<span class="cp">    Datepattern = Regexp.new(&#39;Date:\s*(.*)\n&#39;)</span>

<span class="cp">    # reads mails from open file and stores them</span>
<span class="cp">    def read(file)</span>
<span class="cp">        $INPUT_RECORD_SEPARATOR = &#39;&#39;  # paragraph reads</span>
<span class="cp">        msgno = -1</span>
<span class="cp">        file.each { |para|</span>
<span class="cp">            if para =~ /^From/</span>
<span class="cp">                mail = Mail.new</span>
<span class="cp">                mail.no = (msgno += 1)</span>
<span class="cp">                md = Subjectpattern.match(para)</span>
<span class="cp">                if md</span>
<span class="cp">                    mail.subject = md[1]</span>
<span class="cp">                end</span>
<span class="cp">                md = Datepattern.match(para)</span>
<span class="cp">                if md</span>
<span class="cp">                    mail.date = DateTime.parse(md[1])</span>
<span class="cp">                else</span>
<span class="cp">                    mail.date = DateTime.now</span>
<span class="cp">                end</span>
<span class="cp">                self.push(mail)</span>
<span class="cp">            end</span>
<span class="cp">            mail.append(para) if mail</span>
<span class="cp">        }</span>
<span class="cp">    end</span>

<span class="cp">    def sort_by_subject_and_no</span>
<span class="cp">        self.sort_by { |m|</span>
<span class="cp">            [m.subject, m.no]</span>
<span class="cp">        }</span>
<span class="cp">    end</span>

<span class="cp">    # sorts by a list of attributs of mail, given as symbols</span>
<span class="cp">    def sort_by_attributs(*attrs)</span>
<span class="cp">        # you can sort an Enumerable by an array of</span>
<span class="cp">        # values, they would be compared</span>
<span class="cp">        # from ary[0] to ary[n]t, say:</span>
<span class="cp">        # [&#39;b&#39;,1] &gt; [&#39;a&#39;,10] &gt; [&#39;a&#39;,9]</span>
<span class="cp">        self.sort_by { |elem|</span>
<span class="cp">            attrs.map { |attr|</span>
<span class="cp">                elem.send(attr)</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">    end</span>

<span class="cp">end</span>

<span class="cp">mailbox = Mailbox.new</span>
<span class="cp">mailbox.read(ARGF)</span>

<span class="cp"># print only subjects sorted by subject and number</span>
<span class="cp">for m in mailbox.sort_by_subject_and_no</span>
<span class="cp">    puts(m.subject)</span>
<span class="cp">end</span>

<span class="cp"># print complete mails sorted by date, then subject, then number</span>
<span class="cp">for m in mailbox.sort_by_attributs(:date, :subject)</span>
<span class="cp">    puts(m)</span>
<span class="cp">end</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Directories</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>References and Records</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>