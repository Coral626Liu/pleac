<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=latin1">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span class="c1">// -*- c -*-</span>

<span class="c1">// @@PLEAC@@_NAME</span>
<span class="c1">// @@SKIP@@ C/Posix/GNU</span>


<span class="c1">// @@PLEAC@@_WEB</span>
<span class="c1">// @@SKIP@@ http://www.gnu.org/software/libc/libc.html</span>


<span class="c1">// @@PLEAC@@_2.7</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// rand() srand()</span>

<span class="p">...</span>

<span class="cm">/*</span>
<span class="cm">    rand() function is not guaranted to produce random values</span>
<span class="cm">*/</span>

<span class="kt">int</span> <span class="n">random</span><span class="p">;</span>

<span class="c1">// the same value between 0 and RAND_MAX</span>
<span class="c1">// for every run</span>
<span class="n">random</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="p">...</span>

<span class="kt">float</span> <span class="n">random</span><span class="p">;</span>

<span class="c1">// the same value between 0 and 1.0</span>
<span class="c1">// for every run</span>
<span class="n">random</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="p">...</span>

<span class="cp">#define N 42</span>

<span class="p">...</span>

<span class="kt">int</span> <span class="n">random</span><span class="p">;</span>

<span class="c1">// the same value between 0 and N -1</span>
<span class="c1">// for every run</span>
<span class="n">random</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">);</span>

<span class="p">...</span>

<span class="c1">// @@PLEAC@@_2.8</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// rand() srand()</span>
<span class="cp">#include &lt;time.h&gt; </span><span class="c1">// time()</span>

<span class="p">...</span>

<span class="kt">int</span> <span class="n">random</span><span class="p">;</span>

<span class="c1">// seeds a new sequence of random number</span>
<span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

<span class="c1">// a different value between 0 and RAND_MAX</span>
<span class="c1">// for every run</span>
<span class="n">random</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>

<span class="p">...</span>

<span class="c1">// @@PLEAC@@_2.9</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cm">/*</span>
<span class="cm">    under Linux /dev/random or /dev/urandom</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// FILE *, fopen(), fread(), fclose()</span>

<span class="p">...</span>

<span class="kt">FILE</span> <span class="o">*</span> <span class="n">fp</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">random</span><span class="p">;</span>

<span class="k">if</span> <span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&quot;/dev/random&quot;</span><span class="p">,</span><span class="s">&quot;r&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;fopen&quot;</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">random</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">random</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;random number %u from /dev/random</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">random</span><span class="p">);</span>

<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>

<span class="c1">// @@PLEAC@@_3.0</span>
<span class="c1">// NOTE: In order to keep the size / verbosity of code examples to a minimum, library function</span>
<span class="c1">// calls will generally not include error checking and handling. Example:</span>
<span class="c1">//</span>
<span class="c1">//     p = malloc(...);                if ((p = malloc(...)) == NULL)</span>
<span class="c1">//                                     {</span>
<span class="c1">//                                       ... handle error ...</span>
<span class="c1">//                                     }</span>
<span class="c1">//</span>
<span class="c1">// However, any necessary, application-specific error-related code, will still be used. Code</span>
<span class="c1">// examples will endeavour, wherever possible, to make use of:</span>
<span class="c1">//</span>
<span class="c1">// * C99 Features e.g. variable-length arrays, non-const aggregate initialisers</span>
<span class="c1">// * GNU Extensions e.g. nested functions, statement expressions</span>
<span class="c1">//</span>
<span class="c1">// The aim of doing so is to reduce redundancy [i.e. copious examples of older / standard C</span>
<span class="c1">// already exist] as well as enhance the information value of each PLEAC example.</span>
<span class="c1">//</span>
<span class="c1">// Another item worthy of note is the use of writeable &#39;static local storage&#39; in many custom</span>
<span class="c1">// functions. Whilst a commonly-used technique that makes functions self-contained, and easier</span>
<span class="c1">// to use [which is precisely why it is used here], it is not viable in multi-threaded code;</span>
<span class="c1">// examples need to be suitably modified to work in such code. The section, &#39;Printing a Date&#39;,</span>
<span class="c1">// in Chapter 3: Dates and Times, discusses this issue, and provides illustrative examples.</span>
<span class="c1">//</span>
<span class="c1">// The GNU C Library provides extensive, if somewhat low-level, date / time functionality. The</span>
<span class="c1">// relevant section of the manual may be found at:</span>
<span class="c1">//</span>
<span class="c1">//     http://www.gnu.org/software/libc/manual/html_mono/libc.html#Date%20and%20Time</span>
<span class="c1">//</span>
<span class="c1">// Outline of some of the more important concepts:</span>
<span class="c1">//</span>
<span class="c1">// * Calendar time represented in three forms:</span>
<span class="c1">//   - Simple time [a.k.a. Epoch Seconds, seconds since Jan 1, 1970]; represented by the</span>
<span class="c1">//    &#39;time_t&#39; type [generally implemented as a 32 bit integer]</span>
<span class="c1">//   - Broken-down time; represented by &#39;struct tm&#39;, having a field for each time component</span>
<span class="c1">//   - Formatted string; certain string formats are printable and parseable as valid calendar</span>
<span class="c1">//     times</span>
<span class="c1">//</span>
<span class="c1">// * Date manipulations are ordinarily performed using broken-down time form, and are converted</span>
<span class="c1">//   to / from this form as the need arises:</span>
<span class="c1">//   - Input</span>
<span class="c1">//     + simple -&gt; broken-down: &#39;localtime&#39; / &#39;gmtime&#39;</span>
<span class="c1">//     + string -&gt; broken-down: &#39;strptime&#39; / &#39;getdate&#39;</span>
<span class="c1">//   - Arithmetic</span>
<span class="c1">//     + broken-down -&gt; simple: &#39;mktime&#39;</span>
<span class="c1">//   - Output</span>
<span class="c1">//     + broken-down -&gt; string: &#39;strftime&#39;, &#39;asctime&#39;</span>
<span class="c1">//</span>
<span class="c1">//   The above list shows that a date / time value might be either be read in as a string [then</span>
<span class="c1">//   parsed, and converted], or converted from a simple-time value [e.g. the &#39;time&#39; and</span>
<span class="c1">//   &#39;gettimeofday&#39; routines return the current date / time as a simple-time value]. Date</span>
<span class="c1">//   arithmetic can, of course, be performed using the component fields of a broken-time value,</span>
<span class="c1">//   but would, more commonly, be first converted to a simple-time value [via &#39;mktime&#39;], the</span>
<span class="c1">//   relevant operations performed, and converted back. Date / time output is ordinarily in</span>
<span class="c1">//   string form, the conversion most likely performed using &#39;strftime&#39; routine, but use of the</span>
<span class="c1">//   &#39;printf&#39; family is also possible</span>
<span class="c1">//</span>
<span class="c1">// * Despite a few exceptions, the date / time library routines are well standardised [just</span>
<span class="c1">//   include the &lt;time.h&gt; header], so are available across platforms. The widely-implemented,</span>
<span class="c1">//   though *NIX-specific, routines include:</span>
<span class="c1">//   - &#39;gettimeofday&#39;, essentially a higher resolution [microseconds, possibly nanoseconds]</span>
<span class="c1">//      version of &#39;time&#39;</span>
<span class="c1">//   - &#39;strptime&#39; and &#39;getdate&#39;, both routines similar in functionlity to &#39;sscanf&#39; but using</span>
<span class="c1">//     format specifications specialised for date / time handling</span>
<span class="c1">//</span>
<span class="c1">// Implementations of general purpose date routines [which are generally used in several</span>
<span class="c1">// sections] appear here. Protoypes appear in each section in which they are used. To</span>
<span class="c1">// successfully compile examples ensure the relevant code from this section is copied into</span>
<span class="c1">// the example source file.</span>

<span class="k">struct</span> <span class="n">tm</span> <span class="n">mk_tm</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minute</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span>
  <span class="p">{</span>
    <span class="p">.</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">hour</span><span class="p">,</span> <span class="p">.</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">minute</span><span class="p">,</span> <span class="p">.</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">second</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tm_year</span> <span class="o">=</span> <span class="n">year</span> <span class="o">-</span> <span class="mi">1900</span><span class="p">,</span> <span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="n">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="n">day</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tm_isdst</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="p">};</span>

  <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">tmv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">tm</span> <span class="n">mk_tm_unfilled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// -1 value used to indicate &#39;unfilled&#39; since zero is a legitimate value in some fields</span>
  <span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">tm</span><span class="p">)</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">});</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">tm</span> <span class="n">mk_tm_zero</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">tm</span><span class="p">)</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">show_tm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">+</span> <span class="mi">1900</span> <span class="o">:</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_year</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_mon</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Y/M/D H:M:S -&gt; %04d/%02d/%02d %02d:%02d:%02d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">,</span>
    <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_hour</span><span class="p">,</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_min</span><span class="p">,</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_sec</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;DOW: %02d</span><span class="se">\n</span><span class="s">DOY: %02d</span><span class="se">\n</span><span class="s">Daylight Saving: %02d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_wday</span><span class="p">,</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_yday</span><span class="p">,</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_isdst</span><span class="p">);</span>

  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Note: Equivalent of &#39;timegm&#39; function implemented on *NIX platforms [code may be &#39;unpacked&#39;</span>
<span class="c1">// for compilers not supporting nested functions] using the more portable technique of changing,</span>
<span class="c1">// temporarily, the TZ value</span>
<span class="kt">time_t</span> <span class="n">mktime_utc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">NUL</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="kt">char</span> <span class="n">tzold</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">NUL</span><span class="p">},</span> <span class="n">tznew</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">NUL</span><span class="p">};</span>

  <span class="kt">void</span> <span class="nf">save_tz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">tz</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&quot;TZ&quot;</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="n">tz</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">tzold</span><span class="p">,</span> <span class="n">tz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">restore_tz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">tz</span> <span class="o">=</span> <span class="p">(</span><span class="n">tzold</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NUL</span><span class="p">)</span> <span class="o">?</span> <span class="n">strcat</span><span class="p">(</span><span class="n">strcpy</span><span class="p">(</span><span class="n">tznew</span><span class="p">,</span> <span class="s">&quot;TZ=&quot;</span><span class="p">),</span> <span class="n">tzold</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;TZ&quot;</span><span class="p">;</span>
    <span class="n">putenv</span><span class="p">(</span><span class="n">tz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">save_tz</span><span class="p">();</span>
  <span class="n">putenv</span><span class="p">(</span><span class="s">&quot;TZ=UTC&quot;</span><span class="p">);</span>
  <span class="kt">time_t</span> <span class="n">utc</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="n">tmvptr</span><span class="p">);</span>
  <span class="n">restore_tz</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">utc</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// The following helper functions are loosely based on the implementations found in the</span>
<span class="c1">// corresponding section(s) of PLEAC-PHP. The &#39;mk_date_interval&#39; function is notable for</span>
<span class="c1">// several reasons:</span>
<span class="c1">// * Heavy use of pointer manipulation to search and tokenise string contents; illustrative</span>
<span class="c1">//   of a faster, more lightweight, though considerably more complex, approach to this task</span>
<span class="c1">//   when compared with use of library functions like &#39;strtok&#39;, &#39;strstr&#39; and &#39;strchr&#39;</span>
<span class="c1">// * Comprehensive example of both variable-argument handling, and of sensible nested function</span>
<span class="c1">//   use</span>
<span class="c1">// * The &#39;parse_entry&#39; nested function illustrates an approach that can be used for mimicing</span>
<span class="c1">//   named function parameters</span>
<span class="c1">// * Use of a delimited string as a lookup table in the &#39;getvalue&#39; nested function is mainly</span>
<span class="c1">//   illustrative. Better performance can be obtained by other means; if still opting for a</span>
<span class="c1">//   string-based lookup table approach, a &#39;perfect hash&#39;-based technique would be ideal,</span>
<span class="c1">//   though would require much more code to implement</span>
<span class="c1">//</span>
<span class="c1">// This function, together with &#39;to_epoch&#39; and &#39;from_epoch&#39;, make use of string parameters</span>
<span class="c1">// to represent a keyword. In C this approach wouldn&#39;t ordinarily be used because such</span>
<span class="c1">// information can most often be encode in integer form e.g. integer constants or enumerations,</span>
<span class="c1">// and the processing of integers is dramatically faster and far more efficient than string</span>
<span class="c1">// operations such as linear searching and comparision. However, the reason for adopting this</span>
<span class="c1">// string-based approach is to mimic the beahviour of the PLEAC-PHP implementations, as well</span>
<span class="c1">// as illustrate various C techniques such as pointer manipulation and variable argument</span>
<span class="c1">// handling.</span>
<span class="c1">//</span>
<span class="c1">// As an aside, error checking is minimal in most of these functions, and could certainly be</span>
<span class="c1">// improved.</span>

<span class="kt">time_t</span> <span class="n">mk_date_interval</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg1</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">EQ</span> <span class="o">=</span> <span class="sc">&#39;=&#39;</span><span class="p">,</span> <span class="n">COMMA</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">,</span> <span class="n">NUL</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

  <span class="c1">// ----</span>

  <span class="kt">char</span><span class="o">*</span> <span class="nf">parse_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">entry</span><span class="p">;</span> <span class="c1">// Assumes: &quot;key=value&quot; form</span>

    <span class="c1">// Extract, and convert &#39;value&#39;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="n">EQ</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="n">NUL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

    <span class="c1">// Extract &#39;key&#39;, copy to buffer for return</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">entry</span> <span class="o">!=</span> <span class="n">EQ</span><span class="p">)</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">entry</span><span class="o">++</span><span class="p">;</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ----</span>

  <span class="kt">int</span> <span class="nf">getvalue</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Lookup table implemented as a delimited string</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">TBL</span> <span class="o">=</span> <span class="s">&quot;sec=1,min=60,hou=3600,day=86400,wee=604800&quot;</span><span class="p">;</span>

    <span class="c1">// Perform table lookup [via linear search (slow) of string]</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">strcasestr</span><span class="p">(</span><span class="n">TBL</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Extract table value. Since table is in delimited string form, use pointer</span>
    <span class="c1">// manipulation to mark start and end locations of required substring [value for key].</span>
    <span class="c1">// Since locations are in a string constant, NUL-termination cannot be performed</span>
    <span class="c1">// in-place, so substring is copied to a buffer for subsequent processing</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="n">EQ</span><span class="p">)</span> <span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">q</span> <span class="o">!=</span> <span class="n">NUL</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">q</span> <span class="o">==</span> <span class="n">COMMA</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="k">else</span> <span class="o">++</span><span class="n">q</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span>
    <span class="o">*</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">atoi</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ----</span>

  <span class="kt">int</span> <span class="n">interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">;</span>

  <span class="c1">// Extract values from 1st argument</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">parse_entry</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">interval</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

  <span class="c1">// Setup for variable argument handling, and extract values from each of these</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg</span><span class="p">;</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">arg1</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">((</span><span class="n">arg</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">parse_entry</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">interval</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">interval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">time_t</span> <span class="n">to_epoch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">intvltype</span><span class="p">,</span> <span class="kt">double</span> <span class="n">multiple</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">time_t</span><span class="p">)</span> <span class="n">floor</span><span class="p">(</span><span class="n">multiple</span> <span class="o">*</span> <span class="n">get_date_interval_value</span><span class="p">(</span><span class="n">intvltype</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="n">from_epoch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">intvltype</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">tv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">get_date_interval_value</span><span class="p">(</span><span class="n">intvltype</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">?</span> <span class="n">tv</span> <span class="o">/</span> <span class="n">interval</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="n">get_date_interval_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">intvltype</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">interval</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

  <span class="c1">// What, no lookup table ;) ?</span>
  <span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">intvltype</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;d&#39;</span> : <span class="n">interval</span> <span class="o">=</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">intvltype</span><span class="p">,</span> <span class="s">&quot;day&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">86400.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;h&#39;</span> : <span class="n">interval</span> <span class="o">=</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">intvltype</span><span class="p">,</span> <span class="s">&quot;hou&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">3600.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;m&#39;</span> : <span class="n">interval</span> <span class="o">=</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">intvltype</span><span class="p">,</span> <span class="s">&quot;min&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">60.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;s&#39;</span> : <span class="n">interval</span> <span class="o">=</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">intvltype</span><span class="p">,</span> <span class="s">&quot;sec&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;w&#39;</span> : <span class="n">interval</span> <span class="o">=</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">intvltype</span><span class="p">,</span> <span class="s">&quot;wee&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">604800.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">interval</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="n">doy</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">BASE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// Zero base [i.e. 1st day is zero] assumed</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cumdays</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">151</span><span class="p">,</span> <span class="mi">181</span><span class="p">,</span> <span class="mi">212</span><span class="p">,</span> <span class="mi">243</span><span class="p">,</span> <span class="mi">273</span><span class="p">,</span> <span class="mi">304</span><span class="p">,</span> <span class="mi">334</span><span class="p">,</span> <span class="mi">365</span> <span class="p">};</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">month</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">month</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">BASE</span> <span class="o">+</span> <span class="n">cumdays</span><span class="p">[</span><span class="n">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">day</span> <span class="o">+</span> <span class="p">(</span><span class="n">is_leap_year</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">month</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">dayname</span><span class="p">(</span><span class="kt">int</span> <span class="n">day</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">dnams</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Sunday&quot;</span><span class="p">,</span> <span class="s">&quot;Monday&quot;</span><span class="p">,</span> <span class="s">&quot;Tuesday&quot;</span><span class="p">,</span> <span class="s">&quot;Wednesday&quot;</span><span class="p">,</span> <span class="s">&quot;Thursday&quot;</span><span class="p">,</span> <span class="s">&quot;Friday&quot;</span><span class="p">,</span> <span class="s">&quot;Saturday&quot;</span> <span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">day</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">day</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">dnams</span><span class="p">[</span><span class="n">day</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">bool</span> <span class="n">is_parseable_date</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">date</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">datebuf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

  <span class="c1">// Date / time string is parsed according to format specification; if it fails it can</span>
  <span class="c1">// be assumed a format or type error occurred</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strptime</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tmvptr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">datebuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\1&#39;</span><span class="p">;</span>
    <span class="c1">// Attempt to generate a date / time string using the previously created broken-time</span>
    <span class="c1">// value; if it succeeds it can be assumed the broken-down value is sound, but further</span>
    <span class="c1">// validation is needed to ensure the value is truly &#39;valid&#39;</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">strftime</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">datebuf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tmvptr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">datebuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">is_leap_year</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">year</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">year</span> <span class="o">%</span> <span class="mi">400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">is_valid_hms</span><span class="p">(</span><span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minute</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Purely arbitrary choice; allows 24:00:00, but may be omitted</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hour</span> <span class="o">==</span> <span class="mi">24</span> <span class="o">&amp;&amp;</span> <span class="n">minute</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">second</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">hour</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">hour</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">minute</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">minute</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">second</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">second</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">is_valid_ymd</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">mtbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span> <span class="p">};</span>

  <span class="c1">// Purely arbitrary choice; may be modified or omitted</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&lt;</span> <span class="mi">1970</span> <span class="o">||</span> <span class="n">year</span> <span class="o">&gt;</span> <span class="mi">2038</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">month</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">month</span> <span class="o">&lt;</span> <span class="mi">13</span> <span class="o">&amp;&amp;</span> <span class="n">day</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">day</span> <span class="o">&lt;=</span> <span class="n">mtbl</span><span class="p">[</span><span class="n">month</span><span class="p">])</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">day</span> <span class="o">==</span> <span class="mi">29</span> <span class="o">&amp;&amp;</span> <span class="n">month</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">is_leap_year</span><span class="p">(</span><span class="n">year</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">is_valid_tm</span><span class="p">(</span><span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span>
    <span class="n">is_valid_hms</span><span class="p">(</span><span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_hour</span><span class="p">,</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_min</span><span class="p">,</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_sec</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">is_valid_ymd</span><span class="p">(</span><span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">+</span> <span class="mi">1900</span><span class="p">,</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tmvptr</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">mktime</span><span class="p">(</span><span class="n">tmvptr</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mk_fmt_date</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">datebuf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">strftime</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">datebuf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tmvptr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">datebuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">double</span> <span class="n">hms_to_frac</span><span class="p">(</span><span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">hour</span> <span class="o">*</span> <span class="mi">3600</span> <span class="o">+</span> <span class="n">min</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">sec</span><span class="p">)</span> <span class="o">/</span> <span class="mf">86400.</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">frac_to_hms</span><span class="p">(</span><span class="kt">double</span> <span class="n">frac</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">seconds</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">frac</span> <span class="o">*</span> <span class="mf">86400.</span><span class="p">);</span>

  <span class="o">*</span><span class="n">hour</span> <span class="o">=</span> <span class="n">seconds</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">;</span>
  <span class="o">*</span><span class="n">min</span> <span class="o">=</span> <span class="p">(</span><span class="n">seconds</span> <span class="o">-</span> <span class="o">*</span><span class="n">hour</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">)</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>
  <span class="o">*</span><span class="n">sec</span> <span class="o">=</span> <span class="p">(</span><span class="n">seconds</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">hour</span> <span class="o">*</span> <span class="mi">3600</span> <span class="o">+</span> <span class="o">*</span><span class="n">min</span> <span class="o">*</span> <span class="mi">60</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.1</span>
<span class="c1">// The current date may be obtained by two means:</span>
<span class="c1">// * &#39;time&#39; library function call; this is the standard, cross-platform approach, which</span>
<span class="c1">//   returns a value in Epoch Seconds [elapsed seconds since Jan 1, 1970]</span>
<span class="c1">// * &#39;gettimeofday&#39; library function; *NIX-specific approach which is similar to &#39;time&#39;</span>
<span class="c1">//   function, but also allows values retrieveable to microsecond resolution</span>
<span class="c1">//</span>
<span class="c1">// Once an epoch second value is so obtained it is usual to convert it to a broken-down time</span>
<span class="c1">// representation for subsequent manipulation, particularly conversion to string form for</span>
<span class="c1">// output. If however, date arithmetic is to be performed, it is more common to see it done</span>
<span class="c1">// directly in epoch second form</span>

<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Current time: epoch seconds</span>
  <span class="kt">time_t</span> <span class="n">curtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Current time: broken-down time</span>
  <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">locptr</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;time.h&gt;</span>
<span class="cp">#include &lt;sys/time.h&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Current time: epoch seconds</span>
  <span class="kt">time_t</span> <span class="n">curtime</span> <span class="o">=</span> <span class="p">({</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="n">timev</span><span class="p">;</span> <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="n">timev</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span> <span class="p">});</span>

  <span class="c1">// Current time: broken-down time</span>
  <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">locptr</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">time_t</span> <span class="n">curtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Print standard format date string generated from a simple-time value</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;today is %s&quot;</span><span class="p">,</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">));</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">locptr</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">);</span>

  <span class="c1">// Print standard format date string generated from a broken-time value</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;today is %s&quot;</span><span class="p">,</span> <span class="n">asctime</span><span class="p">(</span><span class="n">locptr</span><span class="p">));</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// Use &#39;strftime&#39; and date format specification to generate date string</span>
  <span class="kt">char</span> <span class="n">datebuf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="n">strftime</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">datebuf</span><span class="p">),</span> <span class="s">&quot;%Y-%m-%d&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;today is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">datebuf</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// Extract broken-down time components, and format string using &#39;printf&#39;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;today is %04d-%02d-%02d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">+</span> <span class="mi">1900</span><span class="p">,</span>
    <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">);</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.2</span>
<span class="c1">// The &#39;mktime&#39; library function fulfils this role by converting a broken-down time value to</span>
<span class="c1">// the required epoch seconds. By default the generated value is local time based; a custom</span>
<span class="c1">// function is provided for UTC-based time</span>

<span class="cp">#include &lt;time.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="k">struct</span> <span class="n">tm</span> <span class="n">mk_tm</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minute</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">);</span>
<span class="kt">time_t</span> <span class="nf">mktime_utc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Create a broken-down time value from arbitrary component values [Y,M,D,H,M,S]</span>
  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="n">mk_tm</span><span class="p">(</span><span class="mi">2007</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Convert a broken-down time value to epoch seconds [local time assumed]</span>
  <span class="kt">time_t</span> <span class="n">epoch_seconds_local</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span>

  <span class="c1">// Convert a broken-down time value to epoch seconds [UTC time]</span>
  <span class="kt">time_t</span> <span class="n">epoch_seconds_utc</span> <span class="o">=</span> <span class="n">mktime_utc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.3</span>
<span class="c1">// Two library functions fulfil this role:</span>
<span class="c1">// * &#39;localtime&#39;, generates a local time-based value</span>
<span class="c1">// * &#39;gmtime&#39;, as above, except generated value is UTC-based</span>

<span class="cp">#include &lt;time.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Current time: epoch seconds</span>
  <span class="kt">time_t</span> <span class="n">curtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Current time: broken-down time [local time-based]</span>
  <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">locptr</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">);</span>

  <span class="c1">// Current time: broken-down time [UTC-based]</span>
  <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">utcptr</span> <span class="o">=</span> <span class="n">gmtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Dateline: %02d:%02d:%02d-%04d/%02d/%02d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_hour</span><span class="p">,</span> <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_min</span><span class="p">,</span> <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_sec</span><span class="p">,</span>
    <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">+</span> <span class="mi">1900</span><span class="p">,</span> <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">);</span>

  <span class="k">struct</span> <span class="n">tm</span> <span class="n">loct</span> <span class="o">=</span> <span class="o">*</span><span class="n">locptr</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Dateline: %02d:%02d:%02d-%04d/%02d/%02d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">loct</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">,</span> <span class="n">loct</span><span class="p">.</span><span class="n">tm_min</span><span class="p">,</span> <span class="n">loct</span><span class="p">.</span><span class="n">tm_sec</span><span class="p">,</span>
    <span class="n">loct</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">+</span> <span class="mi">1900</span><span class="p">,</span> <span class="n">loct</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">loct</span><span class="p">.</span><span class="n">tm_mday</span><span class="p">);</span>

  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.4</span>
<span class="c1">// This task entails the conversion of all dates to be so treated to epoch seconds, which can</span>
<span class="c1">// then be arithmetically manipulated. A number of helper functions are included:</span>
<span class="c1">// * &#39;to_epoch&#39;, &#39;from_epoch&#39;; convert a time interval e.g. day, week etc to / from epoch second</span>
<span class="c1">//   intervals</span>
<span class="c1">// * &#39;mk_date_interval&#39;, creates an epoch second interval from a set of disparate time intervals</span>
<span class="c1">// * &#39;frac_to_hms&#39; and &#39;hms_to_frac&#39; convert fractional days to / from H:M:S values</span>
<span class="c1">//</span>
<span class="c1">// In general, arithmetic manipulation of &#39;time_t&#39; values is safe, but on platforms where it</span>
<span class="c1">// may not be implemented as an &#39;int&#39; or related type, the &#39;difftime&#39; library function should</span>
<span class="c1">// used</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;math.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">time_t</span> <span class="nf">mk_date_interval</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg1</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">double</span> <span class="nf">get_date_interval_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">intvltype</span><span class="p">);</span>

<span class="kt">time_t</span> <span class="nf">to_epoch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">intvltype</span><span class="p">,</span> <span class="kt">double</span> <span class="n">multiple</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">from_epoch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">intvltype</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">tv</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">mk_fmt_date</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">tm</span> <span class="nf">mk_tm</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minute</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">time_t</span> <span class="n">now</span><span class="p">,</span> <span class="n">difference</span><span class="p">;</span>

  <span class="kt">time_t</span> <span class="n">when</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">difference</span><span class="p">;</span>     <span class="c1">// &#39;difference&#39; epoch seconds in the future</span>
  <span class="kt">time_t</span> <span class="n">then</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">difference</span><span class="p">;</span>     <span class="c1">// &#39;difference&#39; epoch seconds in the past</span>

  <span class="c1">// ------------</span>

  <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="kt">time_t</span> <span class="n">diff1</span> <span class="o">=</span> <span class="n">to_epoch</span><span class="p">(</span><span class="s">&quot;day&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
         <span class="n">diff2</span> <span class="o">=</span> <span class="n">to_epoch</span><span class="p">(</span><span class="s">&quot;week&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Today is:                  %s&quot;</span><span class="p">,</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Two days in the future is: %s&quot;</span><span class="p">,</span> <span class="p">({</span> <span class="kt">time_t</span> <span class="n">tv</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">diff1</span><span class="p">;</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span> <span class="p">}));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Two weeks in the past is:  %s&quot;</span><span class="p">,</span> <span class="p">({</span> <span class="kt">time_t</span> <span class="n">tv</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">diff2</span><span class="p">;</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span> <span class="p">}));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Today is:                  %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%Y-%m-%d&quot;</span><span class="p">,</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">)));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Two days in the future is: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="p">({</span> <span class="kt">time_t</span> <span class="n">tv</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">diff1</span><span class="p">;</span> <span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%Y-%m-%d&quot;</span><span class="p">,</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">));</span> <span class="p">}));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Two weeks in the past is:  %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="p">({</span> <span class="kt">time_t</span> <span class="n">tv</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">diff2</span><span class="p">;</span> <span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%Y-%m-%d&quot;</span><span class="p">,</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">));</span> <span class="p">}));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// ------------</span>

  <span class="kt">time_t</span> <span class="n">birthtime</span> <span class="o">=</span> <span class="mi">96176750</span><span class="p">;</span>                  <span class="c1">// 18/Jan/1973, 3:45:50 am</span>

  <span class="kt">time_t</span> <span class="n">interval</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span>                         <span class="c1">// 5 seconds</span>
                    <span class="mi">17</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span>                   <span class="c1">// 17 minutes</span>
                    <span class="mi">2</span>  <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span>              <span class="c1">// 2 hours</span>
                    <span class="mi">55</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span><span class="p">;</span>          <span class="c1">// and 55 days</span>

  <span class="n">then</span> <span class="o">=</span> <span class="n">birthtime</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>

  <span class="c1">// Then is Wed Mar 14 06:02:55 1973</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Then is %s&quot;</span><span class="p">,</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">then</span><span class="p">));</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// ------------</span>

  <span class="n">birthtime</span> <span class="o">=</span> <span class="p">({</span> <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="n">mk_tm</span><span class="p">(</span><span class="mi">1973</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span> <span class="p">});</span>

  <span class="n">interval</span> <span class="o">=</span> <span class="n">mk_date_interval</span><span class="p">(</span><span class="s">&quot;day=55&quot;</span><span class="p">,</span> <span class="s">&quot;hou=2&quot;</span><span class="p">,</span> <span class="s">&quot;min=17&quot;</span><span class="p">,</span> <span class="s">&quot;sec=5&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">then</span> <span class="o">=</span> <span class="n">birthtime</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;To be precise: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%H:%M:%S, %Y-%m-%d&quot;</span><span class="p">,</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">then</span><span class="p">)));</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.5</span>
<span class="c1">// Refer to explanation in previous section</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;math.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">double</span> <span class="nf">get_date_interval_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">intvltype</span><span class="p">);</span>

<span class="kt">time_t</span> <span class="nf">to_epoch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">intvltype</span><span class="p">,</span> <span class="kt">double</span> <span class="n">multiple</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">from_epoch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">intvltype</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">tv</span><span class="p">);</span>

<span class="kt">double</span> <span class="nf">hms_to_frac</span><span class="p">(</span><span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sec</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">frac_to_hms</span><span class="p">(</span><span class="kt">double</span> <span class="n">frac</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sec</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tm</span> <span class="nf">mk_tm</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minute</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">time_t</span> <span class="n">recent</span><span class="p">,</span> <span class="n">earlier</span><span class="p">;</span>

  <span class="kt">time_t</span> <span class="n">seconds</span> <span class="o">=</span> <span class="n">recent</span> <span class="o">-</span> <span class="n">earlier</span><span class="p">;</span>  <span class="c1">// &#39;seconds&#39; is epoch seconds interval</span>

  <span class="c1">// ------------</span>

  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv1</span> <span class="o">=</span> <span class="n">mk_tm</span><span class="p">(</span><span class="mi">1982</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">tmv2</span> <span class="o">=</span> <span class="n">mk_tm</span><span class="p">(</span><span class="mi">1981</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="kt">time_t</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv1</span><span class="p">)</span> <span class="o">-</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv2</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">days</span> <span class="o">=</span> <span class="n">from_epoch</span><span class="p">(</span><span class="s">&quot;day&quot;</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;An interval of %d epoch seconds is %.3f days</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">days</span><span class="p">);</span>

  <span class="c1">// ------------</span>

  <span class="kt">time_t</span> <span class="n">bree</span> <span class="o">=</span> <span class="mi">361535725</span><span class="p">;</span>            <span class="c1">// 16 Jun 1981, 4:35:25 [actually: 20:35:25]</span>
  <span class="kt">time_t</span> <span class="n">nat</span> <span class="o">=</span> <span class="mi">96201950</span><span class="p">;</span>              <span class="c1">// 18 Jan 1973, 3:45:50 [actually: 21:45:50]</span>

  <span class="kt">time_t</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">bree</span> <span class="o">-</span> <span class="n">nat</span><span class="p">;</span>     <span class="c1">// Or do: difference = difftime(bree, nat);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;There were %d seconds between Nat and Bree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">difference</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// ----</span>

  <span class="c1">// Or do following to ensure correctly adjusted intervals are generated:</span>
  <span class="n">bree</span> <span class="o">=</span> <span class="p">({</span> <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="n">mk_tm</span><span class="p">(</span><span class="mi">1981</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span> <span class="p">});</span>
  <span class="n">nat</span> <span class="o">=</span> <span class="p">({</span> <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="n">mk_tm</span><span class="p">(</span><span class="mi">1973</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span> <span class="p">});</span>

  <span class="n">difference</span> <span class="o">=</span> <span class="n">bree</span> <span class="o">-</span> <span class="n">nat</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;There were %d seconds between Nat and Bree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">difference</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// ------------</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;There were %.3f seconds between Nat and Bree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">from_epoch</span><span class="p">(</span><span class="s">&quot;sec&quot;</span><span class="p">,</span> <span class="n">difference</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;There were %.3f minutes between Nat and Bree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">from_epoch</span><span class="p">(</span><span class="s">&quot;min&quot;</span><span class="p">,</span> <span class="n">difference</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;There were %.3f hours between Nat and Bree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">from_epoch</span><span class="p">(</span><span class="s">&quot;hour&quot;</span><span class="p">,</span> <span class="n">difference</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;There were %.3f days between Nat and Bree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">from_epoch</span><span class="p">(</span><span class="s">&quot;day&quot;</span><span class="p">,</span> <span class="n">difference</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;There were %.3f weeks between Nat and Bree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">from_epoch</span><span class="p">(</span><span class="s">&quot;week&quot;</span><span class="p">,</span> <span class="n">difference</span><span class="p">));</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// ------------</span>

  <span class="kt">double</span> <span class="n">frac</span> <span class="o">=</span> <span class="p">({</span> <span class="kt">double</span> <span class="n">days</span> <span class="o">=</span> <span class="n">from_epoch</span><span class="p">(</span><span class="s">&quot;day&quot;</span><span class="p">,</span> <span class="n">difference</span><span class="p">);</span> <span class="n">days</span> <span class="o">-</span> <span class="n">floor</span><span class="p">(</span><span class="n">days</span><span class="p">);</span> <span class="p">});</span>
  <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span><span class="p">;</span>

  <span class="n">frac_to_hms</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hour</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sec</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Bree came %d days, %d:%d:%d after Nat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">from_epoch</span><span class="p">(</span><span class="s">&quot;day&quot;</span><span class="p">,</span> <span class="n">difference</span><span class="p">),</span>
    <span class="n">hour</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span><span class="p">);</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.6</span>
<span class="c1">// These are obtainable by generating a broken-down time value, and either:</span>
<span class="c1">// * Computing the required item using data from the relevant &#39;tm_&#39; fields</span>
<span class="c1">// * Calling the &#39;strftime&#39; library function with the broken-down time value, and</span>
<span class="c1">//   appropriate format specification. Examples use &#39;mk_fmt_date&#39; which makes use of</span>
<span class="c1">//   &#39;strftime&#39;</span>
<span class="c1">// It should be noted that each item may have several possible values, so care is needed</span>
<span class="c1">// in interpreting results</span>

<span class="cp">#include &lt;stdbool.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">mk_fmt_date</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tm</span> <span class="nf">mk_tm</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minute</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">is_leap_year</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">doy</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">dayname</span><span class="p">(</span><span class="kt">int</span> <span class="n">day</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Current time in broken-down time form</span>
  <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">locptr</span> <span class="o">=</span> <span class="p">({</span> <span class="kt">time_t</span> <span class="n">curtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">);</span> <span class="p">});</span>

  <span class="kt">int</span> <span class="n">day_of_week</span><span class="p">,</span> <span class="n">day_of_year</span><span class="p">,</span> <span class="n">week_of_year</span><span class="p">;</span>

  <span class="n">day_of_week</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%w&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">));</span>   <span class="c1">// 1st DOW: sun=0 -&gt; sat=6</span>

  <span class="n">day_of_week</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%u&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">));</span>   <span class="c1">// 1st DOW: mon=1 -&gt; sun=7</span>
  <span class="n">day_of_week</span> <span class="o">=</span> <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_wday</span><span class="p">;</span>                   <span class="c1">// &quot;   &quot;    &quot;</span>

  <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%j&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">));</span>   <span class="c1">// 1 -&gt; 366</span>
  <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">locptr</span><span class="o">-&gt;</span><span class="n">tm_yday</span><span class="p">;</span>                   <span class="c1">// 0 -&gt; 365</span>
  <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">doy</span><span class="p">(</span><span class="mi">2007</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>                  <span class="c1">// &quot; -&gt; &quot;</span>

  <span class="n">week_of_year</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%U&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">));</span>  <span class="c1">// 0 -&gt; 53; sun 1st day of week 1;</span>
                                                   <span class="c1">//          preceding days week 0</span>
  <span class="n">week_of_year</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%V&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">));</span>  <span class="c1">// 1 -&gt; 53; ISO</span>
  <span class="n">week_of_year</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%W&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">));</span>  <span class="c1">// 0 -&gt; 53; mon 1st day of week 1;</span>
                                                   <span class="c1">//          preceding days week 0</span>

  <span class="c1">// ------------</span>

  <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="mi">1981</span><span class="p">,</span> <span class="n">month</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">day</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="n">mk_tm</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d/%d/%d was a %s in week %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">dayname</span><span class="p">(</span><span class="n">tmv</span><span class="p">.</span><span class="n">tm_wday</span><span class="p">),</span> <span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%V&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmv</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.7</span>
<span class="c1">// Parsing date / time values from strings generally sees:</span>
<span class="c1">// * Use of the &#39;strptime&#39; / &#39;getdate&#39; functions on *NIX platforms</span>
<span class="c1">// * Use of &#39;sscanf&#39;</span>
<span class="c1">// * Custom routines [e.g. strtok&#39;-based, regex-based, raw pointer manipulations]</span>
<span class="c1">//</span>
<span class="c1">// to extract date / time components and create broken-down time values from them. The first</span>
<span class="c1">// approach is probably the simplest, but is not possible on all platforms. It is also</span>
<span class="c1">// interesting that it includes only minimal validation capability, that is, while format and</span>
<span class="c1">// type violations are readily detected [e.g. supplying either 2007-12-12, or aaaa/bb/cc, when</span>
<span class="c1">// something like 2007/12/12 is expected], date validity is only minimally checked [e.g.</span>
<span class="c1">// invalid day-month combinations are allowed, as are unrepresentable years (like 1111)], so</span>
<span class="c1">// must be manually implemented. A small set of validation and helper functions is implemented</span>
<span class="c1">// below.</span>
<span class="c1">//</span>
<span class="c1">// Note: &#39;getdate&#39; is a high-level function built using top of &#39;strptime&#39;. It will not be</span>
<span class="c1">// discussed here, so refer to GNU C Library documentation for details.</span>

<span class="c1">// 1. &#39;strptime&#39; Example [conventional use of &#39;strptime&#39;]</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">date</span> <span class="o">=</span> <span class="s">&quot;1998-06-03&quot;</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">FMT</span> <span class="o">=</span> <span class="s">&quot;%Y-%m-%d&quot;</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">strptime</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">FMT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Date parse error ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

  <span class="kt">time_t</span> <span class="n">epoch_seconds</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// 2. &#39;sscanf&#39; Example [conventional use of &#39;sscanf&#39;]</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">date</span> <span class="o">=</span> <span class="s">&quot;1998-06-03&quot;</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">FMT</span> <span class="o">=</span> <span class="s">&quot;%04d-%02d-%02d&quot;</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">FMT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">year</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">month</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">day</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">result</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Date parse error ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">year</span> <span class="o">-</span> <span class="mi">1900</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

  <span class="kt">time_t</span> <span class="n">epoch_seconds</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// 3. &#39;strtok&#39; Example [hardcoded, minimal error checking, assumes date string will not be used</span>
<span class="c1">//    elsewhere, hence may have its contents altered]</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">date</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;1998-06-03&quot;</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">SEP</span> <span class="o">=</span> <span class="s">&quot;-&quot;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ymd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">SEP</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Date parse error ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ymd</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">SEP</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ymd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ymd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ymd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1900</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

  <span class="kt">time_t</span> <span class="n">epoch_seconds</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// 4. Regex Example [hardcoded, minimal error checking. Assumes date string will not be used</span>
<span class="c1">//    elsewhere, hence may have its contents altered]</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="cp">#include &lt;regex.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">date</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;1998-06-03&quot;</span><span class="p">;</span>

  <span class="c1">// Setup regex pattern, and compile; bail out if problem detected</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">PATTERN</span> <span class="o">=</span> <span class="s">&quot;([[:digit:]]{4})-([[:digit:]]{1,2})-([[:digit:]]{1,2})&quot;</span><span class="p">;</span>
  <span class="kt">regex_t</span> <span class="n">rx</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">regcomp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="p">,</span> <span class="n">PATTERN</span><span class="p">,</span> <span class="n">REG_EXTENDED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Date parse error [regex compilation failure] ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Hardcoded for 3 [subexpreesion] matches. Match buffer needs to be one larger to</span>
  <span class="c1">// accomodate whole-expression match]</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">nmatch</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="kt">regmatch_t</span> <span class="n">match</span><span class="p">[</span><span class="n">nmatch</span><span class="p">];</span>

  <span class="c1">// Perform regex match</span>
  <span class="kt">int</span> <span class="n">match_result</span> <span class="o">=</span> <span class="n">regexec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">nmatch</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Regex resources no longer required [only match buffer results required], so free them</span>
  <span class="n">regfree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="p">);</span>

  <span class="c1">// In the current case, a mismatch indicates an ill-formatted date string was supplied,</span>
  <span class="c1">// so bail out</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">match_result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Date parse error [regex mismatch] ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// NUL-terminate subexpression match areas for easy extraction</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">NUL</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

  <span class="n">date</span><span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rm_eo</span><span class="p">]</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span>
  <span class="n">date</span><span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">rm_eo</span><span class="p">]</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span>
  <span class="n">date</span><span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">rm_eo</span><span class="p">]</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span>

  <span class="c1">// Convert each subexpression match to required value</span>
  <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">date</span> <span class="o">+</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rm_so</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">date</span> <span class="o">+</span> <span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">rm_so</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">date</span> <span class="o">+</span> <span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">rm_so</span><span class="p">);</span>

  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">year</span> <span class="o">-</span> <span class="mi">1900</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

  <span class="kt">time_t</span> <span class="n">epoch_seconds</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// 5. Raw Pointer Example [hardcoded, no error checking, assumes date string is in the</span>
<span class="c1">//    correct format, and that it will not be used elsewhere, hence may have its contents</span>
<span class="c1">//    altered]</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">date</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;1998-06-03&quot;</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">char</span> <span class="n">NUL</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">SEP</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">date</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">date</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">;</span>

  <span class="c1">// Traverse date buffer, NUL-terminating each required substring in turn for easy conversion</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="n">SEP</span><span class="p">)</span> <span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span> <span class="n">year</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="n">q</span> <span class="o">=</span> <span class="o">++</span><span class="n">p</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="n">SEP</span><span class="p">)</span> <span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span> <span class="n">month</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="n">q</span> <span class="o">=</span> <span class="o">++</span><span class="n">p</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="n">NUL</span><span class="p">)</span> <span class="p">;</span> <span class="n">day</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">year</span> <span class="o">-</span> <span class="mi">1900</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

  <span class="kt">time_t</span> <span class="n">epoch_seconds</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdbool.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="k">struct</span> <span class="n">tm</span> <span class="nf">mk_tm</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minute</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">tm</span> <span class="nf">mk_tm_unfilled</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">tm</span> <span class="nf">mk_tm_zero</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">show_tm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">);</span>

<span class="kt">bool</span> <span class="nf">is_parseable_date</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">date</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">);</span>

<span class="kt">bool</span> <span class="nf">is_leap_year</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">is_valid_hms</span><span class="p">(</span><span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minute</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">is_valid_ymd</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">is_valid_tm</span><span class="p">(</span><span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Format specification</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">FMT</span> <span class="o">=</span> <span class="s">&quot;%Y/%m/%d&quot;</span><span class="p">;</span>

  <span class="c1">// Initialise &#39;struct tm&#39; object</span>
  <span class="k">struct</span> <span class="n">tm</span> <span class="n">tmv</span> <span class="o">=</span> <span class="n">mk_tm_zero</span><span class="p">();</span>

  <span class="c1">// Use a generously-sized input buffer</span>
  <span class="kt">char</span> <span class="n">datebuf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

  <span class="k">do</span>
  <span class="p">{</span>
    <span class="c1">// Prompt and get a date string from the user</span>
    <span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Enter a date in YYYY/MM/DD form: &quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="n">fgets</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">datebuf</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>

    <span class="c1">// Two stage validation:</span>
    <span class="c1">// * Check that input at least matches &#39;date&#39; form / structure</span>
    <span class="c1">// * Ensure generated date / time components comprise a &#39;sensible&#39; value</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_parseable_date</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="n">FMT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmv</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_valid_tm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">))</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="c1">// Oops !</span>
    <span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Bad date string - try again</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>

  <span class="c1">// Let&#39;s look at the generated date / time components</span>
  <span class="n">show_tm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.8</span>
<span class="c1">// Printing a date usually sees a broken-down time object either supplied or generated, then</span>
<span class="c1">// date components extracted and formatted. This may be accomplished:</span>
<span class="c1">// * Manually; extracting broken-down time components and formatting via a &#39;printf&#39; family</span>
<span class="c1">//   function</span>
<span class="c1">// * Via &#39;strftime&#39; library function, a &#39;printf&#39;-like function that uses a host of date / time</span>
<span class="c1">//   specific format specifications</span>
<span class="c1">//</span>
<span class="c1">// &#39;ctime&#39; and &#39;asctime&#39; library functions are available where only a default string</span>
<span class="c1">// representation is needed.</span>
<span class="c1">//</span>
<span class="c1">// In the final part of this section is a self-contained example illustarting, and discussing</span>
<span class="c1">// in detail, several implementations of a custom function, &#39;mk_fmt_date&#39;, which makes use of</span>
<span class="c1">// &#39;strftime&#39; to generate a formatted date string</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">time_t</span> <span class="n">curtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// &#39;ctime&#39; accepts a &#39;time_t&#39; pointer, and creates a date string in the form:</span>
  <span class="c1">//     &quot;Fri May  4 10:38:03 2007\n&quot;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">));</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">curtmptr</span> <span class="o">=</span> <span class="p">({</span> <span class="kt">time_t</span> <span class="n">curtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">);</span> <span class="p">});</span>

  <span class="c1">// &#39;asctime&#39; accepts a &#39;struct tm&#39; pointer and creates a date string in the form:</span>
  <span class="c1">// &quot;Fri May  4 10:38:03 2007\n&quot;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">asctime</span><span class="p">(</span><span class="n">curtmptr</span><span class="p">));</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="k">struct</span> <span class="n">tm</span> <span class="nf">mk_tm</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minute</span><span class="p">,</span> <span class="kt">int</span> <span class="n">second</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">curtmptr</span> <span class="o">=</span> <span class="p">({</span> <span class="kt">time_t</span> <span class="n">curtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">);</span> <span class="p">});</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span> <span class="o">=</span> <span class="s">&quot;%Y/%m/%d&quot;</span><span class="p">;</span> <span class="c1">// format: YYYY/MM/DD</span>

  <span class="c1">// &#39;strftime&#39; accepts a &#39;struct tm&#39; pointer and creates a date string in the form specified</span>
  <span class="c1">// by a format string, one which is similar to that used by the &#39;printf&#39; function family,</span>
  <span class="c1">// but specialised for date / time formatting. Example below assumes the generated string</span>
  <span class="c1">// will fit within a 32 byte buffer. It is possible to determine the actual buffer size</span>
  <span class="c1">// needed to accomodate the generated string by making an initial call to &#39;strftime&#39;, as</span>
  <span class="c1">// follows:</span>
  <span class="c1">//</span>
  <span class="c1">//    #include &lt;limits.h&gt;</span>
  <span class="c1">//    ...</span>
  <span class="c1">//    int DATESIZE = strftime(NULL, _POSIX_SSIZE_MAX, fmt, curtmptr);</span>
  <span class="c1">//    ...</span>
  <span class="c1">//    char datebuf[DATESIZE + 1];</span>
  <span class="c1">//    ...</span>
  <span class="c1">//    strftime(datebuf, DATESIZE + 1, fmt, curtmptr);</span>
  <span class="c1">//</span>
  <span class="kt">char</span> <span class="n">datebuf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

  <span class="n">strftime</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">datebuf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">curtmptr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">datebuf</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// As above, except that a custom helper function is used to create a &#39;struct tm&#39; object</span>
  <span class="k">struct</span> <span class="n">tm</span> <span class="n">curtm</span> <span class="o">=</span> <span class="n">mk_tm</span><span class="p">(</span><span class="mi">2007</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">strftime</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">datebuf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curtm</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">datebuf</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// As above, except that &#39;printf&#39; is used to perform date string formatting</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%04d/%02d/%02d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curtmptr</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">+</span> <span class="mi">1900</span><span class="p">,</span> <span class="n">curtmptr</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">curtmptr</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">);</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">mk_fmt_date</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">mk_fmt_date_r</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">datebuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufsize</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">mk_fmt_date_a</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">locptr</span> <span class="o">=</span> <span class="p">({</span> <span class="kt">time_t</span> <span class="n">curtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curtime</span><span class="p">);</span> <span class="p">});</span>

  <span class="c1">// 1. Return pointer to static local storage</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mk_fmt_date</span><span class="p">(</span><span class="s">&quot;%Y/%m/%d&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">));</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// 2. Return pointer to supplied buffer</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">BUFSIZE</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFSIZE</span><span class="p">];</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mk_fmt_date_r</span><span class="p">(</span><span class="s">&quot;%Y/%m/%d&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">BUFSIZE</span><span class="p">));</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="c1">// 3. Return dynamically allocated memory pointer</span>

  <span class="c1">// a) Typical use where pointer is captured, used, and finally freed</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">bptr</span> <span class="o">=</span> <span class="n">mk_fmt_date_a</span><span class="p">(</span><span class="s">&quot;%Y/%m/%d&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bptr</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">bptr</span><span class="p">);</span> <span class="n">bptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="c1">// b) Or, for a slightly more compact solution, use the comma operator</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">bptrf</span><span class="p">;</span>
  <span class="n">free</span><span class="p">(((</span><span class="n">bptrf</span> <span class="o">=</span> <span class="n">mk_fmt_date_a</span><span class="p">(</span><span class="s">&quot;%Y/%m/%d&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">)),</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bptrf</span><span class="p">),</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">),</span> <span class="n">bptrf</span><span class="p">));</span>
  <span class="n">bptrf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="c1">// c) Or, for the most compact solution, use a statement expression</span>
  <span class="p">({</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">bptr</span> <span class="o">=</span> <span class="n">mk_fmt_date_a</span><span class="p">(</span><span class="s">&quot;%Y/%m/%d&quot;</span><span class="p">,</span> <span class="n">locptr</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bptr</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span> <span class="n">free</span><span class="p">(</span><span class="n">bptr</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">mk_fmt_date</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Use of static local storage makes the function self-contained, and keeps the interface</span>
  <span class="c1">// uncluttered; an approach adopted, incidentally, in many of the string-handling library</span>
  <span class="c1">// functions. However, since each invocation of the function updates the same buffer, it is</span>
  <span class="c1">// possible, for example, to inadvertantly use a value generated by a call of this function</span>
  <span class="c1">// in another thread, which is why the use of static local storage is not considered &#39;thread</span>
  <span class="c1">// safe&#39; [even use of &#39;buffer locking&#39; code cannot prevent this type of problem]</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">datebuf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">strftime</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">datebuf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tmvptr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">datebuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">mk_fmt_date_r</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">datebuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufsize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// The canonical C approach: supply the function a buffer, and associated buffer size</span>
  <span class="c1">// information, and return the buffer&#39;s address. This approach clutters the function interface,</span>
  <span class="c1">// as well as making function calls more &#39;noisy&#39; since storage for the call needs to be</span>
  <span class="c1">// supplied / allocated, and size information obtained. Its advantage, though, is that thread</span>
  <span class="c1">// safety is assured since each call of the function updates a different memory area</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">strftime</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tmvptr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">datebuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">mk_fmt_date_a</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tmvptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Read-only static local storage is, by definition, thread safe</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">MAXBUFSIZE</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

  <span class="c1">// Function interface is again uncluttered when using dynamic memory, and the function is</span>
  <span class="c1">// also thread safe. However, the function is no longer self-contained in that the returned</span>
  <span class="c1">// buffer address *must* be captured [usually by assignment to a variable], and the allocated</span>
  <span class="c1">// memory later explicitly deallocated</span>
  <span class="kt">size_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="n">strftime</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">MAXBUFSIZE</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tmvptr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">datebuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">bufsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">bufsize</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">datebuf</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">strftime</span><span class="p">(</span><span class="n">datebuf</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tmvptr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">?</span> <span class="n">datebuf</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.9</span>
<span class="c1">// On single-tasking platforms it can be assumed that elapsed time [i.e. the length of an interval</span>
<span class="c1">// between two calendar times] equals processor time [i.e the total amount of time a process has</span>
<span class="c1">// used the CPU]. Not so on multi-tasking platforms where a process relinquishes the CPU [e.g.</span>
<span class="c1">// the scheduler gives the CPU to another process, process blocks waiting for I/O, or voluntarily</span>
<span class="c1">// &#39;goes to sleep&#39;]. It is therefore important to be mindful of the difference, and care taken</span>
<span class="c1">// to use / measure the appropriate one.</span>
<span class="c1">//</span>
<span class="c1">// Elapsed time can portably be measured by performing simple arithmetic using &#39;time_t&#39; values</span>
<span class="c1">// obtained via the &#39;time&#39; function. However, the resolution is quite low, being second-based.</span>
<span class="c1">// Higher resolution timing is possible via platform-specific functionality; in the case of</span>
<span class="c1">// *NIX / GNU platforms, the &#39;gettimeofday&#39; function together with the &#39;timeval&#39; structure,</span>
<span class="c1">// allows for microsecond-level resolution.</span>
<span class="c1">//</span>
<span class="c1">// Should there be a need to measure processor time, the - portable - &#39;clock_t&#39; type with &#39;clock&#39;</span>
<span class="c1">// function is available, while on *NIX / GNU platforms there is &#39;struct tms&#39; together with</span>
<span class="c1">// the &#39;times&#39; function.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">time_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// ... do work here ...</span>

  <span class="kt">time_t</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Elapsed time %.9f seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">difftime</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;sys/time.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">timeval</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">;</span>

  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// ... do work here ...</span>

  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">finish</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">finish</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="p">(</span><span class="n">finish</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.e6</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Elapsed time %.9f seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">clock_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

  <span class="c1">// ... do work here ...</span>

  <span class="kt">clock_t</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

  <span class="kt">double</span> <span class="n">proctime</span> <span class="o">=</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="p">(</span><span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Processor time %.9f seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">proctime</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>
<span class="cp">#include &lt;sys/times.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">long</span> <span class="n">CLOCK_TICKS</span> <span class="o">=</span> <span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_CLK_TCK</span><span class="p">);</span>

  <span class="k">struct</span> <span class="n">tms</span> <span class="n">st_cpu</span><span class="p">,</span> <span class="n">en_cpu</span><span class="p">;</span>

  <span class="kt">clock_t</span> <span class="n">st_time</span> <span class="o">=</span> <span class="n">times</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st_cpu</span><span class="p">);</span>

  <span class="c1">// ... do work here ...</span>

  <span class="kt">clock_t</span> <span class="n">en_time</span> <span class="o">=</span> <span class="n">times</span><span class="p">(</span><span class="o">&amp;</span><span class="n">en_cpu</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Processor Time (seconds):</span><span class="se">\n\t</span><span class="s">Real Time: %.9f, User Time %.9f, System Time %.9f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">difftime</span><span class="p">(</span><span class="n">en_time</span><span class="p">,</span> <span class="n">st_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCK_TICKS</span><span class="p">,</span>
    <span class="n">difftime</span><span class="p">(</span><span class="n">en_cpu</span><span class="p">.</span><span class="n">tms_utime</span><span class="p">,</span> <span class="n">st_cpu</span><span class="p">.</span><span class="n">tms_utime</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCK_TICKS</span><span class="p">,</span>
    <span class="n">difftime</span><span class="p">(</span><span class="n">en_cpu</span><span class="p">.</span><span class="n">tms_stime</span><span class="p">,</span> <span class="n">st_cpu</span><span class="p">.</span><span class="n">tms_stime</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCK_TICKS</span><span class="p">);</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;sys/time.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">timeval</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">;</span>

  <span class="c1">// Start timing</span>
  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// ... do work here ...</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Type in some text, press ENTER when done: &quot;</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

  <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
  <span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>

  <span class="c1">// End timing</span>
  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">finish</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Compute and print elapsed [not processor] time</span>
  <span class="kt">double</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">finish</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="p">(</span><span class="n">finish</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.e6</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;You took %.9f seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>
<span class="cp">#include &lt;sys/time.h&gt;</span>

<span class="kt">void</span> <span class="nf">sort</span><span class="p">(</span><span class="kt">double</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">timeval</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">NUMBER</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">array</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>

  <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUMBER</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>

    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">);</span>

    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">finish</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">elapsed</span> <span class="o">+</span> <span class="p">(</span><span class="n">finish</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="p">(</span><span class="n">finish</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.e6</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Compute and print average elapsed [not processor] time</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;On average, sorting %d random numbers took %.9f seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">,</span> <span class="n">elapsed</span> <span class="o">/</span> <span class="n">NUMBER</span><span class="p">);</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">sort</span><span class="p">(</span><span class="kt">double</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">cmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">lp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">rp</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">lpv</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">)</span> <span class="n">lp</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">rpv</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">)</span> <span class="n">rp</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">lpv</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">rpv</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">lpv</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">rpv</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">qsort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">cmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.10</span>
<span class="c1">// Pausing a process for a designated time period may be accomplished several ways. Only one</span>
<span class="c1">// approach is portable across platforms, but is a &#39;busy waiting&#39;-based approach which, while</span>
<span class="c1">// it allows for sub-second pause periods, has the disadvantage of wasting CPU cycles for the</span>
<span class="c1">// entire pause period.</span>

<span class="cp">#include &lt;time.h&gt;</span>

<span class="kt">void</span> <span class="nf">busywait</span><span class="p">(</span><span class="kt">double</span> <span class="n">seconds</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">busywait</span><span class="p">(</span><span class="mf">0.25</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">busywait</span><span class="p">(</span><span class="kt">double</span> <span class="n">seconds</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">elapsed</span><span class="p">;</span>
  <span class="kt">clock_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

  <span class="k">do</span> <span class="p">{</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="p">(</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">elapsed</span> <span class="o">&lt;</span> <span class="n">seconds</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Approaches where a process is &#39;put to sleep&#39; i.e. suspended, with its share of the CPU</span>
<span class="c1">// allocated to other processes, are inherently platform-specific. Under *NIX / GNU, several</span>
<span class="c1">// library functions may be used:</span>
<span class="c1">// * Combination of either &#39;alarm&#39; or &#39;setitimer&#39;, and &#39;pause&#39;, together with appropriate</span>
<span class="c1">//   signal trapping and handling to avoid problems like potential race conditions. Note:</span>
<span class="c1">//   code below is a simplistic, purely illustrative example, and does not do this [need to</span>
<span class="c1">//   use &#39;sigprocmask&#39;, &#39;sigaction&#39; et al]</span>
<span class="c1">// * Either &#39;sleep&#39; [second-resolution] or &#39;nanosleep&#39; [up to nanosecond-resolution if</span>
<span class="c1">//   supported by the platform]; will terminate before pause period if process receives a</span>
<span class="c1">//   signal</span>
<span class="c1">// * Either &#39;select&#39;, or &#39;poll&#39;, to implement microsecond-resolution pause not interrupted by</span>
<span class="c1">//   signal</span>

<span class="cp">#include &lt;signal.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">void</span> <span class="nf">alarmSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">sec</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Low-resolution: sleep time specified in seconds</span>
  <span class="n">alarmSec</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">alarmSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">sig_alrm</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">sig_alrm</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">alarm</span><span class="p">(</span><span class="n">sec</span><span class="p">);</span>
  <span class="n">pause</span><span class="p">();</span>
  <span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;sys/time.h&gt;</span>

<span class="kt">void</span> <span class="nf">sleepSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">sec</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">sleepMicroSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">usec</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">sleepNanoSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">nsec</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Low-resolution: sleep time specified in seconds</span>
  <span class="n">sleepSec</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// High-resolution: sleep time specified in microseconds</span>
  <span class="n">sleepMicroSec</span><span class="p">(</span><span class="mi">250000</span><span class="p">);</span>

  <span class="c1">// Very high resolution. However, actual resolution is hardware / platform</span>
  <span class="c1">// dependant, and will be rounded up to level actually supported</span>
  <span class="n">sleepNanoSec</span><span class="p">(</span><span class="mi">250000</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">sleepSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span><span class="p">)</span> <span class="p">{</span> <span class="n">sec</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}),</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sleepMicroSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span><span class="p">)</span> <span class="p">{</span> <span class="n">usec</span> <span class="o">/</span> <span class="mi">1000000L</span><span class="p">,</span> <span class="n">usec</span> <span class="o">%</span> <span class="mi">1000000L</span> <span class="o">*</span> <span class="mi">1000000L</span> <span class="p">}),</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sleepNanoSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span><span class="p">)</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nsec</span> <span class="p">}),</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;sys/time.h&gt;</span>

<span class="kt">void</span> <span class="nf">sleepAbsSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">sec</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">sleepAbsMicroSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">usec</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Low-resolution: sleep time specified in seconds</span>
  <span class="n">sleepAbsSec</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// High-resolution: sleep time specified in microseconds</span>
  <span class="n">sleepAbsMicroSec</span><span class="p">(</span><span class="mi">250000</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">sleepAbsSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">select</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">timeval</span><span class="p">)</span> <span class="p">{</span> <span class="n">sec</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sleepAbsMicroSec</span><span class="p">(</span><span class="kt">long</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">select</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">timeval</span><span class="p">)</span> <span class="p">{</span> <span class="n">usec</span> <span class="o">/</span> <span class="mi">1000000L</span><span class="p">,</span> <span class="n">usec</span> <span class="o">%</span> <span class="mi">1000000L</span> <span class="p">}));</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_3.11</span>
<span class="c1">// @@INCOMPLETE@@</span>
<span class="c1">// @@INCOMPLETE@@</span>

<span class="c1">// @@PLEAC@@_5.0</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#define _GNU_SOURCE</span>

<span class="cp">#include &lt;search.h&gt; </span><span class="c1">// hcreate_r() hdestroy_r() struct hsearch_data</span>
<span class="cp">#include &lt;string.h&gt;</span><span class="c1">// memset()</span>
<span class="cp">#include &lt;stdio.h&gt;</span><span class="c1">// perror()</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">//exit()</span>

<span class="cp">#define TAB 4</span>

<span class="p">...</span>

<span class="k">struct</span> <span class="n">hsearch_data</span> <span class="n">hash</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">max_element</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// of elements in search table</span>

<span class="p">...</span>

<span class="kt">char</span> <span class="o">*</span> <span class="n">food</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Apple&quot;</span><span class="p">,</span>
		  <span class="s">&quot;Banana&quot;</span><span class="p">,</span>
		  <span class="s">&quot;Lemon&quot;</span><span class="p">,</span>
		  <span class="s">&quot;Carrot&quot;</span>
<span class="p">};</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">color</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;red&quot;</span><span class="p">,</span>
		   <span class="s">&quot;yellow&quot;</span><span class="p">,</span>
		   <span class="s">&quot;yellow&quot;</span><span class="p">,</span>
		   <span class="s">&quot;orange&quot;</span>
<span class="p">};</span>

<span class="c1">// we create the hash</span>
<span class="n">memset</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hash</span><span class="p">)</span> <span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">hcreate_r</span><span class="p">(</span><span class="n">max_element</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;hcreate_r&quot;</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  adding some elements</span>
<span class="cm">*/</span>

<span class="c1">// we destroy the hash</span>
<span class="n">hdestroy_r</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">hash</span> <span class="p">);</span>

<span class="p">...</span>

<span class="c1">// @@PLEAC@@_5.1</span>
<span class="c1">//------------------------------------------------------------------</span>

<span class="p">...</span>

<span class="kt">void</span> <span class="n">hash_add_element</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">elmt_key</span><span class="p">,</span>
		      <span class="kt">char</span> <span class="o">*</span> <span class="n">elmt_data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">hsearch_data</span> <span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">ENTRY</span> <span class="n">item</span><span class="p">;</span>
  <span class="n">ENTRY</span> <span class="o">*</span> <span class="n">ret</span><span class="p">;</span>

  <span class="n">item</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">elmt_key</span><span class="p">);</span>
  <span class="n">item</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">elmt_data</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span> <span class="n">hsearch_r</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ENTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;hsearch_r&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">ENTRY</span> <span class="n">entry</span><span class="p">;</span>
<span class="n">ENTRY</span> <span class="o">*</span> <span class="n">found</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">  hash creation</span>
<span class="cm">*/</span>

<span class="n">hash_add_element</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">);</span>
<span class="n">hash_add_element</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">);</span>
<span class="n">hash_add_element</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">);</span>
<span class="n">hash_add_element</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">color</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">);</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;Known foods:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TAB</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">entry</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">hsearch_r</span><span class="p">(</span> <span class="n">entry</span><span class="p">,</span> <span class="n">FIND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash</span> <span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">found</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

  <span class="c1">// It is the responsibility of the program code</span>
  <span class="c1">// to free the elements contained in the hashing table</span>
  <span class="n">free</span><span class="p">(</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  hash destruction</span>
<span class="cm">*/</span>

<span class="p">...</span>

<span class="cp"># Known foods:</span>
<span class="cp"># Apple</span>
<span class="cp"># Banana</span>
<span class="cp"># Lemon</span>
<span class="cp"># Carrot</span>

<span class="c1">// @@PLEAC@@_5.2</span>
<span class="c1">//------------------------------------------------------------------</span>

<span class="p">...</span>

<span class="n">entry</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="s">&quot;Martini&quot;</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="n">hsearch_r</span><span class="p">(</span> <span class="n">entry</span><span class="p">,</span> <span class="n">FIND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="c1">// Martini exists</span>
<span class="k">else</span>
  <span class="c1">// it doesn&#39;t</span>

<span class="p">...</span>

<span class="c1">// @@PLEAC@@_5.3</span>
<span class="c1">//------------------------------------------------------------------</span>

<span class="c1">// we can&#39;t delete an element with the hashing table</span>
<span class="c1">// provided by the GNU C library</span>


<span class="c1">// @@PLEAC@@_7.4</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt; </span><span class="c1">// strerror()</span>
<span class="cp">#include &lt;errno.h&gt; </span><span class="c1">// errno</span>

<span class="p">...</span>

<span class="kt">FILE</span> <span class="o">*</span> <span class="n">fp</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
  <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t open %s for reading : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
           <span class="n">filename</span><span class="p">,</span>
           <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">);</span>

<span class="p">...</span>

<span class="c1">// @@PLEAC@@_7.5</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// tmpfile()</span>

<span class="p">...</span>

<span class="kt">FILE</span> <span class="o">*</span> <span class="n">file</span><span class="p">;</span>

<span class="c1">// /!\ the temporary filename isn&#39;t accessible</span>
<span class="n">file</span> <span class="o">=</span> <span class="n">tmpfile</span><span class="p">();</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// remove()</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// mkstemp()</span>

<span class="p">...</span>

<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">template</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

<span class="n">strcpy</span><span class="p">(</span> <span class="n">template</span><span class="p">,</span> <span class="s">&quot;tmp/XXXXXX&quot;</span> <span class="p">);</span>
<span class="n">fd</span> <span class="o">=</span> <span class="n">mkstemp</span><span class="p">(</span> <span class="n">template</span> <span class="p">);</span>

<span class="k">if</span><span class="p">(</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span> <span class="n">mkstemp</span> <span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">remove</span><span class="p">(</span> <span class="n">template</span> <span class="p">);</span>

<span class="c1">// now go on to use the file ...</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// tempnam()</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt; </span><span class="c1">// unlink()</span>
<span class="cp">#include &lt;fcntl.h&gt; </span><span class="c1">// open()</span>
<span class="cp">#include &lt;sys/stat.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>

<span class="p">...</span>

<span class="kt">char</span> <span class="o">*</span> <span class="n">tmpname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">tmpname</span> <span class="o">=</span> <span class="n">tempnam</span><span class="p">(</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">tmpname</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span> <span class="s">&quot;tempname&quot;</span> <span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// is another process creating a temporary file at the same moment?</span>
  <span class="c1">// we don&#39;t know.</span>
  <span class="c1">// =&gt; we have to ensure an exclusive open</span>
  <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span> <span class="n">tmpname</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="mo">0600</span> <span class="p">);</span>

  <span class="c1">// temporary file will be destroy on close() call</span>
  <span class="n">unlink</span><span class="p">(</span> <span class="n">tmpname</span> <span class="p">);</span>

  <span class="n">free</span><span class="p">(</span> <span class="n">tmpname</span> <span class="p">);</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="n">perror</span><span class="p">(</span> <span class="s">&quot;open&quot;</span> <span class="p">);</span>
  <span class="k">else</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// now go on to use the file ...</span>

<span class="p">...</span>


<span class="c1">// @@PLEAC@@_8.2</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cm">/*</span>
<span class="cm">  using external program : wc -l</span>
<span class="cm">*/</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// system(), exit(); malloc(), free()</span>
<span class="cp">#include &lt;string.h&gt; </span><span class="c1">// strlen()</span>
<span class="cp">#include &lt;errno.h&gt; </span><span class="c1">// errno</span>

<span class="p">...</span>

<span class="kt">char</span> <span class="n">file</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// a pathname</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">command</span><span class="p">;</span>

<span class="c1">// we format the shell command</span>
<span class="n">command</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="s">&quot;wc -l &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="s">&quot;%s %s&quot;</span><span class="p">,</span> <span class="s">&quot;wc -l&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="c1">// bad solution</span>

<span class="n">system</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>

<span class="c1">// good solution : using popen() instead of system()</span>

<span class="kt">FILE</span> <span class="o">*</span> <span class="n">message</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">message</span> <span class="o">=</span> <span class="n">popen</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;error popen %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">wc_output</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">fgets</span><span class="p">(</span><span class="n">wc_output</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">wc_output</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">wc_output</span><span class="p">);</span>

<span class="n">pclose</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>

<span class="n">free</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cm">/*</span>
<span class="cm">    using standard C library</span>
<span class="cm">*/</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="p">...</span>

<span class="kt">char</span> <span class="n">file</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// a pathname</span>
<span class="kt">FILE</span> <span class="o">*</span> <span class="n">fp</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span> <span class="n">file</span><span class="p">,</span> <span class="s">&quot;r&quot;</span> <span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;fopen&quot;</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">!=</span> <span class="n">EOF</span> <span class="p">)</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
   <span class="n">line</span><span class="o">++</span><span class="p">;</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;number of lines : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="p">);</span>
<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cm">/*</span>
<span class="cm">    using system calls</span>
<span class="cm">    /!\ fast implementation, the whole file is in memory</span>
<span class="cm">*/</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="cp">#include &lt;fcntl.h&gt; </span><span class="c1">// open()</span>
<span class="cp">#include &lt;sys/stat.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt; </span><span class="c1">// lseek(), close()</span>

<span class="p">...</span>

<span class="kt">char</span> <span class="n">file</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// a pathname</span>
<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>

<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

<span class="n">size</span> <span class="o">=</span> <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span> <span class="p">);</span> <span class="c1">// size of the buffer</span>

<span class="kt">char</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">;</span>
<span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

<span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span> <span class="c1">// back to the beginning of the file</span>

<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">!=</span> <span class="n">size</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;read&quot;</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
    <span class="n">line</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;number of lines : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="p">);</span>

<span class="p">...</span>


<span class="c1">// @@PLEAC@@_9.0</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// perror(), fprintf()</span>
<span class="cp">#include &lt;unistd.h&gt; </span><span class="c1">// stat(), fstat(), lstat()</span>
<span class="cp">#include &lt;sys/stat.h&gt; </span><span class="c1">// struct stat</span>

<span class="p">...</span>

<span class="k">struct</span> <span class="n">stat</span> <span class="n">entry</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span> <span class="n">stat</span><span class="p">(</span><span class="s">&quot;/usr/bin/vi&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">st_mode</span><span class="p">)</span> <span class="p">)</span>
  <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;file</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// perror(), fprintf()</span>
<span class="cp">#include &lt;unistd.h&gt; </span><span class="c1">// stat(), fstat(), lstat()</span>
<span class="cp">#include &lt;sys/stat.h&gt; </span><span class="c1">// struct stat</span>

<span class="p">...</span>

<span class="k">struct</span> <span class="n">stat</span> <span class="n">entry</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span> <span class="n">stat</span><span class="p">(</span><span class="s">&quot;/usr/bin&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">S_ISDIR</span><span class="p">(</span> <span class="n">entry</span><span class="p">.</span><span class="n">st_mode</span><span class="p">)</span> <span class="p">)</span>
  <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;directory</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="c1">// we can&#39;t access the inode of a file with a stream as parameter</span>
<span class="c1">// we need to pass a file descriptor parameter to fstat</span>
<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// perror(), fprintf()</span>
<span class="cp">#include &lt;unistd.h&gt; </span><span class="c1">// stat(), fstat(), lstat()</span>
<span class="cp">#include &lt;sys/stat.h&gt; </span><span class="c1">// struct stat</span>
<span class="cp">#include &lt;fcntl.h&gt; </span><span class="c1">//open()</span>

<span class="p">...</span>

<span class="k">struct</span> <span class="n">stat</span> <span class="n">entry</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span> <span class="c1">// file descriptor</span>
<span class="kt">FILE</span> <span class="o">*</span> <span class="n">fp</span><span class="p">;</span>  <span class="c1">// stream</span>

<span class="k">if</span><span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&quot;/etc/group&quot;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span> <span class="n">fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&quot;r&quot;</span> <span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="c1">// we attach the file descriptor to a stream</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// perror()</span>
<span class="cp">#include &lt;unistd.h&gt; </span><span class="c1">// stat(), fstat(), lstat()</span>
<span class="cp">#include &lt;sys/stat.h&gt; </span><span class="c1">// struct stat</span>
<span class="cp">#include &lt;sys/types.h&gt; </span><span class="c1">// off_t</span>

<span class="p">...</span>

<span class="k">struct</span> <span class="n">stat</span> <span class="n">entry</span><span class="p">;</span>

<span class="kt">time_t</span> <span class="n">ctime</span><span class="p">;</span>
<span class="kt">off_t</span> <span class="n">size</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="n">stat</span><span class="p">(</span><span class="s">&quot;/usr/bin/vi&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

<span class="n">ctime</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">st_ctime</span><span class="p">;</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
<span class="c1">//fprintf( stdout, &quot;ctime: %ld\nsize: %ld\n&quot;, ctime, size );</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="c1">// No equivalent in C ANSI/POSIX/GNU for -T (file is a text file)?</span>
<span class="cm">/*</span>
<span class="cm"># -s for filesize (test if nonzero)</span>
<span class="cm">unless (-s F &amp;&amp; -T _) {</span>
<span class="cm">  die &quot;$filename doesn&#39;t have text in it.\n&quot;;</span>
<span class="cm">}</span>
<span class="cm">*/</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;dirent.h&gt; </span><span class="c1">// struct dirent, opendir(), readdir(), closedir()</span>
<span class="cp">#include &lt;sys/types.h&gt; </span><span class="c1">// DIR type</span>

<span class="p">...</span>

<span class="kt">DIR</span> <span class="o">*</span> <span class="n">dir</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span> <span class="n">entry</span><span class="p">;</span>

<span class="n">dir</span> <span class="o">=</span> <span class="n">opendir</span><span class="p">(</span><span class="s">&quot;/usr/bin&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">dir</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="k">while</span><span class="p">((</span><span class="n">entry</span> <span class="o">=</span> <span class="n">readdir</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;Inside /usr/bin is something called %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">closedir</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

<span class="p">...</span>


<span class="c1">// @@PLEAC@@_9.10</span>
<span class="c1">//------------------------------------------------------------------</span>

<span class="c1">//  we use the XPG version of basename which overrides</span>
<span class="c1">//  the GNU version (not portable) if libgen.h is included</span>
<span class="c1">//  /!\ do not call basename or dirname with a static string (bugs in glibc)</span>

<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// fprintf()</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// free()</span>
<span class="cp">#include &lt;string.h&gt;  </span><span class="c1">// strdup(), strrchr()</span>
<span class="cp">#include &lt;libgen.h&gt;  </span><span class="c1">// basename(), dirname()</span>

<span class="p">...</span>
 <span class="kt">char</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="o">*</span> <span class="n">ext</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">tmp_dirname</span><span class="p">,</span> <span class="o">*</span> <span class="n">tmp_file</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;/usr/lib/libc.a&quot;</span><span class="p">;</span>

<span class="n">tmp_dirname</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="n">tmp_file</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
   <span class="n">dir</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span><span class="n">tmp_dirname</span><span class="p">);</span>
<span class="n">file</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="n">tmp_file</span><span class="p">);</span>
<span class="n">ext</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span> <span class="c1">// extension as everything after the last &#39;.&#39;</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;dir is %s, file is %s, ext is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">ext</span><span class="p">);</span>
<span class="c1">// dir is /usr/lib, file is libc.a, ext is .a</span>
 <span class="n">free</span><span class="p">(</span><span class="n">tmp_file</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">tmp_dirname</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// fprintf()</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// free()</span>
<span class="cp">#include &lt;string.h&gt;  </span><span class="c1">// strdup()</span>
<span class="cp">#include &lt;libgen.h&gt;  </span><span class="c1">// basename(), dirname()</span>

<span class="p">...</span>

<span class="kt">char</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="o">*</span> <span class="n">tmp_file</span><span class="p">,</span> <span class="o">*</span> <span class="n">tmp_dirname</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;/usr/lib/libc.a&quot;</span><span class="p">;</span>

<span class="n">tmp_file</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span> <span class="n">path</span> <span class="p">);</span>
<span class="n">tmp_dirname</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span> <span class="n">path</span> <span class="p">);</span>
<span class="n">dir</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span> <span class="n">tmp_dirname</span> <span class="p">);</span>
<span class="n">file</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span> <span class="n">tmp_file</span> <span class="p">);</span>

<span class="n">fprintf</span><span class="p">(</span> <span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;dir is %s, file is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">file</span> <span class="p">);</span>
<span class="c1">// dir is /usr/lib, file is libc.a</span>
<span class="n">free</span><span class="p">(</span><span class="n">tmp_dirname</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">tmp_file</span><span class="p">);</span>
 <span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="c1">// no equivalent in C for fileparse() but we can</span>
<span class="c1">//  implement a (very basic) similar function</span>

<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// fprintf()</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// free()</span>
<span class="cp">#include &lt;string.h&gt;  </span><span class="c1">// strdup(), strrchr(), strlen()</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Pathname_</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">dirname</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">filename</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">extension</span><span class="p">;</span>
<span class="p">}</span><span class="n">Pathname</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">fileparse</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="n">Pathname</span> <span class="o">*</span> <span class="n">split_path</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">tmp_path</span><span class="p">,</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="o">*</span> <span class="n">extension</span><span class="p">;</span>

  <span class="n">tmp_path</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
 <span class="n">ptr</span><span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span> <span class="n">tmp_path</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
  <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">++</span><span class="p">;</span>

  <span class="c1">// dirname</span>
  <span class="n">split_path</span><span class="o">-&gt;</span><span class="n">dirname</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">);</span>
  <span class="c1">// filename</span>
  <span class="n">split_path</span><span class="o">-&gt;</span><span class="n">filename</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">split_path</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

  <span class="c1">// extension</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span> <span class="c1">// extension as everything</span>
<span class="n">after</span> <span class="n">the</span> <span class="n">last</span> <span class="sc">&#39;.&#39;</span>
  <span class="n">split_path</span><span class="o">-&gt;</span><span class="n">extension</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">extension</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">);</span>
 <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span> <span class="p">{</span>

  <span class="n">Pathname</span> <span class="n">fparsed</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;/usr/lib/libc.a&quot;</span><span class="p">;</span>
 <span class="n">fileparse</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fparsed</span><span class="p">);</span>
 <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;dir is %s, file is %s, ext is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
      <span class="n">fparsed</span><span class="p">.</span><span class="n">dirname</span><span class="p">,</span>
      <span class="n">fparsed</span><span class="p">.</span><span class="n">filename</span><span class="p">,</span>
      <span class="n">fparsed</span><span class="p">.</span><span class="n">extension</span><span class="p">);</span>
  <span class="c1">// dir is /usr/lib, file is libc.a, ext is .a</span>
 <span class="n">free</span><span class="p">(</span><span class="n">fparsed</span><span class="p">.</span><span class="n">dirname</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">fparsed</span><span class="p">.</span><span class="n">filename</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">fparsed</span><span class="p">.</span><span class="n">extension</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="c1">//  we are Unix centric so no equivalent for fileparse_set_fstype(&quot;MacOS&quot;);</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="kt">char</span> <span class="o">*</span> <span class="nf">extension</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">path</span><span class="p">){</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">ext</span><span class="p">;</span>
  <span class="n">ext</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">ext</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ext</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// fprintf(stdout, &quot;ext is %s\n&quot;, extension(path));</span>
<span class="c1">// ext is .a</span>

<span class="c1">// @@PLEAC@@_10.0</span>
<span class="c1">// NOTE: In order to keep the size / verbosity of code examples to a minimum, library function</span>
<span class="c1">// calls will generally not include error checking and handling. Example:</span>
<span class="c1">//</span>
<span class="c1">//     p = malloc(...);                if ((p = malloc(...)) == NULL)</span>
<span class="c1">//                                     {</span>
<span class="c1">//                                       ... handle error ...</span>
<span class="c1">//                                     }</span>
<span class="c1">//</span>
<span class="c1">// However, any necessary, application-specific error-related code, will still be used. Code</span>
<span class="c1">// examples will endeavour, wherever possible, to make use of:</span>
<span class="c1">//</span>
<span class="c1">// * C99 Features e.g. variable-length arrays, non-const aggregate initialisers</span>
<span class="c1">// * GNU Extensions e.g. nested functions, statement expressions</span>
<span class="c1">//</span>
<span class="c1">// The aim of doing so is to reduce redundancy [i.e. copious examples of older / standard C</span>
<span class="c1">// already exist] as well as enhance the information value of each PLEAC example.</span>
<span class="c1">//</span>
<span class="c1">// Another item worthy of note is the use of writeable &#39;static local storage&#39; in many custom</span>
<span class="c1">// functions. Whilst a commonly-used technique that makes functions self-contained, and easier</span>
<span class="c1">// to use [which is precisely why it is used here], it is not viable in multi-threaded code;</span>
<span class="c1">// examples need to be suitably modified to work in such code. The section, &#39;Printing a Date&#39;,</span>
<span class="c1">// in Chapter 3: Dates and Times, discusses this issue, and provides illustrative examples.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">// Declaring the variable as &#39;static&#39; ensures it has &#39;file scope&#39;, that is:</span>
<span class="c1">// * It may be considered globally accessable within the current source file</span>
<span class="c1">// * Is not visible to code defined outside the current file</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">greeted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">howManyGreetings</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">hello</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">hello</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">greetings</span> <span class="o">=</span> <span class="n">howManyGreetings</span><span class="p">();</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;bye there!, there have been %d greetings so far</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">greetings</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">howManyGreetings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">greeted</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hello</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;high there!, this function has been called %d times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">++</span><span class="n">greeted</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.1</span>
<span class="c1">// Standard C requires that a function be prototyped, hence the name and type of parameters</span>
<span class="c1">// must be specified, and the argumemt list in any calls to that function must match the</span>
<span class="c1">// parameter list, as illustrated here.</span>

<span class="cp">#include &lt;math.h&gt;</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Standard C does not support the dynamic packaging / unpackaging of arguments, thus it is</span>
<span class="c1">// *not* possible to call a function which has, for example, been declared to expect two</span>
<span class="c1">// parameters, with a single argument, to to pass it its arguments packed as elements in</span>
<span class="c1">// a single array and expect those elements to be &#39;unpacked&#39; from the array. If the function</span>
<span class="c1">// is to be passed an array when called, then it must be declared to expect an array. Put</span>
<span class="c1">// simply, the function call must conform to the function declaration and definition</span>

<span class="cp">#include &lt;math.h&gt;</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">sidearr</span><span class="p">[]);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">sidearr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">};</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="n">sidearr</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">sidearr</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">sidearr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">sidearr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Scope does exist to implement functions that may be passed a variable number of parameters.</span>
<span class="c1">// However, such functions have to be especially written to determine the number and type of</span>
<span class="c1">// arguments passed, a task that is generally quite precarious because there is little system</span>
<span class="c1">// support for it, and it is strongly reliant on the programmer adhering to certain conventions.</span>
<span class="c1">// For instance, it is not possible to determine the type of the arguments passed. Instead, this</span>
<span class="c1">// must be determined by &#39;hints&#39; [e.g. &#39;printf&#39; uses the format specifiers in the format</span>
<span class="c1">// string to determine argument type], or by strictly adhering to other conventions [e.g.</span>
<span class="c1">// assuming a specific number of arguments, or using a value to indicate the &#39;last&#39; argument</span>

<span class="cp">#include &lt;math.h&gt;</span>
<span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="c1">// Note: at least one parameter must be specified, the rest may then be unspecified i.e. a</span>
<span class="c1">// variable number</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="p">...);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// Note: at least one parameter must be specified, the rest may then be unspecified i.e. a</span>
<span class="c1">// variable number</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">side1</span><span class="p">);</span>

  <span class="c1">// Here we&#39;re assuming exactly two arguments are passed: the first argument is &#39;side1&#39;</span>
  <span class="c1">// and the first [and only] variable argument is extracted into &#39;side2&#39;. Any additional</span>
  <span class="c1">// arguments ar simply ignored. Normally, however, &#39;va_arg&#39; is placed in a loop, and</span>
  <span class="c1">// each argument extracted in turn</span>
  <span class="kt">double</span> <span class="n">side2</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>

  <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stddef.h&gt;</span>

<span class="kt">void</span> <span class="nf">int_all</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">retarr</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">arrsize</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">};</span>

  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">ARRSIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ints</span><span class="p">[</span><span class="n">ARRSIZE</span><span class="p">];</span>

  <span class="n">int_all</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">ints</span><span class="p">,</span> <span class="n">ARRSIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">int_all</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">retarr</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">arrsize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arrsize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Since &#39;retarr&#39; is type &#39;int&#39;, implicit data conversion occurs, but data could</span>
    <span class="c1">// be lost; &#39;arr&#39; is untouched, and is protected since it is &#39;const&#39; qualified</span>
    <span class="n">retarr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stddef.h&gt;</span>
<span class="cp">#include &lt;math.h&gt;</span>

<span class="kt">void</span> <span class="nf">trunc_em</span><span class="p">(</span><span class="kt">double</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">arrsize</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">};</span>
  <span class="n">trunc_em</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">trunc_em</span><span class="p">(</span><span class="kt">double</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">arrsize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arrsize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Safer to use &#39;floor&#39; instead of casting</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.2</span>
<span class="c1">// Variables declared within a function body are local to that function, and those declared</span>
<span class="c1">// outside a function body are global, that is, are visible throughout the executable</span>
<span class="c1">// unless their visibility has been restricted to the source file in which they are defined</span>
<span class="c1">// via the &#39;static&#39; keyword</span>

<span class="kt">void</span> <span class="nf">somefunc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// All these variables are local to this function</span>
  <span class="kt">int</span> <span class="n">variable</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">another</span><span class="p">,</span> <span class="n">an_array</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stddef.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="c1">// File scope variables</span>
<span class="k">static</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">condition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">run_check</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">check_x</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">age</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

  <span class="n">check_x</span><span class="p">(</span><span class="n">age</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">void</span> <span class="nf">run_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Full access to file scope variables</span>
  <span class="n">condition</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">check_x</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Full access to file scope variables</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">y</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;whatever&quot;</span><span class="p">;</span>

  <span class="n">run_check</span><span class="p">();</span>

  <span class="c1">// &#39;condition&#39; updated by &#39;run_check&#39;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.3</span>
<span class="c1">// Through use of the &#39;static&#39; keyword it is possible to create &#39;persistent private variables&#39;,</span>
<span class="c1">// that is, variables that are accessable only by a select set of functions, and that retain</span>
<span class="c1">// their value in between function calls. In Standard C these may be implemented in two ways:</span>
<span class="c1">// * File Scope Variables. Here a source file contains global variable(s) [those residing</span>
<span class="c1">//   outside any function body] declared as &#39;static&#39;. Only the set of function defined within</span>
<span class="c1">//   that file has access those variables, thus they may be considered &#39;private&#39;, and since</span>
<span class="c1">//   they retain their value in between function calls, are also &#39;persistent&#39;</span>

<span class="c1">// File: &#39;mysubs.h&#39;</span>
<span class="kt">void</span> <span class="nf">mysub</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;mysubs.c&#39;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">variable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">mysub</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ... do something with &#39;variable&#39; ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">variable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;test.c&#39;</span>
<span class="cp">#include &quot;mysubs.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// &#39;variable&#39; is not accessable here</span>

  <span class="c1">// Call &#39;mysub&#39;, which can access &#39;variable&#39;</span>
  <span class="n">mysub</span><span class="p">();</span>

  <span class="c1">// Call &#39;reset&#39; which sets &#39;variable&#39; to 1</span>
  <span class="n">reset</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// File: &#39;counter.h&#39;</span>
<span class="kt">int</span> <span class="nf">increment</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">decrement</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// File: &#39;counter.c&#39;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">increment</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">decrement</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">--</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// File: &#39;test.c&#39;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;counter.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">increment</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">decrement</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// * Function Scope Variables. These are local variables declared &#39;static&#39;; they are visible</span>
<span class="c1">//   only within the function body [hence are &#39;private&#39;], and persist in between calls of that</span>
<span class="c1">//   function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">enum</span> <span class="n">CMD_TYPE</span> <span class="p">{</span><span class="n">INC_CMD</span><span class="p">,</span> <span class="n">DEC_CMD</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">Counter</span><span class="p">(</span><span class="k">enum</span> <span class="n">CMD_TYPE</span> <span class="n">cmd_type</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">INC_CMD</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">DEC_CMD</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">Counter</span><span class="p">(</span><span class="k">enum</span> <span class="n">CMD_TYPE</span> <span class="n">cmd_type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// GNU Extension: nested functions, have direct access to &#39;counter&#39;</span>
  <span class="kt">int</span> <span class="n">increment</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">decrement</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">--</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">INC_CMD</span><span class="p">)</span> <span class="n">increment</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cmd_type</span> <span class="o">==</span> <span class="n">DEC_CMD</span><span class="p">)</span> <span class="n">decrement</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.4</span>
<span class="c1">// Standard C offers no facility for performing ad-hoc, runtime stack inspection; therefore,</span>
<span class="c1">// information such as the currently-executing function name, cannot be obtained. However,</span>
<span class="c1">// there is a GNU extension which allows the embedding of the function name within the</span>
<span class="c1">// function body, and code may be written to somehow utilise this information. Two additional</span>
<span class="c1">// GNU extension functions - &#39;__builtin_return_address&#39; and &#39;__builtin_frame_address&#39; - *do*</span>
<span class="c1">// allow runtime stack inspection. However, this does not include access to information such</span>
<span class="c1">// as the function name.</span>

<span class="kt">void</span> <span class="nf">whoami</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// A Standard C facility, &#39;__func__&#39;, performs a similar role</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;I am function: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.5</span>
<span class="c1">// Standard C supports only &#39;pass-by-value&#39;, that is, a copy of each argument is passed when</span>
<span class="c1">// calling a function. The approach is the same whether the argument is a primitive type such</span>
<span class="c1">// as an &#39;int&#39;, an aggregate type such as a struct, or an array, or, a specialised type like</span>
<span class="c1">// a pointer. Despite this, &#39;pass-by-reference&#39; is possible, though it is performed indirectly</span>
<span class="c1">// via pointers. Put simply, when an argument needs to be modified, or to avoid the overhead</span>
<span class="c1">// of copying a potentially &#39;large&#39; argument, its address [i.e. pointer] is passed in its</span>
<span class="c1">// place. The pointer is then used to refer to the actual item [hence &#39;reference&#39;].</span>
<span class="c1">// In all such cases, bar one, the address of the referred item must be specifically obtained.</span>
<span class="c1">// The exception is when passing arrays; the system automatically passes a pointer rather than</span>
<span class="c1">// copying the array: the address of the first array element from which all other element</span>
<span class="c1">// locations can be computed.</span>

<span class="kt">void</span> <span class="nf">array_diff</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr1</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">arr2</span><span class="p">[]);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

  <span class="c1">// Call &#39;array_diff&#39; with &#39;arr1&#39; and &#39;arr2&#39; as arguments. Although each argument is</span>
  <span class="c1">// passed-by-value, because they are arrays, only the address of the first element</span>
  <span class="c1">// is passed. Effectively, &#39;references&#39; to these arrays are passed, and the overhead</span>
  <span class="c1">// of copying is avoided</span>
  <span class="n">array_diff</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">array_diff</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr1</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">arr2</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span><span class="o">*</span> <span class="nf">add_vecpair</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">vec2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="n">b</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>

  <span class="kt">int</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="n">add_vecpair</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span><span class="o">*</span> <span class="nf">add_vecpair</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">vec1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">vec2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">retvec</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">retvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">retvec</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.6</span>
<span class="c1">// Standard C is a statically-typed language based on type declarations. This means that:</span>
<span class="c1">// * Each variable, as well each function&#39;s parameters and return value, is declared to have</span>
<span class="c1">//   a type; this is a permanent attribute which cannot be altered [except through &#39;casting&#39;</span>
<span class="c1">//   which may be seen as selective circumvention of the type system]. Put simply, a variable</span>
<span class="c1">//   declared to be of type &#39;X&#39; can only be assigned such types; a function declared to return</span>
<span class="c1">//   type &#39;X&#39; must return such a type</span>
<span class="c1">// * Type checking is done at compilation time, so it should not be possible [except through</span>
<span class="c1">//   casting] to generate code that is not type conformant e.g. attempts to assign type &#39;Y&#39;</span>
<span class="c1">//   where a type &#39;X&#39; is expected, or to return an array instead of a struct from a function,</span>
<span class="c1">//   should fail as compilation errors</span>
<span class="c1">//</span>
<span class="c1">// The short of it is that, in Standard C, &#39;return context&#39; is something that is determined at</span>
<span class="c1">// compilation time, therefore is not something that can be altered. Runtime-determined</span>
<span class="c1">// &#39;return context&#39; is really only something meaningful in dynamically-typed, interpreted</span>
<span class="c1">// languages.</span>
<span class="c1">//</span>
<span class="c1">// That being said, it *is* possible to implement a crude, very limited, form of</span>
<span class="c1">// runtime-determined &#39;return context&#39; via the use of &#39;void*&#39;. The Perl &#39;mysub&#39; example, below,</span>
<span class="c1">// will use this approach. Please note the intent here is to show possibilities; the approach is</span>
<span class="c1">// an example of &#39;selective type system circumvention&#39;, and is not generally a recommended one</span>
<span class="c1">// unless it is part of a larger library specifcally designed for this purpose</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">enum</span> <span class="n">ret_type</span> <span class="p">{</span> <span class="n">WANT_NULL</span><span class="p">,</span> <span class="n">WANT_INT</span><span class="p">,</span> <span class="n">WANT_INT_ARRAY</span> <span class="p">}</span> <span class="n">RET_TYPE</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">mysub</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mysub</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="n">RET_TYPE</span> <span class="o">=</span> <span class="n">WANT_INT</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">mysub</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

  <span class="n">RET_TYPE</span> <span class="o">=</span> <span class="n">WANT_INT_ARRAY</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">retarr</span> <span class="o">=</span> <span class="n">mysub</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d:%d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">mysub</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RET_TYPE</span> <span class="o">==</span> <span class="n">WANT_INT</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RET_TYPE</span> <span class="o">==</span> <span class="n">WANT_INT_ARRAY</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.7</span>
<span class="c1">// Standard C offers no support for named / keyword parameters. It is of course possible to</span>
<span class="c1">// mimic such functionality in several ways:</span>
<span class="c1">// * Adopt a convention of passing arguments as hash table entries, or as list nodes, as</span>
<span class="c1">//   an array of entries</span>
<span class="c1">// * Bury key=value pairs in a string, and pass string as single argument</span>
<span class="c1">// * Use variable argument functions with structs of key / value pairs [or, as a variation</span>
<span class="c1">//   on the second suggestion, key=value strings]</span>
<span class="c1">//</span>
<span class="c1">// In all cases argument unpacking must be performed within the function body, so the</span>
<span class="c1">// approach can hardly be called transparent. Additionally, a fair amount of code would be</span>
<span class="c1">// needed to build a usable, flexible and robust facility. Examples of each approach are</span>
<span class="c1">// shown.</span>

<span class="c1">// 1. Array of struct named_parm_t [For simplicity, &#39;value&#39; is assumed to be a &#39;char*&#39;,</span>
<span class="c1">//    but could instead use a &#39;type tagging&#39; approach [i.e. a field identifying type of</span>
<span class="c1">//    data being stored, and either a void* or a union, for storing the various types]</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="k">struct</span> <span class="kt">named_parm_t</span>
<span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">named_parms_as_array_of_struct</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="kt">named_parm_t</span> <span class="n">parms</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">num_parms</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// a=1, b=2, c=cat</span>
  <span class="n">named_parms_as_array_of_struct</span><span class="p">((</span><span class="k">struct</span> <span class="kt">named_parm_t</span><span class="p">[]){{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">}},</span> <span class="mi">3</span><span class="p">);</span>

  <span class="c1">// b=12 [a and c have default values]</span>
  <span class="n">named_parms_as_array_of_struct</span><span class="p">((</span><span class="k">struct</span> <span class="kt">named_parm_t</span><span class="p">[]){{</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;12&quot;</span><span class="p">}},</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">named_parms_as_array_of_struct</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="kt">named_parm_t</span> <span class="n">parms</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">num_parms</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Ensure local variables are initialised to sensible default values</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="s">&quot;default&quot;</span><span class="p">;</span>

  <span class="c1">// Extract named parameter values, and assign to corresponding local variable(s)</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_parms</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">parms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">);</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">b</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">parms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">);</span> <span class="k">continue</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">c</span> <span class="o">=</span> <span class="n">parms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Value of a is %d, b is %d, and c is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// 2. Delimited string of key=value substrings</span>

<span class="cp">#include &lt;stdbool.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">void</span> <span class="nf">named_parms_as_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">parms</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// &quot;a=1,b=2,c=cat&quot;</span>
  <span class="n">named_parms_as_string</span><span class="p">(</span><span class="s">&quot;a=1,b=2,c=cat&quot;</span><span class="p">);</span>

  <span class="c1">// &quot;b=12&quot; [a and c have default values]</span>
  <span class="n">named_parms_as_string</span><span class="p">(</span><span class="s">&quot;b=2&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">named_parms_as_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">parms</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">COMMA</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">,</span> <span class="n">EQ</span> <span class="o">=</span> <span class="sc">&#39;=&#39;</span><span class="p">,</span> <span class="n">NUL</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">parse_entry</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">entry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">sep</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">EQ</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="p">({</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="o">++</span><span class="n">q</span><span class="p">;</span> <span class="nb">true</span><span class="p">;</span> <span class="p">})</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Ensure local variables are initialised to sensible default values</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="s">&quot;default&quot;</span><span class="p">;</span>

  <span class="c1">// Parse string of key=value entries ...</span>
  <span class="kt">char</span> <span class="n">entry</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">parms</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">COMMA</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">q</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">NUL</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span> <span class="o">*</span><span class="p">(</span><span class="n">entry</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span>

    <span class="c1">// Parse each entry, assign to corresponding variable</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parse_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">EQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">c</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="o">?</span> <span class="o">++</span><span class="n">q</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Value of a is %d, b is %d, and c is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// 3. Variable arguments of key=value strings</span>
<span class="c1">//</span>
<span class="c1">//    The example from Perl Cookbook is implemented using this approach . Note that the code</span>
<span class="c1">//    here does not perform exactly the same task as the original. Instead, emphasis is placed</span>
<span class="c1">//    on illustrating string parsing and argument handling techniques</span>

<span class="cp">#include &lt;stdbool.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;ctype.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">void</span> <span class="nf">the_func</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg1</span><span class="p">,</span> <span class="p">...);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">the_func</span><span class="p">(</span><span class="s">&quot;increment=20s&quot;</span><span class="p">,</span> <span class="s">&quot;start=+5m&quot;</span><span class="p">,</span> <span class="s">&quot;finish=+30m&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">the_func</span><span class="p">(</span><span class="s">&quot;start=+5m&quot;</span><span class="p">,</span> <span class="s">&quot;finish=+30m&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">the_func</span><span class="p">(</span><span class="s">&quot;finish=+30m&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">the_func</span><span class="p">(</span><span class="s">&quot;start=+5m&quot;</span><span class="p">,</span> <span class="s">&quot;increment=15s&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">the_func</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg1</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">COMMA</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">,</span> <span class="n">EQ</span> <span class="o">=</span> <span class="sc">&#39;=&#39;</span><span class="p">,</span> <span class="n">NUL</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">parse_entry</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">entry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">sep</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">EQ</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="p">({</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="o">++</span><span class="n">q</span><span class="p">;</span> <span class="nb">true</span><span class="p">;</span> <span class="p">})</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">inc_secs</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">inc_tok</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">lp</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">inc_tok</span><span class="p">,</span> <span class="n">NUL</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="kt">char</span> <span class="n">inc_mul</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="p">);</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">NUL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inc_mul</span> <span class="o">==</span> <span class="sc">&#39;s&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="n">atoi</span><span class="p">(</span><span class="n">inc_tok</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inc_mul</span> <span class="o">==</span> <span class="sc">&#39;m&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="n">atoi</span><span class="p">(</span><span class="n">inc_tok</span><span class="p">)</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Ensure local variables are initialised to sensible default values</span>
  <span class="kt">int</span> <span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kt">char</span> <span class="n">increment</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;10s&quot;</span><span class="p">;</span>

  <span class="c1">// Storage for parsing ...</span>
  <span class="kt">char</span> <span class="n">entry</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>

  <span class="c1">// Extract values from 1st argument</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">parse_entry</span><span class="p">(</span><span class="n">strcpy</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">arg1</span><span class="p">),</span> <span class="n">EQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;start&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">start</span> <span class="o">=</span> <span class="n">inc_secs</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;finish&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">inc_secs</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;increment&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">increment</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Setup for variable argument handling, and extract values from each of these</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg</span><span class="p">;</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">arg1</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">((</span><span class="n">arg</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Parse each entry, assign to corresponding variable</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parse_entry</span><span class="p">(</span><span class="n">strcpy</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">arg</span><span class="p">),</span> <span class="n">EQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;start&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">start</span> <span class="o">=</span> <span class="n">inc_secs</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;finish&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">inc_secs</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;increment&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">increment</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;start -&gt; %d : finish -&gt; %d : increment -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span> <span class="n">increment</span><span class="p">);</span>
  <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.8</span>
<span class="c1">// It&#39;s generally only interpreted languages, or those supporting some sort of pattern</span>
<span class="c1">// matching that implement such a facility. In Standard C a function must return a value in</span>
<span class="c1">// conformance with its return type specification [returning nothing - &#39;void&#39; - may still be</span>
<span class="c1">// seen as returning a value]. Where the return value is an aggregate - struct or array - it</span>
<span class="c1">// is not possible to perform selective &#39;masking out&#39; of it&#39;s contents; the entire item is</span>
<span class="c1">// captured then processed as needs be. Therefore the examples in this section could not be</span>
<span class="c1">// implemented</span>

<span class="c1">// @@PLEAC@@_10.9</span>
<span class="c1">// Standard C allows only the return of a single value. The return of multiple values *can*,</span>
<span class="c1">// however, be simulated by packaging them within an aggregate type: a struct or an array.</span>
<span class="c1">// The catch is, however, that the return value must be manually &#39;unpacked&#39;, thus using</span>
<span class="c1">// this approach is a deliberate design decision rather than the use of an ad-hoc facility</span>

<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">HASH_</span>
<span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">HASH</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ARRAY_HASH_</span>
<span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">array</span><span class="p">;</span>
  <span class="n">HASH</span><span class="o">*</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ARRAY_HASH</span><span class="p">;</span>

<span class="n">ARRAY_HASH</span> <span class="nf">some_func</span><span class="p">(</span><span class="kt">char</span> <span class="n">array</span><span class="p">[],</span> <span class="n">HASH</span> <span class="n">hash</span><span class="p">[]);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// GNU Extensions: compound literals</span>
  <span class="n">ARRAY_HASH</span> <span class="n">refs</span> <span class="o">=</span> <span class="n">some_func</span><span class="p">((</span><span class="kt">char</span><span class="p">[])</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">},</span> <span class="p">(</span><span class="n">HASH</span><span class="p">[])</span> <span class="p">{{</span><span class="s">&quot;k1&quot;</span><span class="p">,</span> <span class="s">&quot;v1&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;k2&quot;</span><span class="p">,</span> <span class="s">&quot;v2&quot;</span><span class="p">}});</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">refs</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">refs</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">refs</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">ARRAY_HASH</span> <span class="nf">some_func</span><span class="p">(</span><span class="kt">char</span> <span class="n">array</span><span class="p">[],</span> <span class="n">HASH</span> <span class="n">hash</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ... do something with &#39;array&#39; and &#39;hash&#39;</span>

  <span class="c1">// GNU Extensions: compound literals</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">ARRAY_HASH</span><span class="p">)</span> <span class="p">{</span><span class="n">array</span><span class="p">,</span> <span class="n">hash</span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.10</span>
<span class="c1">// Unlike in Perl, it is not possible for a function to selectively return / not return a</span>
<span class="c1">// value; a function is defined to either return a specific type, or to return no value at</span>
<span class="c1">// all [i.e. to return &#39;void&#39;]. Thus, this approach cannot be used to &#39;return failure&#39;.</span>
<span class="c1">// Conventions used in Standard C to indicate function failure include:</span>
<span class="c1">// * Return a pointer; the return of a NULL-valued pointer may indicate &#39;failure&#39; such as,</span>
<span class="c1">//   for example, the inability to allocate dynamic memory, or, in the case of the &#39;fopen&#39;</span>
<span class="c1">//   library function, the failure to open a file</span>
<span class="c1">// * Return an &#39;int&#39; value where a 0 or positive value indicates success, and a -1 value</span>
<span class="c1">//   indicates failure. Some library functions also set the &#39;errno&#39; global variable to a</span>
<span class="c1">//   known error code for further diagnostic information</span>

<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">char</span><span class="o">*</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">valid_char_pointer</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">return</span> <span class="n">valid_char_pointer</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">die</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sfunc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">afunc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">hfunc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">s</span><span class="p">;</span> <span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">sfunc</span><span class="p">())</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">die</span><span class="p">(</span><span class="s">&quot;&#39;sfunc&#39; failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">=</span> <span class="n">afunc</span><span class="p">())</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">die</span><span class="p">(</span><span class="s">&quot;&#39;afunc&#39; failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">h</span> <span class="o">=</span> <span class="n">hfunc</span><span class="p">())</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">die</span><span class="p">(</span><span class="s">&quot;&#39;hfunc&#39; failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">void</span> <span class="nf">die</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">fputs</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">sfunc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">valid_int_value</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">return</span> <span class="n">valid_int_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span><span class="o">*</span> <span class="nf">afunc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">valid_char_pointer</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">return</span> <span class="n">valid_char_pointer</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span><span class="o">*</span> <span class="nf">hfunc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">valid_char_pointer</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">return</span> <span class="n">valid_char_pointer</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.11</span>
<span class="c1">// Whilst in Perl function prototyping is optional, this is not the case in C, where it is</span>
<span class="c1">// necessary to:</span>
<span class="c1">// * Declare a function before use; this could either be a function declaration separate from</span>
<span class="c1">//   the function definition, or the function definition itself which serves as its own</span>
<span class="c1">//   declaration</span>
<span class="c1">// * Specify both parameter positional and type information; parameter names are optional in</span>
<span class="c1">//   declarations, mandatory in definitions</span>
<span class="c1">// * Specify return type; in the past this was optional, but now this is mandatory</span>

<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">// Function Declaration</span>
<span class="kt">int</span><span class="o">*</span> <span class="nf">myfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">);</span> <span class="c1">// Also possible: int* myfunc(int, int);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Call function with all required arguments; this is the only calling method</span>
  <span class="c1">// [except for calling via function pointer which still needs all arguments supplied]</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">results</span> <span class="o">=</span> <span class="n">myfunc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

  <span class="c1">// Let&#39;s look at our return array&#39;s contents</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">results</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// Function Definition</span>
<span class="kt">int</span><span class="o">*</span> <span class="nf">myfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Allocate some memory, pack arguments into array for return</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">results</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

  <span class="o">*</span><span class="p">(</span><span class="n">results</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">results</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">results</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// Other Perl examples are omitted since there is no variation in C function calling or</span>
<span class="c1">// parameter handling</span>

<span class="c1">// @@PLEAC@@_10.12</span>
<span class="c1">// Though perhaps not a widely used idiom in Standard C the language does offer exception</span>
<span class="c1">// handling support. Some pertinent reading:</span>
<span class="c1">//</span>
<span class="c1">// * http://en.wikipedia.org/wiki/Exception_handling</span>
<span class="c1">// * http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl=GUIDE&amp;id=512997</span>
<span class="c1">//</span>
<span class="c1">// The example in this section doesn&#39;t strctly follow the Perl code, but merely shows how</span>
<span class="c1">// an exception can be thrown, and handled. The approach used is based on code from:</span>
<span class="c1">//</span>
<span class="c1">// * http://ldeniau.home.cern.ch/ldeniau/html/exception/exception.html</span>
<span class="c1">//</span>
<span class="c1">// It is worth mentioning that &#39;exception handling support&#39; consists of the provision, in</span>
<span class="c1">// the Standard C library, of the &#39;setjmp&#39; and &#39;longjmp&#39; functions. Exception handling</span>
<span class="c1">// code such as that used here is essentially an infrastrucure built around these two</span>
<span class="c1">// functions with &#39;setjmp&#39; being used to create a destination for a later invocation of</span>
<span class="c1">// &#39;longjmp&#39; to &#39;goto&#39; [a.k.a. perform a non-local exit], and in the process, ensuring</span>
<span class="c1">// the &#39;program state&#39; is wound back to the time the &#39;setjmp&#39; call was made. Further</span>
<span class="c1">// details are obtainable by referencing the relevant documentation.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;exception.h&quot;</span>

<span class="k">enum</span>
<span class="p">{</span>
  <span class="n">E_invalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>     <span class="c1">// This exception can never be thrown</span>

  <span class="n">E_bad_exit</span><span class="p">,</span>        <span class="c1">// &#39;standard&#39; exceptions</span>
  <span class="n">E_bad_alloc</span><span class="p">,</span>
  <span class="n">E_bad_cast</span><span class="p">,</span>
  <span class="n">E_bad_typeid</span><span class="p">,</span>

  <span class="n">E_usr_fullmoon</span><span class="p">,</span>    <span class="c1">// User-defined exceptions</span>

  <span class="n">E_last_exception</span>   <span class="c1">// Last exception id</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;main - entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="n">try</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;try block - entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;... doing stuff ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="c1">// if (... error condition detected ...)</span>
         <span class="n">throw</span><span class="p">(</span><span class="n">E_usr_fullmoon</span><span class="p">);</span>

    <span class="c1">// Control never gets here ...</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;try block - end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">catch</span> <span class="p">(</span><span class="n">E_usr_fullmoon</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Caught a &#39;fullmoon&#39; exception</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">catch_any</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Caught an unknown exception, error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">endtry</span><span class="p">;</span>

  <span class="c1">// Control gets here regardless of whether an exception is thrown or not</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;main - end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Include here, or separately compile and link with your executable</span>
<span class="cp">#include &quot;exception.c&quot;</span>

<span class="c1">// @@PLEAC@@_10.13</span>
<span class="c1">// In Standard C it *isn&#39;t possible* to access a global variable that has been shadowed by a</span>
<span class="c1">// local variable of the same name, thus there is no need to save / restore such variables. If</span>
<span class="c1">// both global and local variable need to be accessable, consider renaming one of them. An</span>
<span class="c1">// oft used convention is to name global variables using capitals; thus the same name may be</span>
<span class="c1">// used to indicate the variables are related, but the different case ensures that each remains</span>
<span class="c1">// visible</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">// Global variable</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">print_age</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Global value, &#39;age&#39;, is accessed</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Age is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// A local variable named, &#39;age&#39; will act to &#39;shadow&#39; the globally</span>
  <span class="c1">// defined version, thus any changes to, &#39;age&#39;, will not affect</span>
  <span class="c1">// the global version</span>
  <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// Prints 18, the current value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Local version is altered, *not* global version</span>
  <span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

  <span class="c1">// Prints 18, the current value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">// Global variable</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">print_age</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Global value, &#39;age&#39;, is accessed</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Age is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Here no local version declared: any changes affect global version</span>
  <span class="n">age</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// Prints 5, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Global version again altered</span>
  <span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

  <span class="c1">// Prints 23, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">// Global variable</span>
<span class="kt">int</span> <span class="n">AGE</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">print_age</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Global value, &#39;AGE&#39;, is accessed</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Age is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">AGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">AGE</span><span class="p">;</span>

  <span class="c1">// Prints 18, the new value of &#39;AGE&#39;</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Global variable is altered</span>
  <span class="n">AGE</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

  <span class="c1">// Prints 23, the new value of &#39;AGE&#39;</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// &#39;AGE&#39; restored from saved local version</span>
  <span class="n">AGE</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>

  <span class="c1">// Prints 18, the restored value of &#39;AGE&#39;</span>
  <span class="n">print_age</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.14</span>
<span class="c1">// Standard C does not allow the redefinition of a function at runtime. A function&#39;s name</span>
<span class="c1">// [as seen in source code] is, at runtime, actually an unalterable value: the address of</span>
<span class="c1">// a chunk of code. Therefore, a function named &#39;f&#39; will, for as long as the executable</span>
<span class="c1">// exists, be associated with a particular chunk of code.</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>                   <span class="c1">// Call function &#39;f&#39;</span>

  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>  <span class="c1">// Get address of function &#39;f&#39;; place in function pointer variable</span>
  <span class="n">fp</span><span class="p">();</span>                  <span class="c1">// Call function &#39;f&#39; using its address</span>
<span class="p">}</span>

<span class="c1">// However, if the convention of using a function pointer variable to call a function, is</span>
<span class="c1">// adopted, then it becomes possible to call one of possibly several same-signature [i.e.</span>
<span class="c1">// same parameter list and return type] functions by simply assigning a different address</span>
<span class="c1">// to the variable. In this way it is possible to not only execute other available functions,</span>
<span class="c1">// but also those residing in external libraries [i.e. shared libraries / DLL&#39;s]</span>

<span class="c1">// Perl &#39;grow / expand&#39; combined example</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">FPTR</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">grow</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;grow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">expand</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;expand</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Display addresses of each function; each should be a different value</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;grow -&gt; %x | expand -&gt; %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">grow</span><span class="p">,</span> <span class="n">expand</span><span class="p">);</span>

  <span class="c1">// Call functions directly by name</span>
  <span class="n">grow</span><span class="p">();</span>
  <span class="n">expand</span><span class="p">();</span>

  <span class="c1">// Call functions indirectly using function pointer variable</span>
  <span class="n">FPTR</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">grow</span><span class="p">;</span>
  <span class="n">fp</span><span class="p">();</span>

  <span class="n">fp</span> <span class="o">=</span> <span class="n">expand</span><span class="p">;</span>
  <span class="n">fp</span><span class="p">();</span>

  <span class="c1">// Local scope</span>
  <span class="p">{</span>
    <span class="c1">// Current version of &#39;fp&#39; will shadow outer scope version</span>
    <span class="n">FPTR</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">grow</span><span class="p">;</span>

    <span class="c1">// Should now be &#39;grow&#39;</span>
    <span class="n">fp</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Should still be &#39;expand&#39; since the &#39;fp&#39; at this scope was untouched</span>
  <span class="n">fp</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">FPTR</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">fred_func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fred</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">barney_func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;barney</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Note: &#39;fred&#39; is the pointer variable name. It is *not* possible to redefine function</span>
  <span class="c1">// names</span>
  <span class="n">FPTR</span> <span class="n">fred</span> <span class="o">=</span> <span class="n">fred_func</span><span class="p">;</span>
  <span class="n">fred</span><span class="p">();</span>

  <span class="n">fred</span> <span class="o">=</span> <span class="n">barney_func</span><span class="p">;</span>
  <span class="n">fred</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">red</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">strcat</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="n">strcpy</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="s">&quot;&lt;FONT COLOR=&#39;red&#39;&gt;&quot;</span><span class="p">),</span> <span class="n">text</span><span class="p">),</span> <span class="s">&quot;&lt;/FONT&gt;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">color_tag</span> <span class="o">=</span> <span class="n">red</span><span class="p">(</span><span class="s">&quot;careful here&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">color_tag</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">color_tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">color_font</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">color</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">strcat</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="n">strcpy</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="s">&quot;&lt;FONT COLOR=&#39;&quot;</span><span class="p">),</span> <span class="n">color</span><span class="p">),</span> <span class="s">&quot;&#39;&gt;&quot;</span><span class="p">),</span> <span class="n">text</span><span class="p">),</span> <span class="s">&quot;&lt;/FONT&gt;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">red</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">color_font</span><span class="p">(</span><span class="s">&quot;red&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">);</span> <span class="p">}</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">blue</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">color_font</span><span class="p">(</span><span class="s">&quot;blue&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">);</span> <span class="p">}</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">green</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">color_font</span><span class="p">(</span><span class="s">&quot;green&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">color_tag</span> <span class="o">=</span> <span class="n">red</span><span class="p">(</span><span class="s">&quot;careful here&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">color_tag</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">color_tag</span><span class="p">);</span>

  <span class="n">color_tag</span> <span class="o">=</span> <span class="n">blue</span><span class="p">(</span><span class="s">&quot;careful here&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">color_tag</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">color_tag</span><span class="p">);</span>

  <span class="n">color_tag</span> <span class="o">=</span> <span class="n">green</span><span class="p">(</span><span class="s">&quot;careful here&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">color_tag</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">color_tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// It isn&#39;t possible, in Standard C, to generate code &#39;on the fly&#39; as is done in the Perl</span>
<span class="c1">// examples. The code must have been pre-generated, and either statically linked [i.e.</span>
<span class="c1">// actually part of the executable] or be dynamically loadable [i.e. residing in an external</span>
<span class="c1">// library which may be located and loaded]. A more appropriate way to solve this problem</span>
<span class="c1">// is simply to directly call the &#39;color_font&#39; function with the required arguments, two</span>
<span class="c1">// approaches of which are shown below in (1) and (2)</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">color_font</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">color</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">strcat</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="n">strcpy</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="s">&quot;&lt;FONT COLOR=&#39;&quot;</span><span class="p">),</span> <span class="n">color</span><span class="p">),</span> <span class="s">&quot;&#39;&gt;&quot;</span><span class="p">),</span> <span class="n">text</span><span class="p">),</span> <span class="s">&quot;&lt;/FONT&gt;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// (1) Traverse parallel arrays of arguments</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">colors</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;red&quot;</span><span class="p">,</span> <span class="s">&quot;blue&quot;</span><span class="p">,</span> <span class="s">&quot;green&quot;</span><span class="p">,</span> <span class="s">&quot;yellow&quot;</span><span class="p">,</span> <span class="s">&quot;orange&quot;</span><span class="p">,</span> <span class="s">&quot;purple&quot;</span><span class="p">,</span> <span class="s">&quot;violet&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">texts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="s">&quot;z&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">color_tag</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">,</span> <span class="o">**</span><span class="n">text</span> <span class="o">=</span> <span class="n">texts</span><span class="p">;</span> <span class="o">*</span><span class="n">color</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="o">++</span><span class="n">color</span><span class="p">,</span> <span class="o">++</span><span class="n">text</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">color_tag</span> <span class="o">=</span> <span class="n">color_font</span><span class="p">(</span><span class="o">*</span><span class="n">color</span><span class="p">,</span> <span class="o">*</span><span class="n">text</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">color_tag</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">color_tag</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// (2) Package arguments as a struct; traverse array of such structs</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">TAG_TEXT_</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">color</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">;</span>
<span class="p">}</span> <span class="n">TAG_TEXT</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="n">TAG_TEXT</span> <span class="n">tags</span><span class="p">[]</span> <span class="o">=</span>
  <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;red&quot;</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;blue&quot;</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;green&quot;</span><span class="p">,</span> <span class="s">&quot;z&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;yellow&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;orange&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;purple&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;violet&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">}</span>
  <span class="p">};</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">TAGS</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TAG_TEXT</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">color_tag</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TAGS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">color_tag</span> <span class="o">=</span> <span class="n">color_font</span><span class="p">(</span><span class="n">tags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">color</span><span class="p">,</span> <span class="n">tags</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">text</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">color_tag</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">color_tag</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.15</span>
<span class="c1">// Undefined function calls are detected as errors at code generation time:</span>
<span class="c1">//</span>
<span class="c1">// * At compilation time a function must be explicitly declared before being called i.e. it</span>
<span class="c1">//   must have a prototype, else a compilation error occurs</span>
<span class="c1">// * At linkage time [i.e. when currently-generated code is combined with library code to</span>
<span class="c1">//   create an executable module] the code identified with a function must be available,</span>
<span class="c1">//   [or, with shared libraries, in a known location] else a linkage error occurs</span>
<span class="c1">//</span>
<span class="c1">// In short, in the Standard C language, no runtime detection of &#39;missing&#39; functions is</span>
<span class="c1">// possible since such code could never have been generated in the first place.</span>
<span class="c1">//</span>
<span class="c1">// However, if the convention of using a function pointer to call a function, is adopted,</span>
<span class="c1">// it does become possible to check whether the function pointer variable is assigned a non-NULL</span>
<span class="c1">// address, presumably the address of a valid function. Unfortunately, without the aid of</span>
<span class="c1">// specialised, platform-specific library routines, it is not possible to verify the validity</span>
<span class="c1">// of this address; an attempted function call either succeeds or fails, and may fail because</span>
<span class="c1">// it was a bogus address. Again, the Standard C language offers no runtime detection of</span>
<span class="c1">// something like a &#39;bogus&#39; function address.</span>
<span class="c1">//</span>
<span class="c1">// The combination of &#39;call-by-function-pointer&#39;, and a suitable set of shared library handling</span>
<span class="c1">// functions does make it possible to implement an dynamic code loading facility, even a</span>
<span class="c1">// full-blown AUTOLOAD facility. However, it is important to realise that this is an</span>
<span class="c1">// infrastructure built on top of the Standard C language, not an integral language feature.</span>
<span class="c1">//</span>
<span class="c1">// In the *NIX environment the &#39;dlopen&#39;, &#39;dlsymbol&#39;, &#39;dlerror&#39;, and &#39;dlclose&#39; set of functions</span>
<span class="c1">// is commonly used for shared library management, and would form the basis for implementing</span>
<span class="c1">// an AUTOLOAD facility. The following is an example of a very minimal dynamic loading system</span>
<span class="c1">// illustrating how a function named &#39;chartreuse&#39; residing in a shared library called &#39;colors.so&#39;</span>
<span class="c1">// would be loaded, called, and unloaded. Note that this is not an example of dynamic code</span>
<span class="c1">// generation, as in the Perl example, since the &#39;chartreuse&#39; function *must already exist*</span>
<span class="c1">// for it to even have a chance of executing.</span>
<span class="c1">//</span>
<span class="c1">// Of course it is possible to write code that creates C source file(s), invokes various</span>
<span class="c1">// code generation tools, and builds a shared library which may subsequently be loaded and</span>
<span class="c1">// run. Again, though, this is a custom infrastructure, not an integral language facility.</span>
<span class="c1">// @@INCOMPLETE@@</span>

<span class="c1">// @@PLEAC@@_10.16</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="c1">// Nested functions are supported by GNU C as an extension</span>
<span class="c1">// See the documentation of your GCC version</span>
<span class="kt">int</span> <span class="nf">outer</span><span class="p">(</span> <span class="kt">int</span> <span class="n">arg1</span> <span class="p">){</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">inner</span><span class="p">()</span>
    <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// nested function can access</span>
                       <span class="c1">// all the variables of the containing function</span>
                       <span class="c1">// that are visible at the point of its definition</span>

  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">inner</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.17</span>
<span class="c1">// @@INCOMPLETE@@</span>
<span class="c1">// @@INCOMPLETE@@</span>

<span class="c1">// @@PLEAC@@_11.15</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cm">/* binary tree demo program */</span>
<span class="cp">#define _GNU_SOURCE </span><span class="c1">// getline(), tdestroy()</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;search.h&gt; </span><span class="c1">// tsearch(), tfind(), tdelete(), tdestroy(); twalk()</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// rand(), malloc(), free()</span>

<span class="k">static</span> <span class="n">VISIT</span> <span class="n">walk_type</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">compar_int</span><span class="p">(</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">elm1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">elm2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">elm1</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">elm2</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">walk</span><span class="p">(</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="n">VISIT</span> <span class="n">method</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">node</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="n">walk_type</span><span class="p">)</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span> <span class="p">);</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">method</span> <span class="o">==</span> <span class="n">leaf</span> <span class="p">)</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span> <span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_elmt</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">node</span> <span class="p">){</span>
  <span class="n">free</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="p">{</span>

  <span class="kt">void</span> <span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

  <span class="c1">// first generate 20 random inserts</span>
  <span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">);</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">tsearch</span><span class="p">(</span> <span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="n">compar_int</span> <span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;tsearch&quot;</span><span class="p">);</span>
      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// now dump out the tree all three ways</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;Pre order</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">walk_type</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">;</span>
  <span class="n">twalk</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">walk</span> <span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;In order</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">walk_type</span> <span class="o">=</span> <span class="n">postorder</span><span class="p">;</span> <span class="c1">// /!\  postorder is rather confusing</span>
  <span class="n">twalk</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">walk</span> <span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;Post order</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">walk_type</span> <span class="o">=</span> <span class="n">endorder</span><span class="p">;</span>
  <span class="n">twalk</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">walk</span> <span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="c1">// prompt until EOF</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">istr</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;Search? : &quot;</span><span class="p">);</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">istr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">getline</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">istr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">stdin</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">sscanf</span><span class="p">(</span> <span class="n">istr</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span> <span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">istr</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">tfind</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="n">compar_int</span> <span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
      <span class="n">fprintf</span><span class="p">(</span> <span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;No %d in tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="p">);</span>
    <span class="k">else</span>
      <span class="n">fprintf</span><span class="p">(</span> <span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;Found %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="n">tdestroy</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">free_elmt</span> <span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// @@PLEAC@@_15.10</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="c1">// /!\ this function is deprecated</span>
<span class="cp">#include &lt;unistd.h&gt; </span><span class="c1">// getpass()</span>

<span class="p">...</span>

<span class="kt">char</span> <span class="o">*</span> <span class="n">password</span> <span class="o">=</span> <span class="n">getpass</span><span class="p">(</span> <span class="s">&quot;password : &quot;</span> <span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="c1">// gcc -Wall -o checkuser checkuser.c -lcrypt</span>
<span class="cp">#define _GNU_SOURCE</span>

<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// gnu version of getline()</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// at_exit()</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt; </span><span class="c1">// getlogin()</span>
<span class="cp">#include &lt;termios.h&gt; </span><span class="c1">// struct termios, tcgetattr(), tcsetattr()</span>
<span class="cp">#include &lt;pwd.h&gt; </span><span class="c1">// struct passwd, fgetpwent()</span>
<span class="cp">#include &lt;crypt.h&gt;  </span><span class="c1">// crypt()</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">termios</span> <span class="n">stored_settings</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">restore_term_setting</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="p">{</span>
  <span class="cm">/*</span>
<span class="cm">    restore terminal setting</span>
<span class="cm">  */</span>
  <span class="n">tcsetattr</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TCSANOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stored_settings</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="n">termios</span> <span class="n">new_settings</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">cryptpw</span><span class="p">;</span> <span class="c1">// our encrypted password</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">my_login</span> <span class="o">=</span> <span class="n">getlogin</span><span class="p">();</span> <span class="c1">// our login</span>

  <span class="cm">/*</span>
<span class="cm">    we ask for password</span>
<span class="cm">  */</span>
  <span class="n">fprintf</span><span class="p">(</span> <span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;Password : &quot;</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    we disable echo input</span>
<span class="cm">  */</span>

  <span class="c1">// we first set an exit handler to restore terminal setting</span>
  <span class="c1">// * if something go wrong</span>
  <span class="c1">// * on the final return</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">atexit</span><span class="p">(</span> <span class="n">restore_term_setting</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;error on atexit</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>


  <span class="n">tcgetattr</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stored_settings</span> <span class="p">);</span> <span class="c1">// save terminal setting</span>

  <span class="n">new_settings</span> <span class="o">=</span> <span class="n">stored_settings</span><span class="p">;</span>
  <span class="n">new_settings</span><span class="p">.</span><span class="n">c_lflag</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">ECHO</span><span class="p">);</span> <span class="c1">// disable echo input characters</span>
  <span class="n">tcsetattr</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TCSANOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_settings</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    we get the plain password</span>
<span class="cm">  */</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">passwd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">getline</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">passwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">stdin</span> <span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// we &quot;chomp&quot; the plain password</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span> <span class="n">passwd</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span> <span class="p">);</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    we get our login encrypted password</span>
<span class="cm">    /!\ most of the Linux system use shadow password</span>
<span class="cm">    we have to use /etc/shadow instead of /etc/passwd</span>
<span class="cm">    /!\ we have to be root in order to read /etc/shadow</span>
<span class="cm">  */</span>
  <span class="kt">FILE</span> <span class="o">*</span> <span class="n">fp</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span> <span class="s">&quot;/etc/shadow&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span> <span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;fopen&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">struct</span> <span class="n">passwd</span> <span class="o">*</span> <span class="n">shadow_pwd_ent</span><span class="p">;</span>
  <span class="n">cryptpw</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">shadow_pwd_ent</span> <span class="o">=</span> <span class="n">fgetpwent</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// we search our login in the entry returned</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">strcmp</span><span class="p">(</span> <span class="n">my_login</span><span class="p">,</span> <span class="n">shadow_pwd_ent</span><span class="o">-&gt;</span><span class="n">pw_name</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cryptpw</span> <span class="o">=</span> <span class="n">shadow_pwd_ent</span><span class="o">-&gt;</span><span class="n">pw_passwd</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    password matching</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(</span> <span class="n">crypt</span><span class="p">(</span><span class="n">passwd</span><span class="p">,</span> <span class="n">cryptpw</span><span class="p">),</span> <span class="n">cryptpw</span> <span class="p">);</span>

  <span class="c1">// we hurry to free the plain version of the password</span>
  <span class="n">free</span><span class="p">(</span><span class="n">passwd</span><span class="p">),</span> <span class="n">passwd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="n">puts</span><span class="p">(</span> <span class="s">&quot;&quot;</span> <span class="p">);</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">match</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;Welcome, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">my_login</span> <span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;You are not %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">my_login</span> <span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// @@PLEAC@@_17.8</span>
<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt; </span><span class="c1">// gethostname()</span>
<span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">// malloc(), realloc(), free()</span>
<span class="cp">#include &lt;errno.h&gt; </span><span class="c1">// errno</span>

<span class="p">...</span>

<span class="kt">char</span> <span class="o">*</span> <span class="n">hostname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">sizebuf</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="n">hostname</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>


<span class="k">while</span><span class="p">(</span> <span class="n">gethostname</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">sizebuf</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">ENAMETOOLONG</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;gethostname&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// the buffer size is too small</span>
  <span class="n">sizebuf</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="n">hostname</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">sizebuf</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;my hostname : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hostname</span><span class="p">);</span>

<span class="n">free</span><span class="p">(</span><span class="n">hostname</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;sys/utsname.h&gt; </span><span class="c1">// struct utsname, uname()</span>

<span class="p">...</span>

<span class="k">struct</span> <span class="n">utsname</span> <span class="n">my_utsname</span><span class="p">;</span>

<span class="n">uname</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">my_utsname</span> <span class="p">);</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;my hostname : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">my_utsname</span><span class="p">.</span><span class="n">nodename</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">//------------------------------------------------------------------</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="cp">#include &lt;netdb.h&gt; </span><span class="c1">// gethostbyname(), gethostbyaddr(), h_errno, herror()</span>
<span class="cp">#include &lt;netinet/in.h&gt; </span><span class="c1">// struct in_addr</span>
<span class="cp">#include &lt;arpa/inet.h&gt; </span><span class="c1">// inet_ntoa()</span>

<span class="p">...</span>

<span class="c1">// we don&#39;t handle IPV6 for more simplicity</span>
<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">address</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span> <span class="n">ip</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hostent</span> <span class="o">*</span> <span class="n">host</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">    gethostbyname()</span>
<span class="cm">*/</span>
<span class="kt">char</span> <span class="n">hostname</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;a_valid_hostname&quot;</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">host</span> <span class="o">=</span> <span class="n">gethostbyname</span><span class="p">(</span><span class="n">hostname</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">herror</span><span class="p">(</span><span class="s">&quot;gethostbyname&quot;</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">h_addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">ip</span> <span class="o">=</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="p">)(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">h_addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;address for %s : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hostname</span> <span class="p">,</span><span class="n">inet_ntoa</span><span class="p">(</span><span class="o">*</span><span class="n">ip</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">    gethostbyaddr()</span>
<span class="cm">*/</span>
<span class="kt">char</span> <span class="n">addr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;127.0.0.1&quot;</span><span class="p">;</span>

<span class="c1">// we verify the IPV4 address</span>
<span class="k">if</span><span class="p">(</span> <span class="n">inet_aton</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;invalid address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">host</span> <span class="o">=</span> <span class="n">gethostbyaddr</span><span class="p">(</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">),</span> <span class="n">AF_INET</span> <span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">herror</span><span class="p">(</span><span class="s">&quot;gethostbyaddr&quot;</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;hostname for %s : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">h_name</span> <span class="p">);</span>

<span class="p">...</span>
</pre></div>
</body>
</html>
