<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Helpers</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Haskell"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Web Automation"
HREF="webautomation.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="APPENDIX"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Haskell</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="webautomation.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
>&nbsp;</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="APPENDIX"
><H1
CLASS="APPENDIX"
><A
NAME="AEN1102"
>A. Helpers</A
></H1
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="kr">module</span> <span class="nn">Pleac</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">((</span><span class="o">$</span><span class="p">),(</span><span class="o">^</span><span class="p">),(</span><span class="o">.</span><span class="p">),(</span><span class="o">!!</span><span class="p">),</span><span class="nf">map</span><span class="p">,</span><span class="nf">take</span><span class="p">,</span><span class="nf">lookup</span><span class="p">,</span><span class="nf">drop</span><span class="p">,</span><span class="nf">splitAt</span><span class="p">,</span><span class="nf">reverse</span><span class="p">,</span><span class="nf">filter</span><span class="p">,</span><span class="nf">takeWhile</span><span class="p">,</span><span class="nf">dropWhile</span><span class="p">,</span><span class="nf">null</span><span class="p">,</span><span class="nf">foldl</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">Common</span>

<span class="c1">----------------------------------------------------------------------------------------------------</span><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">----------------------------------------------------------------------------------------------------</span>
<span class="kr">module</span> <span class="nn">Common</span> <span class="p">(</span> <span class="nf">module</span> <span class="kt">Common</span>
		<span class="p">,</span> <span class="nf">module</span> <span class="kt">Regexp</span>
		<span class="p">,</span> <span class="nf">module</span> <span class="kt">System</span>
		<span class="p">,</span> <span class="nf">module</span> <span class="kt">Complex</span>
		<span class="p">,</span> <span class="nf">module</span> <span class="kt">Char</span> 
		<span class="p">,</span> <span class="nf">module</span> <span class="kt">Numeric</span> 
		<span class="c1">-- Monad</span>
		<span class="p">,</span> <span class="nf">foldM</span>
		<span class="c1">-- List</span>
		<span class="p">,</span> <span class="nf">elemIndex</span><span class="p">,</span> <span class="nf">elemIndices</span><span class="p">,</span>
		<span class="nf">find</span><span class="p">,</span> <span class="nf">findIndex</span><span class="p">,</span> <span class="nf">findIndices</span><span class="p">,</span>
		<span class="nf">nub</span><span class="p">,</span> <span class="nf">nubBy</span><span class="p">,</span> <span class="nf">delete</span><span class="p">,</span> <span class="nf">deleteBy</span><span class="p">,</span> <span class="p">(</span><span class="o">\\</span><span class="p">),</span> <span class="nf">deleteFirstsBy</span><span class="p">,</span>
		<span class="nf">union</span><span class="p">,</span> <span class="nf">unionBy</span><span class="p">,</span> <span class="nf">intersect</span><span class="p">,</span> <span class="nf">intersectBy</span><span class="p">,</span>
		<span class="nf">intersperse</span><span class="p">,</span> <span class="nf">transpose</span><span class="p">,</span> <span class="nf">partition</span><span class="p">,</span> <span class="nf">group</span><span class="p">,</span> <span class="nf">groupBy</span><span class="p">,</span>
		<span class="nf">inits</span><span class="p">,</span> <span class="nf">tails</span><span class="p">,</span> <span class="nf">isPrefixOf</span><span class="p">,</span> <span class="nf">isSuffixOf</span><span class="p">,</span>
		<span class="nf">mapAccumL</span><span class="p">,</span> <span class="nf">mapAccumR</span><span class="p">,</span>
		<span class="nf">sort</span><span class="p">,</span> <span class="nf">sortBy</span><span class="p">,</span> <span class="nf">insert</span><span class="p">,</span> <span class="nf">insertBy</span><span class="p">,</span> <span class="nf">maximumBy</span><span class="p">,</span> <span class="nf">minimumBy</span><span class="p">,</span>
		<span class="nf">genericLength</span><span class="p">,</span> <span class="nf">genericTake</span><span class="p">,</span> <span class="nf">genericDrop</span><span class="p">,</span>
		<span class="nf">genericSplitAt</span><span class="p">,</span> <span class="nf">genericIndex</span><span class="p">,</span> <span class="nf">genericReplicate</span><span class="p">,</span>
		<span class="nf">zip4</span><span class="p">,</span> <span class="nf">zip5</span><span class="p">,</span> <span class="nf">zip6</span><span class="p">,</span> <span class="nf">zip7</span><span class="p">,</span>
		<span class="nf">zipWith4</span><span class="p">,</span> <span class="nf">zipWith5</span><span class="p">,</span> <span class="nf">zipWith6</span><span class="p">,</span> <span class="nf">zipWith7</span><span class="p">,</span>
		<span class="nf">unzip4</span><span class="p">,</span> <span class="nf">unzip5</span><span class="p">,</span> <span class="nf">unzip6</span><span class="p">,</span> <span class="nf">unzip7</span><span class="p">,</span> <span class="nf">unfoldr</span>
<span class="c1">--		,module Prelude</span>

<span class="p">)</span> <span class="kr">where</span>

<span class="c1">----------------------------------------------------------------------------------------------------</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">((</span><span class="o">$</span><span class="p">),(</span><span class="o">^</span><span class="p">),(</span><span class="o">.</span><span class="p">),(</span><span class="o">!!</span><span class="p">),</span><span class="nf">map</span><span class="p">,</span><span class="nf">take</span><span class="p">,</span><span class="nf">lookup</span><span class="p">,</span><span class="nf">drop</span><span class="p">,</span><span class="nf">splitAt</span><span class="p">,</span><span class="nf">reverse</span><span class="p">,</span><span class="nf">filter</span><span class="p">,</span><span class="nf">takeWhile</span><span class="p">,</span><span class="nf">dropWhile</span><span class="p">,</span><span class="nf">null</span><span class="p">,</span><span class="nf">foldl</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">List</span> <span class="k">hiding</span> <span class="p">((</span><span class="o">!!</span><span class="p">),</span><span class="nf">map</span><span class="p">,</span><span class="nf">take</span><span class="p">,</span><span class="nf">lookup</span><span class="p">,</span><span class="nf">drop</span><span class="p">,</span><span class="nf">splitAt</span><span class="p">,</span><span class="nf">reverse</span><span class="p">,</span><span class="nf">filter</span><span class="p">,</span><span class="nf">takeWhile</span><span class="p">,</span><span class="nf">dropWhile</span><span class="p">,</span><span class="nf">null</span><span class="p">,</span><span class="nf">insert</span><span class="p">,</span><span class="nf">union</span><span class="p">,</span><span class="nf">intersect</span><span class="p">,</span><span class="nf">delete</span><span class="p">,</span><span class="nf">partition</span><span class="p">,</span><span class="nf">foldl</span><span class="p">,</span><span class="nf">length</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Random</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">split</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Monad</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">join</span><span class="p">,</span><span class="nf">when</span><span class="p">,</span><span class="nf">unless</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">Regexp</span>
<span class="kr">import</span> <span class="nn">System</span>
<span class="kr">import</span> <span class="nn">Complex</span>

<span class="c1">-- seems ghc need it for chr,ord, readHex, readOct</span>
<span class="kr">import</span> <span class="nn">Char</span> 
<span class="kr">import</span> <span class="nn">Numeric</span> 
<span class="c1">--ghc import Time</span>
<span class="c1">--ghc import Locale</span>

<span class="c1">--import Trace</span>

<span class="c1">----------------------------------------------------------------------------------------------------</span>
<span class="nf">substr</span> <span class="n">start</span> <span class="n">len</span> <span class="n">insert</span> <span class="n">s</span> <span class="ow">=</span> 
    <span class="kr">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="kr">then</span> <span class="n">s</span><span class="o">!!</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">++</span> <span class="n">insert</span> <span class="o">++</span> <span class="n">s</span><span class="o">!!</span><span class="p">[</span><span class="n">start</span><span class="o">+</span><span class="n">len</span><span class="o">..</span><span class="p">]</span> <span class="c1">-- [0.. -1] -&gt; []</span>
    <span class="kr">else</span> <span class="n">s</span><span class="o">!!</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">length</span> <span class="n">s</span> <span class="o">+</span> <span class="n">start</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">++</span> <span class="n">insert</span> <span class="o">++</span> <span class="n">s</span><span class="o">!!</span><span class="p">[</span><span class="n">start</span><span class="o">+</span><span class="n">len</span><span class="o">..</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="c1">--substr s start len insert = take s start ++ insert ++ s!![start+len..]</span>
<span class="nf">substr2</span> <span class="n">start</span> <span class="n">insert</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">substr</span> <span class="n">start</span> <span class="p">(</span><span class="kr">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="kr">then</span> <span class="p">(</span><span class="n">length</span> <span class="n">s</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="kr">else</span> <span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="n">insert</span> <span class="n">s</span>

<span class="kr">data</span> <span class="kt">Unpack_option</span> <span class="ow">=</span> <span class="kt">Grab</span> <span class="kt">Int</span> 
		   <span class="o">|</span> <span class="kt">Forward</span> <span class="kt">Int</span> 
		   <span class="o">|</span> <span class="kt">Backward</span> <span class="kt">Int</span> 
		   <span class="o">|</span> <span class="kt">GrabAll</span> 
		     <span class="kr">deriving</span> <span class="kt">Show</span>
<span class="nf">unpack</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Unpack_option</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="nf">unpack</span> <span class="n">opt</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">foldl</span> <span class="n">aux</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span><span class="o">.</span><span class="n">snd</span><span class="o">.</span><span class="n">reverse</span> <span class="c1">--(snd $ reverse) (foldl aux (0,[]) opt)</span>
    <span class="kr">where</span> <span class="n">aux</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="kt">Grab</span> <span class="n">i</span><span class="p">)</span>      <span class="ow">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="o">!!</span><span class="p">[</span><span class="n">n</span><span class="o">..</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="kt">:</span> <span class="n">l</span><span class="p">)</span>
	  <span class="n">aux</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="kt">Forward</span> <span class="n">i</span><span class="p">)</span>   <span class="ow">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
	  <span class="n">aux</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="kt">Backward</span> <span class="n">i</span><span class="p">)</span>  <span class="ow">=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
	  <span class="n">aux</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="kt">GrabAll</span>       <span class="ow">=</span> <span class="p">(</span><span class="n">length</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">!!</span><span class="p">[</span><span class="n">n</span><span class="o">..</span><span class="p">]</span> <span class="kt">:</span> <span class="n">l</span><span class="p">)</span>
<span class="c1">-- could do a foldr so that no need reverse but need reverse opt</span>
<span class="c1">-- could to a str2Unpack_option so that str2Unpack_option &quot;A5 A*&quot; =&gt; [Grab 5,GrabAll]</span>
<span class="c1">----------------------------------------------------------------------------------------------------</span>

<span class="c1">-- use http://www.dcs.gla.ac.uk/~meurig/regexp/ for substS, ...</span>
<span class="c1">-- TODO, a subst that take group</span>
<span class="nf">subst</span> <span class="n">re</span> <span class="n">f</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">matchresult</span> <span class="ow">=</span> <span class="n">searchS</span> <span class="n">re</span> <span class="kt">[]</span> <span class="n">s</span> <span class="kr">in</span>
		   <span class="kr">if</span> <span class="n">matchedAny</span> <span class="n">matchresult</span> <span class="kr">then</span> 
		      <span class="n">beforeMatch</span> <span class="n">matchresult</span> <span class="o">++</span> 
		      <span class="n">f</span> <span class="p">(</span><span class="n">wholeMatch</span> <span class="n">matchresult</span><span class="p">)</span> <span class="o">++</span> 
		      <span class="n">afterMatch</span> <span class="n">matchresult</span>
		   <span class="kr">else</span> <span class="n">s</span>

<span class="nf">gsubst</span> <span class="n">re</span> <span class="n">f</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">matchresult</span> <span class="ow">=</span> <span class="n">searchS</span> <span class="n">re</span> <span class="kt">[]</span> <span class="n">s</span> <span class="kr">in</span>
		   <span class="kr">if</span> <span class="n">matchedAny</span> <span class="n">matchresult</span> <span class="kr">then</span> 
		      <span class="n">beforeMatch</span> <span class="n">matchresult</span> <span class="o">++</span> 
		      <span class="n">f</span> <span class="p">(</span><span class="n">wholeMatch</span> <span class="n">matchresult</span><span class="p">)</span> <span class="o">++</span> 
			<span class="p">(</span><span class="n">gsubst</span> <span class="n">re</span> <span class="n">f</span> <span class="p">(</span><span class="n">afterMatch</span> <span class="n">matchresult</span><span class="p">))</span>
		   <span class="kr">else</span> <span class="n">s</span>
<span class="c1">-- in perl, =~ do 2 things, first it returns a bool and bind $i</span>
<span class="c1">-- in haskell we are forced to do it in 2 steps</span>
<span class="p">(</span><span class="o">=~</span><span class="p">)</span> <span class="n">s</span> <span class="n">re</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">matchresult</span> <span class="ow">=</span> <span class="n">searchS</span> <span class="n">re</span> <span class="kt">[]</span> <span class="n">s</span> <span class="kr">in</span>
	    <span class="n">matchedAny</span> <span class="n">matchresult</span>
<span class="p">(</span><span class="o">==~</span><span class="p">)</span> <span class="n">s</span> <span class="n">re</span> <span class="ow">=</span> <span class="n">s</span> <span class="o">=~</span> <span class="p">(</span><span class="s">&quot;^&quot;</span><span class="o">++</span><span class="n">s</span><span class="o">++</span><span class="s">&quot;$&quot;</span><span class="p">)</span>

<span class="c1">-- the Regexp lib require regexp of the form   &quot; var@(...) var2@(...)&quot; i dont</span>
<span class="c1">-- like put name on this, prefer anonymous as in perl, that is &quot;(...) (...)&quot;</span>
<span class="c1">-- TODO, handle |, for example when match .(..)|.(..) i would like to return a list of one element</span>
<span class="c1">-- TODO, handle ?: of perl</span>
<span class="nf">match</span> <span class="n">re</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">max</span><span class="p">,</span><span class="n">re2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">re</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">acc</span><span class="p">)</span> <span class="n">c</span> <span class="ow">-&gt;</span> 
			    <span class="kr">if</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span> <span class="kr">then</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">acc</span><span class="o">++</span><span class="s">&quot; &quot;</span><span class="o">++</span><span class="n">show</span> <span class="n">i</span><span class="o">++</span><span class="s">&quot;@(&quot;</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">acc</span><span class="o">++</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
				   <span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span>
		 <span class="n">matchresult</span> <span class="ow">=</span> <span class="n">s</span><span class="o">.</span><span class="n">searchS</span> <span class="n">re2</span> <span class="kt">[]</span>
		 <span class="c1">-- there is a pb cos in match &quot;(\\w+)=(.*)&quot; &quot;MAIL=&quot;, we dont get [&quot;MAIL&quot;,&quot;&quot;]</span>
		 <span class="c1">-- but only [&quot;MAIL&quot;], the lib does not handle well empty match</span>
		 <span class="n">subs</span>  <span class="ow">=</span> <span class="n">allSubexps</span> <span class="n">matchresult</span>
		 <span class="n">subs2</span> <span class="ow">=</span> <span class="kr">if</span>   <span class="p">(</span><span class="n">subs</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">&amp;&amp;</span> <span class="n">subs</span><span class="o">.</span><span class="n">last</span><span class="o">.</span><span class="n">fst</span> <span class="o">/=</span> <span class="n">show</span> <span class="p">(</span><span class="n">max</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			     <span class="o">||</span><span class="p">(</span><span class="n">subs</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">max</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			  <span class="kr">then</span> <span class="n">subs</span><span class="o">++</span><span class="p">[(</span><span class="n">show</span> <span class="p">(</span><span class="n">max</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="s">&quot;&quot;</span><span class="p">)]</span>
			  <span class="kr">else</span> <span class="n">subs</span>
		 <span class="n">subs3</span> <span class="ow">=</span> <span class="n">subs2</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">acc</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">str</span><span class="p">)</span><span class="ow">-&gt;</span> 
			      <span class="kr">if</span> <span class="n">show</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="kr">then</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">acc</span><span class="o">++</span><span class="p">[</span><span class="n">str</span><span class="p">])</span>
			      <span class="kr">else</span> <span class="p">((</span><span class="n">read</span> <span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">acc</span><span class="o">++</span><span class="n">replicate</span> <span class="p">((</span><span class="n">read</span> <span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="s">&quot;&quot;</span><span class="o">++</span><span class="p">[</span><span class="n">str</span><span class="p">])</span>
				       <span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span> <span class="kr">in</span>
		 <span class="n">subs3</span><span class="o">.</span><span class="n">snd</span>
<span class="c1">-- cant make match and gmatch the same type, cos one give [] and gmatch give [[]]</span>
<span class="nf">gmatch</span> <span class="n">re</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">max</span><span class="p">,</span><span class="n">re2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">re</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">acc</span><span class="p">)</span> <span class="n">c</span> <span class="ow">-&gt;</span> 
			    <span class="kr">if</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span> <span class="kr">then</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">acc</span><span class="o">++</span><span class="s">&quot; &quot;</span><span class="o">++</span><span class="n">show</span> <span class="n">i</span><span class="o">++</span><span class="s">&quot;@(&quot;</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">acc</span><span class="o">++</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
				   <span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span>
		  <span class="n">matchresult</span> <span class="ow">=</span> <span class="n">s</span><span class="o">.</span><span class="n">searchS</span> <span class="n">re2</span> <span class="kt">[]</span> <span class="kr">in</span>
		  <span class="kr">if</span> <span class="n">matchedAny</span> <span class="n">matchresult</span> <span class="kr">then</span> <span class="p">(</span><span class="n">match</span> <span class="n">re</span> <span class="n">s</span><span class="p">)</span><span class="kt">:</span><span class="p">(</span><span class="n">gmatch</span> <span class="n">re</span> <span class="p">(</span><span class="n">afterMatch</span> <span class="n">matchresult</span><span class="p">))</span>
		  <span class="kr">else</span> <span class="kt">[]</span>


<span class="c1">--myl = &quot;cava et toi&quot;.match  &quot;(a..) et (t)oi&quot;</span>
<span class="c1">--myl = match &quot;(\\w+)&quot; &quot;pad tty etrre&quot;</span>
<span class="c1">--myl = match &quot;(\\w+)=&quot; &quot;PAD=/home/pad&quot;</span>
<span class="c1">--myl = match &quot;(\\w+)=(.*)&quot; &quot;PAD_MAIL=&quot;</span>

<span class="nf">pattern_matches</span> <span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">s</span> <span class="o">=~</span> <span class="n">re</span> <span class="kr">then</span> <span class="n">v</span> <span class="kr">else</span> <span class="n">pattern_matches</span> <span class="n">xs</span> <span class="n">s</span>

<span class="c1">----------------------------------------------------------------------------------------------------</span>
<span class="c1">-- an imitation of the &#39;?&#39; C operator, could even define (:-) = (:) and then have bool ? v1 :- v2</span>
<span class="p">(</span><span class="o">?</span><span class="p">)</span> <span class="kt">True</span>  <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>
<span class="p">(</span><span class="o">?</span><span class="p">)</span> <span class="kt">False</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">b</span>

<span class="p">(</span><span class="o">==&gt;</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

<span class="c1">-- TODO, would like to overload . to behave as &gt;&gt;&gt; when monad, but hard to do (a -&gt; (a-&gt;b) -&gt; b) does</span>
<span class="c1">-- not unify with m a -&gt; (a -&gt; b) -&gt; m b, and want that ?</span>
<span class="c1">-- it is cool that record get autogenerated func, =&gt; we could do object.record_selector</span>
<span class="c1">-- consistency</span>

<span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="n">o</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">o</span> <span class="c1">-- object notation for object fan, use it if function have more than one parameter or</span>
	      <span class="c1">-- if you want make an &quot;oo-line&quot; (ex o.words.reverse.unwords)</span>
<span class="p">(</span><span class="o">.&gt;</span><span class="p">)</span> <span class="n">m</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">o</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">o</span><span class="p">))</span> <span class="c1">-- &lt;=&gt; &gt;&gt;&gt;</span>

<span class="p">(</span><span class="err">°</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
<span class="p">(</span><span class="n">f</span> <span class="o">$</span> <span class="n">g</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">g</span> <span class="err">°</span> <span class="n">f</span><span class="p">)</span> <span class="n">x</span>

<span class="nf">next_char</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">chr</span> <span class="p">(</span><span class="n">ord</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="nf">show_float</span> <span class="n">i</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">showFFloat</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">i</span><span class="p">)</span> <span class="n">f</span> <span class="s">&quot;&quot;</span>

<span class="nf">fixpoint</span> <span class="n">f</span> <span class="n">d</span> <span class="o">|</span> <span class="n">f</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d</span>  <span class="ow">=</span> <span class="n">d</span>
	     <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">fixpoint</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">d</span><span class="p">)</span>
<span class="nf">times</span> <span class="ow">=</span> <span class="n">replicate</span>

<span class="nf">join</span> <span class="n">e</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">join</span> <span class="n">e</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">++</span> <span class="n">e</span> <span class="o">++</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span> 
<span class="c1">-- join e []     = []</span>
<span class="c1">-- join e [x]    = x</span>
<span class="c1">-- join e (x:xs) = x ++ e ++ join e xs</span>
<span class="c1">-- ex: join &quot; &quot; [&quot;bi&quot;,&quot;te&quot;,&quot;di&quot;,&quot;ck&quot;] == &quot;bi te di ck&quot;</span>

<span class="c1">-- string only split</span>
<span class="c1">--split e xs = splitaux e [] xs</span>
<span class="c1">--splitaux e a xs | xs.length &lt; e.length     = [a ++ xs]</span>
<span class="c1">--		  | take (e.length) xs == e  = a:(splitaux e [] (drop (e.length) xs))</span>
<span class="c1">--		  | otherwise                = splitaux e (a++[head xs]) (tail xs)</span>
<span class="c1">-- better split, handle regexp</span>
<span class="nf">split</span> <span class="n">re</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">matchresult</span> <span class="ow">=</span> <span class="n">searchS</span> <span class="n">re</span> <span class="kt">[]</span> <span class="n">xs</span> <span class="kr">in</span>
		   <span class="kr">if</span> <span class="n">matchedAny</span> <span class="n">matchresult</span> 
		   <span class="kr">then</span> <span class="p">(</span><span class="n">beforeMatch</span> <span class="n">matchresult</span><span class="p">)</span><span class="kt">:</span><span class="p">(</span><span class="n">split</span> <span class="n">re</span> <span class="p">(</span><span class="n">afterMatch</span> <span class="n">matchresult</span><span class="p">))</span>
		   <span class="kr">else</span> <span class="p">[</span><span class="n">xs</span><span class="p">]</span>
<span class="c1">--test=split &quot;\\s+&quot; &quot;toto titi  tia to&quot;</span>

<span class="nf">break_char</span> <span class="n">c</span> <span class="n">f</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">break</span> <span class="p">(</span><span class="o">==</span> <span class="n">c</span><span class="p">)</span> <span class="n">s</span> <span class="kr">in</span>
		   <span class="kr">if</span> <span class="n">b</span> <span class="o">==</span> <span class="kt">[]</span> <span class="kr">then</span> <span class="n">a</span> <span class="kr">else</span> <span class="n">f</span> <span class="n">a</span> <span class="p">(</span><span class="n">tail</span> <span class="n">b</span><span class="p">)</span>

<span class="nf">upcase</span> <span class="n">xs</span>     <span class="ow">=</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="n">xs</span>
<span class="nf">downcase</span> <span class="n">xs</span>   <span class="ow">=</span> <span class="n">map</span> <span class="n">toLower</span> <span class="n">xs</span>
<span class="nf">capitalize</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">toUpper</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span>

<span class="nf">tonum</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">fromInteger</span> <span class="n">x</span>

<span class="nf">hex</span> <span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="kt">:</span><span class="p">(</span><span class="n">&#39;x&#39;</span><span class="kt">:</span><span class="n">s</span><span class="p">))</span> <span class="ow">=</span> <span class="n">fst</span> <span class="p">(</span><span class="n">head</span> <span class="p">(</span><span class="n">readHex</span> <span class="n">s</span><span class="p">))</span> <span class="c1">-- TODO do some check</span>
<span class="nf">oct</span> <span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="kt">:</span><span class="p">(</span><span class="n">&#39;o&#39;</span><span class="kt">:</span><span class="n">s</span><span class="p">))</span> <span class="ow">=</span> <span class="n">fst</span> <span class="p">(</span><span class="n">head</span> <span class="p">(</span><span class="n">readOct</span> <span class="n">s</span><span class="p">))</span> <span class="c1">-- TODO do some check</span>
<span class="nf">tohex</span> <span class="n">i</span> <span class="ow">=</span> <span class="s">&quot;0x&quot;</span><span class="o">++</span><span class="n">aux</span> <span class="n">i</span> 
    <span class="kr">where</span> <span class="n">aux</span> <span class="n">i</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="s">&quot;&quot;</span> <span class="kr">else</span> <span class="n">aux</span> <span class="p">(</span><span class="n">i</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">16</span><span class="p">)</span><span class="o">++</span><span class="p">(([</span><span class="sc">&#39;0&#39;</span><span class="o">..</span><span class="sc">&#39;9&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;F&#39;</span><span class="p">])</span><span class="o">!!</span><span class="p">[</span><span class="n">i</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">16</span><span class="p">])</span>
<span class="nf">tooct</span> <span class="n">i</span> <span class="ow">=</span> <span class="s">&quot;0o&quot;</span><span class="o">++</span><span class="n">aux</span> <span class="n">i</span> 
    <span class="kr">where</span> <span class="n">aux</span> <span class="n">i</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="s">&quot;&quot;</span> <span class="kr">else</span> <span class="n">aux</span> <span class="p">(</span><span class="n">i</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">8</span><span class="p">)</span><span class="o">++</span><span class="p">([</span><span class="sc">&#39;0&#39;</span><span class="o">..</span><span class="sc">&#39;7&#39;</span><span class="p">]</span><span class="o">!!</span><span class="p">[</span><span class="n">i</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">8</span><span class="p">])</span>


<span class="nf">unique</span>                     <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="c1">-- dont know why but forced to put the type</span>
<span class="nf">unique</span> <span class="ow">=</span> <span class="n">nub</span>

<span class="nf">insert_at</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">insert_at</span> <span class="n">i</span> <span class="n">toadd</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="n">i</span> <span class="n">xs</span> <span class="kr">in</span>
			   <span class="n">a</span><span class="o">++</span><span class="n">toadd</span><span class="o">++</span><span class="n">b</span>

<span class="nf">replace</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">replace</span> <span class="n">assoc</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">assoc</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="n">i</span> <span class="n">a</span> <span class="kr">in</span> <span class="n">x</span><span class="o">++</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">++</span><span class="n">y</span> <span class="p">)</span> <span class="n">xs</span>

<span class="nf">shift</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span>
<span class="nf">pop</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">(</span><span class="n">init</span> <span class="n">xs</span><span class="p">,</span> <span class="n">last</span> <span class="n">xs</span><span class="p">)</span> <span class="c1">-- more efficient let (a,[b]) = splitAt (xs.length - 1) xs in (a,b)</span>

<span class="nf">foldl_index</span> <span class="n">f</span> <span class="n">acc</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">f</span> <span class="n">acc</span> <span class="p">(</span><span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">complex_i</span> <span class="ow">=</span> <span class="mi">0</span> <span class="kt">:+</span> <span class="mi">1</span>

<span class="p">(</span><span class="o">&lt;=&gt;</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">compare</span> <span class="n">a</span> <span class="n">b</span>

<span class="c1">--debug expr = trace (&quot;Debug:&quot;++show expr++&quot;\n&quot;) expr</span>
<span class="c1">----------------------------------------------------------------------------------------------------</span>
<span class="kr">infixl</span> <span class="mi">1</span> <span class="o">&gt;&gt;&gt;</span>
<span class="p">(</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="n">monad</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">monad</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="n">return</span> <span class="err">°</span> <span class="n">f</span><span class="p">)</span>
<span class="nf">eval</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="n">putStrLn</span> <span class="err">°</span> <span class="n">show</span><span class="p">)</span>

<span class="nf">action</span> <span class="p">`</span><span class="n">when</span><span class="p">`</span> <span class="n">bool</span>   <span class="ow">=</span> <span class="kr">if</span> <span class="n">bool</span> <span class="kr">then</span> <span class="n">action</span> <span class="kr">else</span> <span class="n">return</span> <span class="nb">()</span>
<span class="nf">action</span> <span class="p">`</span><span class="n">unless</span><span class="p">`</span> <span class="n">bool</span> <span class="ow">=</span> <span class="n">action</span> <span class="p">`</span><span class="n">when</span><span class="p">`</span> <span class="p">(</span><span class="n">not</span> <span class="n">bool</span><span class="p">)</span>
<span class="nf">cat</span> <span class="n">file</span> <span class="ow">=</span> <span class="n">readFile</span> <span class="n">file</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">lines</span>
<span class="nf">contents</span> <span class="ow">=</span> <span class="n">getContents</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">lines</span>

<span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">l</span> <span class="ow">&lt;-</span> <span class="n">argv</span>
	  <span class="kr">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="kt">[]</span><span class="p">)</span> <span class="kr">then</span> <span class="n">contents</span> <span class="kr">else</span> <span class="n">foldM</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">cat</span> <span class="n">e</span> <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">))</span> <span class="kt">[]</span> <span class="n">l</span>

<span class="c1">-- i know it is just poor code, but haskell force me</span>
<span class="c1">-- TODO, dont work, seems monad are lazy too, dont understand io in haskell anymore :(</span>
<span class="c1">--  if do {l &lt;- exec &quot;ps ux&quot;; l2 &lt;- exec &quot;who&quot;; l.mapM putStrLn} print the contents of l2 !!</span>
<span class="nf">exec</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span> <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">system</span> <span class="p">(</span><span class="n">s</span><span class="o">++</span><span class="s">&quot; &gt; /tmp/file&quot;</span><span class="p">)</span>
	    <span class="n">cat</span> <span class="s">&quot;/tmp/file&quot;</span>

<span class="nf">rand</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Int</span> <span class="c1">-- force to do that to resolve overloading :(</span>
<span class="nf">rand</span> <span class="ow">=</span> <span class="n">getStdRandom</span> <span class="err">°</span> <span class="n">randomR</span>
<span class="nf">stdrand</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Double</span>
<span class="nf">stdrand</span> <span class="ow">=</span> <span class="n">getStdRandom</span> <span class="p">(</span><span class="n">randomR</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="nf">srand</span> <span class="n">val</span> <span class="ow">=</span> <span class="n">setStdGen</span> <span class="p">(</span><span class="n">mkStdGen</span> <span class="n">val</span><span class="p">)</span>

<span class="c1">-- in haskell we have getEnv::String -&gt; String, but not getEnvs :(</span>
<span class="nf">env</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="kt">String</span> <span class="kt">String</span><span class="p">)</span>
<span class="nf">env</span> <span class="ow">=</span> <span class="n">exec</span> <span class="s">&quot;env&quot;</span> <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="ow">=</span> <span class="n">s</span><span class="o">.</span><span class="n">match</span> <span class="s">&quot;(</span><span class="se">\\</span><span class="s">w+)=(.*)&quot;</span> <span class="kr">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span> <span class="o">$</span> <span class="n">fromList</span><span class="p">)</span>
<span class="c1">-- env = getEnvironment  -- for ghc</span>
<span class="nf">argv</span> <span class="ow">=</span> <span class="n">getArgs</span>

<span class="nf">just</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">just</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;Common:just&quot;</span>

<span class="nf">exit</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">primExitWith</span> <span class="n">i</span>
<span class="nf">usage</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="s">&quot;usage:&quot;</span><span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">exit</span> <span class="mi">1</span>

<span class="c1">-- printf a la danvy</span>
<span class="c1">-- type fmt a = </span>
<span class="c1">----------------------------------------------------------------------------------------------------</span>
<span class="c1">--ghc now = do cl &lt;- getClockTime</span>
<span class="c1">--ghc 	       return (toUTCTime cl)</span>
<span class="c1">--ghc localtime = toCalendarTime . toClockTime </span>
<span class="c1">--ghc strftime fmt time = formatCalendarTime defaultTimeLocale  fmt time</span>
<span class="c1">--ghc nulltime = TimeDiff {tdYear=0, tdMonth=0, tdDay=0, tdHour=0, tdMin=0, tdSec=0, tdPicosec = 0}</span>

<span class="c1">----------------------------------------------------------------------------------------------------</span>

<span class="c1">-- Collects e [e] where ...</span>
<span class="c1">-- Collects e (e -&gt; Bool) where ...</span>
<span class="c1">-- Collects Char BitSet where ...</span>
<span class="c1">-- (Hashable e, Collects a ce) Collects e (Array Int ce)</span>
<span class="c1">-- type Assoc a b = [(a,b)]</span>
<span class="c1">--    </span>
<span class="c1">-- -- this class support only collection of kind/1 =&gt; :( cos assoc dont match this criteria</span>
<span class="c1">-- -- note that some new type variable are introduced (something impossible with ocaml oo, can not</span>
<span class="c1">-- --  define a list object and then a fold, cos the type of the accumulator is new</span>
<span class="c1">-- --  can do it in caml/C++ by making fold an external function of the class</span>
<span class="c1">-- class Collection1 c where</span>
<span class="c1">--     member1 :: Eq e =&gt; e -&gt; c e -&gt; Bool -- need Eq e, otherwise at instance declaration, when member = elem, pb (WHY?)</span>
<span class="c1">--     cmap1   :: (a -&gt; b) -&gt; c a -&gt; c b</span>
<span class="c1">--     insert1 :: e -&gt; c e -&gt; c e</span>
<span class="c1">-- instance Collection1 [] where</span>
<span class="c1">--     member1 = elem</span>
<span class="c1">--     cmap1   = map</span>
<span class="c1">--     insert1 = (:)</span>
<span class="c1">-- -- instance Collection1 Assoc ..., is not possible</span>
<span class="c1">-- </span>
<span class="c1">-- -- class Collection2 e c where, useless constructor class do the same job</span>

<span class="c1">-- edison is cool, but they dont use depedencies =&gt; cant make a superclass Collection of Assoc and Sequence</span>
<span class="c1">--  morover, there are too many classes, i prefer one class Collection, and then instance OrdSet,Bag,OrdBag,...</span>
<span class="c1">-- edison use constructor class =&gt; if a type is not of the form c a, then it does not work</span>
<span class="c1">-- as for the Functor class, this is a pb cos you cant make an instance Functor Assoc, cos Assoc is of kind/2</span>
<span class="c1">-- TODO, to allow default null, need Eq ce =&gt;, mais apres foldl need des Eq [b] =&gt;</span>
<span class="c1">--  must cut Collection in section CollectionEq, Collection</span>
<span class="kr">class</span> <span class="kt">Collection</span> <span class="n">e</span> <span class="n">ce</span> <span class="o">|</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">e</span> <span class="kr">where</span>
    <span class="c1">-- constructors</span>
    <span class="n">empty</span> <span class="ow">::</span> <span class="n">ce</span>
    <span class="n">single</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="n">insert</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>

    <span class="n">fromList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="n">fromList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="n">flip</span> <span class="n">insert</span><span class="p">)</span> <span class="n">empty</span>
    <span class="n">copy</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
<span class="c1">--    union, intersect, difference :: ce -&gt; ce -&gt; ce</span>
        <span class="c1">-- tabulate ?</span>

    <span class="c1">-- destructors</span>
     <span class="c1">-- simple</span>
    <span class="n">delete</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>

    <span class="n">delete_all</span><span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="c1">-- not relevant for Set	      </span>
     <span class="c1">-- predicate based</span>

    <span class="n">filter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="n">partition</span><span class="ow">::</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">ce</span><span class="p">,</span><span class="n">ce</span><span class="p">)</span>
    <span class="c1">-- observers</span>
    <span class="n">toList</span> <span class="ow">::</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>

    <span class="n">size</span> <span class="ow">::</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="c1">--    member :: e -&gt; ce -&gt; Bool</span>
<span class="c1">--    null :: ce -&gt; Bool</span>
<span class="c1">--    null ce = ce == empty</span>
    

    <span class="c1">-- iterators</span>

       <span class="c1">--    concatMap, cfoldr + 1, reducer* ?</span>
    <span class="n">foldl</span><span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">a</span>
    <span class="n">each</span> <span class="ow">::</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>

    <span class="c1">-- find each</span>
    <span class="c1">-- zip unzip zippWith </span>
<span class="c1">--    map:: (e -&gt; b) -&gt; ce -&gt; cb -- cant define as is, would like a depedency constraint</span>
	                       <span class="c1">-- such as ce+b-&gt;cb</span>
	                       <span class="c1">-- can be put outside and use insert/observers</span>

<span class="c1">-- TODO make AssocOrd class, OrdColl, ...</span>
<span class="c1">-- goal: Set,Bag</span>
<span class="c1">-- implementation: list,ordlist, (if odererd =&gt; can use bintree), okasaki optimised</span>

<span class="nf">null</span> <span class="n">es</span> <span class="ow">=</span> <span class="n">es</span> <span class="o">==</span> <span class="n">empty</span>
<span class="nf">member</span> <span class="n">e</span> <span class="n">es</span> <span class="ow">=</span> <span class="n">e</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">(</span><span class="n">es</span><span class="o">.</span><span class="n">toList</span><span class="p">)</span>

<span class="c1">-- TODO, could make union more cool, to allow each time different collection</span>
<span class="c1">-- could allow to do in place of a.insert e, [e]+a </span>
<span class="nf">union</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Collection</span> <span class="n">a</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="c1">-- to force the same collection type</span>
<span class="nf">union</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="n">flip</span> <span class="n">insert</span><span class="p">)</span> <span class="n">a</span>
<span class="nf">intersect</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Collection</span> <span class="n">a</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="c1">-- to force the same collection type</span>
<span class="nf">intersect</span>  <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">e</span> <span class="p">`</span><span class="n">member</span><span class="p">`</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">a</span><span class="o">.</span><span class="n">insert</span> <span class="n">e</span> <span class="kr">else</span> <span class="n">a</span><span class="p">)</span> <span class="n">empty</span>
<span class="nf">difference</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Collection</span> <span class="n">a</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="c1">-- to force the same collection type</span>
<span class="nf">difference</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">e</span> <span class="p">`</span><span class="n">member</span><span class="p">`</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">a</span> <span class="kr">else</span> <span class="n">a</span><span class="o">.</span><span class="n">insert</span> <span class="n">e</span><span class="p">)</span> <span class="n">empty</span>
    
<span class="kr">class</span> <span class="kt">Collection</span> <span class="n">e</span> <span class="n">ce</span> <span class="ow">=&gt;</span> <span class="kt">Sequence</span> <span class="n">e</span> <span class="n">ce</span> <span class="kr">where</span>
    <span class="c1">-- constructors</span>
    <span class="n">cons</span><span class="p">,</span><span class="n">snoc</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="n">append</span> <span class="ow">::</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="n">append</span> <span class="ow">=</span> <span class="n">union</span>
    <span class="c1">-- destructors</span>
     <span class="c1">--simple</span>
    <span class="n">lview</span><span class="p">,</span><span class="n">rview</span> <span class="ow">::</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">ce</span><span class="p">)</span>

    <span class="n">lhead</span><span class="p">,</span><span class="n">rhead</span> <span class="ow">::</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">e</span>
    <span class="n">ltail</span><span class="p">,</span><span class="n">rtail</span> <span class="ow">::</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
     <span class="c1">-- int based</span>
    <span class="n">take</span><span class="p">,</span><span class="n">drop</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="n">splitAt</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">ce</span><span class="p">,</span><span class="n">ce</span><span class="p">)</span>
    <span class="n">subseq</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="n">takeWhile</span><span class="p">,</span><span class="n">dropWhile</span><span class="ow">::</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="n">splitWhile</span> <span class="ow">::</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">ce</span><span class="p">,</span><span class="n">ce</span><span class="p">)</span>
    <span class="c1">-- misc</span>
    <span class="n">reverse</span> <span class="ow">::</span> <span class="n">ce</span> <span class="ow">-&gt;</span> <span class="n">ce</span>
    <span class="c1">--    concat :: [ce] -&gt; ce; not [ce] but ce ce =&gt; how ?</span>
    <span class="c1">-- update, inbounds, adjust, [map|foldl|foldr]WithIndex</span>

<span class="c1">-- instance [a], Queue [a], okasaki optimised</span>

<span class="c1">-- TODO, make too strong condition, Eq b for example, could make keyss outside the class</span>
<span class="kr">class</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Collection</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">cab</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Association</span> <span class="n">a</span> <span class="n">b</span> <span class="n">cab</span> <span class="o">|</span> <span class="n">cab</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">cab</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span>
    <span class="n">keys</span> <span class="ow">::</span> <span class="n">cab</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="n">values</span><span class="ow">::</span> <span class="n">cab</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
    <span class="n">has_key</span><span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">cab</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">has_key</span> <span class="n">k</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">k</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>
    <span class="n">delete_key</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">cab</span> <span class="ow">-&gt;</span> <span class="n">cab</span>
    <span class="n">each_key</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">cab</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
    <span class="n">keyss</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">cab</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="n">keyss</span> <span class="n">v</span> <span class="n">cab</span> <span class="ow">=</span> <span class="n">cab</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="n">snd</span> <span class="o">$</span> <span class="p">(</span><span class="o">==</span><span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">map</span> <span class="n">fst</span>
    <span class="n">has_value</span><span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">cab</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">has_value</span> <span class="n">v</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">v</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>		  

<span class="c1">-- instance Assoc, okasaki optimised (bintree, ...)</span>
<span class="c1">-- AssocMulti, key -&gt; list</span>

<span class="nf">map</span> <span class="n">f</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span><span class="kt">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
<span class="nf">cmap</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">toList</span> <span class="err">°</span> <span class="n">map</span> <span class="n">f</span> <span class="err">°</span> <span class="n">fromList</span> <span class="c1">-- cant make in the type that this must be the same collection</span>

<span class="kr">class</span> <span class="kt">Indexable</span> <span class="n">i</span> <span class="n">ca</span> <span class="n">a</span> <span class="o">|</span> <span class="n">ca</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">!~</span><span class="p">)</span> <span class="ow">::</span> <span class="n">ca</span> <span class="ow">-&gt;</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="c1">-- lookupM</span>
    <span class="p">(</span><span class="o">!</span><span class="p">)</span> <span class="ow">::</span> <span class="n">ca</span> <span class="ow">-&gt;</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="c1">-- lookup, to be more esthetic do s!(0) rather than s!0</span>
    <span class="p">(</span><span class="o">!</span><span class="p">)</span> <span class="n">xs</span> <span class="n">i</span> <span class="ow">=</span> <span class="p">(</span><span class="n">xs</span><span class="o">!~</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">just</span>
    <span class="c1">-- lookupWithDefaul</span>
    <span class="p">(</span><span class="o">!!</span><span class="p">)</span> <span class="ow">::</span> <span class="n">ca</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="p">(</span><span class="o">!!</span><span class="p">)</span> <span class="n">xs</span> <span class="n">is</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">xs</span> <span class="o">!</span> <span class="n">i</span><span class="p">)</span> <span class="n">is</span> <span class="c1">-- seems you can not define with infix notation default class value</span>

<span class="c1">-------------------------------</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">b</span><span class="p">,</span><span class="kt">Ord</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Indexable</span> <span class="n">b</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="n">a</span> <span class="kr">where</span>
<span class="c1">-- to allow s![1..]</span>
<span class="c1">-- note: a &#39;try (...) with&#39; would be more efficient that constantly check for array bound</span>
<span class="c1">-- note: we stop as soon as we have a big index =&gt; xs ! [1000, 2,3] if length xs &lt; 1000 will give [] </span>
<span class="c1">--   (to handle infinite list)</span>
<span class="c1">-- TODO allow s!![-4..]</span>
    <span class="p">(</span><span class="o">!!</span><span class="p">)</span> <span class="n">xs</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
    <span class="p">(</span><span class="o">!!</span><span class="p">)</span> <span class="n">xs</span> <span class="p">(</span><span class="n">i</span><span class="kt">:</span><span class="n">is</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">fromInt</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">[]</span> <span class="c1">-- handle infinite list</span>
		   <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span>          <span class="ow">=</span> <span class="n">xs</span><span class="o">!</span><span class="p">((</span><span class="n">fromInt</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">))</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="kt">:</span> <span class="n">xs</span><span class="o">!!</span><span class="n">is</span>
		   <span class="o">|</span> <span class="n">otherwise</span>      <span class="ow">=</span> <span class="n">xs</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="kt">:</span> <span class="n">xs</span><span class="o">!!</span><span class="n">is</span>


<span class="c1">--    (x:_)  !~ 0       = Just x</span>
    <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span>  <span class="o">!~</span> <span class="n">n</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>  <span class="ow">=</span> <span class="kt">Just</span> <span class="n">x</span> <span class="c1">-- allow s!3.2</span>
    <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">!~</span> <span class="n">n</span> <span class="o">|</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">!~</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="kr">_</span>  <span class="o">!~</span> <span class="kr">_</span>       <span class="ow">=</span> <span class="kt">Nothing</span>


<span class="kr">instance</span> <span class="kt">Collection</span> <span class="n">a</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">insert</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span>

    <span class="n">foldl</span> <span class="n">f</span> <span class="n">z</span> <span class="kt">[]</span>      <span class="ow">=</span> <span class="n">z</span>
    <span class="n">foldl</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">foldl</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">z</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span>
    
    <span class="n">filter</span> <span class="n">p</span> <span class="n">xs</span>       <span class="ow">=</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">p</span> <span class="n">x</span> <span class="p">]</span>
    <span class="n">each</span> <span class="ow">=</span> <span class="n">mapM_</span>
    <span class="n">toList</span> <span class="ow">=</span> <span class="n">id</span>
    <span class="n">fromList</span> <span class="ow">=</span> <span class="n">id</span> <span class="c1">-- default fromList dont respect the order</span>
    <span class="n">empty</span> <span class="ow">=</span> <span class="kt">[]</span>


<span class="kr">instance</span> <span class="kt">Sequence</span> <span class="n">a</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">reverse</span>    <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span>

<span class="c1">-- this can be dangerous, cos insert for an Association is replace/add (key,val) whereas</span>
<span class="c1">-- for a list with simply add, and so use Assoc if you want to choose</span>
<span class="c1">-- same for each, each will print all the pair, even the obsolete</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span><span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Association</span> <span class="n">a</span> <span class="n">b</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]</span> <span class="kr">where</span>    
    <span class="n">keys</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">map</span> <span class="n">fst</span>
    <span class="n">delete_key</span> <span class="n">k</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">/=</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">each_key</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">keys</span> <span class="o">$</span> <span class="n">each</span> <span class="n">f</span>
    
<span class="c1">-------------------------------</span>
<span class="kr">data</span> <span class="kt">SetList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">SetList</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Collection</span> <span class="n">a</span> <span class="p">(</span><span class="kt">SetList</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">insert</span> <span class="n">e</span> <span class="p">(</span><span class="kt">SetList</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">SetList</span> <span class="p">(</span><span class="n">e</span><span class="kt">:</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="o">/=</span> <span class="n">e</span><span class="p">)))</span>
    <span class="n">toList</span> <span class="p">(</span><span class="kt">SetList</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span>			    
    

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">SetList</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Default_val</span> <span class="p">(</span><span class="kt">SetList</span> <span class="n">a</span><span class="p">)</span>  <span class="kr">where</span> <span class="n">null_val</span> <span class="ow">=</span> <span class="kt">SetList</span> <span class="kt">[]</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">SetList</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="p">(</span><span class="kt">SetList</span> <span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">SetList</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">all</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="n">ys</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">ys</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="c1">-------------------------------</span>
<span class="kr">data</span> <span class="kt">Assoc</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Assoc</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]</span> <span class="kr">deriving</span> <span class="kt">Eq</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="o">^</span><span class="s">&quot; =&gt; &quot;</span><span class="o">^</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">unlines</span>


<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Collection</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">empty</span> <span class="ow">=</span> <span class="kt">Assoc</span> <span class="kt">[]</span>
    <span class="n">insert</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Assoc</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="kt">:</span><span class="n">xs</span><span class="o">.</span><span class="n">filter</span> <span class="p">((</span><span class="o">/=</span> <span class="n">k</span><span class="p">)</span> <span class="err">°</span> <span class="n">fst</span><span class="p">))</span>  <span class="c1">-- [ (k&#39;,v&#39;) | (k&#39;,v&#39;) &lt;- xs, k /= k&#39;])</span>
    <span class="n">toList</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span>
    <span class="n">each</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">each</span> <span class="n">f</span>
    <span class="n">foldl</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">foldl</span> <span class="n">f</span> <span class="n">z</span>


<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span><span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Association</span> <span class="n">a</span> <span class="n">b</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">keys</span>   <span class="p">(</span><span class="kt">Assoc</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">map</span> <span class="n">fst</span>
    <span class="n">values</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">map</span> <span class="n">snd</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Indexable</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="n">b</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">!~</span><span class="p">)</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="kt">[]</span><span class="p">)</span> <span class="n">k</span> <span class="ow">=</span> <span class="kt">Nothing</span>
    <span class="p">(</span><span class="o">!~</span><span class="p">)</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">xys</span><span class="p">))</span> <span class="n">k</span> <span class="o">|</span> <span class="n">k</span><span class="o">==</span><span class="n">x</span>      <span class="ow">=</span> <span class="kt">Just</span> <span class="n">y</span>
			       <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">xys</span><span class="p">)</span><span class="o">!~</span><span class="n">k</span>

<span class="c1">-- to do assoc with default value to allow </span>
<span class="c1">--  from.update (name,+1), better than</span>
<span class="c1">--  from.insert(name,1+((from!~name ||| (Just 0)).just))</span>
<span class="kr">data</span> <span class="kt">AssocDefault</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)])</span> <span class="kr">deriving</span> <span class="kt">Eq</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">xs</span><span class="p">))</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="o">^</span><span class="s">&quot; =&gt; &quot;</span><span class="o">^</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">unlines</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span><span class="kt">Default_val</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Collection</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">empty</span> <span class="ow">=</span> <span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">null_val</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span> 
    <span class="n">insert</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">xs</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="kt">:</span><span class="n">xs</span><span class="o">.</span><span class="n">filter</span> <span class="p">((</span><span class="o">/=</span> <span class="n">k</span><span class="p">)</span> <span class="err">°</span> <span class="n">fst</span><span class="p">)))</span>  <span class="c1">-- [ (k&#39;,v&#39;) | (k&#39;,v&#39;) &lt;- xs, k /= k&#39;])</span>
    <span class="n">toList</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">xs</span><span class="p">))</span> <span class="ow">=</span> <span class="n">xs</span>
    <span class="n">each</span> <span class="n">f</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">xs</span><span class="p">))</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">each</span> <span class="n">f</span>
    <span class="n">foldl</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">xs</span><span class="p">))</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">foldl</span> <span class="n">f</span> <span class="n">z</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span><span class="kt">Default_val</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Association</span> <span class="n">a</span> <span class="n">b</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">keys</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">xs</span><span class="p">))</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">map</span> <span class="n">fst</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Indexable</span> <span class="n">a</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="n">b</span> <span class="kr">where</span>
   <span class="p">(</span><span class="o">!~</span><span class="p">)</span> <span class="p">(</span><span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">xs</span><span class="p">))</span> <span class="n">k</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Assoc</span> <span class="n">xs</span><span class="p">)</span><span class="o">!~</span> <span class="n">k</span>

<span class="c1">-- TODO, could put update in classe Association ?</span>
<span class="nf">update</span> <span class="n">k</span> <span class="n">f</span> <span class="n">h</span><span class="o">@</span><span class="p">(</span><span class="kt">AssocDefault</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">xs</span><span class="p">))</span> <span class="ow">=</span> <span class="n">h</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="o">!~</span><span class="n">k</span> <span class="o">|||</span> <span class="kt">Just</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">just</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
<span class="c1">----------------------------------------------------------------------------------------------------</span>

<span class="c1">-- make tuple indexable, oveload ! to work with all, but does not work</span>
<span class="c1">-- instance Indexable Int (a,b) a where</span>
<span class="c1">--     (!~) (a,b) 0 = Just a</span>
<span class="c1">-- instance Indexable Int (a,b) b where</span>
<span class="c1">--     (!~) (a,b) 1 = Just b</span>


    
<span class="c1">----------------------------------------------------------------------------------------------------</span>
<span class="c1">-- matrix, there exist some implementation on the web, TODO dont do list but fixed size vector =&gt;</span>
<span class="c1">-- could make compile-time check, ex *, we must have row_size a = column_size b</span>
<span class="c1">-- TODO, could be made a class of FinitMap, and that we could have a generic accessor</span>
<span class="kr">newtype</span> <span class="kt">Matrix</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Matrix</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span> <span class="c1">-- prefer a newtype, cos dont want to allow + on every list of list</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Show</span><span class="p">)</span> <span class="c1">-- newtype force you to redefine the deriving stuff</span>
<span class="nf">row_size</span>    <span class="p">(</span><span class="kt">Matrix</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">m</span><span class="o">.</span><span class="n">length</span>
<span class="nf">column_size</span> <span class="p">(</span><span class="kt">Matrix</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">m</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">length</span>
<span class="p">(</span><span class="o">%%</span><span class="p">)</span> <span class="p">(</span><span class="kt">Matrix</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">m</span><span class="o">!</span><span class="n">i</span><span class="o">!</span><span class="n">j</span>

<span class="c1">-- could so straessen, this is very inefficient cos we dont have 0(1) access to element</span>
<span class="c1">-- TODO, use list comprehension, cf hugs demo</span>
<span class="kr">instance</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Num</span> <span class="p">(</span><span class="kt">Matrix</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">ma</span> <span class="o">*</span> <span class="n">mb</span> <span class="o">|</span> <span class="n">ma</span><span class="o">.</span><span class="n">column_size</span> <span class="o">==</span> <span class="n">mb</span><span class="o">.</span><span class="n">row_size</span> <span class="ow">=</span> <span class="kt">Matrix</span> <span class="n">aux</span>
	    <span class="kr">where</span> <span class="n">aux</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">ma</span><span class="o">.</span><span class="n">row_size</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">i</span> <span class="ow">-&gt;</span> 
				<span class="n">acc</span><span class="o">++</span><span class="p">[</span>
				      <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">mb</span><span class="o">.</span><span class="n">column_size</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				      <span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">j</span> <span class="ow">-&gt;</span>
					      <span class="n">acc</span><span class="o">++</span><span class="p">[</span>
						    <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">ma</span><span class="o">.</span><span class="n">column_size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
						    <span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">k</span> <span class="ow">-&gt;</span>
							    <span class="n">acc</span><span class="o">+</span>
							    <span class="p">(</span><span class="n">ma</span><span class="o">%%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">mb</span> <span class="o">%%</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">))))</span>
						    <span class="mi">0</span><span class="p">]</span>
					      <span class="p">)</span> <span class="kt">[]</span>
				      <span class="p">]</span>
				<span class="p">)</span> <span class="kt">[]</span>


<span class="c1">----------------------------------------------------------------------------------------------------</span>
<span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Default_val</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">null_val</span> <span class="ow">::</span> <span class="n">a</span>
    <span class="n">is_null</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">is_null</span> <span class="ow">=</span> <span class="p">(</span><span class="o">==</span> <span class="n">null_val</span><span class="p">)</span>

<span class="c1">-- not really logical, cos we dont really need to force Default_val a, we dont care about a</span>
<span class="c1">--instance Default_val a =&gt; Default_val [a]  where null_val = []</span>
<span class="c1">-- and need provide extra instance</span>
<span class="c1">--instance Default_val Char  where null_val = &#39;a&#39;</span>

<span class="c1">-- need -98 option, still dont know why we need to put the constraint Eq [a] for working</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">=&gt;</span> <span class="kt">Default_val</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>  <span class="kr">where</span> <span class="n">null_val</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Default_val</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span> <span class="n">null_val</span> <span class="ow">=</span> <span class="kt">Nothing</span>

<span class="c1">-- instance Num b =&gt; Default_val b    where null_val = 0; cant do that :( hugs say it overlaps</span>
<span class="c1">--  but it is not cos [a] is not member of the Num class</span>
<span class="kr">instance</span> <span class="kt">Default_val</span> <span class="kt">Int</span>  <span class="kr">where</span> <span class="n">null_val</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="kr">instance</span> <span class="kt">Default_val</span> <span class="kt">Float</span>  <span class="kr">where</span> <span class="n">null_val</span> <span class="ow">=</span> <span class="mf">0.0</span>
<span class="c1">-- would like to do that, but not possible cos Num is a class, not a type</span>
<span class="c1">--instance Default_val (Num a) where null_val = 0</span>

<span class="c1">-- v1 = (2::Int) &amp;&amp;&amp; &quot;ee&quot; --  &quot;ee&quot; -- need the type annotation :(</span>
<span class="c1">-- v2 = 0.0 &amp;&amp;&amp; &quot;ee&quot; --  &quot;&quot;</span>

<span class="c1">-- overloading on return value</span>
<span class="p">(</span><span class="o">&amp;&amp;&amp;</span><span class="p">)</span><span class="ow">::</span> <span class="p">(</span><span class="kt">Default_val</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Default_val</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">a</span> <span class="o">&amp;&amp;&amp;</span> <span class="n">b</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_null</span> <span class="kr">then</span> <span class="n">null_val</span> <span class="kr">else</span> <span class="n">b</span>

<span class="p">(</span><span class="o">|||</span><span class="p">)</span><span class="ow">::</span> <span class="kt">Default_val</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">a</span> <span class="o">|||</span> <span class="n">b</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_null</span> <span class="kr">then</span> <span class="n">b</span> <span class="kr">else</span> <span class="n">a</span>

<span class="c1">----------------------------------------------------------------------------------------------------</span>
<span class="c1">-- class Show a =&gt; Showbis a where</span>
<span class="c1">--    showbis :: a -&gt; String</span>
<span class="c1">--    showbis x = show x</span>
<span class="c1">-- cant do instance Showbis [Char] where showbis x = x</span>
<span class="c1">--  cos we cant specialise so far in haskell, we specialise &quot;chacun son tour&quot; =&gt;</span>
<span class="c1">--  first [] then Char =&gt; to handle that, do as in the class Show, make 2 func</span>
<span class="c1">-- (as you may have note,  show &quot;123&quot; =&gt; &quot;123&quot; and show &#39;1&#39; =&gt; &#39;1&#39;, strange, might expect</span>
<span class="c1">--  [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;] cos String = [Char]</span>
<span class="c1">--  in fact, show [a] is not a map show !! cf Prelude to understand the trick</span>
<span class="c1">--  they introduce another func in the class definition to allow specialisation for [a]</span>

<span class="c1">--    showbisList :: [a] -&gt; String</span>
<span class="c1">--    showbisList [] = &quot;[]&quot;</span>
<span class="c1">--    showbisList (x:xs) = &quot;[&quot; ++ join &quot;,&quot; (map show (x:xs)) ++ &quot;]&quot;</span>

<span class="c1">--instance Showbis a =&gt; Showbis [a] where showbis = showbisList</span>
<span class="c1">--instance Num a =&gt; Showbis a where showbis = show</span>

<span class="c1">-- the beautfile one, but hugs/ghc do special case with show; when </span>
<span class="c1">--   do 1 ~~ 2 then he wants (1::Int) ~~ (2::Int) :((</span>
<span class="c1">-- (~~) a b = showbis a ++ showbis b</span>

<span class="c1">-- the ugly one, if you have a type that when show put a &quot; at begin and end, then pb !!</span>
<span class="c1">--  but as it is rarely the case, no matter, same for \</span>
<span class="nf">update_anti_slash</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">update_anti_slash</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="nf">update_anti_slash</span> <span class="p">(</span><span class="sc">&#39;</span><span class="se">\\</span><span class="sc">&#39;</span><span class="kt">:</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> 
    <span class="p">(</span><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> 
     <span class="n">&#39;n&#39;</span> <span class="ow">-&gt;</span> <span class="sc">&#39;</span><span class="se">\n</span><span class="sc">&#39;</span>
     <span class="n">&#39;t&#39;</span> <span class="ow">-&gt;</span> <span class="sc">&#39;</span><span class="se">\t</span><span class="sc">&#39;</span>
     <span class="n">x</span>   <span class="ow">-&gt;</span> <span class="n">x</span>
     <span class="p">)</span> <span class="kt">:</span> <span class="n">update_anti_slash</span> <span class="n">xs</span>
<span class="nf">update_anti_slash</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">update_anti_slash</span> <span class="n">xs</span>

<span class="nf">del_enclose</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">del_enclose</span> <span class="n">xs</span> <span class="o">|</span> <span class="n">length</span> <span class="n">xs</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">=</span> <span class="n">xs</span>
	       <span class="o">|</span> <span class="n">head</span> <span class="n">xs</span> <span class="o">==</span> <span class="sc">&#39;&quot;&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">last</span> <span class="n">xs</span> <span class="o">==</span> <span class="sc">&#39;&quot;&#39;</span> <span class="ow">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">init</span>
	       <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">xs</span>
<span class="p">(</span><span class="o">^</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">(</span><span class="n">update_anti_slash</span> <span class="err">°</span> <span class="n">del_enclose</span> <span class="err">°</span> <span class="n">show</span><span class="p">)</span> <span class="n">a</span> <span class="o">++</span> <span class="p">(</span><span class="n">update_anti_slash</span> <span class="err">°</span> <span class="n">del_enclose</span> <span class="err">°</span> <span class="n">show</span><span class="p">)</span> <span class="n">b</span> 
<span class="c1">-- (^) a b  = let op = update_anti_slash ° del_enclose ° show in op a ++ op b -- dont WORK !! AMAZING</span>
<span class="kr">infixl</span> <span class="mi">1</span> <span class="o">^</span>
</pre></div>
</body>
</html></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="webautomation.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Web Automation</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>&nbsp;</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>