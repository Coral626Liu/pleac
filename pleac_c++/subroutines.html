<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Subroutines</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-C++/STL/Boost"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Directories"
HREF="directories.html"><LINK
REL="NEXT"
TITLE="References and Records"
HREF="referencesandrecords.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-C++/STL/Boost</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SUBROUTINES"
>10. Subroutines</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN536"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// NOTE: Whilst it is perfectly valid to use Standard C Library, or GNU C Library, routines in</span>
<span class="c1">// C++ programs, the code examples here will, as far as possible, avoid doing so, instead using</span>
<span class="c1">// C++-specific functionality and idioms. In general:</span>
<span class="c1">// * I/O will be iostream-based [i.e. no &#39;scanf&#39;, &#39;printf&#39;, &#39;fgets&#39; etc]</span>
<span class="c1">// * Container / iterator idioms based on the Standard Template Library [STL]</span>
<span class="c1">//   will replace the built-in array / raw pointer idioms typically used in C</span>
<span class="c1">// * Boost Library functionality utilised wherever possible [the reason for</span>
<span class="c1">//   this is that much of this functionality is likely to appear in the next</span>
<span class="c1">//   C++ standard]</span>
<span class="c1">// * Error detection/handling will generally be exception-based [this is done</span>
<span class="c1">//   to keep examples simple. Exception use is optional in C++, and is not as</span>
<span class="c1">//   pervasive as it is in other languages like Java or C#]</span>
<span class="c1">// C-based solution(s) to problem(s) will be found in the corresponding section of PLEAC-C/Posix/GNU.</span>

<span class="cp">#include &lt;iostream&gt;</span>

<span class="c1">// &#39;greeted&#39; defined outside of any namespace, class or function, so is part of the</span>
<span class="c1">// global namespace, and will be visible throughout the entire executable. Should it</span>
<span class="c1">// be necessary to restrict the visibility of this global identifier to the current</span>
<span class="c1">// &#39;compilation unit&#39; [i.e. current source file] then the following may be used:</span>
<span class="c1">//</span>
<span class="c1">//     namespace { int greeted = 0; }</span>
<span class="c1">//</span>
<span class="c1">// The effect is similar to using the &#39;static&#39; keyword, in this same context, in the C</span>
<span class="c1">// language.</span>

<span class="kt">int</span> <span class="n">greeted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">howManyGreetings</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">hello</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">hello</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">greetings</span> <span class="o">=</span> <span class="n">howManyGreetings</span><span class="p">();</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bye there!, there have been &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">greetings</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; greetings so far&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">howManyGreetings</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Access &#39;greeted&#39; identifier in the global namespace using the scope resolution</span>
  <span class="c1">// operator. Use of this operator is only necessary if a similarly-named identifier</span>
  <span class="c1">// exists in a </span>
  <span class="k">return</span> <span class="o">::</span><span class="n">greeted</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hello</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Here &#39;greeted&#39; is accessed without additional qualification. Since a &#39;greeted&#39; identifier</span>
  <span class="c1">// exists only in the global namespace, it is that identifier that is used</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;high there!, this function has been called &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">greeted</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; times&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN539"
>Accessing Subroutine Arguments</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Standard C++ requires that a function be prototyped, hence the name and type of parameters</span>
<span class="c1">// must be specified, and the argumemt list in any calls to that function must match the</span>
<span class="c1">// parameter list, as shown here </span>

<span class="cp">#include &lt;cmath&gt;</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Variable length argument list functions, via the C Language derived &#39;va_...&#39; macros,</span>
<span class="c1">// are also supported. However use of this facility is particularly discouraged in C++</span>
<span class="c1">// because:</span>
<span class="c1">// * It is an inherently type-unsafe facility; type safety is a core C++ concern</span>
<span class="c1">// * Other facilities, such as overloaded functions, and default arguments [neither of which</span>
<span class="c1">//   are available in C] can sometimes obviate the need for variable length argument lists</span>
<span class="c1">// * OOP techniques can also lessen the need for variable length argument lists. The most</span>
<span class="c1">//   obvious example here is the Iostream library where repeated calls of I/O operators replace</span>
<span class="c1">//   the format string / variable arguments of &#39;printf&#39;</span>

<span class="cp">#include &lt;cmath&gt;</span>
<span class="cp">#include &lt;cstdarg&gt;</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="p">...);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="c1">// More details available in the corresponding section of PLEAC-C/Posix/GNU</span>
  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">side1</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">side2</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// An example using default arguments appears below</span>

<span class="cp">#include &lt;cmath&gt;</span>

<span class="c1">// Specify default argument values in declaration</span>
<span class="c1">// Note: This may be done in either of the declaration or the definition [not both], but it</span>
<span class="c1">// makes more sense to do so in the declaration since these are usually placed in header files</span>
<span class="c1">// which may be included in several source files. The default argument values would need to be</span>
<span class="c1">// known in all those locations</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// All arguments specified</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>

  <span class="c1">// Both calls utilise default argument value(s)</span>
  <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">);</span>

  <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// A [very contrived, not very practical] example using function overloading appears below</span>

<span class="cp">#include &lt;cmath&gt;</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Call version (1)</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>

  <span class="c1">// Call version (2)</span>
  <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">);</span>

  <span class="c1">// Call version (3)</span>
  <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// (1)</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// (2)</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// (3)</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;cstddef&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_all</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">arrsize</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_all</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load vectors from built-in arrays, or use Boost &#39;assign&#39; library</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">};</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// Conversion effected at vector creation time</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span> <span class="o">=</span> <span class="n">int_all</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">arrsize</span><span class="p">);</span>

  <span class="c1">// Vector -&gt; vector copy / conversion </span>
  <span class="n">ints</span> <span class="o">=</span> <span class="n">int_all</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">nums</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_all</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">arrsize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_all</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">r</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>  <span class="c1">// Type safe element copying </span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;algorithm&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="cp">#include &lt;cmath&gt;</span>
<span class="cp">#include &lt;cstddef&gt;</span>

<span class="kt">void</span> <span class="n">trunc_em</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load vectors from built-in arrays, or use Boost &#39;assign&#39; library</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">};</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">numsv</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">nums</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">);</span>

  <span class="n">trunc_em</span><span class="p">(</span><span class="n">numsv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">trunc_em</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Replace each element with the value returned by applying &#39;floor&#39; to that element</span>
  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">floor</span><span class="p">);</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN542"
>Making Variables Private to a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Variables declared within a function body are local to that function, and those declared</span>
<span class="c1">// outside a function body [and not as part of a class / struct definition, or enclosed within</span>
<span class="c1">// a namespace] are global, that is, are visible throughout the executable unless their</span>
<span class="c1">// visibility has been restricted to the source file in which they are defined via enclosing</span>
<span class="c1">// them within an anonymous namespace [which has the same effect as using the &#39;static&#39; keyword,</span>
<span class="c1">// in this same context, in the C language]</span>

<span class="cp">#include &lt;vector&gt;</span>

<span class="kt">void</span> <span class="n">somefunc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// All these variables are local to this function</span>
  <span class="kt">int</span> <span class="n">variable</span><span class="p">,</span> <span class="n">another</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// A couple of generic, type-safe type conversion helpers. The Boost Library sports a conversion</span>
<span class="c1">// library at: http://www.boost.org/libs/conversion/index.html</span>

<span class="cp">#include &lt;sstream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">class</span> <span class="nc">bad_conversion</span> <span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fromString</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">iss</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">T</span> <span class="n">t</span><span class="p">;</span> <span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iss</span><span class="p">)</span> <span class="k">throw</span> <span class="n">bad_conversion</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
  <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ends</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oss</span><span class="p">)</span> <span class="k">throw</span> <span class="n">bad_conversion</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;string&gt;</span>

<span class="c1">// File scope variables</span>
<span class="k">namespace</span> 
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">condition</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">run_check</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">check_x</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="c1">// An alternative, C++-specific approach, to command-line handling and type conversion</span>
<span class="c1">// may be seen at: http://www.boost.org/libs/conversion/lexical_cast.htm</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">name</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">try</span>
  <span class="p">{</span>  
    <span class="n">age</span> <span class="o">=</span> <span class="n">fromString</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">bad_conversion</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ... handle conversion error ...</span>
  <span class="p">}</span>

  <span class="n">check_x</span><span class="p">(</span><span class="n">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">void</span> <span class="nf">run_check</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Full access to file scope variables</span>
  <span class="n">condition</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">check_x</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Full access to file scope variables</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">y</span><span class="p">(</span><span class="s">&quot;whatever&quot;</span><span class="p">);</span>

  <span class="n">run_check</span><span class="p">();</span>

  <span class="c1">// &#39;condition&#39; updated by &#39;run_check&#39;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN545"
>Creating Persistent Private Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Standard C++, owing to its C heritage, allows the creation of &#39;persistent private variables&#39;,</span>
<span class="c1">// via use of the &#39;static&#39; keyword. For more details about this, and illustrative code examples,</span>
<span class="c1">// refer to this same section in PLEAC-C/Posix/GNU. Standard C++-specific methods of perfoming</span>
<span class="c1">// this task involve use of the &#39;namespace&#39; facility, or creating a class containing &#39;static&#39;</span>
<span class="c1">// members and using access specifiers to restrict access</span>

<span class="c1">// This example replaces the &#39;static&#39; keyword with use of an anonymous namespace to force</span>
<span class="c1">// &#39;variable&#39; to have file scope, and be visible only within the &#39;mysubs.cpp file. It is</span>
<span class="c1">// therefore both persistant [because it is a global variable] and private [because it is</span>
<span class="c1">// visible only to functions defined within the same source file]</span>

<span class="c1">// File: &#39;mysubs.h&#39;</span>
<span class="kt">void</span> <span class="nf">mysub</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;mysubs.cpp&#39;</span>
<span class="k">namespace</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">variable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">mysub</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ... do something with &#39;variable&#39; ...</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">variable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;test.cpp&#39;</span>
<span class="cp">#include &quot;mysubs.h&quot;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// &#39;variable&#39; is not accessable here</span>

  <span class="c1">// Call &#39;mysub&#39;, which can access &#39;variable&#39;</span>
  <span class="n">mysub</span><span class="p">();</span>

  <span class="c1">// Call &#39;reset&#39; which sets &#39;variable&#39; to 1  </span>
  <span class="n">reset</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// This example is similar to the previous one in using an anonymous namespace to restrict</span>
<span class="c1">// variable visibility. It goes further, hoewever, grouping logically related items within</span>
<span class="c1">// a named namespace, thus ensuring access to those items is controlled [i.e. requires</span>
<span class="c1">// qualification, or a &#39;using&#39; declaration or directive]</span>

<span class="c1">// File: &#39;counter.h&#39;</span>
<span class="k">namespace</span> <span class="n">cnt</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">increment</span><span class="p">();</span>
  <span class="kt">int</span> <span class="nf">decrement</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;counter.cpp&#39;</span>
<span class="k">namespace</span> <span class="n">cnt</span>
<span class="p">{</span>
  <span class="c1">// Ensures &#39;counter&#39; is visible only within the current source file</span>
  <span class="k">namespace</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">reset</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">int</span> <span class="n">increment</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">decrement</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">--</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;test.cpp&#39;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &quot;counter.h&quot;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Following line is illegal because &#39;cnt::counter&#39; is private to the &#39;counter.cpp&#39; file</span>
  <span class="c1">// int c = cnt::counter;</span>
  
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">::</span><span class="n">increment</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">::</span><span class="n">decrement</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// This example sees a class containing &#39;static&#39; members and using access specifiers to</span>
<span class="c1">// restrict access to those members. Since all the members are static, this class is not</span>
<span class="c1">// meant to be instantiated [i.e. objects created from it - it can be done, but they would</span>
<span class="c1">// all be the exact same object :)], but merely uses the &#39;class&#39; facility to encapsulate</span>
<span class="c1">// [i.e. group together] and allow selective access [i.e. hide some parts, allow access to</span>
<span class="c1">// others]. For Design Pattern afficiandos, this is a crude example of the Singleton Pattern</span>

<span class="c1">// File: &#39;counter.h&#39;</span>
<span class="k">class</span> <span class="nc">Counter</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">increment</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">decrement</span><span class="p">();</span>
<span class="nl">private:</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;counter.cpp&#39;</span>
<span class="cp">#include &quot;counter.h&quot;</span>

<span class="kt">int</span> <span class="n">Counter</span><span class="o">::</span><span class="n">increment</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">Counter</span><span class="o">::</span><span class="n">decrement</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">--</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">Counter</span><span class="o">::</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;test.cpp&#39;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &quot;counter.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Counter</span><span class="o">::</span><span class="n">increment</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">Counter</span><span class="o">::</span><span class="n">decrement</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN548"
>Determining Current Function Name</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Standard C++ offers no facility for performing adhoc, runtime stack inspection; therefore,</span>
<span class="c1">// information such as the currently-executing function name, cannot be obtained. Now, this</span>
<span class="c1">// isn&#39;t to say that such facilities don&#39;t exist [since, after all, a symbolic debugger works</span>
<span class="c1">// by doing just this - stack inspection, among other things], but that such features are, for</span>
<span class="c1">// native code compiled languages like C++, &#39;extra-language&#39; and development tool-specific</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN551"
>Passing Arrays and Hashes by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Standard C++ supports both</span>
<span class="c1">// * &#39;pass-by-value&#39;: a copy of an argument is passed when calling a function; in this way</span>
<span class="c1">//   the original is safe from modification, but a copying overhead is incurred which may</span>
<span class="c1">//   adversely affect performance</span>
<span class="c1">// * &#39;pass-by-reference&#39;: the address of an argument is passed when calling a function;</span>
<span class="c1">//   allows the original to be modified, and incurrs no performance penalty from copying</span>
<span class="c1">//</span>
<span class="c1">// The &#39;pass-by-value&#39; mechanism works in the same way as in the Standard C language [see</span>
<span class="c1">// corresponding section in PLEAC-C/Posix/GNU]. The &#39;pass-by-reference&#39; mechanism provides</span>
<span class="c1">// the same functionality as passing a pointer-to-a-pointer-to-an-argument, but without the</span>
<span class="c1">// complications arising from having to correctly dereference. Using a reference to a non-const</span>
<span class="c1">// item allows:</span>
<span class="c1">// * The item&#39;s state to be modified i.e. if an object was passed, it can be mutated [effect</span>
<span class="c1">//   can be mimiced by passing a pointer to the item]</span>
<span class="c1">// * The item, itself, can be replaced with a new item i.e. the memory location to which the</span>
<span class="c1">//   reference refers is updated [effect can be mimiced by passing a pointer-to-a-pointer to</span>
<span class="c1">//   the item]</span>

<span class="cp">#include &lt;cstddef&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="c1">// &#39;pass-by-value&#39;: a copy of each vector is passed as an argument</span>
<span class="c1">// void array_diff(const std::vector&lt;int&gt; arr1, const std::vector&lt;int&gt; arr2);</span>

<span class="c1">// &#39;pass-by-reference&#39;: the address of each vector is passed as an argument. Some variants:</span>
<span class="c1">// * Disallow both vector replacement and alteration of its contents</span>
<span class="c1">//     void array_diff(const std::vector&lt;const int&gt;&amp; arr1, const std::vector&lt;const int&gt;&amp; arr2);</span>
<span class="c1">// * Disallow vector replacement only</span>
<span class="c1">//     void array_diff(const std::vector&lt;int&gt;&amp; arr1, const std::vector&lt;int&gt;&amp; arr2);</span>
<span class="c1">// * Disallow alteration of vector contents only</span>
<span class="c1">//     void array_diff(std::vector&lt;const int&gt;&amp; arr1, std::vector&lt;const int&gt;&amp; arr2);</span>
<span class="c1">// * Allow replacement / alteration</span>
<span class="c1">//     void array_diff(std::vector&lt;int&gt;&amp; arr1, std::vector&lt;int&gt;&amp; arr2);</span>

<span class="kt">void</span> <span class="nf">array_diff</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr2</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load vectors from built-in arrays, or use Boost &#39;assign&#39; library</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="c1">// Function call is the same whether &#39;array_diff&#39; is declared to be &#39;pass-by-value&#39;</span>
  <span class="c1">// or &#39;pass-by-reference&#39;</span>
  <span class="n">array_diff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr1</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr2</span><span class="p">,</span> <span class="n">arr2</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// void array_diff(const std::vector&lt;int&gt; arr1, const std::vector&lt;int&gt; arr2)</span>
<span class="c1">// {</span>
<span class="c1">//  ; // &#39;arr1&#39; and &#39;arr2&#39; are copies of the originals</span>
<span class="c1">// }</span>

<span class="kt">void</span> <span class="nf">array_diff</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// &#39;arr1&#39; and &#39;arr2&#39; are references to the originals</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;cstddef&gt;</span>

<span class="cp">#include &lt;algorithm&gt;</span>
<span class="cp">#include &lt;functional&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">add_vecpair</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr2</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load vectors from built-in arrays, or use Boost &#39;assign&#39; library</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">aa</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="n">ba</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>
  <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">aa</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">ba</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">);</span>  

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">add_vecpair</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">add_vecpair</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">retvec</span><span class="p">;</span> <span class="n">retvec</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">arr1</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">arr1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">arr2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">retvec</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">retvec</span><span class="p">;</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN554"
>Detecting Return Context</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Please refer to the corresponding section in PLEAC-C/Posix/GNU since the points raised there</span>
<span class="c1">// apply to C++ also. Examples here don&#39;t so much illustrate C++&#39;s handling of &#39;return context&#39;</span>
<span class="c1">// as much as how disparate types might be handled in a reasonably uniform manner</span>

<span class="c1">// Here, &#39;mysub&#39; is implemented as a function template, and its return type varies with the</span>
<span class="c1">// argument type. In most cases the compiler is able to infer the return type from the </span>
<span class="c1">// argument, however, it is possible to pass the type as a template parameter. Note this</span>
<span class="c1">// code operates at compile-time, as does any template-only code</span>

<span class="cp">#include &lt;cstddef&gt;</span>

<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">mysub</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// 1. Type information inferred by compiler</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">mysub</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">mysub</span><span class="p">(</span><span class="mf">7.6</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">mysub</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">));</span>

  <span class="c1">// 2. Type information provided by user</span>
  <span class="c1">// Pass a &#39;const char*&#39; argument and specify type information in the call</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">mysub</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;xyz&quot;</span><span class="p">);</span>

  <span class="c1">// Could avoid specifying type information by passing a &#39;std::string&#39; argument  </span>
  <span class="c1">// std::string s = mysub(std::string(&quot;xyz&quot;));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// This is a variant on the previous example that uses the Boost Library&#39;s &#39;any&#39; type as a</span>
<span class="c1">// generic &#39;stub&#39; type</span>

<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="cp">#include &lt;boost/any.hpp&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">any</span> <span class="n">mysub</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">any</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">any</span><span class="o">&gt;</span> <span class="n">any</span><span class="p">;</span>

  <span class="c1">// Add various types [encapsulated in &#39;any&#39; objects] to the container</span>
  <span class="n">any</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mysub</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">any</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mysub</span><span class="p">(</span><span class="mf">7.6</span><span class="p">));</span>
  <span class="n">any</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mysub</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)));</span>
  <span class="n">any</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mysub</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;xyz&quot;</span><span class="p">)));</span>

  <span class="c1">// Extract the various types from the container by appropriately casting the relevant</span>
  <span class="c1">// &#39;any&#39; object</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">any</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">any</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">any</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">any</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN557"
>Passing by Named Parameter</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Just like the C language, C++ offers no support for named / keyword parameters. It is of</span>
<span class="c1">// course possible to mimic such functionality the same way it is done in C [see corresponding</span>
<span class="c1">// section in PLEAC-C/Posix/GNU], the most obvious means being by passing a set of key/value</span>
<span class="c1">// pairs in a std::map. This will not be shown here. Instead, two quite C++-specific examples</span>
<span class="c1">// will be provided, based on:</span>
<span class="c1">//</span>
<span class="c1">// * Named Parameter Idiom [see: http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.18]</span>
<span class="c1">// * Boost &#39;parameter&#39; Library [see: http://www.boost.org/libs/parameter/doc/html/index.html]</span>

<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;map&gt;</span>

<span class="k">class</span> <span class="nc">TimeEntry</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">TimeEntry</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">char</span> <span class="n">dim</span> <span class="o">=</span> <span class="sc">&#39;s&#39;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">);</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">value_</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">dim_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="o">&gt;</span> <span class="n">TENTRY</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="o">&gt;</span> <span class="n">TIMETBL</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">RaceTime</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">START_TIME</span><span class="p">,</span> <span class="n">FINISH_TIME</span><span class="p">,</span> <span class="n">INCR_TIME</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="nf">RaceTime</span><span class="p">();</span>

  <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">start_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">);</span>
  <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">finish_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">);</span>
  <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">incr_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">);</span>

  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>

<span class="nl">private:</span>
  <span class="n">TIMETBL</span> <span class="n">timetbl_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">START_TIME</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">FINISH_TIME</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">INCR_TIME</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">the_func</span><span class="p">(</span><span class="k">const</span> <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">the_func</span><span class="p">(</span><span class="n">RaceTime</span><span class="p">().</span><span class="n">start_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)).</span><span class="n">finish_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">)).</span><span class="n">incr_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)));</span>

  <span class="n">the_func</span><span class="p">(</span><span class="n">RaceTime</span><span class="p">().</span><span class="n">start_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">)).</span><span class="n">finish_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">)));</span>

  <span class="n">the_func</span><span class="p">(</span><span class="n">RaceTime</span><span class="p">().</span><span class="n">start_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">value_</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">dim_</span><span class="p">;</span> <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r_</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">RaceTime</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

  <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;start_time:  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r_</span><span class="p">.</span><span class="n">timetbl_</span><span class="p">[</span><span class="n">RaceTime</span><span class="o">::</span><span class="n">START_TIME</span><span class="p">]</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">finish_time: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r_</span><span class="p">.</span><span class="n">timetbl_</span><span class="p">[</span><span class="n">RaceTime</span><span class="o">::</span><span class="n">FINISH_TIME</span><span class="p">]</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">incr_time:   &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r_</span><span class="p">.</span><span class="n">timetbl_</span><span class="p">[</span><span class="n">RaceTime</span><span class="o">::</span><span class="n">INCR_TIME</span><span class="p">];</span>

  <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TimeEntry</span><span class="o">::</span><span class="n">TimeEntry</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="n">dim</span><span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">dim_</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">bool</span> <span class="n">TimeEntry</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">dim_</span> <span class="o">==</span> <span class="n">right</span><span class="p">.</span><span class="n">dim_</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">value_</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">.</span><span class="n">value_</span><span class="p">)</span> <span class="o">:</span> <span class="o">!</span><span class="p">(</span><span class="n">dim_</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">.</span><span class="n">dim_</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">RaceTime</span><span class="o">::</span><span class="n">RaceTime</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">timetbl_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">TENTRY</span><span class="p">(</span><span class="n">START_TIME</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)));</span>
  <span class="n">timetbl_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">TENTRY</span><span class="p">(</span><span class="n">FINISH_TIME</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)));</span>
  <span class="n">timetbl_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">TENTRY</span><span class="p">(</span><span class="n">INCR_TIME</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)));</span>
<span class="p">}</span>

<span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">start_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">timetbl_</span><span class="p">[</span><span class="n">START_TIME</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">finish_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">timetbl_</span><span class="p">[</span><span class="n">FINISH_TIME</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">incr_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">timetbl_</span><span class="p">[</span><span class="n">INCR_TIME</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">the_func</span><span class="p">(</span><span class="k">const</span> <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// The Boost &#39;parameter&#39; library requires a significant amount of setup code to be written,</span>
<span class="c1">// much more than this section warrants. My recommendation is to read carefully through the</span>
<span class="c1">// tutorial to determine whether a problem for which it is being considered justifies all</span>
<span class="c1">// the setup.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN560"
>Skipping Selected Return Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// The Boost &#39;tuple&#39; Library also allows multiple assignment to variables, including the</span>
<span class="c1">// selective skipping of return values</span>

<span class="cp">#include &lt;iostream&gt;</span>

<span class="cp">#include &lt;boost/tuple/tuple.hpp&gt;</span>

<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">T3</span><span class="p">;</span>

<span class="n">T3</span> <span class="nf">func</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// A tuple of references to the referred variables is created; the values</span>
  <span class="c1">// captured from the returned tuple are thus multiply-assigned to them</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Variables can still be individually referenced</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span> 
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Return values may be ignored; affected variables retain existing values</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">ignore</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">T3</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">T3</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span> <span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN563"
>Returning More Than One Array or Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Like Standard C, C++ allows only the return of a single value. The return of multiple values</span>
<span class="c1">// *can*, however, be simulated by packaging them within an aggregate type [as in C], or a</span>
<span class="c1">// custom class, or one of the STL containers like std::vector. Probably the most robust, and</span>
<span class="c1">// [pseudo]-standardised, approach is to use the Boost &#39;tuple&#39; Library, as will be done in this</span>
<span class="c1">// section. Notes:</span>
<span class="c1">// * Use made of Boost &#39;assign&#39; Library to simplify container loading; this is a *very* handy</span>
<span class="c1">//   library</span>
<span class="c1">// * Use made of Boost &#39;any&#39; Library to make containers heterogenous; &#39;variant&#39; Library is</span>
<span class="c1">//   similar, and is more appropriate where type-safe container traversal is envisaged e.g.</span>
<span class="c1">//   for printing  </span>

<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;map&gt;</span>

<span class="cp">#include &lt;boost/any.hpp&gt;</span>
<span class="cp">#include &lt;boost/tuple/tuple.hpp&gt;</span>

<span class="cp">#include &lt;boost/assign/std/vector.hpp&gt;</span>
<span class="cp">#include &lt;boost/assign/list_inserter.hpp&gt;</span>

<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">any</span><span class="o">&gt;</span> <span class="n">ARRAY</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">any</span><span class="o">&gt;</span> <span class="n">HASH</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">HASH</span><span class="o">&gt;</span> <span class="n">ARRAY_HASH</span><span class="p">;</span>

<span class="n">ARRAY_HASH</span> <span class="nf">some_func</span><span class="p">(</span><span class="k">const</span> <span class="n">ARRAY</span><span class="o">&amp;</span> <span class="n">array</span><span class="p">,</span> <span class="k">const</span> <span class="n">HASH</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load containers using Boost &#39;assign&#39; Library </span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">assign</span><span class="p">;</span>
  <span class="n">ARRAY</span> <span class="n">array</span><span class="p">;</span> <span class="n">array</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">HASH</span> <span class="n">hash</span><span class="p">;</span> <span class="n">insert</span><span class="p">(</span><span class="n">hash</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;k1&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;k2&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;k3&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

  <span class="c1">// Pass arguments to &#39;somefunc&#39; and retrieve them as members of a tuple</span>
  <span class="n">ARRAY_HASH</span> <span class="n">refs</span> <span class="o">=</span> <span class="n">some_func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>

  <span class="c1">// Retrieve copy of &#39;array&#39; from tuple</span>
  <span class="n">ARRAY</span> <span class="n">ret_array</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">refs</span><span class="p">);</span>

  <span class="c1">// Retrieve copy of &#39;hash&#39; from tuple</span>
  <span class="n">HASH</span> <span class="n">ret_hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">refs</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">ARRAY_HASH</span> <span class="nf">some_func</span><span class="p">(</span><span class="k">const</span> <span class="n">ARRAY</span><span class="o">&amp;</span> <span class="n">array</span><span class="p">,</span> <span class="k">const</span> <span class="n">HASH</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ... do something with &#39;array&#39; and &#39;hash&#39;</span>

  <span class="k">return</span> <span class="n">ARRAY_HASH</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN566"
>Returning Failure</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Like function calls in Standard C, function calls in C++ need to conform to signature</span>
<span class="c1">// requirements; a function call must match its declaration with the same number, and type,</span>
<span class="c1">// of arguments passed [includes implicitly-passed default arguments], and the same return</span>
<span class="c1">// value type. Thus, unlike Perl, a function declared to return a value *must* do so, thus</span>
<span class="c1">// cannot &#39;return nothing&#39; to indicate failure. </span>
<span class="c1">// Whilst in Standard C certain conventions like returning NULL pointers, or returning -1, to</span>
<span class="c1">// indicate the &#39;failure&#39; of a task [i.e. function return codes are checked, and control</span>
<span class="c1">// proceeds conditionally] are used, Standard C++ sports facilities which lessen the need for</span>
<span class="c1">// dong the same. Specifically, C++ offers:</span>
<span class="c1">// * Built-in exception handling which can be used to detect [and perhaps recover from],</span>
<span class="c1">//   all manner of unusual, or erroneous / problematic situations. One recommended use is</span>
<span class="c1">//   to avoid writing code that performs a lot of return code checking</span>
<span class="c1">// * Native OOP support allows use of the Null Object Design Pattern. Put simply, rather than</span>
<span class="c1">//   than checking return codes then deciding on an action, an object with some predefined</span>
<span class="c1">//   default behaviour is returned / used where an unusual / erroneous / problematic situation</span>
<span class="c1">//   is encountered. This approach could be as simple as having some sort of default base</span>
<span class="c1">//   class member function behaviour, or as complex as having a diagnostic-laden object created</span>
<span class="c1">// * Functions can still return &#39;error-indicating entities&#39;, but rather than primitive types</span>
<span class="c1">//   like &#39;int&#39;s or NULL pointers, complex objects can be returned. For example, the Boost</span>
<span class="c1">//   Library sports a number of such types:</span>
<span class="c1">//   - &#39;tuple&#39;</span>
<span class="c1">//   - &#39;any&#39;, &#39;variant&#39; and &#39;optional&#39;</span>
<span class="c1">//   - &#39;tribool&#39; [true, false, indeterminate]</span>

<span class="c1">// Exception Handling Example</span>

<span class="k">class</span> <span class="nc">XYZ_exception</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="nf">func</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">valid_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">try</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ...</span>

    <span class="n">valid_value</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span>

    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">XYZ_exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">valid_value</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">throw</span> <span class="n">XYZ_exception</span><span class="p">();</span>

  <span class="p">;</span> <span class="c1">// ...</span>
  
  <span class="k">return</span> <span class="n">valid_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// Null Object Design Pattern Example</span>

<span class="cp">#include &lt;iostream&gt;</span>

<span class="k">class</span> <span class="nc">Value</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">do_something</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">NullValue</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Value</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">do_something</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ValidValue</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Value</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">do_something</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">Value</span><span class="o">*</span> <span class="nf">func</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Error checking is performed within &#39;func&#39;. However, regardless of the outcome, an</span>
  <span class="c1">// object of &#39;Value&#39; type is returned which possesses similar behaviour, though appropriate</span>
  <span class="c1">// to whether processing was successful or not. In this way no error checking is needed</span>
  <span class="c1">// outside of &#39;func&#39;</span>
  <span class="n">Value</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span>

  <span class="n">v</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>

  <span class="k">delete</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="n">NullValue</span><span class="o">::</span><span class="n">do_something</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*null*&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ValidValue</span><span class="o">::</span><span class="n">do_something</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;valid&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Value</span><span class="o">*</span> <span class="n">func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">NullValue</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>
  
  <span class="k">return</span> <span class="k">new</span> <span class="n">ValidValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// The Boost &#39;optional&#39; library has many uses, but in the current context, one is of particular</span>
<span class="c1">// use: returning a specified type [thus satisfying language requirements], but whose value</span>
<span class="c1">// may be &#39;set&#39; [if the function succeeded] or &#39;unset&#39; [if it failed], and this condition very</span>
<span class="c1">// easily checked</span>

<span class="cp">#include &lt;iostream&gt;</span>

<span class="cp">#include &lt;cstdlib&gt;</span>

<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;map&gt;</span>

<span class="cp">#include &lt;boost/optional/optional.hpp&gt;</span>

<span class="k">class</span> <span class="nc">func_fail</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">func_fail</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="o">:</span> <span class="n">msg_</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">msg_</span><span class="p">;</span> <span class="p">}</span> 
<span class="nl">private:</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">die</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>

<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sfunc</span><span class="p">();</span>
<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">afunc</span><span class="p">();</span>
<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">hfunc</span><span class="p">();</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">try</span>
  <span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">h</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">sfunc</span><span class="p">()))</span> <span class="k">throw</span> <span class="n">func_fail</span><span class="p">(</span><span class="s">&quot;&#39;sfunc&#39; failed&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">afunc</span><span class="p">()))</span> <span class="k">throw</span> <span class="n">func_fail</span><span class="p">(</span><span class="s">&quot;&#39;afunc&#39; failed&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">hfunc</span><span class="p">()))</span> <span class="k">throw</span> <span class="n">func_fail</span><span class="p">(</span><span class="s">&quot;&#39;hfunc&#39; failed&quot;</span><span class="p">);</span>

    <span class="p">;</span> <span class="c1">// ... do stuff with &#39;s&#39;, &#39;a&#39;, and &#39;h&#39; ...</span>
    <span class="kt">int</span> <span class="n">scalar</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">func_fail</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">die</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">msg</span><span class="p">());</span>   
  <span class="p">}</span>

  <span class="p">;</span> <span class="c1">// ... other code executed if no error above ...</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">void</span> <span class="nf">die</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Should only be used if all objects in the originating local scope have been destroyed</span>
  <span class="n">std</span><span class="o">::</span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sfunc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">valid_int_value</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="p">;</span> <span class="c1">// ...</span>
  
  <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">valid_int_value</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">afunc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// ... code not shown ...</span>
 
  <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// ... code not shown</span>
<span class="p">}</span>

<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">hfunc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// ... code not shown ...</span>

  <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// ... code not shown ...</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN569"
>Prototyping Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Whilst in Perl function prototyping is optional, this is not the case in C++, where it is</span>
<span class="c1">// necessary to:</span>
<span class="c1">// * Declare a function before use; this could either be a function declaration separate from</span>
<span class="c1">//   the function definition, or the function definition itself which serves as its own</span>
<span class="c1">//   declaration</span>
<span class="c1">// * Specify both parameter positional and type information; parameter names are optional in</span>
<span class="c1">//   declarations, mandatory in definitions</span>
<span class="c1">// * Specify return type</span>

<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="c1">// Function Declaration</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">);</span> <span class="c1">// Also possible: std::vector&lt;int&gt; myfunc(int, int);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Call function with all required arguments; this is the only calling method</span>
  <span class="c1">// [except for calling via function pointer which still needs all arguments supplied]</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">myfunc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

  <span class="c1">// Let&#39;s look at our return array&#39;s contents</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// Function Definition</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// A version on the above code that is generic, that is, making use of the C++ template</span>
<span class="c1">// mechanism to work with any type</span>

<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="c1">// Function Declaration</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">arg1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">arg2</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">myfunc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// Function Definition</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">arg1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// Other Perl examples are omitted since there is no variation in C++ function calling or</span>
<span class="c1">// parameter handling</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN572"
>Handling Exceptions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// One of the key, non-object oriented features of Standard C++ is its built-in support for</span>
<span class="c1">// exceptions / exception handling. The feature is well-integrated into the language, including</span>
<span class="c1">// a set of predefined exception classes included in, and used by, the Standard Library, is</span>
<span class="c1">// quite easy to use, and helps the programmer write robust code provided certain conventions</span>
<span class="c1">// are followed. On the downside, the C++ exception handling system is criticised for imposing</span>
<span class="c1">// significant runtime overhead, as well as increasing executable code size [though this</span>
<span class="c1">// varies considerably between CPU&#39;s, OS&#39;s, and compilers]. Please refer to the corresponding</span>
<span class="c1">// section in PLEAC-C/Posix/GNU for pertinent reading references.</span>
<span class="c1">//</span>
<span class="c1">// The example code below matches the PLEAC-C/Posix/GNU example rather than the Perl code. Note:</span>
<span class="c1">// * A very minimal, custom exception class is implemented; a more complex class, one richer in</span>
<span class="c1">//   diagnostic information, could have been implemented, or perhaps one based on a standard</span>
<span class="c1">//   exception class like &#39;std::exception&#39;</span>
<span class="c1">// * Ordinarily error / exception messages are directed to &#39;std::cerr&#39; or &#39;std::clog&#39;</span>
<span class="c1">// * General recommendation is to throw &#39;temporaries&#39; [via invoking a constructor],</span>
<span class="c1">//   and to &#39;catch&#39; as const reference(s)</span>
<span class="c1">// * Proper &#39;cleanup&#39; is very important; consult a suitable book for guidance on writing</span>
<span class="c1">//   &#39;exception safe&#39; code</span>

<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">class</span> <span class="nc">FullmoonException</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">FullmoonException</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="o">:</span> <span class="n">msg_</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">FullmoonException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">msg_</span><span class="p">;</span> <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main - entry&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">try</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;try block - entry&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;... doing stuff ...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// if (... error condition detected ...)</span>
         <span class="k">throw</span> <span class="n">FullmoonException</span><span class="p">(</span><span class="s">&quot;... the problem description ...&quot;</span><span class="p">);</span>

    <span class="c1">// Control never gets here ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;try block - end&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">FullmoonException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Caught a&#39;Fullmoon&#39; exception. Message: &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">catch</span><span class="p">(...)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Caught an unknown exceptione&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Control gets here regardless of whether an exception is thrown or not</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main - end&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN575"
>Saving Global Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Standard C++ sports a namespace facility which allows an application to be divided into</span>
<span class="c1">// logical sub-systems, each of which operates within its own scope. Put very simply, the same</span>
<span class="c1">// identifiers [i.e. name of types, objects, and functions] may be each used in a namespace</span>
<span class="c1">// without fear of a nameclash occurring when logical sub-systems are variously combined as</span>
<span class="c1">// an application. The name-clash problem is inherent in single-namespace languages like C; it</span>
<span class="c1">// often occurs when several third-party libraries are used [a common occurrence in C], or</span>
<span class="c1">// when an application scales up. The remedy is to rename identifiers, or, in the case of </span>
<span class="c1">// functions that cannot be renamed, to wrap them up in other functions in a separate source</span>
<span class="c1">// file. Of course the problem may be minimised via strict adherence to naming conventions. </span>
<span class="c1">//</span>
<span class="c1">// The C++ namespace facility is important, too, because it avoids the need to utilise certain</span>
<span class="c1">// C language practices, in particular:</span>
<span class="c1">// * Use of, possibly, &#39;clumsy&#39; naming conventions [as described above]</span>
<span class="c1">// * Partition an application by separating logically-related items into separate source</span>
<span class="c1">//   files. Namespaces cross file boundaries, so items may reside in several source files</span>
<span class="c1">//   and still comprise a single, logical sub-system</span>
<span class="c1">// * Anonymous namespaces avoid use of the &#39;static&#39; keyword in creating file scope globals</span>

<span class="c1">// Global variable</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">print_age</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Global value, &#39;age&#39;, is accessed</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Age is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// A local variable named, &#39;age&#39; will act to &#39;shadow&#39; the globally</span>
  <span class="c1">// defined version, thus any changes to, &#39;age&#39;, will not affect</span>
  <span class="c1">// the global version</span>
  <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// Prints 18, the current value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Local version is altered, *not* global version</span>
  <span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

  <span class="c1">// Prints 18, the current value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Global variable</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">print_age</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Global value, &#39;age&#39;, is accessed</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Age is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Here no local version declared: any changes affect global version</span>
  <span class="n">age</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// Prints 5, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Global version again altered</span>
  <span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

  <span class="c1">// Prints 23, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Global variable</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">print_age</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Global value, &#39;age&#39;, is accessed</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Age is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Global version value saved into local version</span>
  <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="o">::</span><span class="n">age</span><span class="p">;</span>

  <span class="c1">// Prints 18, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Global version this time altered</span>
  <span class="o">::</span><span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

  <span class="c1">// Prints 23, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Global version value restored from saved local version</span>
  <span class="o">::</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>

  <span class="c1">// Prints 18, the restored value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN578"
>Redefining a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Please refer to the corresponding section in PLEAC-C/Posix/GNU since the points raised there</span>
<span class="c1">// about functions and function pointers apply equally to Standard C++ [briefly: functions</span>
<span class="c1">// cannot be redefined; several same-signature functions may be called via the same function</span>
<span class="c1">// pointer variable; code cannot be generated &#39;on-the-fly&#39; (well, not without the use of</span>
<span class="c1">// several external tools, making it an extra-language, not integral, feature)].</span>
<span class="c1">// @@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN581"
>Trapping Undefined Function Calls with AUTOLOAD</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Please refer to the corresponding section in PLEAC-C/Posix/GNU since all the points raised</span>
<span class="c1">// there apply equally to Standard C++ [briefly: undefined function calls are compiler-detected</span>
<span class="c1">// errors; function-pointer-based calls can&#39;t be checked for integrity].</span>
<span class="c1">// @@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN584"
>Nesting Subroutines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// Standard C++ does not support either simple nested functions or closures, therefore the</span>
<span class="c1">// example cannot be implemented exactly as per the Perl code</span>

<span class="cm">/* ===</span>
<span class="cm">int outer(int arg)</span>
<span class="cm">{</span>
<span class="cm">  int x = arg + 35;</span>

<span class="cm">  // *** wrong - illegal C++ ***</span>
<span class="cm">  int inner() { return x * 19; }</span>

<span class="cm">  return x + inner();</span>
<span class="cm">}</span>
<span class="cm">=== */</span>

<span class="c1">// The problem may, of course, be solved by defining two functions using parameter passing</span>
<span class="c1">// where appropriate, but this is contrary to the intent of the original Perl code</span>
<span class="kt">int</span> <span class="nf">inner</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">outer</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// An arguably better [but far more complicated] approach is to encapsulate all items within</span>
<span class="c1">// a namespace, but again, is an approach that is counter the intent of the original Perl code</span>
<span class="cp">#include &lt;iostream&gt;</span>

<span class="k">namespace</span> <span class="n">nst</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">inner</span><span class="p">();</span>
  <span class="kt">int</span> <span class="nf">outer</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nst</span><span class="o">::</span><span class="n">outer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="n">nst</span><span class="o">::</span><span class="n">inner</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">nst</span><span class="o">::</span><span class="n">x</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">nst</span><span class="o">::</span><span class="n">outer</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">nst</span><span class="o">::</span><span class="n">x</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">nst</span><span class="o">::</span><span class="n">x</span> <span class="o">+</span> <span class="n">nst</span><span class="o">::</span><span class="n">inner</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Another way to solve this problem and avoiding the use of an external function, is to</span>
<span class="c1">// create a local type and instantiate an object passing any required environment context</span>
<span class="c1">// to the constructor. Then, what appears as a parameterless nested function call, can be</span>
<span class="c1">// effected using &#39;operator()&#39;. This approach most closely matches the original Perl code</span>

<span class="kt">int</span> <span class="n">outer</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>

  <span class="c1">// &#39;Inner&#39; is what is known as a Functor or Function Object [or Command Design Pattern]; it</span>
  <span class="c1">// allows objects that capture state / context to be instantiated, and that state / context</span>
  <span class="c1">// used / retained / altered at multiple future times. Both the STL and Boost Libraries</span>
  <span class="c1">// provide extensive support these constructs</span>
  <span class="k">struct</span> <span class="n">Inner</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n_</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="nf">Inner</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">n_</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n_</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span> <span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">inner</span><span class="p">();</span>
<span class="p">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN587"
>Program: Sorting Your Mail</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">// @@INCOMPLETE@@</span>
<span class="c1">// @@INCOMPLETE@@</span>
</pre></div>
</body>
</html></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Directories</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>References and Records</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>