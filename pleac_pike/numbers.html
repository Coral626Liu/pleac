<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Numbers</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Pike"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Strings"
HREF="strings.html"><LINK
REL="NEXT"
TITLE="Dates and Times"
HREF="datesandtimes.html"></HEAD
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Pike</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="strings.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="datesandtimes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="NUMBERS"
>2. Numbers</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN73"
>Checking Whether a String Is a Valid Number</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">string number=&quot;123.3asdf&quot;;

int|float realnumber= (int)number;  // casting to int will throw away all
                                    // nonnumber parts
string rest;
[realnumber, rest] = array_sscanf(number, &quot;%d%s&quot;); // scan for an integer
// if rest contains anything but the empty string, then there was more than a
// number in the string
// use %f to scan for float, %x for hex or %o for octal</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN76"
>Comparing Floating-Point Numbers</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">int same(float one, float two, int accuracy)
{
  return sprintf(&quot;%.*f&quot;, accuracy, one) == sprintf(&quot;%.*f&quot;, accuracy, two);
}

int wage=536;
int week=40*wage;
write(&quot;one week's wage is: $%.2f\n&quot;, week/100.0);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN79"
>Rounding Floating-Point Numbers</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">float unrounded=3.5;
string rounded=sprintf(&quot;%.*f&quot;, accuracy, unrounded);

float a=0.255;
string b=sprintf(&quot;%.2f&quot;, a);

write(&quot;Unrounded: %f\nRounded: %s\n&quot;, a, b);
write(&quot;Unrounded: %f\nRounded: %.2f\n&quot;, a, a);

// dec to bin
string bin=sprintf(&quot;%b&quot;, 5);

int dec=array_sscanf(&quot;0000011111111111111&quot;, &quot;%b&quot;)[0]; 
                // array_sscanf returns an array

int num = array_sscanf(&quot;0110110&quot;, &quot;%b&quot;)[0];  // num is 54
string binstr = sprintf(&quot;%b&quot;, 54);           // binstr is 110110</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN82"
>Converting Between Binary and Decimal</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">// contributed by martin nilsson.

string dec2bin(int n) 
{ 
  return sprintf(&quot;%b&quot;,n); 
}

int bin2dec(string n) 
{ 
  return array_sscanf(n, &quot;%b&quot;)[0];
}</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN85"
>Operating on a Series of Integers</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">// foreach(enumerate(int count, int step, int start);; int val)
// {
//   // val is set to each of count integers starting at start
// }

foreach(enumerate(y-x+1,1,x);; int val)
{
  // val is set to every integer from X to Y, inclusive
}

for(int i=x; i&lt;=y; i++)
{
  // val is set to every integer from X to Y, inclusive
}

for(int i=x; i&lt;=y; i+=7)
{
  // val is set to every integer from X to Y, stepsize = 7
}

foreach(enumerate(y-x+1,7,x);; int val)
{
  // val is set to every integer from X to Y, stepsize = 7
}

//----------------------------------------
write(&quot;Infancy is: &quot;);
foreach(enumerate(3);; int val) 
{
  write(&quot;%d &quot;, val);
}
write(&quot;\n&quot;);

write(&quot;Toddling is: %{%d %}\n&quot;, enumerate(2,1,3));

write(&quot;Childhood is: &quot;);
for (int i = 5; i &lt;= 12; i++) 
{
  write(&quot;%d &quot;, i);
}
write(&quot;\n&quot;);

// Infancy is: 0 1 2 
// Toddling is: 3 4 
// Childhood is: 5 6 7 8 9 10 11 12 </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN88"
>Working with Roman Numerals</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">int arabic;
string roman = String.int2roman(arabic);        // handles values up to 10000

array nums=enumerate(10001);                
array romans=String.int2roman(nums[*]);     
mapping roman2int = mkmapping(romans, nums);                   

int arabic = roman2int[roman];

//------------------------------------------------
string roman_fifteen = String.int2roman(15);    //  &quot;XV&quot;
write(&quot;Roman for fifteen is %s\n&quot;, roman_fifteen);

int arabic_fifteen = roman2int[roman_fifteen];
write(&quot;Converted back, %s is %d\n&quot;, roman_fifteen, arabic_fifteen);

// Roman for fifteen is XV
// Converted back, XV is 15</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN91"
>Generating Random Numbers</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">int y,x;
int rand = random(y-x+1)+x;

float y,x;
float rand = random(y-x+1)+x;

int rand = random(51)+25;
write(&quot;%d\n&quot;, rand);

array arr;
mixed elt = arr[random(sizeof(arr))];
mixed elt = random(arr);

array chars=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@$%^&amp;*&quot;/&quot;&quot;;
string password = &quot;&quot;;
for(int i=1; i&lt;=8; i++)
{
  password+=random(chars);
}

string password = random((({chars})*8)[*])*&quot;&quot;;

string password = random_string(8);      // creates an untypable string

// turn the string into something typable using the base64 charset
string password = MIME.encode_base64(random_string(8))[..7];</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN94"
>Generating Different Random Numbers</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">random_seed(int seed);
random_seed((int)argv[1]);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN97"
>Making Numbers Even More Random</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">// Crypto.Random.random(int max)
// Crypto.Random.random_string(int length)
// Crypto.Random.blocking_random_string(int length)
// Crypto.Random.add_entropy(string random_data, int entropy)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN100"
>Generating Biased Random Numbers</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">float gaussian_rand()
{
  float u1, u2, w, g1, g2;
  
  do
  {
    u1 = 2.0 * random(1.0) - 1.0; u2 = 2.0 * random(1.0) - 1.0;
    w = u1 * u1 + u2 * u2;
  } while (w &gt; 1.0);
  
  w = sqrt((-2.0 * log(w)) / w); g2 = u1 * w; g1 = u2 * w;

  return g1;
}

// ----

float mean = 25.0, sdev = 2.0;
float salary = gaussian_rand() * mean + sdev;

write(&quot;You have been hired at: %.2f\n&quot;, salary);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN103"
>Doing Trigonometry in Degrees, not Radians</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">float deg2rad(float deg)
{
  return (deg / 180.0) * Math.pi;
}

float rad2deg(float rad)
{
  return (rad / Math.pi) * 180.0;
}

// ----

write(&quot;%f\n&quot;, Math.convert_angle(180, &quot;deg&quot;, &quot;rad&quot;));
write(&quot;%f\n&quot;, deg2rad(180.0));

// ----------------------------

float degree_sin(float deg)
{
  return sin(deg2rad(deg));
}

// ----

float rad = deg2rad(380.0);
write(&quot;%f\n&quot;, sin(rad));
write(&quot;%f\n&quot;, degree_sin(380.0));</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN106"
>Calculating More Trigonometric Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">float my_tan(float theta)
{
  return sin(theta) / cos(theta);
}

// ----

float theta = 3.7;

write(&quot;%f\n&quot;, my_tan(theta));
write(&quot;%f\n&quot;, tan(theta));</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN109"
>Taking Logarithms</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">float value = 100.0;

float log_e = log(value);
float log_10 = Math.log10(value);

// ----------------------------

float log_base(float base, float value)
{
  return log(value) / log(base);
}

// ----

float answer = log_base(10.0, 10000.0);

write(&quot;log(10, 10,000) = %f\n&quot;, answer);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN112"
>Multiplying Matrices</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">// Pike offers a solid matrix implementation; highlights:
// * Operator overloading makes matrix operations succinct
// * Matrices may be of various types, thus allowing user to
//   choose between range representation and speed
// * Wide variety of operations available

Math.Matrix a = Math.Matrix( ({ ({3, 2, 3}), ({5, 9, 8})  }) ),
            b = Math.Matrix( ({ ({4, 7}), ({9, 3}), ({8, 1}) }) );

Math.Matrix c = a * b;

// ------------

Math.Matrix t = c-&gt;transpose();</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN115"
>Using Complex Numbers</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">// @@INCOMPLETE@@</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN118"
>Converting Between Octal and Hexadecimal</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">// Like C, Pike supports decimal-alternate notations. Thus, for example,
// the integer value, 867, is expressable in literal form as:
//
//   Hexadecimal -&gt; 0x363
//   Octal       -&gt; 01543
//
// For effecting such conversions using strings there is 'sprintf' and
// 'sscanf'.

int dec = 867;
string hex = sprintf(&quot;%x&quot;, dec);
string oct = sprintf(&quot;%o&quot;, dec);

// ------------

int dec;
string hex = &quot;363&quot;; sscanf(hex, &quot;%x&quot;, dec);

// ------------

int dec;
string oct = &quot;1543&quot;; sscanf(oct, &quot;%o&quot;, dec);

// ----------------------------

int number;

write(&quot;Gimme a number in decimal, octal, or hex: &quot;);
sscanf(Stdio.stdin-&gt;gets(), &quot;%D&quot;, number);

write(&quot;%d %x %o\n&quot;, number, number, number);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN121"
>Putting Commas in Numbers</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">string commify_series(int series)
{
  return reverse((reverse((string)series) / 3.0) * &quot;,&quot;);
}

// ----

int hits = 3452347;

write(&quot;Your website received %s accesses last month.\n&quot;, commify_series(hits));

// ----------------------------

string commify(string s)
{
  function t = lambda(string m) { return reverse((reverse(m) / 3.0) * &quot;,&quot;); };
  return Regexp.PCRE(&quot;([0-9]+)&quot;)-&gt;replace(s, t);
}

// ----

int hits = 3452347;
string output = sprintf(&quot;Your website received %d accesses last month.&quot;, hits);

write(&quot;%s\n&quot;, commify(output));</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN124"
>Printing Correct Plurals</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">string pluralise(int value, string root, void|string singular_, void|string plural_)
{
  string singular = singular_ ? singular_ : &quot;&quot;;
  string plural = plural_ ? plural_ : &quot;s&quot;;

  return root + ( (value &gt; 1) ? plural : singular );
}

// ----

int duration = 1;
write(&quot;It took %d %s\n&quot;, duration, pluralise(duration, &quot;hour&quot;));
write(&quot;%d %s %s enough.\n&quot;, duration, pluralise(duration, &quot;hour&quot;),
      pluralise(duration, &quot;&quot;, &quot;is&quot;, &quot;are&quot;));

duration = 5;
write(&quot;It took %d %s\n&quot;, duration, pluralise(duration, &quot;hour&quot;));
write(&quot;%d %s %s enough.\n&quot;, duration, pluralise(duration, &quot;hour&quot;),
      pluralise(duration, &quot;&quot;, &quot;is&quot;, &quot;are&quot;));

// ----------------------------

// Non-regexp implementation, uses the string-based, 'has_prefix'
// and 'replace' library functions
string plural(string singular)
{
  mapping(string : string) e2 =
    ([&quot;ss&quot;:&quot;sses&quot;, &quot;ph&quot;:&quot;phes&quot;, &quot;sh&quot;:&quot;shes&quot;, &quot;ch&quot;:&quot;ches&quot;,
      &quot;ey&quot;:&quot;eys&quot;, &quot;ix&quot;:&quot;ices&quot;, &quot;ff&quot;:&quot;ffs&quot;]);

  mapping(string : string) e1 =
    ([&quot;z&quot;:&quot;zes&quot;, &quot;f&quot;:&quot;ves&quot;, &quot;y&quot;:&quot;ies&quot;, &quot;s&quot;:&quot;ses&quot;, &quot;x&quot;:&quot;xes&quot;]);

  foreach(({e2, e1}), mapping(string : string) endings) 
  {
    foreach(indices(endings), string ending)
    {
      if (has_suffix(singular, ending))
      {
        return replace(singular, ending, endings[ending]);
      }
    }
  }

  return singular;
}

// ----

int main()
{
  foreach(aggregate(&quot;mess&quot;, &quot;index&quot;, &quot;leaf&quot;, &quot;puppy&quot;), string word)
    write(&quot;%6s -&gt; %s\n&quot;, word, plural(word));
}</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN127"
>Program: Calculating Prime Factors</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">// <font size="-1"><a href="http://pleac.sourceforge.net/include/pike/ch02/bigfact">download the following standalone program</a></font>
#!/usr/bin/pike
// contributed by martin nilsson

void main(int n, array args) 
{
  foreach(args[1..], string arg) 
  {
    mapping r = ([]);
    foreach(Math.factor((int)arg), int f)
      r[f]++;
    write(&quot;%-10s&quot;, arg);
    if(sizeof(r)==1)
      write(&quot; PRIME&quot;);
    else 
    {
      foreach(sort(indices(r)), int f) 
      {
        write(&quot; %d&quot;, f);
        if(r[f]&gt;1) write(&quot;**%d&quot;, r[f]);
      }
    }
    write(&quot;\n&quot;);
  }
}</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="strings.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="datesandtimes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Strings</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Dates and Times</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>