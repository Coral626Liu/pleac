<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=latin1">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span class="c1">; -*- clojure -*-</span>
<span class="c1">; @@PLEAC@@_NAME</span>
<span class="c1">; @@SKIP@@ Clojure</span>

<span class="c1">; @@PLEAC@@_WEB</span>
<span class="c1">; @@SKIP@@ http://clojure.org/</span>

<span class="c1">; @@PLEAC@@_INTRO</span>
<span class="c1">; @@SKIP@@ You need version 1.3.0 or above for this code to work.</span>

<span class="c1">;; @@PLEAC@@_1.0 Introduction</span>

<span class="c1">;; ---------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;\\n&quot;</span><span class="p">)</span>                 <span class="c1">; two characters, \ and an n</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;Jon &#39;Maddog&#39; Orwant&quot;</span><span class="p">)</span> <span class="c1">; literal single quotes</span>
<span class="c1">;; ---------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span>                    <span class="c1">; &quot;newline&quot; character</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;Jon \&quot;Maddog\&quot; Orwant&quot;</span><span class="p">)</span> <span class="c1">; literal double quotes</span>

<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="s">&quot;</span>
<span class="s">    This is a multiline here document</span>
<span class="s">    terminated by one double quote.</span>
<span class="s">    &quot;</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_1.1 Accessing Substrings</span>
<span class="p">(</span><span class="k">def </span><span class="nv">value</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="nv">offset</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">offset</span> <span class="nv">count</span><span class="p">)))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">value</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="nv">offset</span> <span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)))</span>

<span class="c1">;; or</span>
<span class="p">(</span><span class="k">def </span><span class="nv">value</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="nv">offset</span><span class="p">))</span>

<span class="c1">;; Clojure strings are immutable Java strings, so while you cannot</span>
<span class="c1">;; modify an existing string, you can build a new one with part of it</span>
<span class="c1">;; replaced by another.</span>

<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="nv">offset</span><span class="p">)</span> <span class="nv">newstring</span>
                 <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">offset</span> <span class="nv">count</span><span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="nv">offset</span><span class="p">)</span> <span class="nv">newtail</span><span class="p">))</span>

<span class="c1">;; -----------------------------</span>
<span class="c1">;; get a 5-byte string, skip 3, then grab 2 8-byte strings, then the rest</span>

<span class="c1">;; split at &#39;sz&#39; byte boundaries</span>
<span class="c1">;; jli for mbac: partition is the bomb for this</span>
<span class="c1">;; mbac for jli: hell yeah!</span>
<span class="c1">;; jli for mbac: I meant, &quot;partition&quot; is old and tired. all the cool</span>
<span class="c1">;;               kids are using &quot;partition-all&quot;. see commify-hipster.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">split-every-n-chars</span> <span class="p">[</span><span class="nv">sz</span> <span class="nv">string</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">string</span><span class="p">)</span>
    <span class="p">()</span>
    <span class="p">(</span><span class="nf">try</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">beg</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="nv">sz</span><span class="p">)</span>
            <span class="nb">rest </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="nv">sz</span><span class="p">)]</span>
        <span class="p">(</span><span class="nb">cons </span><span class="nv">beg</span> <span class="p">(</span><span class="nf">split-every-n-chars</span> <span class="nv">sz</span> <span class="nv">rest</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">catch</span> <span class="nv">Exception</span> <span class="nv">_e</span> <span class="p">[</span><span class="nv">string</span><span class="p">]))))</span>

<span class="c1">;; or the more idiomatic version</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">split-every-n-chars</span> <span class="p">[</span><span class="nv">sz</span> <span class="nv">string</span><span class="p">]</span>
  <span class="c1">;; the map turns vector of char vector into vector of string</span>
  <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">apply str </span><span class="nv">x</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">partition</span> <span class="mi">5</span> <span class="mi">5</span> <span class="nv">nil</span> <span class="nv">string</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">fivers</span> <span class="p">(</span><span class="nf">split-every-n-chars</span> <span class="mi">5</span> <span class="nv">string</span><span class="p">))</span>

<span class="c1">;; chop string into individual characters</span>
<span class="p">(</span><span class="k">def </span><span class="nv">chars</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">string</span><span class="p">))</span>

<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;This is what you have&quot;</span><span class="p">)</span>
<span class="c1">;; Indexes are left to right. There is no possibility to index</span>
<span class="c1">;; directly from right to left</span>
<span class="c1">;; &quot;T&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nb">first </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">;; &quot;is&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">start</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">))</span>
<span class="c1">;; &quot;you have&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nb">rest </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">13</span><span class="p">))</span>
<span class="c1">;; &quot;e&quot; *)</span>
<span class="p">(</span><span class="k">def </span><span class="nb">last </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">len</span> <span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)]</span>
            <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">1</span><span class="p">))))</span>
<span class="c1">;; &quot;have&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">theend</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">len</span> <span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)]</span>
              <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">4</span><span class="p">))))</span>
<span class="c1">;; &quot;you&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">piece</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">len</span> <span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)]</span>
             <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">5</span><span class="p">))))</span>

<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;This is what you have&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s&quot;</span> <span class="s">&quot;string&quot;</span><span class="p">)</span>

<span class="c1">;; Change &quot;is&quot; to &quot;wasn&#39;t&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nf">str</span>
             <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="mi">5</span><span class="p">)</span>
             <span class="s">&quot;wasn&#39;t&quot;</span>
             <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">7</span><span class="p">)))</span>
<span class="c1">;; This wasn&#39;t what you have</span>

<span class="c1">;; This wasn&#39;t wonderous</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span>
     <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)</span> <span class="mi">12</span><span class="p">))</span> <span class="s">&quot;ondrous&quot;</span><span class="p">))</span>

<span class="c1">;; delete first character</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">;; his wasn&#39;t wondrous</span>

<span class="c1">;; delete last 10 characters</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">string</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">string</span><span class="p">)</span> <span class="mi">10</span><span class="p">)))</span>
<span class="c1">;; his wasn&#39;</span>
<span class="c1">;; -----------------------------</span>

<span class="c1">;; @@PLEAC@@_1.2 Establishing a Default Value</span>

<span class="c1">;; While Perl treats undef, 0, and &quot;&quot; as false, Clojure treats the</span>
<span class="c1">;; values false and nil as false, but 0 and &quot;&quot; as true.</span>

<span class="c1">;; -----------------------------</span>
<span class="c1">;; use b if b is true, else c</span>
<span class="c1">;; Note that if b has never been defined or had a value bound to it,</span>
<span class="c1">;; then unlike Perl this will give an error that the value is</span>
<span class="c1">;; undefined.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nb">or </span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>

<span class="c1">;; re-define x with the value y, unless x is already true</span>
<span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nb">when-not </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="c1">;; use b if b is defined, otherwise c</span>
<span class="c1">;; This correctly tests whether b is bound to a value or not, but</span>
<span class="c1">;; if it is not, then it throws an exception because of the last</span>
<span class="c1">;; occurrence of b not having a value.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">find </span><span class="p">(</span><span class="nb">ns-interns </span><span class="nv">*ns*</span><span class="p">)</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="c1">;; This is closer:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">find </span><span class="p">(</span><span class="nb">ns-interns </span><span class="nv">*ns*</span><span class="p">)</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval </span><span class="ss">&#39;b</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span>

<span class="c1">;; But note that if b is only bound in a let, or as a function</span>
<span class="c1">;; argument, but not at the top level with def or something similar,</span>
<span class="c1">;; then this code will go with the value of c.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="s">&quot;c-value&quot;</span>
      <span class="nv">b</span> <span class="s">&quot;b-value&quot;</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">find </span><span class="p">(</span><span class="nb">ns-interns </span><span class="nv">*ns*</span><span class="p">)</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval </span><span class="ss">&#39;b</span><span class="p">)</span> <span class="nv">c</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;a=%s&quot;</span> <span class="nv">a</span><span class="p">)))</span>
<span class="c1">;; a=c-value</span>

<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">foo</span> <span class="p">(</span><span class="nb">or </span><span class="nv">bar</span> <span class="s">&quot;DEFAULT VALUE&quot;</span><span class="p">))</span>

<span class="c1">;; Clojure data structures are immutable.  The code below does not</span>
<span class="c1">;; change the value of *command-line-args*, whereas Perl</span>
<span class="c1">;; &#39;shift(@ARGV)&#39; does modify @ARGV by removing its first element.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">dir</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">count </span><span class="nv">*command-line-args*</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">nth </span><span class="nv">*command-line-args*</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;/tmp&quot;</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_1.3 Exchanging Values Without Using Temporary Variables</span>
<span class="c1">;; -----------------------------</span>

<span class="c1">;; This Clojure code does _not_ exchange values of var1 and var2</span>
<span class="c1">;; without a temporary.  It binds var1 to the value of var2, then</span>
<span class="c1">;; binds var2 to the new value of var1, so they both end up with the</span>
<span class="c1">;; original value of var2.</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">var1</span> <span class="nv">var2</span>
      <span class="nv">var2</span> <span class="nv">var1</span><span class="p">])</span>

<span class="c1">;; This will achieve the desired effect.  It creates a vector of the</span>
<span class="c1">;; values of var2 and var1, then binds them using a technique called</span>
<span class="c1">;; &#39;destructuring&#39; to var1 and var2.</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">var1</span> <span class="nv">var2</span><span class="p">]</span> <span class="p">[</span><span class="nv">var2</span> <span class="nv">var1</span><span class="p">]])</span>


<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">temp</span> <span class="nv">a</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="nv">temp</span><span class="p">)</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="s">&quot;alpha&quot;</span>
      <span class="nv">b</span> <span class="s">&quot;omega&quot;</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">[</span><span class="nv">b</span> <span class="nv">a</span><span class="p">]]</span>
    <span class="c1">;; the first shall be last -- and versa vice</span>
    <span class="p">))</span>

<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">alpha</span> <span class="s">&quot;January&quot;</span>
      <span class="nv">beta</span> <span class="s">&quot;March&quot;</span>
      <span class="nv">production</span> <span class="s">&quot;August&quot;</span><span class="p">]</span>
<span class="c1">;; move beta to alpha</span>
<span class="c1">;; move production to beta</span>
<span class="c1">;; move alpha to production</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">alpha</span> <span class="nv">beta</span> <span class="nv">production</span><span class="p">]</span> <span class="p">[</span><span class="nv">beta</span> <span class="nv">production</span> <span class="nv">alpha</span><span class="p">]]</span>

    <span class="p">))</span>

<span class="c1">;; @@PLEAC@@_1.4 Converting Between ASCII Characters and Values</span>

<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">num</span> <span class="p">(</span><span class="nb">int </span><span class="sc">\a</span><span class="p">))</span>     <span class="c1">; =&gt; ASCII code 97</span>
<span class="p">(</span><span class="k">def </span><span class="nb">char </span><span class="p">(</span><span class="nb">char </span><span class="mi">97</span><span class="p">))</span>   <span class="c1">; =&gt; \a</span>
<span class="c1">;; -----------------------------</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-ascii-code-for-char</span> <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Number %d is character &#39;%c&#39;\n&quot;</span> <span class="p">(</span><span class="nb">int </span><span class="nv">c</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span>

<span class="c1">;; (print-ascii-code-for-char \a)</span>
<span class="c1">;; Number 97 is the ASCII character a</span>

<span class="c1">;; @@PLEAC@@_1.5 Processing a String One Character at a Time</span>
<span class="c1">;; Strings in Clojure can be treated as sequences, so the usual</span>
<span class="c1">;; map, reduce, doseq functions apply.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">one-char-at-a-time</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">string</span><span class="p">]</span> <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">b</span> <span class="nv">string</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">b</span><span class="p">)))</span>

<span class="c1">;; =&gt; (one-char-at-a-time</span>
<span class="c1">;;       (fn [b] (printf &quot;do something with: %c\n&quot; b))</span>
<span class="c1">;;       &quot;abc&quot;)</span>
<span class="c1">;; do something with: a</span>
<span class="c1">;; do something with: b</span>
<span class="c1">;; do something with: c</span>
<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-uniq-chars</span> <span class="p">[</span><span class="nv">string</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;unique chars are: %s\n&quot;</span>
          <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">set </span><span class="nv">string</span><span class="p">))))</span>
<span class="c1">;; =&gt; (print-uniq-chars &quot;an apple a day&quot;)</span>
<span class="c1">;; unique chars are: (\space \a \d \e \l \n \p \y)</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">print-ascii-value-sum</span> <span class="p">[</span><span class="nv">string</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;sum is %s\n&quot;</span> <span class="p">(</span><span class="nb">apply + </span><span class="p">(</span><span class="nb">map int </span><span class="nv">string</span><span class="p">))))</span>
<span class="c1">;; =&gt; (print-ascii-value-sum &quot;an apple a day&quot;)</span>
<span class="c1">;; sum is 1248</span>
<span class="c1">;; -----------------------------</span>

<span class="c1">;; @@PLEAC@@_1.6 Reversing a String by Word or Character</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; Make namespace clojure.string usable with the abbreviated name</span>
<span class="c1">;; &#39;str&#39;.</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">revbytes</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">string</span><span class="p">))</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; TBD: Verify whether the split call below matches the behavior of</span>
<span class="c1">;; Perl split with a &quot; &quot; as first arg.  Should we use the regular</span>
<span class="c1">;; expression #&quot;\s+&quot; to match Perl behavior more closely?  Does that</span>
<span class="c1">;; even match exactly?  What about white space before first word or</span>
<span class="c1">;; after last word in the string to be split?</span>
<span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nf">str/split</span> <span class="nb">str </span><span class="o">#</span><span class="s">&quot;\s+&quot;</span><span class="p">)))</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">gnirts</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">string</span><span class="p">))</span>    <span class="c1">; str/reverse reverses letters in string</span>

<span class="p">(</span><span class="k">def </span><span class="nv">sdrow</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">words</span><span class="p">))</span>          <span class="c1">; reverse reverses elements in sequence</span>

<span class="c1">;; TBD: What corresponds to following Perl?</span>
<span class="c1">;; $confused = reverse(@words);        # reverse letters in join(&quot;&quot;, @words)</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; reverse word order</span>
<span class="p">(</span><span class="k">def </span><span class="nv">string</span> <span class="s">&quot;Yoda said, \&quot;can you see this?\&quot;&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">allwords</span> <span class="p">(</span><span class="nf">str/split</span> <span class="nv">string</span> <span class="o">#</span><span class="s">&quot;\s+&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">revwords</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">allwords</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">revwords</span><span class="p">)</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; There is no shortcut in Clojure like in Perl for the last arg of</span>
<span class="c1">;; str/split equal to &quot; &quot; meaning the same thing as matching on the</span>
<span class="c1">;; regular expression #&quot;\s+&quot;</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">revwords</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nf">str/split</span> <span class="nb">str </span><span class="o">#</span><span class="s">&quot;\s+&quot;</span><span class="p">))))</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">word</span> <span class="s">&quot;reviver&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">is-palindrome</span> <span class="p">(</span><span class="nb">= </span><span class="nv">word</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">word</span><span class="p">)))</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; No Clojure program I know of equivalent to Perl&#39;s for finding</span>
<span class="c1">;; palindromes of length 5 or larger conveniently fits into a single</span>
<span class="c1">;; line.  Better to create a file with this program.</span>

<span class="p">(</span><span class="kd">ns </span><span class="nv">print-palindromes</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>

<span class="c1">;; mbac for jafingerhut: don&#39;t you need to close the file handle returned by io/reader?</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">filename</span> <span class="nv">*command-line-args*</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">filename</span><span class="p">))]</span>
    <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">line</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">line</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">count </span><span class="nv">line</span><span class="p">)</span> <span class="mi">5</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">line</span><span class="p">))))</span>

<span class="c1">;; Save the above in a file print-palindromes.clj, then run from</span>
<span class="c1">;; command prompt (replace path to wherever your clojure-1.3.0.jar</span>
<span class="c1">;; file is located):</span>

<span class="c1">;; % java -cp /Users/jafinger/lein/clj-1.3.0/lib/clojure-1.3.0.jar clojure.main print-palindromes.clj /usr/share/dict/words</span>

<span class="c1">;; Alternately, on Linux/*BSD/Mac OS X, create a shell script like</span>
<span class="c1">;; this:</span>

<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="c1">;; #! /bin/sh</span>
<span class="c1">;;</span>
<span class="c1">;; # Replace the path below to refer to the Clojure jar file on your system.</span>
<span class="c1">;; CLJ_JAR=$HOME/lein/clj-1.3.0/lib/clojure-1.3.0.jar</span>
<span class="c1">;; scriptname=&quot;$1&quot;</span>
<span class="c1">;; shift</span>
<span class="c1">;; java -cp $CLJ_JAR:. clojure.main &quot;$scriptname&quot; &quot;$@&quot;</span>
<span class="c1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="c1">;; If you save that as the file &#39;clj&#39; somewhere in your command path</span>
<span class="c1">;; and make it executable (remove the &#39;;; &#39; before each line), and add</span>
<span class="c1">;; this line to the beginning of print-palindromes.clj:</span>
<span class="c1">;;</span>
<span class="c1">;; #! /usr/bin/env clj</span>
<span class="c1">;;</span>
<span class="c1">;; Then you can use the command line:</span>
<span class="c1">;;</span>
<span class="c1">;; % ./print-palindromes.clj /usr/share/dict/words</span>
<span class="c1">;;</span>
<span class="c1">;; or if print-palindromes.clj is in your command path (perhaps</span>
<span class="c1">;; because . is in your command path, although I wouldn&#39;t recommend it</span>
<span class="c1">;; for security reasons):</span>
<span class="c1">;;</span>
<span class="c1">;; % print-palindromes.clj /usr/share/dict/words</span>

<span class="c1">;; @@PLEAC@@_1.7 Reversing a String by Word or by Character</span>

<span class="c1">;; -----------------------------</span>
<span class="c1">;; Clojure&#39;s built-in regexp matching functions have something like</span>
<span class="c1">;; Perl&#39;s $&amp; that returns everything that a regexp matched within a</span>
<span class="c1">;; string, and also like Perl&#39;s $1, $2, $3, etc. that match</span>
<span class="c1">;; parenthesized groups.  However, it seems to require calls to Java</span>
<span class="c1">;; methods to get something like Perl&#39;s $` and $&#39; that return the</span>
<span class="c1">;; strings that are before and after the regexp match.</span>

<span class="c1">;; The Clojure function expand-str below is most closely analagous to</span>
<span class="c1">;; the following Perl code:</span>

<span class="c1">;; sub expand_str {</span>
<span class="c1">;;     my $s = shift;</span>
<span class="c1">;;     while (1) {</span>
<span class="c1">;;         if ($s =~ /\t+/) {</span>
<span class="c1">;;             $s = $` . (&#39; &#39; x (length($&amp;) * 8 - length($`) % 8)) . $&#39;;</span>
<span class="c1">;;         } else {</span>
<span class="c1">;;             return $s;</span>
<span class="c1">;;         }</span>
<span class="c1">;;     }</span>
<span class="c1">;; }</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">s</span> <span class="nv">s</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">m</span> <span class="p">(</span><span class="nb">re-matcher </span><span class="o">#</span><span class="s">&quot;\t+&quot;</span> <span class="nv">s</span><span class="p">)</span>
          <span class="nv">tabs</span> <span class="p">(</span><span class="nb">re-find </span><span class="nv">m</span><span class="p">)]</span>         <span class="c1">; Like Perl&#39;s $&amp;</span>
      <span class="p">(</span><span class="k">if </span><span class="nv">tabs</span>
        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">before-tabs</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="mi">0</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">start</span><span class="p">)))</span>  <span class="c1">; Like Perl&#39;s $`</span>
              <span class="nv">after-tabs</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">end</span><span class="p">)))]</span>      <span class="c1">; $&#39;</span>
          <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">str </span><span class="nv">before-tabs</span>
                      <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">)</span>
                                            <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">before-tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">))</span>
                                         <span class="s">&quot; &quot;</span><span class="p">))</span>
                      <span class="nv">after-tabs</span><span class="p">)))</span>
        <span class="nv">s</span><span class="p">))))</span>

<span class="c1">;; Performance note: The code above will recompile the regexp #&quot;\t+&quot;</span>
<span class="c1">;; each time through the loop.  If you want it to be compiled only</span>
<span class="c1">;; once, wrap the function body in a (let [pat #&quot;\t+&quot;] ...) and use</span>
<span class="c1">;; pat in place of #&quot;\t+&quot; in the body.</span>

<span class="c1">;; Another way is to use the regexp &quot;^([^\t]*)(\t+)&quot; instead of simply</span>
<span class="c1">;; &quot;\t+&quot;.  The ([^\t]*) will explicitly match everything before the</span>
<span class="c1">;; first tabs.  Warning: using (.*) instead would greedily match as</span>
<span class="c1">;; much of the beginning of the string as possible, including tabs, so</span>
<span class="c1">;; would not correctly cause (\t+) to match the _first_ tabs in the</span>
<span class="c1">;; string.</span>

<span class="c1">;; According to http://dev.clojure.org/jira/browse/CLJ-753 there is a</span>
<span class="c1">;; bug in str/replace-first where it returns nil instead of the</span>
<span class="c1">;; unmodified string s if the regexp pattern is not found to match</span>
<span class="c1">;; anywhere in s.</span>

<span class="c1">;; replace-first-fixed is a modified version of str/replace-first that</span>
<span class="c1">;; behaves as the corrected version should.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">replace-first-fixed</span> <span class="p">[</span><span class="nv">s</span> <span class="nv">pat</span> <span class="nv">fn</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">new-s</span> <span class="p">(</span><span class="nf">str/replace-first</span> <span class="nv">s</span> <span class="nv">pat</span> <span class="nv">fn</span><span class="p">)]</span>
    <span class="nv">new-s</span>
    <span class="nv">s</span><span class="p">))</span>

<span class="c1">;; The last argument to str/replace-first is a fn that takes a vector</span>
<span class="c1">;; of strings as an argument.  The first of these strings is</span>
<span class="c1">;; everything that was matched by the regexp pattern.  The rest are</span>
<span class="c1">;; the strings matched by parenthesized groups inside the regexp.  We</span>
<span class="c1">;; use Clojure&#39;s destructuring on function arguments to break up the</span>
<span class="c1">;; vector argument to replace-tabs and give names to its elements.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">replace-tabs</span> <span class="p">[[</span><span class="nv">all-matched</span> <span class="nv">before-tabs</span> <span class="nv">tabs</span><span class="p">]]</span>
  <span class="p">(</span><span class="nb">str </span><span class="nv">before-tabs</span>
       <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">before-tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">))</span>
                          <span class="s">&quot; &quot;</span><span class="p">))))</span>

<span class="c1">;; Repeatedly call replace-first-fixed until the string does not</span>
<span class="c1">;; change, indicating that no match was found.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">s</span> <span class="nv">s</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">next-s</span> <span class="p">(</span><span class="nf">replace-first-fixed</span> <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;^([^\t]*)(\t+)&quot;</span> <span class="nv">replace-tabs</span><span class="p">)]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">s</span> <span class="nv">next-s</span><span class="p">)</span>
        <span class="nv">s</span>
        <span class="p">(</span><span class="nf">recur</span> <span class="nv">next-s</span><span class="p">)))))</span>

<span class="c1">;; Performance note: Same as above about the regexp being recompiled</span>
<span class="c1">;; every time through the loop.  Bind the regexp to a symbol using</span>
<span class="c1">;; let, outside of the loop, to compile it only once.</span>

<span class="c1">;; My favorite version of this requires defining slightly modified</span>
<span class="c1">;; versions of clojure.core/re-groups and clojure.string/replace-first</span>

<span class="c1">;; The modified re-groups+ returns a vector like (re-groups) does,</span>
<span class="c1">;; except it always returns a vector, even if there are no</span>
<span class="c1">;; parenthesized subexpressions in the regexp, and it always returns</span>
<span class="c1">;; the part of the string before the match (Perl&#39;s $`) as the first</span>
<span class="c1">;; element, and the part of the string after the match (Perl&#39;s $&#39;) as</span>
<span class="c1">;; the last element.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">re-groups+</span> <span class="p">[</span><span class="o">^</span><span class="nv">java.util.regex.Matcher</span> <span class="nv">m</span> <span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">gc</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">groupCount</span><span class="p">))</span>
        <span class="nv">pre</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="mi">0</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">start</span><span class="p">)))</span>
        <span class="nv">post</span> <span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">end</span><span class="p">)))]</span>
    <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">v</span> <span class="p">[</span><span class="nv">pre</span><span class="p">]</span> <span class="nv">c</span> <span class="mi">0</span><span class="p">]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">c</span> <span class="nv">gc</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="p">(</span><span class="k">. </span><span class="nv">m</span> <span class="p">(</span><span class="nf">group</span> <span class="nv">c</span><span class="p">)))</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">c</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="nv">post</span><span class="p">)))))</span>

<span class="c1">;; replace-first+ is based on Clojure&#39;s hidden internal function</span>
<span class="c1">;; replace-first-by, except that it calls the user-supplied fn f for</span>
<span class="c1">;; calculating the replcement string with the return value of</span>
<span class="c1">;; re-groups+ instead of re-groups, so f can use those additional</span>
<span class="c1">;; strings to calculate the replacement.</span>

<span class="c1">;; The other difference is that it returns a vector of two elements:</span>
<span class="c1">;; the first is the string matched, or nil if there was no match.  The</span>
<span class="c1">;; second is the string after replacement on a match, or the original</span>
<span class="c1">;; string if no match.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">replace-first+</span>
  <span class="p">[</span><span class="o">^</span><span class="nv">CharSequence</span> <span class="nv">s</span> <span class="o">^</span><span class="nv">java.util.regex.Pattern</span> <span class="nv">re</span> <span class="nv">f</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">m</span> <span class="p">(</span><span class="nb">re-matcher </span><span class="nv">re</span> <span class="nv">s</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">buffer</span> <span class="p">(</span><span class="nf">StringBuffer.</span> <span class="p">(</span><span class="nf">.length</span> <span class="nv">s</span><span class="p">))]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">.find</span> <span class="nv">m</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">groups</span> <span class="p">(</span><span class="nf">re-groups+</span> <span class="nv">m</span> <span class="nv">s</span><span class="p">)</span>
              <span class="nv">rep</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">groups</span><span class="p">)]</span>
          <span class="p">(</span><span class="nf">.appendReplacement</span> <span class="nv">m</span> <span class="nv">buffer</span> <span class="nv">rep</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">.appendTail</span> <span class="nv">m</span> <span class="nv">buffer</span><span class="p">)</span>
          <span class="p">[(</span><span class="nb">second </span><span class="nv">groups</span><span class="p">)</span> <span class="p">(</span><span class="nb">str </span><span class="nv">buffer</span><span class="p">)])</span>
        <span class="p">[</span><span class="nv">nil</span> <span class="nv">s</span><span class="p">]))))</span>

<span class="c1">;; Assuming the above are added to Clojure, or some user-defined</span>
<span class="c1">;; library of commonly-used utilities, the &quot;new code&quot; is as follows:</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[[</span><span class="nv">found-match</span> <span class="nv">s</span><span class="p">]</span> <span class="p">[</span><span class="nv">true</span> <span class="nv">s</span><span class="p">]]</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">found-match</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">replace-first+</span> <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;\t+&quot;</span>
                             <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">pre</span> <span class="nv">tabs</span> <span class="nv">post</span><span class="p">]]</span>
                               <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="mi">8</span><span class="p">)</span>
                                                     <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">pre</span><span class="p">)</span> <span class="mi">8</span><span class="p">))</span>
                                                  <span class="s">&quot; &quot;</span><span class="p">)))))</span>
      <span class="nv">s</span><span class="p">)))</span>

<span class="c1">;; Performance note: As before, assign the regexp #&quot;\t+&quot; to a symbol</span>
<span class="c1">;; using let, outside of the loop, to compile it only once, instead of</span>
<span class="c1">;; every time through the loop.</span>

<span class="c1">;; Test cases:</span>

<span class="c1">;; (let [t1 (= &quot;No tabs here&quot; (expand-str &quot;No tabs here&quot;))</span>
<span class="c1">;;       t2 (= &quot;Expand          this&quot; (expand-str &quot;Expand\t\tthis&quot;))</span>
<span class="c1">;;       t3 (= &quot;Expand          this    please&quot; (expand-str &quot;Expand\t\tthis\tplease&quot;))]</span>
<span class="c1">;;   [t1 t2 t3])</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; I am not aware of any Clojure library similar to Perl&#39;s Text::Tabs</span>

<span class="c1">;; The expand-str Clojure functions above work on individual strings.</span>
<span class="c1">;; This works on a string or a collection of strings, similar to how</span>
<span class="c1">;; Perl&#39;s does:</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
   <span class="p">(</span><span class="nb">instance? </span><span class="nv">String</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">expand-str</span> <span class="nv">x</span><span class="p">)</span>
   <span class="ss">:else</span> <span class="p">(</span><span class="nb">map </span><span class="nv">expand-str</span> <span class="nv">x</span><span class="p">)))</span>


<span class="p">(</span><span class="kd">defn </span><span class="nv">unexpand-line</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nf">expand</span> <span class="nv">s</span><span class="p">)</span>
        <span class="nv">len</span> <span class="p">(</span><span class="nb">count </span><span class="nv">s</span><span class="p">)</span>
        <span class="nv">tabstop</span> <span class="nv">*tabstop*</span>
        <span class="nv">sections</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">subs </span><span class="nv">s</span> <span class="nv">%</span> <span class="p">(</span><span class="nb">min </span><span class="nv">len</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="nv">tabstop</span><span class="p">)))</span>
                      <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="nv">len</span> <span class="nv">tabstop</span><span class="p">))</span>
        <span class="c1">;; last section must be handled differently than earlier ones</span>
        <span class="nv">lastbit</span> <span class="p">(</span><span class="nb">last </span><span class="nv">sections</span><span class="p">)</span>
        <span class="nv">sections</span> <span class="p">(</span><span class="nb">butlast </span><span class="nv">sections</span><span class="p">)</span>
        <span class="nv">lastbit</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">lastbit</span><span class="p">)</span> <span class="nv">tabstop</span><span class="p">)</span>
                         <span class="p">(</span><span class="nf">str/blank?</span> <span class="nv">lastbit</span><span class="p">))</span>
                  <span class="s">&quot;\t&quot;</span>
                  <span class="nv">lastbit</span><span class="p">)</span>
        <span class="nv">sections</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">str/replace</span> <span class="nv">%</span> <span class="o">#</span><span class="s">&quot;  +$&quot;</span> <span class="s">&quot;\t&quot;</span><span class="p">)</span> <span class="nv">sections</span><span class="p">)</span>
        <span class="nv">sections</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">vec</span> <span class="nv">sections</span><span class="p">)</span> <span class="nv">lastbit</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot;&quot;</span> <span class="nv">sections</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">unexpand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot;\n&quot;</span> <span class="p">(</span><span class="nb">map </span><span class="nv">unexpand-line</span> <span class="p">(</span><span class="nf">str/split</span> <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span> <span class="mi">-1</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">unexpand</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
   <span class="p">(</span><span class="nb">instance? </span><span class="nv">String</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">unexpand-str</span> <span class="nv">x</span><span class="p">)</span>
   <span class="ss">:else</span> <span class="p">(</span><span class="nb">map </span><span class="nv">unexpand-str</span> <span class="nv">x</span><span class="p">)))</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">expand</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>

<span class="c1">;; Use your preferred version of expand here.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">filename</span> <span class="nv">*command-line-args*</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">filename</span><span class="p">))]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">expand</span> <span class="nv">line</span><span class="p">))))</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; Below is a version of expand-str that takes an optional argument</span>
<span class="c1">;; tabstop.  It is based upon the last version of expand-str given</span>
<span class="c1">;; above, but the others could easily be generalized in a similar way.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span>
  <span class="p">([</span><span class="nv">s</span> <span class="nv">tabstop</span><span class="p">]</span>
     <span class="p">(</span><span class="k">loop </span><span class="p">[[</span><span class="nv">found-match</span> <span class="nv">s</span><span class="p">]</span> <span class="p">[</span><span class="nv">true</span> <span class="nv">s</span><span class="p">]]</span>
       <span class="p">(</span><span class="k">if </span><span class="nv">found-match</span>
         <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">replace-first+</span>
                 <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;\t+&quot;</span>
                 <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">pre</span> <span class="nv">tabs</span> <span class="nv">post</span><span class="p">]]</span>
                   <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="nv">tabstop</span><span class="p">)</span>
                                         <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">pre</span><span class="p">)</span> <span class="nv">tabstop</span><span class="p">))</span>
                                      <span class="s">&quot; &quot;</span><span class="p">)))))</span>
         <span class="nv">s</span><span class="p">)))</span>
  <span class="p">([</span><span class="nv">s</span><span class="p">]</span> <span class="p">(</span><span class="nf">expand-str</span> <span class="nv">s</span> <span class="mi">8</span><span class="p">)))</span>

<span class="c1">;; If one wished for a version of expand-str that could use a tabstop</span>
<span class="c1">;; supplied by a &quot;global variable&quot;, then a dynamic var named *tabstop*</span>
<span class="c1">;; that was used inside of expand-str would be a good way to do it.</span>

<span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">*tabstop*</span> <span class="mi">8</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">expand-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[[</span><span class="nv">found-match</span> <span class="nv">s</span><span class="p">]</span> <span class="p">[</span><span class="nv">true</span> <span class="nv">s</span><span class="p">]]</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">found-match</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">replace-first+</span>
              <span class="nv">s</span> <span class="o">#</span><span class="s">&quot;\t+&quot;</span>
              <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">pre</span> <span class="nv">tabs</span> <span class="nv">post</span><span class="p">]]</span>
                <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">count </span><span class="nv">tabs</span><span class="p">)</span> <span class="nv">*tabstop*</span><span class="p">)</span>
                                      <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nb">count </span><span class="nv">pre</span><span class="p">)</span> <span class="nv">*tabstop*</span><span class="p">))</span>
                                   <span class="s">&quot; &quot;</span><span class="p">)))))</span>
      <span class="nv">s</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">expand-str</span> <span class="s">&quot;Expand\t\tthis&quot;</span><span class="p">)</span> <span class="c1">; expands to tabstop 8</span>
<span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">*tabstop*</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="nf">expand-str</span> <span class="s">&quot;Expand\t\tthis&quot;</span><span class="p">)</span> <span class="c1">; expands to tabstop 4 this time</span>

<span class="c1">;; Performance note: Besides the repeated one about avoiding</span>
<span class="c1">;; recompilation of the regexp, a new performance issue here is that</span>
<span class="c1">;; accessing dynamic vars like *tabstop* is slower than accessing a</span>
<span class="c1">;; local binding like those introduced via let or loop.  Wrapping the</span>
<span class="c1">;; entire function body in something like (let [tabstop *tabstop*]</span>
<span class="c1">;; ... ) and using tabstop in place of *tabstop* inside the body</span>
<span class="c1">;; incurs this cost only once, instead of every time through the loop.</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">unexpand</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>

<span class="c1">;; Use your preferred version of expand and unexpand here.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">filename</span> <span class="nv">*command-line-args*</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">filename</span><span class="p">))]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">unexpand</span> <span class="nv">line</span><span class="p">))))</span>
<span class="c1">;; -----------------------------</span>

<span class="c1">;; 1.8 Expanding and Compressing Tabs</span>

<span class="c1">;; 1.9 Expanding Variables in User Input</span>

<span class="c1">;; @PLEAC@@_1.10 Controlling Case</span>
<span class="p">(</span><span class="nf">.toUpperCase</span> <span class="s">&quot;foo&quot;</span><span class="p">)</span> <span class="c1">;; -&gt; &quot;FOO&quot;</span>
<span class="p">(</span><span class="nf">.toLowerCase</span> <span class="s">&quot;FOO&quot;</span><span class="p">)</span> <span class="c1">;; -&gt; &quot;foo&quot;</span>

<span class="c1">;; 1.11 Interpolating Functions and Expressions Within Strings</span>

<span class="c1">;; 1.12 Indenting Here Documents</span>

<span class="c1">;; 1.13 Reformatting Paragraphs</span>

<span class="c1">;; 1.14 Escaping Characters</span>

<span class="c1">;; 1.15 Trimming Blanks from the Ends of a String</span>

<span class="p">(</span><span class="nf">.trim</span> <span class="nv">string</span><span class="p">)</span>
<span class="c1">;; (.trim &quot;  foo  &quot;) =&gt; &quot;foo&quot;</span>

<span class="c1">;; 1.16 Parsing Comma-Separated Data</span>
<span class="c1">;; @@PLEAC@@_2.1 Checking Whether a String Is a Valid Number</span>

<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.text</span> <span class="nv">NumberFormat</span> <span class="nv">ParseException</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Locale</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">locale</span> <span class="nv">Locale/US</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">nb</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">nf</span> <span class="p">(</span><span class="nf">NumberFormat/getInstance</span> <span class="nv">locale</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">.parse</span> <span class="nv">nf</span> <span class="nv">s</span><span class="p">)))</span>

<span class="c1">;; user=&gt; (nb &quot;100&quot;)</span>
<span class="c1">;; 100</span>
<span class="c1">;; user=&gt; (nb &quot;not a number&quot;)</span>
<span class="c1">;; java.text.ParseException: Unparseable number: &quot;not a number&quot;</span>

<span class="c1">;; (def s1 &quot;100&quot;)</span>
<span class="c1">;; (def s1 &quot;not a number&quot;)</span>
<span class="p">(</span><span class="nf">try</span>
  <span class="p">(</span><span class="nf">Integer/parseInt</span> <span class="nv">s1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="nv">NumberFormatException</span> <span class="nv">_ex</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="nv">s1</span> <span class="s">&quot; is not an integer&quot;</span><span class="p">))))</span>

<span class="c1">;; (def s2 3.14)</span>
<span class="c1">;; (def s2 &quot;foo&quot;)</span>
<span class="p">(</span><span class="nf">try</span>
  <span class="p">(</span><span class="nf">Float/parseFloat</span> <span class="nv">s2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="nv">NumberFormatException</span> <span class="nv">_ex</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="nv">s2</span> <span class="s">&quot; is not a float&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">isNumeric</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">nf</span> <span class="p">(</span><span class="nf">NumberFormat/getInstance</span> <span class="nv">locale</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">try</span>
      <span class="p">(</span><span class="nf">do</span>
        <span class="p">(</span><span class="nf">.parse</span> <span class="nv">nf</span> <span class="nv">s</span><span class="p">)</span>
        <span class="nv">true</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">catch</span> <span class="nv">ParseException</span> <span class="nv">_ex</span> <span class="nv">false</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_2.2 Comparing Floating-Point Numbers</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="c1">;; (equal NUM1 NUM2 ACCURACY) returns true if NUM1 and NUM2 are</span>
<span class="c1">;; equal to ACCURACY number of decimal places</span>
<span class="c1">;; jli for mbac: not sure if you can use with-precision for this:</span>
<span class="c1">;; http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/with-precision</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">equal</span> <span class="p">[</span><span class="nv">num1</span> <span class="nv">num2</span> <span class="nv">accuracy</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">letfn</span> <span class="p">[(</span><span class="nf">bignum</span> <span class="p">[</span><span class="nv">num</span><span class="p">]</span>
            <span class="p">(</span><span class="nf">.setScale</span> <span class="p">(</span><span class="nf">BigDecimal.</span> <span class="nv">num</span><span class="p">)</span>
                       <span class="nv">accuracy</span>
                       <span class="nv">BigDecimal/ROUND_DOWN</span><span class="p">))]</span>
    <span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">.compareTo</span> <span class="p">(</span><span class="nf">bignum</span> <span class="nv">num1</span><span class="p">)</span> <span class="p">(</span><span class="nf">bignum</span> <span class="nv">num2</span><span class="p">)))))</span>

<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="c1">;; with a scaling factor</span>
<span class="c1">;; use &quot;M&quot; suffix for BigDecimal literals</span>
<span class="p">(</span><span class="k">def </span><span class="nv">wage</span> <span class="mf">5.36</span><span class="nv">M</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">hours</span> <span class="mi">40</span><span class="nv">M</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">week</span> <span class="p">(</span><span class="nf">.multiply</span> <span class="nv">wage</span> <span class="nv">hours</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;One week&#39;s wage is: $&quot;</span> <span class="nv">week</span><span class="p">))</span>
<span class="c1">;; One week&#39;s wage is: $214.40</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>

<span class="c1">;; @@PLEAC@@_2.3 Rounding Floating-Point Numbers</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="c1">;; (def unrounded ...)</span>
<span class="c1">;; (def scale ...)</span>
<span class="c1">;; (def roundingMode ...)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">rounded</span> <span class="p">(</span><span class="nf">.setScale</span> <span class="nv">unrounded</span> <span class="nv">scale</span> <span class="nv">roundingMode</span><span class="p">))</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="mf">0.255</span><span class="nv">M</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">(</span><span class="nf">.setScale</span> <span class="nv">a</span> <span class="mi">2</span> <span class="nv">BigDecimal/ROUND_HALF_UP</span><span class="p">))</span>
<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Unrounded: &quot;</span> <span class="nv">a</span><span class="p">))</span>
<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Rounded: &quot;</span> <span class="nv">b</span><span class="p">))</span>
<span class="c1">;=&gt; Unrounded: 0.255</span>
<span class="c1">;=&gt; Rounded: 0.26</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="c1">;; caution, Math.rint() rounds to the nearest integer!</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">[</span><span class="mf">3.3</span> <span class="mf">3.5</span> <span class="mf">3.7</span> <span class="mf">-3.3</span><span class="p">])</span>
<span class="p">(</span><span class="nb">println </span><span class="s">&quot;number\tint\tfloor\ceil&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">Math/rint</span> <span class="nv">x</span><span class="p">)</span> <span class="s">&quot;\t&quot;</span> <span class="p">(</span><span class="nf">Math/floor</span> <span class="nv">x</span><span class="p">)</span> <span class="s">&quot;\t&quot;</span> <span class="p">(</span><span class="nf">Math/ceil</span> <span class="nv">x</span><span class="p">))))</span> <span class="nv">a</span><span class="p">)</span>
<span class="c1">;;  3.0     3.0     4.0</span>
<span class="c1">;;  4.0     3.0     4.0</span>
<span class="c1">;;  4.0     3.0     4.0</span>
<span class="c1">;; -3.0    -4.0    -3.0</span>

<span class="c1">;; @@PLEAC@@_2.4 Converting Between Binary and Decimal</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">i</span> <span class="p">(</span><span class="nf">Integer/parseInt</span> <span class="nv">s</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">s</span> <span class="p">(</span><span class="nf">Integer/toString</span> <span class="nv">i</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="c1">;; reader supports &quot;&lt;radix&gt;r&lt;number&gt;&quot;</span>
<span class="p">(</span><span class="k">def </span><span class="nv">i</span> <span class="mi">2</span><span class="nv">r0110110</span><span class="p">)</span> <span class="c1">; i = 54</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">s</span> <span class="p">(</span><span class="nf">Integer/toString</span> <span class="mi">54</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">; s = 110110</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>

<span class="c1">;; @@PLEAC@@_2.5 Operating on a Series of Integers</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">1</span> <span class="nv">y</span> <span class="mi">10</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="nv">x</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">y</span><span class="p">))]</span>
    <span class="c1">;; i is set to every integer from X to Y inclusive</span>
    <span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">1</span> <span class="nv">y</span> <span class="mi">10</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">y</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">7</span><span class="p">)]</span>
    <span class="c1">;; i is set to every integer from X to Y, stepsize = 7</span>
    <span class="p">))</span>

<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="p">(</span><span class="nb">apply println </span><span class="p">(</span><span class="nb">cons </span><span class="s">&quot;Infancy is:&quot;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">3</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">apply println </span><span class="p">(</span><span class="nb">cons </span><span class="s">&quot;Toddling is:&quot;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span> <span class="mi">5</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">apply println </span><span class="p">(</span><span class="nb">cons </span><span class="s">&quot;Childhood is:&quot;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span> <span class="mi">13</span><span class="p">)))</span>
<span class="c1">;; Infancy is: 0 1 2</span>
<span class="c1">;; Toddling is: 3 4</span>
<span class="c1">;; Childhood is: 5 6 7 8 9 10 11 12</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>

<span class="c1">;; @@PLEAC@@_2.6 Working with Roman Numerals</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="c1">;; no roman module available</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>

<span class="c1">;; @@PLEAC@@_2.7 Generating Random Numbers</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Random</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">random</span> <span class="p">(</span><span class="nf">Random.</span> <span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">i</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">.nextInt</span> <span class="nv">random</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span> <span class="nv">x</span><span class="p">))</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">i</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">.nextInt</span> <span class="nv">random</span> <span class="mi">51</span><span class="p">)</span> <span class="mi">25</span><span class="p">))</span>
<span class="p">(</span><span class="nb">println </span><span class="nv">i</span><span class="p">)</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>

<span class="c1">;; @@PLEAC@@_2.8 Generating Different Random Numbers</span>
<span class="c1">;;----------------------------------------------------------------------------------</span>
<span class="c1">;; Seed the generator with an integer</span>
<span class="p">(</span><span class="nf">Random.</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1">;; Use SecureRandom instead to seed with bytes from stdin</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.security</span> <span class="nv">SecureRandom</span><span class="p">))</span>
<span class="c1">;; jli for mbac: unqualified &quot;use&quot; is almost always ungood. use :only</span>
<span class="c1">;; or :rename.</span>
<span class="c1">;; mbac: fixed!</span>
<span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.contrib.io</span> <span class="ss">:only</span> <span class="p">(</span><span class="nf">to-byte-array</span><span class="p">)])</span>
<span class="p">(</span><span class="nf">SecureRandom.</span> <span class="p">(</span><span class="nf">to-byte-array</span> <span class="nv">System/in</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_2.9 Making Numbers Even More Random</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">srng</span> <span class="p">(</span><span class="nf">SecureRandom.</span><span class="p">)</span>
      <span class="nv">buf</span> <span class="p">(</span><span class="nf">byte-array</span> <span class="mi">10</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">do</span>
    <span class="p">(</span><span class="nf">.nextBytes</span> <span class="nv">srng</span> <span class="nv">buf</span><span class="p">)</span>
    <span class="nv">buf</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_2.10 Generating Biased Random Numbers</span>
<span class="p">(</span><span class="k">def </span><span class="nv">prng</span> <span class="p">(</span><span class="nf">Random.</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">gaussian-rand</span> <span class="p">[]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">w</span> <span class="nv">u1</span> <span class="nv">u2</span><span class="p">]</span> <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
                    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">u1</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nf">.nextDouble</span> <span class="nv">prng</span><span class="p">))</span> <span class="mi">1</span><span class="p">)</span>
                          <span class="nv">u2</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nf">.nextDouble</span> <span class="nv">prng</span><span class="p">))</span> <span class="mi">1</span><span class="p">)</span>
                          <span class="nv">w</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">u1</span> <span class="nv">u1</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">u2</span> <span class="nv">u2</span><span class="p">))]</span>
                      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">w</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="p">(</span><span class="nf">recur</span><span class="p">)</span>
                        <span class="p">[</span><span class="nv">w</span> <span class="nv">u1</span> <span class="nv">u2</span><span class="p">])))</span>
        <span class="nv">w</span> <span class="p">(</span><span class="nf">Math/sqrt</span> <span class="p">(</span><span class="nb">* </span><span class="mi">-2</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">Math/log</span> <span class="nv">w</span><span class="p">)</span> <span class="nv">w</span><span class="p">)))</span>
        <span class="nv">g2</span> <span class="p">(</span><span class="nb">* </span><span class="nv">u1</span> <span class="nv">w</span><span class="p">)</span>
        <span class="nv">g1</span> <span class="p">(</span><span class="nb">* </span><span class="nv">u2</span> <span class="nv">w</span><span class="p">)]</span>
    <span class="nv">g1</span><span class="p">))</span>

<span class="c1">;; -----------------------------</span>
<span class="c1">;; weight-to-dist: takes a list of pairs mapping key to weight and</span>
<span class="c1">;; returns a list of pairs mapping key to probability</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">weight-to-dist</span> <span class="p">[</span><span class="nv">weights</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">total</span> <span class="p">(</span><span class="nb">apply + </span><span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">_key</span> <span class="nv">weight</span><span class="p">]]</span> <span class="nv">weight</span><span class="p">)</span> <span class="nv">weights</span><span class="p">))]</span>
    <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nb">key </span><span class="nv">weight</span><span class="p">]]</span> <span class="p">[</span><span class="nb">key </span><span class="p">(</span><span class="nb">/ </span><span class="nv">weight</span> <span class="nv">total</span><span class="p">)])</span>
         <span class="nv">weights</span><span class="p">)))</span>

<span class="c1">;; weighted-rand: takes a list of pairs mapping key to probability</span>
<span class="c1">;; and returns the corresponding key</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">weighted-rand</span> <span class="p">[</span><span class="nv">dist</span><span class="p">]</span>
  <span class="c1">;; accumulate without mutation</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">go</span> <span class="p">(</span><span class="k">fn </span><span class="nv">cont</span> <span class="p">[</span><span class="nv">p</span> <span class="nv">lst</span><span class="p">]</span>
             <span class="p">(</span><span class="nb">if-let </span><span class="p">[[</span><span class="nb">key </span><span class="nv">weight</span><span class="p">]</span> <span class="p">(</span><span class="nb">first </span><span class="nv">lst</span><span class="p">)]</span>
               <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">pp</span> <span class="p">(</span><span class="nb">- </span><span class="nv">p</span> <span class="nv">weight</span><span class="p">)]</span>
                 <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">pp</span> <span class="mi">0</span><span class="p">)</span>
                   <span class="p">[</span><span class="nv">pp</span> <span class="nv">key</span><span class="p">]</span>
                   <span class="p">(</span><span class="nf">recur</span> <span class="nv">pp</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">lst</span><span class="p">))))))</span>
        <span class="nv">result</span> <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">.nextDouble</span> <span class="p">(</span><span class="nf">Random.</span><span class="p">))</span> <span class="nv">dist</span><span class="p">)]</span>
    <span class="c1">;; to avoid floating point inaccuracies</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">result</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="nv">dist</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">_p</span> <span class="nv">key</span><span class="p">]</span> <span class="nv">result</span><span class="p">]</span>
        <span class="nv">key</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">mean</span> <span class="mi">25</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">stddev</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">salary</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">gaussian-rand</span><span class="p">)</span> <span class="nv">stddev</span><span class="p">)</span> <span class="nv">mean</span><span class="p">))</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;You have been hired at $%.2f\n&quot;</span> <span class="nv">salary</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_2.11 Doing Trigonometry in Degrees, not Radians</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">radians</span> <span class="p">[</span><span class="nv">deg</span><span class="p">]</span> <span class="p">(</span><span class="nf">Math/toRadians</span> <span class="nv">deg</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">degrees</span> <span class="p">[</span><span class="nv">rad</span><span class="p">]</span> <span class="p">(</span><span class="nf">Math/toDegrees</span> <span class="nv">rad</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">sin-deg</span> <span class="p">[</span><span class="nv">deg</span><span class="p">]</span> <span class="p">(</span><span class="nf">Math/sin</span> <span class="p">(</span><span class="nf">radians</span> <span class="nv">deg</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_2.12 Calculating More Trigonometric Functions</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">tan</span> <span class="p">[</span><span class="nv">theta</span><span class="p">]</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">Math/sin</span> <span class="nv">theta</span><span class="p">)</span> <span class="p">(</span><span class="nf">Math/cos</span> <span class="nv">theta</span><span class="p">)))</span>
<span class="c1">;; or use Math/tan</span>

<span class="p">(</span><span class="k">def </span><span class="nv">y</span>
  <span class="p">(</span><span class="nf">try</span>
    <span class="p">(</span><span class="nf">tan</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">Math/PI</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">catch</span> <span class="nv">Exception</span> <span class="nv">e</span> <span class="nv">nil</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_2.13 Taking Logarithms</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">log_e</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">Math/log</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">log_10</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">Math/log10</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">log-base</span> <span class="p">[</span><span class="nv">base</span> <span class="nv">value</span><span class="p">]</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">log_e</span> <span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="nf">log_e</span> <span class="nv">base</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">answer</span> <span class="p">(</span><span class="nf">log-base</span> <span class="mi">10</span> <span class="mi">10000</span><span class="p">))</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;log10(10,000) = %f&quot;</span> <span class="nv">answer</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_2.14 Multiplying Matrices</span>
<span class="c1">;; This is a very academic, purely functional implementation of</span>
<span class="c1">;; multiply-matrix.  A performance critical implementation would</span>
<span class="c1">;; likely not use Clojure&#39;s immutable vectors.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">multiply-matrix</span> <span class="p">[</span><span class="nv">m1</span> <span class="nv">m2</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">dim</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">m</span><span class="p">]</span> <span class="p">[(</span><span class="nb">count </span><span class="nv">m</span><span class="p">)</span> <span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">first </span><span class="nv">m</span><span class="p">))])</span>
        <span class="p">[</span><span class="nv">r1</span> <span class="nv">c1</span><span class="p">]</span> <span class="p">(</span><span class="nf">dim</span> <span class="nv">m1</span><span class="p">)</span>
        <span class="p">[</span><span class="nv">r2</span> <span class="nv">c2</span><span class="p">]</span> <span class="p">(</span><span class="nf">dim</span> <span class="nv">m2</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">= </span><span class="nv">c1</span> <span class="nv">r2</span><span class="p">))</span>
      <span class="nv">nil</span> <span class="c1">; matrix dimensions don&#39;t match</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">dot-product</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">]</span>
                          <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">a</span> <span class="nv">i</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">nth </span><span class="nv">v1</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">v2</span> <span class="nv">i</span><span class="p">))))</span>
                                  <span class="mi">0</span>
                                  <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="p">(</span><span class="nb">count </span><span class="nv">v1</span><span class="p">))))</span>
            <span class="nv">row</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">m</span> <span class="nv">i</span><span class="p">]</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">m</span> <span class="nv">i</span><span class="p">))</span>
            <span class="nv">col</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">m</span> <span class="nv">i</span><span class="p">]</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">r</span><span class="p">]</span> <span class="p">(</span><span class="nb">nth </span><span class="p">(</span><span class="nb">nth </span><span class="nv">m</span> <span class="nv">r</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>
                               <span class="p">(</span><span class="nb">range </span><span class="p">(</span><span class="nb">count </span><span class="nv">m</span><span class="p">))))]</span>
        <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">r</span><span class="p">]</span>
               <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">c</span><span class="p">]</span> <span class="p">(</span><span class="nf">dot-product</span> <span class="p">(</span><span class="nf">row</span> <span class="nv">m1</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="nf">col</span> <span class="nv">m2</span> <span class="nv">c</span><span class="p">)))</span>
                    <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="nv">c2</span><span class="p">)))</span>
             <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="nv">r1</span><span class="p">))))))</span>

<span class="c1">;; @@PLEAC@@_2.15 Using Complex Numbers</span>
<span class="c1">;; c = a * b manually</span>
<span class="p">(</span><span class="kd">defrecord </span><span class="nv">Complex</span> <span class="p">[</span><span class="nv">real</span> <span class="nv">imag</span><span class="p">])</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">mul</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">Complex.</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">.real</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">.real</span> <span class="nv">b</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">.imag</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">.imag</span> <span class="nv">b</span><span class="p">))))</span>

<span class="c1">;; c = a * b using the complex-numbers module</span>
<span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">clojure.contrib</span> <span class="nv">complex-numbers</span><span class="p">)</span>
     <span class="o">&#39;</span><span class="p">(</span><span class="nf">clojure.contrib.generic</span> <span class="p">[</span><span class="nv">arithmetic</span> <span class="ss">:only</span> <span class="p">[</span><span class="nb">+ </span><span class="nv">*</span><span class="p">]]</span>
                               <span class="p">[</span><span class="nv">math-functions</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">sqrt</span><span class="p">]]))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nf">complex</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">(</span><span class="nf">complex</span> <span class="mi">2</span> <span class="mi">-2</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">c</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">c</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">complex</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nf">complex</span> <span class="mi">2</span> <span class="mi">-2</span><span class="p">)))</span> <span class="c1">; or on one line</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-complex-sqrt</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">as-string</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">c</span><span class="p">]</span> <span class="p">(</span><span class="nf">format</span> <span class="s">&quot;%s+%si&quot;</span>
                                  <span class="p">(</span><span class="nf">real</span> <span class="nv">c</span><span class="p">)</span>
                                  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">imag</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;&quot;</span> <span class="p">(</span><span class="nf">imag</span> <span class="nv">c</span><span class="p">))))]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;sqrt(%s) = %s\n&quot;</span>
           <span class="p">(</span><span class="nf">as-string</span> <span class="nv">x</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">as-string</span> <span class="p">(</span><span class="nf">sqrt</span> <span class="nv">x</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">d</span> <span class="p">(</span><span class="nf">complex</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print-complex-sqrt</span> <span class="nv">d</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_2.16 Converting Between Octal and Hexadecimal</span>
<span class="c1">;; hex and octal should not have leading 0x or 0 characters</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hex-and-oct-as-decs</span> <span class="p">[</span><span class="nv">hex</span> <span class="nv">octal</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">dec-of-hex</span> <span class="p">(</span><span class="nf">Integer/parseInt</span> <span class="nv">hex</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nv">dec-of-oct</span> <span class="p">(</span><span class="nf">Integer/parseInt</span> <span class="nv">octal</span> <span class="mi">8</span><span class="p">)]</span>
    <span class="c1">;; use dec-of-hex and dec-of-oct here</span>
    <span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">num</span> <span class="p">(</span><span class="nf">-&gt;</span>
           <span class="p">(</span><span class="nf">do</span>
             <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Gimme a number in decimal, octal, or hex: &quot;</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">read-line</span><span class="p">))</span>
           <span class="nv">.trim</span>
           <span class="nv">Integer/parseInt</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s %s %s\n&quot;</span>
          <span class="p">(</span><span class="nf">Integer/toString</span> <span class="nv">num</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">Integer/toOctalString</span> <span class="nv">num</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">Integer/toHexString</span> <span class="nv">num</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_2.17 Putting Commas in Numbers</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.text</span> <span class="nv">NumberFormat</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Locale</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">locale</span> <span class="nv">Locale/US</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">commify-localized</span> <span class="p">[</span><span class="nv">num</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">nf</span> <span class="p">(</span><span class="nf">NumberFormat/getInstance</span> <span class="nv">locale</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">.format</span> <span class="nv">nf</span> <span class="nv">num</span><span class="p">)))</span>

<span class="c1">;; deck version</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">commify-hipster</span> <span class="p">[</span><span class="nv">numstr</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">.toString</span> <span class="nv">numstr</span><span class="p">)</span>
       <span class="nv">reverse</span>
       <span class="p">(</span><span class="nf">partition-all</span> <span class="mi">3</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">interpose</span> <span class="sc">\,</span><span class="p">)</span>
       <span class="nv">flatten</span>
       <span class="nv">reverse</span>
       <span class="p">(</span><span class="nb">apply </span><span class="nv">str</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_2.18 Printing Correct Plurals</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">print-plurals</span> <span class="p">[</span><span class="nv">hours</span> <span class="nv">centuries</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">do</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;It took %d hour%s\n&quot;</span> <span class="nv">hours</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">hours</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;s&quot;</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%d hour%s %s enough.\n&quot;</span>
            <span class="nv">hours</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">hours</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;s&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">hours</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;is&quot;</span> <span class="s">&quot;are&quot;</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;It took %d centur%s\n&quot;</span> <span class="nv">centuries</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">centuries</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;y&quot;</span> <span class="s">&quot;ies&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">noun-rules</span>
  <span class="p">[[</span><span class="o">#</span><span class="s">&quot;ss$&quot;</span> <span class="s">&quot;sses&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;ph$&quot;</span> <span class="s">&quot;phes&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;sh$&quot;</span> <span class="s">&quot;shes&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;ch$&quot;</span> <span class="s">&quot;ches&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;z$&quot;</span>  <span class="s">&quot;zes&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;ff$&quot;</span> <span class="s">&quot;ffs&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;f$&quot;</span>  <span class="s">&quot;ves&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;ey$&quot;</span> <span class="s">&quot;eys&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;y$&quot;</span>  <span class="s">&quot;ies&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;ix$&quot;</span> <span class="s">&quot;ices&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;s$&quot;</span>  <span class="s">&quot;ses&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;x$&quot;</span>  <span class="s">&quot;xes&quot;</span><span class="p">]</span>
   <span class="p">[</span><span class="o">#</span><span class="s">&quot;$&quot;</span>   <span class="s">&quot;s&quot;</span><span class="p">]])</span>

<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">clojure.contrib</span> <span class="p">[</span><span class="nv">str-utils2</span> <span class="ss">:as</span> <span class="nv">s</span><span class="p">]))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">noun_plural</span> <span class="p">[</span><span class="nv">word</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">some </span><span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">re</span> <span class="nv">ending</span><span class="p">]]</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">re-find </span><span class="nv">re</span> <span class="nv">word</span><span class="p">)</span> <span class="p">(</span><span class="nf">s/replace</span> <span class="nv">word</span> <span class="nv">re</span> <span class="nv">ending</span><span class="p">)))</span>
        <span class="nv">noun-rules</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">verb_singular</span> <span class="nv">noun_plural</span><span class="p">)</span> <span class="c1">; make function alias</span>

<span class="c1">;; Note: there&#39;s no perl Lingua::EN::Inflect equivalent module</span>

<span class="c1">;; @@PLEAC@@_2.19 Program: Calculating Prime Factors</span>
<span class="c1">;; jli for mbac: shouldn&#39;t this return {orig 1} for prime numbers?</span>
<span class="c1">;; mbac for jli: maybe, but the perl version doesn&#39;t do this either</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">get-factors</span> <span class="p">[</span><span class="nv">orig</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">letfn</span> <span class="p">[(</span><span class="nf">factor-out</span> <span class="p">[</span><span class="nv">n</span> <span class="nv">factors</span> <span class="nv">i</span><span class="p">]</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">zero? </span><span class="p">(</span><span class="nf">mod</span> <span class="nv">n</span> <span class="nv">i</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">n</span> <span class="nv">i</span><span class="p">)</span>
                     <span class="p">(</span><span class="nb">assoc </span><span class="nv">factors</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">factors</span> <span class="nv">i</span> <span class="mi">0</span><span class="p">)))</span>
                     <span class="nv">i</span><span class="p">)</span>
              <span class="p">[</span><span class="nv">n</span> <span class="nv">factors</span><span class="p">]))]</span>
    <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span> <span class="mi">2</span>
           <span class="nv">sqi</span> <span class="mi">4</span>
           <span class="p">[</span><span class="nv">n</span> <span class="nv">factors</span><span class="p">]</span> <span class="p">[</span><span class="nv">orig</span> <span class="p">{}]]</span>
      <span class="p">(</span><span class="nf">cond</span>
       <span class="p">(</span><span class="nb">&lt;= </span><span class="nv">sqi</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)</span>
                         <span class="p">(</span><span class="nb">+ </span><span class="nv">sqi</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
                         <span class="p">(</span><span class="nf">factor-out</span> <span class="nv">n</span> <span class="nv">factors</span> <span class="nv">i</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">not= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">not= </span><span class="nv">n</span> <span class="nv">orig</span><span class="p">))</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">factors</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">factors</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)))</span>
       <span class="ss">:default</span> <span class="nv">factors</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-factors</span> <span class="p">[</span><span class="nv">orig</span> <span class="nv">factors</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">head</span> <span class="p">(</span><span class="nf">format</span> <span class="s">&quot;%-10d&quot;</span> <span class="nv">orig</span><span class="p">)</span>
        <span class="nv">lines</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">zero? </span><span class="p">(</span><span class="nb">count </span><span class="nv">factors</span><span class="p">))</span>
                <span class="p">[</span><span class="s">&quot;PRIME&quot;</span><span class="p">]</span>
                <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">f</span> <span class="nv">e</span><span class="p">]]</span> <span class="p">(</span><span class="nf">format</span> <span class="s">&quot;%d^%d&quot;</span> <span class="nv">f</span> <span class="nv">e</span><span class="p">))</span> <span class="nv">factors</span><span class="p">))</span>
        <span class="nv">s</span> <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nf">interpose</span> <span class="s">&quot;\n&quot;</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">head</span> <span class="nv">lines</span><span class="p">)))]</span>
    <span class="p">(</span><span class="nb">println </span><span class="nv">s</span><span class="p">)))</span>

<span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span> <span class="mi">0</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">*command-line-args*</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">n</span> <span class="p">(</span><span class="nf">Integer/parseInt</span> <span class="p">(</span><span class="nf">.get</span> <span class="nv">argv</span> <span class="nv">i</span><span class="p">))]</span>
      <span class="p">(</span><span class="nf">do</span>
        <span class="p">(</span><span class="nf">print-factors</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">factorize</span> <span class="nv">n</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))))))</span>
<span class="c1">;; @@PLEAC@@_3.0 Introduction</span>
<span class="c1">;;------------------------------------</span>
<span class="c1">;; Use a calendar to compute year, month, day, hour, minute and second values.</span>

<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Calendar</span><span class="p">))</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">GregorianCalendar</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-day-of-year</span> <span class="p">[]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cal</span> <span class="p">(</span><span class="nf">GregorianCalendar.</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Today is day %d of the current year.\n&quot;</span>
            <span class="p">(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/DAY_OF_YEAR</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_3.1 Finding Today&#39;s Date</span>
<span class="c1">;;------------------------------------</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Calendar</span><span class="p">))</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">GregorianCalendar</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">todays-date</span> <span class="p">[]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cal</span> <span class="p">(</span><span class="nf">GregorianCalendar.</span><span class="p">)</span>
        <span class="nv">day</span> <span class="p">(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/DATE</span><span class="p">)</span>
        <span class="nv">month</span> <span class="p">(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/MONTH</span><span class="p">)</span>
        <span class="nv">year</span> <span class="p">(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/YEAR</span><span class="p">)]</span>
    <span class="p">[</span><span class="nv">day</span> <span class="nv">month</span> <span class="nv">year</span><span class="p">]))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-todays-date</span> <span class="p">[]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">day</span> <span class="nv">month</span> <span class="nv">year</span><span class="p">]</span> <span class="p">(</span><span class="nf">todays-date</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;The current date is %d %02d %02d\n&quot;</span> <span class="nv">year</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">month</span><span class="p">)</span> <span class="nv">day</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_3.2 Converting DMYHMS to Epoch Seconds</span>
<span class="c1">;;------------------------------------</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Calendar</span><span class="p">))</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">TimeZone</span><span class="p">))</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">GregorianCalendar</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">epoch-seconds-of-dmyhms</span> <span class="p">[</span><span class="nv">tz</span> <span class="nv">day</span> <span class="nv">month</span> <span class="nv">year</span> <span class="nv">hour</span> <span class="nv">minute</span> <span class="nv">second</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cal</span> <span class="p">(</span><span class="nf">GregorianCalendar.</span><span class="p">)</span>
        <span class="nv">zone</span> <span class="p">(</span><span class="nf">TimeZone/getTimeZone</span> <span class="nv">tz</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">do</span>
      <span class="p">(</span><span class="nf">.setTimeZone</span> <span class="nv">cal</span> <span class="nv">zone</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">.set</span> <span class="nv">cal</span> <span class="nv">Calendar/DAY_OF_MONTH</span> <span class="nv">day</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">.set</span> <span class="nv">cal</span> <span class="nv">Calendar/MONTH</span> <span class="nv">month</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">.set</span> <span class="nv">cal</span> <span class="nv">Calendar/YEAR</span> <span class="nv">year</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">.set</span> <span class="nv">cal</span> <span class="nv">Calendar/HOUR_OF_DAY</span> <span class="nv">hour</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">.set</span> <span class="nv">cal</span> <span class="nv">Calendar/MINUTE</span> <span class="nv">minute</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">.set</span> <span class="nv">cal</span> <span class="nv">Calendar/SECOND</span> <span class="nv">second</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">.getTime</span> <span class="p">(</span><span class="nf">.getTime</span> <span class="nv">cal</span><span class="p">))</span> <span class="mi">1000</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">epoch-seconds-of-dmyhms</span> <span class="s">&quot;UTC&quot;</span> <span class="mi">4</span> <span class="mi">10</span> <span class="mi">2011</span> <span class="mi">12</span> <span class="mi">30</span> <span class="mi">55</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_3.3 Converting Epoch Seconds to DMYHMS</span>
<span class="c1">;;------------------------------------</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Calendar</span><span class="p">))</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Date</span><span class="p">))</span>
<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">GregorianCalendar</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">dmyhms-of-epoch-seconds</span> <span class="p">[</span><span class="nv">seconds</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cal</span> <span class="p">(</span><span class="nf">GregorianCalendar.</span><span class="p">)</span>
        <span class="nv">date</span> <span class="p">(</span><span class="nf">Date.</span> <span class="p">(</span><span class="nb">* </span><span class="nv">seconds</span> <span class="mi">1000</span><span class="p">))]</span>
    <span class="p">(</span><span class="nf">do</span>
      <span class="p">(</span><span class="nf">.setTime</span> <span class="nv">cal</span> <span class="nv">date</span><span class="p">)</span>
      <span class="p">[(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/DAY_OF_MONTH</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/MONTH</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/YEAR</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/HOUR_OF_DAY</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/MINUTE</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">.get</span> <span class="nv">cal</span> <span class="nv">Calendar/SECOND</span><span class="p">)])))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-dmyhms-of-epoch-seconds</span> <span class="p">[</span><span class="nv">seconds</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">day</span> <span class="nv">month</span> <span class="nv">year</span> <span class="nv">hour</span> <span class="nv">minute</span> <span class="nv">seconds</span><span class="p">]</span> <span class="p">(</span><span class="nf">dmyhms-of-epoch-seconds</span> <span class="nv">seconds</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%02d-%02d-%d %02d:%02d:%02d\n&quot;</span>
            <span class="nv">day</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">month</span><span class="p">)</span> <span class="nv">year</span> <span class="nv">hour</span> <span class="nv">minute</span> <span class="nv">seconds</span><span class="p">)))</span>

<span class="c1">;; 3.4 Adding or Subtracting from a Date</span>
<span class="c1">;; @@PLEAC@@_4.0 Introduction</span>

<span class="c1">;;-----------------------------</span>
<span class="c1">;; vectors</span>
<span class="p">(</span><span class="k">def </span><span class="nv">simple</span> <span class="p">[</span><span class="s">&quot;this&quot;</span> <span class="s">&quot;that&quot;</span> <span class="s">&quot;the&quot;</span> <span class="s">&quot;other&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">nested</span> <span class="p">[</span><span class="s">&quot;this&quot;</span> <span class="s">&quot;that&quot;</span> <span class="p">[</span><span class="s">&quot;the&quot;</span> <span class="s">&quot;other&quot;</span><span class="p">]])</span>

<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">simple</span><span class="p">)</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="nv">nested</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">nth </span><span class="nv">nested</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">tune</span> <span class="p">[</span><span class="s">&quot;The&quot;</span> <span class="s">&quot;Star-Spangled&quot;</span> <span class="s">&quot;Banner&quot;</span><span class="p">])</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.1 Specifying a List in Your Program</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">[</span><span class="s">&quot;quick&quot;</span> <span class="s">&quot;brown&quot;</span> <span class="s">&quot;fox&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">qw</span>
  <span class="s">&quot;Split string on whitespace. Returns a seq.&quot;</span>
  <span class="p">[</span><span class="nv">s</span><span class="p">]</span> <span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nf">.split</span> <span class="nv">s</span> <span class="s">&quot;\\s&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a2</span> <span class="p">(</span><span class="nf">qw</span> <span class="s">&quot;Why are you teasing me?&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">lines</span>
  <span class="p">(</span><span class="nf">.replaceAll</span> <span class="s">&quot;    The boy stood on the burning deck,</span>
<span class="s">    It was as hot as glass.&quot;</span>
               <span class="s">&quot;\\ +&quot;</span> <span class="s">&quot;&quot;</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">bigvector</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>

<span class="p">(</span><span class="nf">try</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">bigvector</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="s">&quot;mydatafile&quot;</span><span class="p">)))]</span>
    <span class="c1">;; rest of code to do something with bigvector</span>
    <span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="nv">java.io.FileNotFoundException</span> <span class="nv">e</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">e</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">flush</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">System/exit</span> <span class="mi">1</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>


<span class="c1">;; @@PLEAC@@_4.2 Printing a List with Commas</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">commify-series</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">case</span> <span class="p">(</span><span class="nb">count </span><span class="nv">coll</span><span class="p">)</span>
        <span class="mi">0</span> <span class="s">&quot;&quot;</span>
        <span class="mi">1</span> <span class="p">(</span><span class="nb">first </span><span class="nv">coll</span><span class="p">)</span>
        <span class="mi">2</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; and &quot;</span> <span class="nv">coll</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot;, &quot;</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">butlast </span><span class="nv">coll</span><span class="p">)</span>
                               <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;and &quot;</span> <span class="p">(</span><span class="nb">last </span><span class="nv">coll</span><span class="p">)))))))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="s">&quot;red&quot;</span> <span class="s">&quot;yellow&quot;</span> <span class="s">&quot;green&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="nb">print </span><span class="s">&quot;I have&quot;</span> <span class="nv">array</span> <span class="s">&quot;marbles.\n&quot;</span><span class="p">)</span>
<span class="c1">;; Clojure does not have string interpolation.</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;I have %s marbles.\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">array</span><span class="p">))</span>
<span class="nv">I</span> <span class="nv">have</span> <span class="p">[</span><span class="nv">red</span> <span class="nv">yellow</span> <span class="nv">green</span><span class="p">]</span> <span class="nv">marbles.</span>

<span class="nv">I</span> <span class="nv">have</span> <span class="nv">red</span> <span class="nv">yellow</span> <span class="nv">green</span> <span class="nv">marbles.</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.3 Changing Array Size</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure vectors cannot be modified, but we can create new vectors</span>
<span class="c1">;; from existing ones, with differences between the existing and new</span>
<span class="c1">;; ones.</span>

<span class="c1">;; create smaller array that is a subset of an existing one.  Unlike</span>
<span class="c1">;; Perl&#39;s $#ARRAY = $NEW_LAST_ELEMENT_INDEX_NUMBER, you must use the</span>
<span class="c1">;; new number of elements with subvec, which is one larger than the</span>
<span class="c1">;; new last element index number.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">newv</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="nv">newv-number-of-elements</span><span class="p">))</span>
<span class="c1">;; In general you can give an arbitrary start (inclusive) and end</span>
<span class="c1">;; (exclusive) index to subvec.  It only takes O(1) time.  The new</span>
<span class="c1">;; vector&#39;s index i has the same value as the original vector&#39;s index</span>
<span class="c1">;; (start+i).</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; We can create a new Clojure vector one larger in size than an</span>
<span class="c1">;; existing one using assoc or conj.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">newv</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">v</span> <span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">newv</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">v</span> <span class="nv">value</span><span class="p">))</span>
<span class="c1">;; I believe there is no way to expand a vector by an arbitrary amount</span>
<span class="c1">;; using a single Clojure built-in function.  One could achieve that</span>
<span class="c1">;; effect by repeatedly using conj to add individual elements to the</span>
<span class="c1">;; end, one at a time, until the desired vector size was reached.</span>
<span class="c1">;; However, if you want a sparsely populated array with elements</span>
<span class="c1">;; indexed by integer, you are likely to be more satisfied using a map</span>
<span class="c1">;; with integer keys than a vector.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">what-about-that-vector</span> <span class="p">[</span><span class="nv">v</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;The vector now has %d elements.\n&quot;</span> <span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;The index of the last element is %d.\n&quot;</span> <span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Element #3 is `%s&#39;.\n&quot;</span> <span class="p">(</span><span class="nf">v</span> <span class="mi">3</span><span class="p">)))</span>
<span class="c1">;; Note that qw returns a sequence of elements that is not a Clojure</span>
<span class="c1">;; vector.  Here we use vec to create a vector containing the same</span>
<span class="c1">;; elements as the sequence.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">people</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">qw</span> <span class="s">&quot;Crosby Stills Nash Young&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">what-about-that-vector</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="nv">The</span> <span class="nb">vector </span><span class="nv">now</span> <span class="nv">has</span> <span class="mi">4</span> <span class="nv">elements.</span>
<span class="nv">The</span> <span class="nb">index </span><span class="nv">of</span> <span class="nv">the</span> <span class="nb">last </span><span class="nv">element</span> <span class="nv">is</span> <span class="mi">3</span><span class="nv">.</span>
<span class="nv">Element</span> <span class="o">#</span><span class="mi">3</span> <span class="nv">is</span> <span class="o">`</span><span class="nv">Young</span><span class="ss">&#39;.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">people</span> <span class="p">(</span><span class="nb">pop </span><span class="nv">people</span><span class="p">))</span>
<span class="c1">;; The following has equivalent behavior for vectors to pop, but not</span>
<span class="c1">;; sure if the efficiency is the same.</span>
<span class="c1">;;(def people (subvec people 0 (dec (count people))))</span>
<span class="p">(</span><span class="nf">what-about-that-vector</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="nv">IndexOutOfBoundsException</span>   <span class="nv">clojure.lang.PersistentVector.arrayFor</span> <span class="p">(</span><span class="nf">PersistentVector.java</span><span class="ss">:106</span><span class="p">)</span>
<span class="nv">The</span> <span class="nb">vector </span><span class="nv">now</span> <span class="nv">has</span> <span class="mi">3</span> <span class="nv">elements.</span>
<span class="nv">The</span> <span class="nb">index </span><span class="nv">of</span> <span class="nv">the</span> <span class="nb">last </span><span class="nv">element</span> <span class="nv">is</span> <span class="mi">2</span><span class="nv">.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; As mentioned above, there is no single builtin function to extend a</span>
<span class="c1">;; vector by an arbitrarily large number of elements.  We&#39;ll do it</span>
<span class="c1">;; here with a loop.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">people</span>
     <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">people</span> <span class="nv">people</span><span class="p">]</span>
       <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">count </span><span class="nv">people</span><span class="p">)</span> <span class="mi">10001</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">people</span> <span class="nv">nil</span><span class="p">))</span>
         <span class="c1">;; else</span>
         <span class="nv">people</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">what-about-that-vector</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="nv">The</span> <span class="nb">vector </span><span class="nv">now</span> <span class="nv">has</span> <span class="mi">10001</span> <span class="nv">elements.</span>
<span class="nv">The</span> <span class="nb">index </span><span class="nv">of</span> <span class="nv">the</span> <span class="nb">last </span><span class="nv">element</span> <span class="nv">is</span> <span class="mi">10000</span><span class="nv">.</span>
<span class="nv">Element</span> <span class="o">#</span><span class="mi">3</span> <span class="nv">is</span> <span class="o">`</span><span class="nv">null</span><span class="ss">&#39;.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Assigning a value to element 10000 of vector people will not change</span>
<span class="c1">;; its size, even if that new value is nil.  To make a vector with a</span>
<span class="c1">;; smaller size, use subvec or pop as described above.</span>

<span class="c1">;; @@PLEAC@@_4.4 Doing Something with Every Element in a List</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; Clojure is often written in a functional style, meaning that you</span>
<span class="c1">;; calculate output value from input values.  So Clojure&#39;s &#39;for&#39; is</span>
<span class="c1">;; actually a way to take one or more input sequences and produce an</span>
<span class="c1">;; output sequence, and in fact this is done in a lazy fashion,</span>
<span class="c1">;; meaning that no actual computation occurs unless some other code</span>
<span class="c1">;; _uses_ elements of the output sequence.</span>

<span class="c1">;; If you use Clojure&#39;s REPL to try out code before using it in a</span>
<span class="c1">;; program, this can easily confuse you, because at the REPL, every</span>
<span class="c1">;; expression you enter is read, executed, and the result is printed.</span>
<span class="c1">;; The fact that the result is printed often forces lazy expressions</span>
<span class="c1">;; to calculate their entire result, but if you use that lazy</span>
<span class="c1">;; expression as part of a larger expression or program, it won&#39;t be.</span>

<span class="c1">;; Here are a couple of quick examples:</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1">;; i iterates over the elements of the sequence (range 0 5).  The for</span>
<span class="c1">;; expression as a whole returns a sequence containing (inc i) for</span>
<span class="c1">;; each input sequence element.  It does this lazily, but because we</span>
<span class="c1">;; are typing it at the REPL, the output value is used in order to</span>
<span class="c1">;; print it.</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)]</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1">;; Here we add some debug print statements, and its output gets</span>
<span class="c1">;; mingled with the printed output value.</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)]</span> <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;i=%d\n&quot;</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">i=0</span>
<span class="nv">i=1</span>
<span class="nv">i=2</span>
<span class="nv">i=3</span>
<span class="nv">i=4</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">;; Here we assign the value of the for expression to a var.  Note that</span>
<span class="c1">;; the only output printed is the output value of the def statement,</span>
<span class="c1">;; which is #&#39;user/a1.  Why don&#39;t the printf&#39;s get executed?  Because</span>
<span class="c1">;; the for is lazy, and nothing has used any part of its output value</span>
<span class="c1">;; yet.</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">a1</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)]</span> <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;i=%d\n&quot;</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))))</span>
<span class="o">#</span><span class="ss">&#39;user/a1</span>

<span class="c1">;; When we ask for the value of a1, then the output value of the for</span>
<span class="c1">;; expression is required, and so its body is executed now.</span>
<span class="nv">user=&gt;</span> <span class="nv">a1</span>
<span class="p">(</span><span class="nf">i=0</span>
<span class="nv">i=1</span>
<span class="nv">i=2</span>
<span class="nv">i=3</span>
<span class="nv">i=4</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1">;; If you want to force the iteration to occur when it is evaluated,</span>
<span class="c1">;; use doseq instead.  It does not return any useful value (only nil),</span>
<span class="c1">;; and is intended to be used when the body contains side effects.</span>
<span class="c1">;; Here the (inc i) is superfluous, since it simply returns a value</span>
<span class="c1">;; that is ignored by the rest of the expression around it.</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">a1</span> <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">5</span><span class="p">)]</span> <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;i=%d\n&quot;</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)))</span>
<span class="nv">i=0</span>
<span class="nv">i=1</span>
<span class="nv">i=2</span>
<span class="nv">i=3</span>
<span class="nv">i=4</span>
<span class="o">#</span><span class="ss">&#39;user/a1</span>

<span class="c1">;; As mentioned above, doseq always returns nil.</span>
<span class="nv">user=&gt;</span> <span class="nv">a1</span>
<span class="nv">nil</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">user</span> <span class="nv">bad-users</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">comlain</span> <span class="nv">user</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="k">var </span><span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">keys </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s=%s\n&quot;</span> <span class="k">var </span><span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">user</span> <span class="nv">all-users</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">disk-space</span> <span class="p">(</span><span class="nf">get-usage</span> <span class="nv">user</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">disk-space</span> <span class="nv">MAX-QUOTA</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">))))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.shell</span> <span class="ss">:as</span> <span class="nv">shell</span><span class="p">])</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nf">str/split</span> <span class="p">(</span><span class="ss">:out</span> <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;who&quot;</span><span class="p">))</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span><span class="p">)]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">re-find </span><span class="o">#</span><span class="s">&quot;tchrist&quot;</span> <span class="nv">line</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">line</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Unlike in Perl, there is nothing in Clojure similar to the $_ and</span>
<span class="c1">;; @_ default variables for iterating over lines of an input file or</span>
<span class="c1">;; elements of a list.</span>

<span class="c1">;; rdr implements interface java.io.BufferedReader in this example,</span>
<span class="c1">;; and so can be used with line-seq.</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="nv">rdr</span><span class="p">)]</span>
  <span class="c1">;; line-seq is a sequence of strings, one for each line in the input</span>
  <span class="c1">;; file, and they never have a trailing \n</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">word</span> <span class="p">(</span><span class="nf">str/split</span> <span class="nv">line</span> <span class="o">#</span><span class="s">&quot;\s+&quot;</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s&quot;</span> <span class="p">(</span><span class="nf">str/reverse</span> <span class="nv">word</span><span class="p">))))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; In Clojure, every for or doseq has variables that are like Perl&#39;s</span>
<span class="c1">;; &quot;my&quot;, i.e. their scope is local to the body of the loop, and any</span>
<span class="c1">;; value the symbol had outside the loop is not visible inside, and</span>
<span class="c1">;; any change made inside has no affect on the symbol&#39;s value outside</span>
<span class="c1">;; the loop.</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">item</span> <span class="nv">array</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;i = %s\n&quot;</span> <span class="nv">item</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure&#39;s native vectors are immutable, so there is no way to</span>
<span class="c1">;; modify their elements, although it is easy to create new vectors</span>
<span class="c1">;; that are the same as old ones except that a single element has been</span>
<span class="c1">;; replaced with a new one.</span>

<span class="c1">;; This is a clunky way to do it that loops over the elements of the</span>
<span class="c1">;; array explicitly.  Note that we first bind the symbol array to the</span>
<span class="c1">;; value [1 2 3], then to the value returned by the loop expression.</span>
<span class="c1">;; The first value of array is then lost.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
      <span class="nv">array</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">a</span> <span class="nv">array</span>
                   <span class="nv">i</span> <span class="mi">0</span><span class="p">]</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">a</span><span class="p">))</span>
                <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">a</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nf">a</span> <span class="nv">i</span><span class="p">)))</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))</span>
                <span class="nv">a</span><span class="p">))]</span>
  <span class="p">(</span><span class="nb">println </span><span class="nv">array</span><span class="p">))</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>

<span class="c1">;; A much more functional style for doing this is to use map.  Here we</span>
<span class="c1">;; use vec on the result of map to convert the list that is returned</span>
<span class="c1">;; by map, which is different than a vector in Clojure, to a vector</span>
<span class="c1">;; with the same elements.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map dec </span><span class="nv">array</span><span class="p">))]</span>
  <span class="p">(</span><span class="nb">println </span><span class="nv">array</span><span class="p">))</span>

<span class="c1">;; Again, this example achieves a similar effect as the Perl code, but</span>
<span class="c1">;; it does not modify a and b in place -- it creates new values and</span>
<span class="c1">;; assigns those new values to a and b.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">[</span><span class="mf">0.5</span> <span class="mi">3</span><span class="p">]</span>
      <span class="nv">b</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">]</span>
      <span class="nv">a</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="mi">7</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
      <span class="nv">b</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="mi">7</span><span class="p">)</span> <span class="nv">b</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s %s\n&quot;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="p">[</span><span class="mf">3.5</span> <span class="mi">21</span><span class="p">]</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">7</span><span class="p">]</span>

<span class="c1">;; Note that you can use native Java arrays in a straightforward way</span>
<span class="c1">;; from Clojure, and these are mutable data structures, like Java&#39;s</span>
<span class="c1">;; and Perl&#39;s mutable arrays.  Java arrays cannot be grown or shrunk</span>
<span class="c1">;; after creation, except by copying their contents into a new array</span>
<span class="c1">;; and abandoning the old one.</span>

<span class="c1">;; into-array creates a Java array with values initialized to the</span>
<span class="c1">;; elements of a sequence.  If you don&#39;t give an explicit type for the</span>
<span class="c1">;; array elements, they default to the type of the first element of</span>
<span class="c1">;; the sequence.  I&#39;ll create Java arrays of java.lang.Object&#39;s below,</span>
<span class="c1">;; so that the elements can be a mix of different subclasses of</span>
<span class="c1">;; Object.</span>

<span class="c1">;; You can use loop, doseq, or dotimes to iterate over the indices of</span>
<span class="c1">;; the array.</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">into-array </span><span class="nv">Object</span> <span class="p">[</span><span class="mf">0.5</span> <span class="mi">3</span><span class="p">])</span>
      <span class="nv">b</span> <span class="p">(</span><span class="nb">into-array </span><span class="nv">Object</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">])]</span>
  <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">alength </span><span class="nv">a</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">aset </span><span class="nv">a</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">aget </span><span class="nv">a</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">7</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">alength </span><span class="nv">b</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">aset </span><span class="nv">b</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">aget </span><span class="nv">b</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">7</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s %s\n&quot;</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">b</span><span class="p">)))</span>  <span class="c1">; seq used to create sequence</span>
                                       <span class="c1">; of values in arrays a and b</span>
<span class="p">(</span><span class="mf">3.5</span> <span class="mi">21</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">7</span><span class="p">)</span>

<span class="c1">;; Clojure&#39;s amap creates new Java arrays, by copying the given one,</span>
<span class="c1">;; then iterating over its elements and replacing each one with the</span>
<span class="c1">;; result of evaluating a given expression.</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">into-array </span><span class="nv">Object</span> <span class="p">[</span><span class="mf">0.5</span> <span class="mi">3</span><span class="p">])</span>
      <span class="nv">b</span> <span class="p">(</span><span class="nb">into-array </span><span class="nv">Object</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">])</span>
      <span class="nv">a</span> <span class="p">(</span><span class="nf">amap</span> <span class="nv">a</span> <span class="nv">i</span> <span class="nv">temp</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">aget </span><span class="nv">a</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">7</span><span class="p">))</span>
      <span class="nv">b</span> <span class="p">(</span><span class="nf">amap</span> <span class="nv">b</span> <span class="nv">i</span> <span class="nv">temp</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">aget </span><span class="nv">b</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">7</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s %s\n&quot;</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">b</span><span class="p">)))</span>
<span class="p">(</span><span class="mf">3.5</span> <span class="mi">21</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; Because Clojure doesn&#39;t provide a way to modify its collections in</span>
<span class="c1">;; place, but instead encourages you to create new versions of</span>
<span class="c1">;; existing data structures, it doesn&#39;t really provide a way to</span>
<span class="c1">;; iterate over several different collections in a single loop.</span>

<span class="c1">;; clojure.string/trim returns a string the same as the string you</span>
<span class="c1">;; give it, except with white space at the beginning and end removed.</span>

<span class="c1">;; do-to-map was written by Brian Carper, and he also wrote the</span>
<span class="c1">;; explanation for how it works that I have copied below.  Original</span>
<span class="c1">;; source is at the following URL:</span>

<span class="c1">;; http://stackoverflow.com/questions/1638854/clojure-how-do-i-apply-a-function-to-a-subset-of-the-entries-in-a-hash-map</span>

<span class="c1">;; It helps to look at it inside-out.  In Clojure, hash-maps act like</span>
<span class="c1">;; functions; if you call them like a function with a key as an</span>
<span class="c1">;; argument, the value associated with that key is returned.  So given</span>
<span class="c1">;; a single key, the current value for that key can be obtained via:</span>

<span class="c1">;; (some-map some-key)</span>

<span class="c1">;; We want to take old values, and change them to new values by</span>
<span class="c1">;; calling some function f on them.  So given a single key, the new</span>
<span class="c1">;; value will be:</span>

<span class="c1">;; (f (some-map some-key))</span>

<span class="c1">;; We want to associate this new value with this key in our hash-map,</span>
<span class="c1">;; &quot;replacing&quot; the old value.  This is what assoc does:</span>

<span class="c1">;; (assoc some-map some-key (f (some-map some-key)))</span>

<span class="c1">;; (&quot;Replace&quot; is in scare-quotes because we&#39;re not mutating a single</span>
<span class="c1">;; hash-map object; we&#39;re returning new, immutable, altered hash-map</span>
<span class="c1">;; objects each time we call assoc.  This is still fast and efficient</span>
<span class="c1">;; in Clojure because hash-maps are persistent and share structure</span>
<span class="c1">;; when you assoc them.)</span>

<span class="c1">;; We need to repeatedly assoc new values onto our map, one key at a</span>
<span class="c1">;; time.  So we need some kind of looping construct.  What we want is</span>
<span class="c1">;; to start with our original hash-map and a single key, and then</span>
<span class="c1">;; &quot;update&quot; the value for that key.  Then we take that new hash-map</span>
<span class="c1">;; and the next key, and &quot;update&quot; the value for that next key.  And we</span>
<span class="c1">;; repeat this for every key, one at a time, and finally return the</span>
<span class="c1">;; hash-map we&#39;ve &quot;accumulated&quot;.  This is what reduce does.</span>

<span class="c1">;; * The first argument to reduce is a function that takes two</span>
<span class="c1">;;   arguments: an &quot;accumulator&quot; value, which is the value we keep</span>
<span class="c1">;;   &quot;updating&quot; over and over; and a single argument used in one</span>
<span class="c1">;;   iteration to do some of the accumulating.</span>
<span class="c1">;; * The second argument to reduce is the initial value passed as the</span>
<span class="c1">;;   first argument to this fn.</span>
<span class="c1">;; * The third argument to reduce is a collection of arguments to be</span>
<span class="c1">;;   passed as the second argument to this fn, one at a time.</span>

<span class="c1">;; So:</span>

<span class="c1">;; (reduce fn-to-update-values-in-our-map</span>
<span class="c1">;;         initial-value-of-our-map</span>
<span class="c1">;;         collection-of-keys)</span>

<span class="c1">;; fn-to-update-values-in-our-map is just the assoc statement from</span>
<span class="c1">;; above, wrapped in an anonymous function:</span>

<span class="c1">;; (fn [map-so-far some-key]</span>
<span class="c1">;;   (assoc map-so-far some-key (f (map-so-far some-key))))</span>

<span class="c1">;; So plugging it into reduce:</span>

<span class="c1">;; (reduce (fn [map-so-far some-key]</span>
<span class="c1">;;           (assoc map-so-far some-key (f (map-so-far some-key))))</span>
<span class="c1">;;         amap</span>
<span class="c1">;;         keyseq)</span>

<span class="c1">;; In Clojure, there&#39;s a shorthand for writing anonymous functions:</span>
<span class="c1">;; #(...) is an anonymous fn consisting of a single form, in which %1</span>
<span class="c1">;; is bound to the first argument to the anonymous function, %2 to the</span>
<span class="c1">;; second, etc.  So our fn from above can be written equivalently as:</span>

<span class="c1">;; #(assoc %1 %2 (f (%1 %2)))</span>

<span class="c1">;; This gives us:</span>

<span class="c1">;; (reduce #(assoc %1 %2 (f (%1 %2))) amap keyseq)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">do-to-map</span> <span class="p">[</span><span class="nv">amap</span> <span class="nv">keyseq</span> <span class="nv">f</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">%1</span> <span class="nv">%2</span><span class="p">)))</span> <span class="nv">amap</span> <span class="nv">keyseq</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">scalar</span> <span class="p">(</span><span class="nf">str/trim</span> <span class="nv">scalar</span><span class="p">)</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="nv">str/trim</span> <span class="nv">array</span><span class="p">))</span> <span class="c1">; skip the vec if a list result is OK</span>
      <span class="nv">hash</span> <span class="p">(</span><span class="nf">do-to-map</span> <span class="nv">hash</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">hash</span><span class="p">)</span> <span class="nv">str/trim</span><span class="p">)]</span>
  <span class="p">)</span>

<span class="c1">;;-----------------------------</span>
<span class="c1">;; No foreach/for synonym in Clojure.  I believe the existing common</span>
<span class="c1">;; alternatives are all mentioned above.</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.5 Iterating Over an Array by Reference</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure does not have Perl&#39;s distinction between an array and an</span>
<span class="c1">;; array ref.  Clojure lists, vectors, maps, etc. can all contain</span>
<span class="c1">;; instances of each other as values, and in maps any of these data</span>
<span class="c1">;; structures can be used as keys, too.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">fruits</span> <span class="p">[</span> <span class="s">&quot;Apple&quot;</span> <span class="s">&quot;Blackberry&quot;</span> <span class="p">])</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">fruit</span> <span class="nv">fruits</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s tastes good in a pie.\n&quot;</span> <span class="nv">fruit</span><span class="p">))</span>
<span class="nv">Apple</span> <span class="nv">tastes</span> <span class="nv">good</span> <span class="nv">in</span> <span class="nv">a</span> <span class="nv">pie.</span>
<span class="nv">Blackberry</span> <span class="nv">tastes</span> <span class="nv">good</span> <span class="nv">in</span> <span class="nv">a</span> <span class="nv">pie.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">fruits</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s tastes good in a pie.\n&quot;</span> <span class="p">(</span><span class="nf">fruits</span> <span class="nv">i</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">namelist</span> <span class="p">{</span> <span class="p">})</span>
<span class="p">(</span><span class="k">def </span><span class="nv">rogue-cats</span> <span class="p">[</span> <span class="s">&quot;YellowFang&quot;</span> <span class="s">&quot;BrokenTail&quot;</span> <span class="s">&quot;Clawface&quot;</span> <span class="p">])</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">namelist</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">namelist</span> <span class="ss">:felines</span> <span class="nv">rogue-cats</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">cat</span> <span class="p">(</span><span class="nf">namelist</span> <span class="ss">:felines</span><span class="p">)]</span>   <span class="c1">; (:felines namelist) gives same result</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s purrs hypnotically..\n&quot;</span> <span class="nv">cat</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;--More--\nYou are controlled.\n&quot;</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">namelist</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">namelist</span> <span class="ss">:felines</span> <span class="nv">rogue-cats</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nf">namelist</span> <span class="ss">:felines</span><span class="p">))]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s purrs hypnotically..\n&quot;</span> <span class="p">((</span><span class="nf">namelist</span> <span class="ss">:felines</span><span class="p">)</span> <span class="nv">i</span><span class="p">))))</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.6 Extracting Unique Elements from a List</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Iterative style -- requires a fair amount of verbiage.</span>
<span class="c1">;; TBD: My use of seq/first/rest might be nonstandard here.  Is it</span>
<span class="c1">;; correct for all cases?  If not, what case causes it to break?</span>
<span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">seen</span> <span class="p">{}</span>
       <span class="nv">uniq</span> <span class="p">[]</span>
       <span class="nv">l</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">list</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">item</span> <span class="p">(</span><span class="nb">first </span><span class="nv">l</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">seen</span> <span class="nv">item</span><span class="p">))</span>   <span class="c1">;; (seen item) is nil if item is not a key</span>
                            <span class="c1">;; in the map seen, and nil is treated as false</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">seen</span> <span class="nv">item</span> <span class="mi">1</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">conj </span><span class="nv">uniq</span> <span class="nv">item</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">rest </span><span class="nv">l</span><span class="p">))</span>
      <span class="c1">;; else</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="nv">seen</span> <span class="nv">uniq</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">l</span><span class="p">)))</span>
    <span class="c1">;; return a final value from loop statement here, perhaps seen and</span>
    <span class="c1">;; uniq</span>
    <span class="p">))</span>

<span class="c1">;; Functional style.  If reduce call is confusing, try first reading</span>
<span class="c1">;; explanation of do-to-map above.  This is a bit simpler than that.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span> <span class="nv">list</span><span class="p">)</span>
      <span class="nv">uniq</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">seen</span><span class="p">))]</span>   <span class="c1">; leave out vec if a list is good enough</span>
  <span class="c1">;; use seen and/or uniq here</span>
  <span class="p">)</span>

<span class="c1">;; Clojure also has sets as a built-in data structure.  They make it</span>
<span class="c1">;; easy to find unique items in a collection.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">uniq</span> <span class="p">(</span><span class="nb">set </span><span class="nv">list</span><span class="p">)]</span>    <span class="c1">; use (vec (set list)) if you want a vector instead</span>
  <span class="c1">;; use uniq here</span>
  <span class="p">)</span>

<span class="c1">;;-----------------------------</span>
<span class="c1">;; This is nearly the same as functional style above, except this time</span>
<span class="c1">;; we want to count occurrences of items.</span>

<span class="c1">;; First we&#39;ll define a tiny helper function to increment the entry.</span>
<span class="c1">;; In Perl, if you increment an undefined entry in a hash, it treats</span>
<span class="c1">;; it as a 0 and increments it to 1.  In Clojure, trying to do (inc</span>
<span class="c1">;; nil) throws an exception.  What we want is a function that when</span>
<span class="c1">;; given nil, returns 1, and when given a number, increments it.</span>
<span class="c1">;; We&#39;ll call it incn.  Clojure evaluates all values except false and</span>
<span class="c1">;; nil as true, when the value is used as the test in an if</span>
<span class="c1">;; expression.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">incn</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">x</span>
    <span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">)</span>
    <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="p">(</span><span class="nf">incn</span> <span class="p">(</span><span class="nf">%1</span> <span class="nv">%2</span><span class="p">)))</span>
                   <span class="p">{}</span> <span class="nv">list</span><span class="p">)</span>
      <span class="nv">uniq</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">seen</span><span class="p">))]</span>   <span class="c1">; leave out vec if a list is good enough</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; fnil can help us in cases like the above, when we want a function</span>
<span class="c1">;; like inc, except it doesn&#39;t work when passed nil.  (fnil f</span>
<span class="c1">;; default-input) returns a function that works just like f does,</span>
<span class="c1">;; except when it is given an argument of nil, it evaluates (f</span>
<span class="c1">;; default-input) instead.  So incn above is the same as (fnil inc 0).</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="p">((</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">%1</span> <span class="nv">%2</span><span class="p">)))</span>
                   <span class="p">{}</span> <span class="nv">list</span><span class="p">)</span>
      <span class="nv">uniq</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">seen</span><span class="p">))]</span>   <span class="c1">; leave out vec if a list is good enough</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; This expression (assoc map key (f (map key))) is so common that</span>
<span class="c1">;; there is a function update-in that can shorten it a bit, as</span>
<span class="c1">;; (update-in map [key] f).  It can also help update nested maps</span>
<span class="c1">;; within maps, but we won&#39;t use it for that until later.  This</span>
<span class="c1">;; generality is the reason that it takes a vector of key values,</span>
<span class="c1">;; instead of only a single key value, and that is why the [] are</span>
<span class="c1">;; there around key in the call to update-in.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nf">update-in</span> <span class="nv">%1</span> <span class="p">[</span><span class="nv">%2</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">))</span>
                   <span class="p">{}</span> <span class="nv">list</span><span class="p">)</span>
      <span class="nv">uniq</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">seen</span><span class="p">))]</span>   <span class="c1">; leave out vec if a list is good enough</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;seen=&#39;%s&#39;\n&quot;</span> <span class="nv">seen</span><span class="p">)</span>
  <span class="p">)</span>

<span class="c1">;;-----------------------------</span>
<span class="c1">;; Here we call function (some-func item) the first time a new item is</span>
<span class="c1">;; encountered in the sequence &#39;list&#39;, but never if it is seen a 2nd</span>
<span class="c1">;; or larger time later in the list.  This function is presumably</span>
<span class="c1">;; called for its side effects, since there is no return value being</span>
<span class="c1">;; used.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">n</span> <span class="p">(</span><span class="nf">%1</span> <span class="nv">%2</span><span class="p">)]</span>
                                   <span class="p">(</span><span class="nb">inc </span><span class="nv">n</span><span class="p">)</span>
                                   <span class="p">(</span><span class="nf">do</span>
                                     <span class="p">(</span><span class="nf">some-func</span> <span class="nv">%2</span><span class="p">)</span>
                                     <span class="mi">1</span><span class="p">)))</span>
                   <span class="p">{}</span> <span class="nv">list</span><span class="p">)]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Here the Perl version is closer to the functional style examples</span>
<span class="c1">;; given above.  No reason to repeat the Clojure code for them here.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The Perl code here is very much like a functional style, except its</span>
<span class="c1">;; condition mutates the hash &#39;seen&#39;.  I&#39;m not going to try to write a</span>
<span class="c1">;; Clojure version that emulates this, since to match its behavior</span>
<span class="c1">;; closely would require using a mutable Java hash table.</span>

<span class="c1">;; %seen = ();</span>
<span class="c1">;; @uniqu = grep { ! $seen{$_} ++ } @list;</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Here is a functional style version of the Perl code.  Let&#39;s make a</span>
<span class="c1">;; function &#39;tally&#39; to create a map of occurrence counts of items in a</span>
<span class="c1">;; collection.</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">])</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.shell</span> <span class="ss">:as</span> <span class="nv">shell</span><span class="p">])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">tally</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nf">update-in</span> <span class="nv">%1</span> <span class="p">[</span><span class="nv">%2</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">))</span>
          <span class="p">{}</span> <span class="nv">coll</span><span class="p">))</span>

<span class="c1">;; Note that we use the regex #&quot;\s.*$&quot; as opposed to the one #&quot;\s.*\n&quot;</span>
<span class="c1">;; in Perl, because the strings in the sequence lines do not have \n</span>
<span class="c1">;; at the end of each one.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">lines</span> <span class="p">(</span><span class="nf">str/split</span> <span class="p">(</span><span class="ss">:out</span> <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;who&quot;</span><span class="p">))</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span><span class="p">)</span>
      <span class="nv">usernames</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">str/replace-first</span> <span class="nv">%</span> <span class="o">#</span><span class="s">&quot;\s.*$&quot;</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="nv">lines</span><span class="p">)</span>
      <span class="nv">ucnt</span> <span class="p">(</span><span class="nf">tally</span> <span class="nv">usernames</span><span class="p">)</span>
      <span class="nv">users</span> <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">keys </span><span class="nv">ucnt</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;users logged in: %s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">users</span><span class="p">)))</span>

<span class="c1">;; If the count of how many times each username occurred is not</span>
<span class="c1">;; important, just the unique ones, then Clojure sets are more</span>
<span class="c1">;; straightforward.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">lines</span> <span class="p">(</span><span class="nf">str/split</span> <span class="p">(</span><span class="ss">:out</span> <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;who&quot;</span><span class="p">))</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span><span class="p">)</span>
      <span class="nv">usernames</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">str/replace-first</span> <span class="nv">%</span> <span class="o">#</span><span class="s">&quot;\s.*$&quot;</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="nv">lines</span><span class="p">)</span>
      <span class="nv">users</span> <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">set </span><span class="nv">usernames</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;users logged in: %s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">users</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.7 Finding Elements in One Array but Not Another</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; First we&#39;ll do it in a similar style to the Perl version.</span>
<span class="c1">;; seen is a map, and we produce a vector aonly.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">A</span> <span class="p">[</span><span class="s">&quot;a&quot;</span> <span class="s">&quot;b&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;d&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;b&quot;</span> <span class="s">&quot;a&quot;</span> <span class="s">&quot;e&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">B</span> <span class="p">[</span><span class="s">&quot;b&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;d&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;b&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span> <span class="nv">B</span><span class="p">)</span>
      <span class="nv">aonly</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">seen</span> <span class="nv">%</span><span class="p">))</span> <span class="nv">A</span><span class="p">))]</span>  <span class="c1">; no vec, if vector not needed</span>
 <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">aonly</span><span class="p">)))</span>
<span class="nv">a</span> <span class="nv">a</span> <span class="nv">e</span>

<span class="c1">;; Then we&#39;ll use Clojure sets to simplify it.</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.set</span> <span class="ss">:as</span> <span class="nv">set</span><span class="p">])</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">seen</span> <span class="p">(</span><span class="nb">set </span><span class="nv">B</span><span class="p">)</span>
      <span class="nv">aonly</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">seen</span> <span class="nv">%</span><span class="p">))</span> <span class="nv">A</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">aonly</span><span class="p">)))</span>
<span class="nv">a</span> <span class="nv">a</span> <span class="nv">e</span>

<span class="c1">;; We can simplify even further if aonly can be a set of unique</span>
<span class="c1">;; elements in A that are not also in B, and the order of the elements</span>
<span class="c1">;; does not matter.  Note that the original Perl code contains</span>
<span class="c1">;; elements of A not also in B in the same order as they occur in A,</span>
<span class="c1">;; and if there are duplicates of such elements in A, they will also</span>
<span class="c1">;; be duplicated in aonly.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">aonly</span> <span class="p">(</span><span class="nf">set/difference</span> <span class="p">(</span><span class="nb">set </span><span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nb">set </span><span class="nv">B</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">aonly</span><span class="p">)))</span>
<span class="nv">a</span> <span class="nv">e</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; I can&#39;t think of any direct correspondence in Clojure of the Perl</span>
<span class="c1">;; techniques used in this code.  The Clojure set examples above are</span>
<span class="c1">;; quite concise.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; This version has a different behavior than the previous one.  It</span>
<span class="c1">;; adds an item to @aonly at most one time, without duplicates, but</span>
<span class="c1">;; the order is the same as the order the items appear in A.</span>

<span class="c1">;; If order does not matter, then the set/difference example above is</span>
<span class="c1">;; shorter and clearer.</span>

<span class="c1">;; If order in aonly does matter, then here is one way to do it.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">aonly</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">aonly</span> <span class="p">[]</span>
                   <span class="nv">s</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">A</span><span class="p">)</span>
                   <span class="nv">seen</span> <span class="o">#</span><span class="p">{}]</span>  <span class="c1">; If we want to use a previously calculated</span>
                              <span class="c1">; set in seen, replace #{} with seen.</span>
              <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">item</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">)]</span>
                <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">seen</span> <span class="nv">item</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">recur</span> <span class="nv">aonly</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">)</span> <span class="nv">seen</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">aonly</span> <span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">seen</span> <span class="nv">item</span><span class="p">)))</span>
                <span class="nv">aonly</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">aonly</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">hash</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">hash</span> <span class="s">&quot;key1&quot;</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nv">hash</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">hash</span> <span class="s">&quot;key2&quot;</span> <span class="mi">2</span><span class="p">)]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">hash</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">hash</span> <span class="s">&quot;key1&quot;</span> <span class="mi">1</span> <span class="s">&quot;key2&quot;</span> <span class="mi">2</span><span class="p">)]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; TBD: What does this Perl code do?</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; TBD: What does this Perl code do?</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.8 Computing Union, Intersection, or Difference of Unique Lists</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">])</span>
<span class="c1">;; All initializations of union, isect, diff will be done in each</span>
<span class="c1">;; example below.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; This time I&#39;ll do it using Clojure sets first.</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.set</span> <span class="ss">:as</span> <span class="nv">set</span><span class="p">])</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">set-a</span> <span class="p">(</span><span class="nb">set </span><span class="nv">a</span><span class="p">)</span>   <span class="c1">; if a is a non-set collection, create one</span>
      <span class="nv">set-b</span> <span class="p">(</span><span class="nb">set </span><span class="nv">b</span><span class="p">)</span>
      <span class="nb">union </span><span class="p">(</span><span class="nf">set/union</span> <span class="nv">set-a</span> <span class="nv">set-b</span><span class="p">)</span>
      <span class="nv">isect</span> <span class="p">(</span><span class="nf">set/intersection</span> <span class="nv">set-a</span> <span class="nv">set-b</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">)))</span>
<span class="nv">union=1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
<span class="nv">isect=3</span> <span class="mi">5</span> <span class="mi">7</span>

<span class="c1">;; Now a way more like the style of the Perl examples.</span>
<span class="c1">;;</span>
<span class="c1">;; Warning: The Perl code has a bug, if the input array b contains</span>
<span class="c1">;; duplicates.  In this case, the duplicate elements in b will become</span>
<span class="c1">;; part of isect, even if the elements are not also in a.  The code</span>
<span class="c1">;; below emulates this behavior of the Perl examples.  The code using</span>
<span class="c1">;; Clojure sets above does not.</span>
<span class="c1">;;</span>
<span class="c1">;; To see this behavior, try out the code below with these values for</span>
<span class="c1">;; a and b:</span>
<span class="c1">;;</span>
<span class="c1">;; (def a [1 3 5 6 7 8])</span>
<span class="c1">;; (def b [2 3 5 7 9 2])  ; 2 is duplicated, and will appear in isect</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">union </span><span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span> <span class="nv">a</span><span class="p">)</span>
      <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span><span class="p">]</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nb">union </span><span class="nv">union</span>
                           <span class="nv">isect</span> <span class="p">{}</span>
                           <span class="nv">s</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">b</span><span class="p">)]</span>
                      <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">e</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">)]</span>
                        <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">assoc union </span><span class="nv">e</span> <span class="mi">1</span><span class="p">)</span>
                               <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">union </span><span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">isect</span> <span class="nv">e</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">isect</span><span class="p">)</span>
                               <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">))</span>
                        <span class="c1">;; return a vector of 2 values from the loop</span>
                        <span class="c1">;; expression, which will be bound to union</span>
                        <span class="c1">;; and isect in the outer let expression.</span>
                        <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span><span class="p">]))</span>
      <span class="c1">;; Note that unlike Perl, the map called union becomes</span>
      <span class="c1">;; inaccessible after the following line.  Give the map and</span>
      <span class="c1">;; sequence different names if you want them both accessible</span>
      <span class="c1">;; later.</span>
      <span class="nb">union </span><span class="p">(</span><span class="nb">keys </span><span class="nv">union</span><span class="p">)</span>
      <span class="nv">isect</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">isect</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">)))</span>
<span class="nv">union=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="nv">isect=7</span> <span class="mi">5</span> <span class="mi">3</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The only way I know to write Clojure code that closely emulates</span>
<span class="c1">;; this Perl example is to use thread-local mutable variables,</span>
<span class="c1">;; introduced using with-local-vars.  These require using var-set to</span>
<span class="c1">;; change the value, and var-get to examine the value, which is a bit</span>
<span class="c1">;; clunky.  (var-get union) can be abbreviated @union, which helps</span>
<span class="c1">;; somewhat.  If you really want to write something in imperative</span>
<span class="c1">;; style, with-local-vars may be your best bet.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nb">union </span><span class="nv">isect</span><span class="p">]</span>
      <span class="p">(</span><span class="nb">with-local-vars </span><span class="p">[</span><span class="nb">union </span><span class="p">{}</span>
                        <span class="nv">isect</span> <span class="p">{}]</span>
        <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">e</span> <span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nb">concat </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))]</span>
          <span class="c1">;; The next let statement behaves as Perl&#39;s $union{$e}++,</span>
          <span class="c1">;; incrementing $union{$e}, but returning the value of</span>
          <span class="c1">;; $union{$e} before the increment occurs.  This is nil in</span>
          <span class="c1">;; Clojure rather than Perl&#39;s undef, but both evaluate to</span>
          <span class="c1">;; false by Clojure &#39;and&#39; or Perl &amp;&amp;.</span>
          <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">in-union</span> <span class="p">(</span><span class="o">@</span><span class="nb">union </span><span class="nv">e</span><span class="p">)]</span>
                 <span class="p">(</span><span class="nb">var-set union </span><span class="p">(</span><span class="nf">update-in</span> <span class="o">@</span><span class="nb">union </span><span class="p">[</span><span class="nv">e</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">)))</span>
                 <span class="nv">in-union</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">var-set </span><span class="nv">isect</span> <span class="p">(</span><span class="nf">update-in</span> <span class="o">@</span><span class="nv">isect</span> <span class="p">[</span><span class="nv">e</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">)))))</span>
        <span class="p">[</span><span class="o">@</span><span class="nb">union </span><span class="o">@</span><span class="nv">isect</span><span class="p">])</span>
      <span class="nb">union </span><span class="p">(</span><span class="nb">keys </span><span class="nv">union</span><span class="p">)</span>
      <span class="nv">isect</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">isect</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">)))</span>
<span class="nv">union=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="nv">isect=7</span> <span class="mi">5</span> <span class="mi">3</span>

<span class="c1">;; The example using set/union and set/difference is really the best</span>
<span class="c1">;; way to go in Clojure, though.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; First the clojure.set way:</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">set-a</span> <span class="p">(</span><span class="nb">set </span><span class="nv">a</span><span class="p">)</span>
      <span class="nv">set-b</span> <span class="p">(</span><span class="nb">set </span><span class="nv">b</span><span class="p">)</span>
      <span class="nb">union </span><span class="p">(</span><span class="nf">set/union</span> <span class="nv">set-a</span> <span class="nv">set-b</span><span class="p">)</span>
      <span class="nv">isect</span> <span class="p">(</span><span class="nf">set/intersection</span> <span class="nv">set-a</span> <span class="nv">set-b</span><span class="p">)</span>
      <span class="nv">diff</span> <span class="p">(</span><span class="nf">set/difference</span> <span class="nb">union </span><span class="nv">isect</span><span class="p">)</span>
      <span class="c1">;; Or, if you want to find the &#39;symmetric difference&#39; without</span>
      <span class="c1">;; explicitly calculation the union and intersection first,</span>
      <span class="c1">;; another way is:</span>
      <span class="c1">;; diff (set/union (set/difference set-a set-b)</span>
      <span class="c1">;;                 (set/difference set-b set-a))</span>
      <span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;diff=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">diff</span><span class="p">)))</span>
<span class="nv">union=1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>
<span class="nv">isect=3</span> <span class="mi">5</span> <span class="mi">7</span>
<span class="nv">diff=1</span> <span class="mi">2</span> <span class="mi">6</span> <span class="mi">8</span> <span class="mi">9</span>

<span class="c1">;; Next a way closer to the Perl code, but without with-local-vars.</span>
<span class="c1">;; Function tally copied from an earlier example, repeated for easier</span>
<span class="c1">;; reference.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">tally</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nf">update-in</span> <span class="nv">%1</span> <span class="p">[</span><span class="nv">%2</span><span class="p">]</span> <span class="p">(</span><span class="nf">fnil</span> <span class="nb">inc </span><span class="mi">0</span><span class="p">))</span>
          <span class="p">{}</span> <span class="nv">coll</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">count </span><span class="p">(</span><span class="nf">tally</span> <span class="p">(</span><span class="nb">concat </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
      <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span> <span class="nv">diff</span><span class="p">]</span>
      <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nb">union </span><span class="p">[]</span>
             <span class="nv">isect</span> <span class="p">[]</span>
             <span class="nv">diff</span> <span class="p">[]</span>
             <span class="nv">s</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">count</span><span class="p">)]</span>
        <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">e</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">)]</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">== </span><span class="p">(</span><span class="nb">count </span><span class="nv">e</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj union </span><span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">isect</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">diff</span>          <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj union </span><span class="nv">e</span><span class="p">)</span> <span class="nv">isect</span>          <span class="p">(</span><span class="nb">conj </span><span class="nv">diff</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">)))</span>
          <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span> <span class="nv">diff</span><span class="p">]))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;diff=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">diff</span><span class="p">)))</span>
<span class="nv">union=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="nv">isect=7</span> <span class="mi">5</span> <span class="mi">3</span>
<span class="nv">diff=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">6</span> <span class="mi">1</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; A similar trick as used in the Perl example can be made to work</span>
<span class="c1">;; with Clojure local mutable vars, if you really want to do it.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">count </span><span class="p">(</span><span class="nf">tally</span> <span class="p">(</span><span class="nb">concat </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
      <span class="p">[</span><span class="nb">union </span><span class="nv">isect</span> <span class="nv">diff</span><span class="p">]</span>
      <span class="p">(</span><span class="nb">with-local-vars </span><span class="p">[</span><span class="nb">union </span><span class="p">[]</span>
                        <span class="nv">isect</span> <span class="p">[]</span>
                        <span class="nv">diff</span> <span class="p">[]]</span>
        <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">e</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">count</span><span class="p">)]</span>
          <span class="p">(</span><span class="nb">var-set union </span><span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">var-get </span><span class="nv">union</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
          <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">target</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">== </span><span class="p">(</span><span class="nb">count </span><span class="nv">e</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">isect</span> <span class="nv">diff</span><span class="p">)]</span>
            <span class="p">(</span><span class="nb">var-set </span><span class="nv">target</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">var-get </span><span class="nv">target</span><span class="p">)</span> <span class="nv">e</span><span class="p">))))</span>
        <span class="p">[(</span><span class="nb">var-get </span><span class="nv">union</span><span class="p">)</span> <span class="p">(</span><span class="nb">var-get </span><span class="nv">isect</span><span class="p">)</span> <span class="p">(</span><span class="nb">var-get </span><span class="nv">diff</span><span class="p">)])]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;union=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">union</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;isect=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">isect</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;diff=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">diff</span><span class="p">)))</span>
<span class="nv">union=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="nv">isect=7</span> <span class="mi">5</span> <span class="mi">3</span>
<span class="nv">diff=9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">6</span> <span class="mi">1</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.9 Appending One Array to Another</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; No vec call needed if the result can be a list.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ARRAY1</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="nv">ARRAY1</span> <span class="nv">ARRAY2</span><span class="p">))]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; I don&#39;t know of any Clojure code that looks like that in the Perl</span>
<span class="c1">;; example for combining two lists.  The example above using concat</span>
<span class="c1">;; will do the job.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">members</span> <span class="p">[</span><span class="s">&quot;Time&quot;</span> <span class="s">&quot;Flies&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">initiates</span> <span class="p">[</span><span class="s">&quot;An&quot;</span> <span class="s">&quot;Arrow&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">members</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="nv">members</span> <span class="nv">initiates</span><span class="p">))]</span>
  <span class="c1">;; members is now [&quot;Time&quot; &quot;Flies&quot; &quot;An&quot; &quot;Arrow&quot;]</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure data structures are immutable, so we can&#39;t write a splice</span>
<span class="c1">;; function that modifies these data structures, but we can write a</span>
<span class="c1">;; split that will return a new data structure that is similar in its</span>
<span class="c1">;; value to the Perl one, after splice modifies it.</span>

<span class="c1">;; First, we&#39;ll write a simpler version that only works with an offset</span>
<span class="c1">;; in the range [0, n] where n is the length of the vector, and a</span>
<span class="c1">;; non-negative length such that offset+length is also in the range</span>
<span class="c1">;; [0,n].</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">splice</span> <span class="p">[</span><span class="nv">v</span> <span class="nv">offset</span> <span class="nv">length</span> <span class="nv">coll-to-insert</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="nv">offset</span><span class="p">)</span>
               <span class="nv">coll-to-insert</span>
               <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">offset</span> <span class="nv">length</span><span class="p">)))))</span>

<span class="c1">;; Since the example below uses a splice with negative offset, I&#39;ll go</span>
<span class="c1">;; ahead and give what I think is a full implementation of all cases</span>
<span class="c1">;; of positive, 0, or negaitve arguments to Perl&#39;s splice (and also</span>
<span class="c1">;; substr) for offset and length.  This helper function converts Perl</span>
<span class="c1">;; offset and length arguments to Clojure start and end arguments for</span>
<span class="c1">;; subvec (and also subs).  It is a bit of a mess because of all of</span>
<span class="c1">;; the conditions to check.  There is likely code much like this</span>
<span class="c1">;; buried inside of Perl&#39;s implementation of subs and splice.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">ps-start-end</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">offset</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">offset</span><span class="p">)</span> <span class="p">[(</span><span class="nb">max </span><span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="nv">offset</span><span class="p">))</span> <span class="nv">n</span><span class="p">]</span>
           <span class="p">(</span><span class="nb">&gt; </span><span class="nv">offset</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">nil</span>
           <span class="ss">:else</span> <span class="p">[</span><span class="nv">offset</span> <span class="nv">n</span><span class="p">]))</span>
  <span class="p">([</span><span class="nv">n</span> <span class="nv">offset</span> <span class="nv">c</span><span class="p">]</span>
     <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">start</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">offset</span><span class="p">)</span>
                   <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="nv">offset</span><span class="p">)</span>
                   <span class="nv">offset</span><span class="p">)</span>
           <span class="nv">end</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">c</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="nv">c</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">+ </span><span class="nv">start</span> <span class="nv">c</span><span class="p">))]</span>
       <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">start</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">end</span><span class="p">)</span>
                            <span class="nv">nil</span>
                            <span class="p">[</span><span class="mi">0</span> <span class="p">(</span><span class="nb">min </span><span class="nv">n</span> <span class="nv">end</span><span class="p">)])</span>
             <span class="p">(</span><span class="nb">&gt; </span><span class="nv">start</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">nil</span>
             <span class="ss">:else</span> <span class="p">[</span><span class="nv">start</span> <span class="p">(</span><span class="nb">min </span><span class="nv">n</span> <span class="p">(</span><span class="nb">max </span><span class="nv">start</span> <span class="nv">end</span><span class="p">))]))))</span>

<span class="c1">;; Here we implement splice that takes a vector and either just an</span>
<span class="c1">;; offset, an offset and a length, or offset, length, and collection</span>
<span class="c1">;; of items to splice in.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">splice-helper</span> <span class="p">[</span><span class="nv">v</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">coll-to-insert</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="nv">start</span><span class="p">)</span>
               <span class="nv">coll-to-insert</span>
               <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="nv">end</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">splice</span>
  <span class="p">([</span><span class="nv">v</span> <span class="nv">offset</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">when-let </span><span class="p">[[</span><span class="nv">start</span> <span class="nv">end</span><span class="p">]</span> <span class="p">(</span><span class="nf">ps-start-end</span> <span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span> <span class="nv">offset</span><span class="p">)]</span>
       <span class="p">(</span><span class="nf">splice-helper</span> <span class="nv">v</span> <span class="nv">start</span> <span class="nv">end</span> <span class="p">[])))</span>
  <span class="p">([</span><span class="nv">v</span> <span class="nv">offset</span> <span class="nv">length</span><span class="p">]</span>
     <span class="p">(</span><span class="nf">splice</span> <span class="nv">v</span> <span class="nv">offset</span> <span class="nv">length</span> <span class="p">[]))</span>
  <span class="p">([</span><span class="nv">v</span> <span class="nv">offset</span> <span class="nv">length</span> <span class="nv">coll-to-insert</span><span class="p">]</span>
     <span class="p">(</span><span class="nb">when-let </span><span class="p">[[</span><span class="nv">start</span> <span class="nv">end</span><span class="p">]</span> <span class="p">(</span><span class="nf">ps-start-end</span> <span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span> <span class="nv">offset</span> <span class="nv">length</span><span class="p">)]</span>
       <span class="p">(</span><span class="nf">splice-helper</span> <span class="nv">v</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">coll-to-insert</span><span class="p">))))</span>


<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">members</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">members</span> <span class="mi">2</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;Like&quot;</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">initiates</span><span class="p">)))</span>
      <span class="nv">_</span> <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">members</span><span class="p">))</span>
      <span class="nv">members</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">members</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">[</span><span class="s">&quot;Fruit&quot;</span><span class="p">])</span>
      <span class="nv">members</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">members</span> <span class="mi">-2</span> <span class="mi">2</span> <span class="p">[</span><span class="s">&quot;A&quot;</span> <span class="s">&quot;Banana&quot;</span><span class="p">])</span>
      <span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">members</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="nv">Time</span> <span class="nv">Flies</span> <span class="nv">Like</span> <span class="nv">An</span> <span class="nv">Arrow</span>
<span class="nv">Fruit</span> <span class="nv">Flies</span> <span class="nv">Like</span> <span class="nv">A</span> <span class="nv">Banana</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.10 Reversing an Array</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">reversed</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">array</span><span class="p">)))</span>  <span class="c1">; remove vec call if sequence result OK</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nb">count </span><span class="nv">ARRAY</span><span class="p">))]</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">i</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1">;; do something with (ARRAY i)</span>
    <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">i</span><span class="p">))))</span>

<span class="c1">;; alternate version</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="p">(</span><span class="nb">dec </span><span class="p">(</span><span class="nb">count </span><span class="nv">ARRAY</span><span class="p">))</span> <span class="mi">-1</span> <span class="mi">-1</span><span class="p">)]</span>
  <span class="c1">;; do something with (ARRAY i)</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">ascending</span> <span class="p">(</span><span class="nb">sort </span><span class="nv">users</span><span class="p">))</span>

<span class="c1">;; If you want to make the comparison function explicit, you can use</span>
<span class="c1">;; this, which is equivalent to the above.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">ascending</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare</span> <span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span> <span class="nv">users</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">descending</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">ascending</span><span class="p">))</span>

<span class="c1">;; one-step: sort with reverse comparison</span>
<span class="p">(</span><span class="k">def </span><span class="nv">descending</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare</span> <span class="nv">%2</span> <span class="nv">%1</span><span class="p">)</span> <span class="nv">users</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.11 Processing Multiple Elements of an Array</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The Perl code @FRONT = splice(@ARRAY, 0, $N); has the side effect</span>
<span class="c1">;; of modifying @ARRAY, removing the first $N elements from it, and</span>
<span class="c1">;; simultaneously assigning an array of those first $N elements to</span>
<span class="c1">;; @FRONT.</span>

<span class="c1">;; To get a similar effect in Clojure can be done as follows:</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">FRONT</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">array</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">)</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">array</span> <span class="nv">n</span><span class="p">)]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; The Perl code @END = splice(@ARRAY, -$N); also has two side</span>
<span class="c1">;; effects: removing the last $N elements from @ARRAY, and assigning</span>
<span class="c1">;; an array containing those last $N elements to @END.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">END</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">array</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">)</span> <span class="nv">n</span><span class="p">))</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">array</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">)</span> <span class="nv">n</span><span class="p">))]</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; or if you want to use the Clojure splice function defined earlier:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">n</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">END</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">array</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span><span class="p">))</span>
      <span class="nv">array</span> <span class="p">(</span><span class="nf">splice</span> <span class="nv">array</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;array=%s   END=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">array</span><span class="p">)</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">END</span><span class="p">))</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; It is not really possible to write a Clojure function that mutates</span>
<span class="c1">;; an immutable data structure, like Perl&#39;s shift2 and pop2 do.</span>

<span class="c1">;; We could write a function that takes a vector v and return a vector</span>
<span class="c1">;; of the two things: (1) a vector of the first two elements of v, and</span>
<span class="c1">;; (2) a vector of all but the first two elements of v.  The caller of</span>
<span class="c1">;; that function could then choose to use one or both of those values</span>
<span class="c1">;; and bind them to symbols of its choice.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">shift2</span> <span class="p">[</span><span class="nv">v</span><span class="p">]</span>
  <span class="p">[(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">2</span><span class="p">)])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">pop2</span> <span class="p">[</span><span class="nv">v</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">v</span><span class="p">)</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="p">[(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">subvec </span><span class="nv">v</span> <span class="mi">0</span> <span class="nv">i</span><span class="p">)]))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure qw defined far above.  Reuse it here.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">friends</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">qw</span> <span class="s">&quot;Peter Paul Mary Jim Tim&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[[</span><span class="nv">this</span> <span class="nv">that</span><span class="p">]</span> <span class="nv">friends</span><span class="p">]</span> <span class="p">(</span><span class="nf">shift2</span> <span class="nv">friends</span><span class="p">)]</span>
  <span class="c1">;; this contains &quot;Peter&quot;, that has &quot;Paul&quot;, and friends has &quot;Mary&quot;,</span>
  <span class="c1">;; &quot;Jim&quot;, and &quot;Tim&quot;.</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;this=%s  that=%s  friends=%s\n&quot;</span> <span class="nv">this</span> <span class="nv">that</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">friends</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">beverages</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">qw</span> <span class="s">&quot;Dew Jolt Cola Sprite Fresca&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">pair</span> <span class="nv">beverages</span><span class="p">]</span> <span class="p">(</span><span class="nf">pop2</span> <span class="nv">beverages</span><span class="p">)]</span>
  <span class="c1">;; (pair 0) contains Sprite, (pair 1) has Fresca, and beverages has</span>
  <span class="c1">;; [&quot;Dew&quot; &quot;Jolt&quot; &quot;Cola&quot;]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;(pair 0)=%s  (pair 1)=%s  beverages=%s\n&quot;</span>
          <span class="p">(</span><span class="nf">pair</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">pair</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">beverages</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure doesn&#39;t have references exactly like Perl&#39;s.  It does have</span>
<span class="c1">;; something called refs, but in Clojure they are intended primarily</span>
<span class="c1">;; for handling coordinated concurrent changes to multiple refs with</span>
<span class="c1">;; transactions.</span>
<span class="c1">;;</span>
<span class="c1">;; TBD: It isn&#39;t clear to me whether Clojure has a way to implement</span>
<span class="c1">;; the behavior in this Perl code.</span>
<span class="c1">;;</span>
<span class="c1">;; $line[5] = \@list;</span>
<span class="c1">;; @got = pop2( @{ $line[5] } );</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.12 Finding the First List Element That Passes a Test</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; If we know that the matching item cannot possibly have a value that</span>
<span class="c1">;; Clojure would evaluate as false, i.e. false or nil, then we can</span>
<span class="c1">;; write the following.  Note that filter is lazy, so since we only</span>
<span class="c1">;; ask for the first element, the rest of the elements after the</span>
<span class="c1">;; first, if any, will not be computed.  (Exception: If array is a</span>
<span class="c1">;; chunked sequence, the predicate function will be evaluated on all</span>
<span class="c1">;; elements of array in the same chunk as the first one that returns a</span>
<span class="c1">;; logical true value.)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">15</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">15</span><span class="p">])</span>
<span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">match</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="nv">array</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="nv">match</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">))</span>

<span class="c1">;; Be careful!  That code will do the wrong thing if the value false</span>
<span class="c1">;; or nil is in the array, and the criterion we are checking for is</span>
<span class="c1">;; true for such a value.  For example:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="nv">nil</span> <span class="mi">13</span> <span class="mi">15</span><span class="p">])</span>
<span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">match</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">filter nil? </span><span class="nv">array</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="nv">match</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">))</span>
<span class="nv">No</span> <span class="nv">matching</span> <span class="nv">item</span> <span class="nv">found</span>

<span class="c1">;; In this case, nil? returned true for the value nil in array, so</span>
<span class="c1">;; filter did include nil in its output sequence.  However, this</span>
<span class="c1">;; causes first to return the first element of the sequence, nil.  if</span>
<span class="c1">;; and if-let treat nil as false, and thus does the else case.</span>

<span class="c1">;; If we want to avoid that possibility, we can use the function some,</span>
<span class="c1">;; and have a predicate function that returns something besides</span>
<span class="c1">;; nil/false in the matching case.  One way to do that is to bundle up</span>
<span class="c1">;; the matching value in a vector, because if and if-let treat [nil]</span>
<span class="c1">;; and [false] as true.  After all, they are not the same as the</span>
<span class="c1">;; values nil or false.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="nv">nil</span> <span class="mi">13</span> <span class="mi">15</span><span class="p">])</span>
<span class="p">(</span><span class="nb">if-let </span><span class="p">[[</span><span class="nv">match</span><span class="p">]</span> <span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">%</span><span class="p">)</span> <span class="p">[</span><span class="nv">%</span><span class="p">])</span> <span class="nv">array</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="nv">match</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">))</span>
<span class="nv">Found</span> <span class="nv">matching</span> <span class="nv">item</span> <span class="nv">null</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The previous examples will work, of course.  If you want the index</span>
<span class="c1">;; of the matching element, though, they won&#39;t do.  We could do it</span>
<span class="c1">;; with loop.  Note that this works with vectors, but not with other</span>
<span class="c1">;; collections, whereas earlier examples work with all kinds of</span>
<span class="c1">;; collections.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">match-idx</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span> <span class="mi">0</span><span class="p">]</span>
                  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
                    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">even?</span> <span class="p">(</span><span class="nf">array</span> <span class="nv">i</span><span class="p">))</span>
                      <span class="nv">i</span>
                      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)))</span>
                    <span class="nv">nil</span><span class="p">))]</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">match-idx</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="p">(</span><span class="nf">array</span> <span class="nv">match-idx</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; TBD: Read more about what this example is intended to do.  Should</span>
<span class="c1">;; Clojure example create a new class?  Seems like overkill.</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Clojure loops like loop, dotimes, doseq all bind symbols locally,</span>
<span class="c1">;; i.e. within their body, only.  They do not have any accessible</span>
<span class="c1">;; value after the body of the loop is complete.  If you really want</span>
<span class="c1">;; to do it in the way the Perl code is written, it seems you must</span>
<span class="c1">;; write imperative style code, like this.</span>
<span class="p">(</span><span class="nb">with-local-vars </span><span class="p">[</span><span class="nv">i</span> <span class="mi">0</span><span class="p">]</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="o">@</span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">even?</span> <span class="p">(</span><span class="nf">array</span> <span class="o">@</span><span class="nv">i</span><span class="p">))</span>
        <span class="nv">true</span>   <span class="c1">; stop the loop</span>
        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">var-set </span><span class="nv">i</span> <span class="p">(</span><span class="nb">inc </span><span class="o">@</span><span class="nv">i</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">recur</span><span class="p">)))))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="o">@</span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="p">(</span><span class="nf">array</span> <span class="o">@</span><span class="nv">i</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">)))</span>

<span class="c1">;; Another way is almost exactly like one of the examples above, where</span>
<span class="c1">;; you return the loop index as the value of the loop expression.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span> <span class="mi">0</span><span class="p">]</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">even?</span> <span class="p">(</span><span class="nf">array</span> <span class="nv">i</span><span class="p">))</span>
              <span class="nv">i</span>
              <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)))</span>
            <span class="nv">i</span><span class="p">))]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">array</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Found matching item %s\n&quot;</span> <span class="p">(</span><span class="nf">array</span> <span class="nv">i</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;No matching item found\n&quot;</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.13 Finding All Elements in an Array Matching Certain Criteria</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">matching</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">test </span><span class="nv">%</span><span class="p">)</span> <span class="nv">collection</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; You can write Clojure code that works much like this Perl code, but</span>
<span class="c1">;; filter is shorter to write in Clojure, much like grep is in Perl.</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">matching</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">matching</span> <span class="p">[]</span>
                      <span class="nv">s</span> <span class="nv">collection</span><span class="p">]</span>
                 <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">s</span><span class="p">)]</span>
                   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">test </span><span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">matching</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">))</span> <span class="p">(</span><span class="nb">next </span><span class="nv">s</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">recur</span> <span class="nv">matching</span> <span class="p">(</span><span class="nb">next </span><span class="nv">s</span><span class="p">)))</span>
                   <span class="nv">matching</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;matching=%s\n&quot;</span> <span class="p">(</span><span class="nf">str/join</span> <span class="s">&quot; &quot;</span> <span class="nv">matching</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">nums</span> <span class="p">[</span><span class="mi">5</span> <span class="mi">1000000</span> <span class="mi">1000001</span> <span class="mi">-2</span><span class="p">])</span>
<span class="p">(</span><span class="k">def </span><span class="nv">bigs</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">%</span> <span class="mi">1000000</span><span class="p">)</span> <span class="nv">nums</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">bigs</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nf">users</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">10000000</span><span class="p">)</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">users</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">matching</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">re-find </span><span class="o">#</span><span class="s">&quot;^gnat &quot;</span> <span class="nv">%</span><span class="p">)</span>
                      <span class="p">(</span><span class="nf">str/split</span> <span class="p">(</span><span class="ss">:out</span> <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;who&quot;</span><span class="p">))</span> <span class="o">#</span><span class="s">&quot;\n&quot;</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; Just calling function position on elements of employees, not</span>
<span class="c1">;; treating them as objects.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">engineers</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">position</span> <span class="nv">%</span><span class="p">)</span> <span class="s">&quot;Engineer&quot;</span><span class="p">)</span> <span class="nv">employees</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">secondary-assistance</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nf">income</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">26000</span><span class="p">)</span>
                                        <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">income</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">30000</span><span class="p">))</span>
                                  <span class="nv">applicants</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.14 Sorting an Array Numerically</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">sorted</span> <span class="p">(</span><span class="nb">sort </span><span class="nv">unsorted</span><span class="p">))</span>
<span class="c1">;; Or if you want to do an explicit comparison function:</span>
<span class="p">(</span><span class="k">def </span><span class="nv">sorted</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare.</span> <span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span> <span class="nv">unsorted</span><span class="p">))</span>
<span class="c1">;; Note that Clojure does not have the distinction between Perl&#39;s &lt;=&gt;</span>
<span class="c1">;; for comparing scalars as numbers vs. cmp for comparing scalars as</span>
<span class="c1">;; strings, because Clojure does not auto-convert value between types</span>
<span class="c1">;; the way Perl does.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.shell</span> <span class="ss">:as</span> <span class="nv">shell</span><span class="p">])</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">pid</span> <span class="p">(</span><span class="nb">sort </span><span class="nv">pids</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%d\n&quot;</span> <span class="nv">pid</span><span class="p">))</span>
<span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Select a process ID to kill:\n&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">flush</span><span class="p">)</span>  <span class="c1">; println does an automatic flush, but printf does not</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">pid</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)]</span>
  <span class="c1">;; Note that re-matches only returns true if the whole string</span>
  <span class="c1">;; matches the regexp.  It is the same as (re-find #&quot;^\d+$&quot; pid).</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">re-matches </span><span class="o">#</span><span class="s">&quot;\d+&quot;</span> <span class="nv">pid</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Exiting...\n&quot;</span><span class="p">)</span>  <span class="c1">; prints to *out*, which is likely not stderr</span>
    <span class="p">(</span><span class="nf">flush</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">System/exit</span> <span class="mi">1</span><span class="p">))</span>
  <span class="c1">;; TBD: Is there a &#39;platform-independent&#39; API for killing a process</span>
  <span class="c1">;; available from Clojure or Java?  If so, use it here.  The</span>
  <span class="c1">;; following depends upon a process named &quot;kill&quot; being available on</span>
  <span class="c1">;; the system, so probably won&#39;t work on Windows, whereas Perl&#39;s</span>
  <span class="c1">;; subroutine kill would.</span>
  <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;kill&quot;</span> <span class="s">&quot;-TERM&quot;</span> <span class="p">(</span><span class="nb">str </span><span class="nv">pid</span><span class="p">))</span>
  <span class="c1">;; TBD: Similar question for sleep.  I&#39;m almost sure Java must have</span>
  <span class="c1">;; something here.</span>
  <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;sleep&quot;</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">shell/sh</span> <span class="s">&quot;kill&quot;</span> <span class="s">&quot;-KILL&quot;</span> <span class="p">(</span><span class="nb">str </span><span class="nv">pid</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">System/exit</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">descending</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare.</span> <span class="nv">%2</span> <span class="nv">%1</span><span class="p">)</span> <span class="nv">unsorted</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; TBD: Put sort function in separate Clojure namespace</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">def </span><span class="nv">all</span> <span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">(</span><span class="nf">compare.</span> <span class="nv">%2</span> <span class="nv">%1</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">19</span> <span class="mi">8</span> <span class="mi">3</span><span class="p">]))</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; @@PLEAC@@_5.0 Introduction</span>

<span class="p">(</span><span class="kd">ns </span><span class="nv">pleac-section-5</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">string</span><span class="p">]))</span>

<span class="c1">;; The commas are whitespace and optional. Maps are printed with them</span>
<span class="c1">;; at the REPL for readability.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">{</span><span class="s">&quot;Nat&quot;</span> <span class="mi">24</span>, <span class="s">&quot;Jules&quot;</span> <span class="mi">25</span>, <span class="s">&quot;Josh&quot;</span> <span class="mi">17</span><span class="p">})</span>

<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Nat&quot;</span> <span class="mi">24</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Jules&quot;</span> <span class="mi">25</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Josh&quot;</span> <span class="mi">17</span><span class="p">))</span>

<span class="c1">;; Commas omitted here.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">{</span><span class="s">&quot;Apple&quot;</span>  <span class="s">&quot;red&quot;</span>
                 <span class="s">&quot;Banana&quot;</span> <span class="s">&quot;yellow&quot;</span>
                 <span class="s">&quot;Lemon&quot;</span>  <span class="s">&quot;yellow&quot;</span>
                 <span class="s">&quot;Carrot&quot;</span> <span class="s">&quot;orange&quot;</span><span class="p">})</span>

<span class="c1">;; @@PLEAC@@_5.1 Adding an Element to a Hash</span>

<span class="c1">;; Maps, like all core Clojure data structures, are immutable.</span>
<span class="c1">;; Functions for &quot;changing&quot; maps just return new maps.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">food-color</span> <span class="s">&quot;Raspberry&quot;</span> <span class="s">&quot;pink&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nb">println </span><span class="s">&quot;Known foods:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">food</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">println </span><span class="nv">food</span><span class="p">))</span>
<span class="c1">;; Known foods:</span>
<span class="c1">;; Carrot</span>
<span class="c1">;; Banana</span>
<span class="c1">;; Raspberry</span>
<span class="c1">;; Lemon</span>
<span class="c1">;; Apple</span>

<span class="c1">;; @@PLEAC@@_5.2 Testing for the Presence of a Key in a Hash</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">contains? </span><span class="nv">food-color</span> <span class="s">&quot;key&quot;</span><span class="p">)</span>
  <span class="s">&quot;exists&quot;</span>
  <span class="s">&quot;doesn&#39;t exist&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nb">name </span><span class="p">[</span><span class="s">&quot;Banana&quot;</span> <span class="s">&quot;Martini&quot;</span><span class="p">]]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">contains? </span><span class="nv">food-color</span> <span class="nv">name</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">println name </span><span class="s">&quot;is a food.&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">println name </span><span class="s">&quot;is a drink.&quot;</span><span class="p">)))</span>

<span class="c1">;; Banana is a food.</span>
<span class="c1">;; Martini is a drink.</span>

<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">{})</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Toddler&quot;</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Unborn&quot;</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">age</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">age</span> <span class="s">&quot;Phantasm&quot;</span> <span class="nv">nil</span><span class="p">))</span>

<span class="c1">;; Maps are functions from keys to values, and can be called exactly</span>
<span class="c1">;; like functions, taking a key as an argument. The function call</span>
<span class="c1">;; returns nil if the key doesn&#39;t exist. This works just like using</span>
<span class="c1">;; the function &quot;get&quot;.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">thing</span> <span class="p">[</span><span class="s">&quot;Toddler&quot;</span> <span class="s">&quot;Unborn&quot;</span> <span class="s">&quot;Phantasm&quot;</span> <span class="s">&quot;Relic&quot;</span><span class="p">]]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s: &quot;</span> <span class="nv">thing</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">contains? </span><span class="nv">age</span> <span class="nv">thing</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Exists &quot;</span><span class="p">))</span>
  <span class="c1">;; get returns nil when the key isn&#39;t in the map, and when the key</span>
  <span class="c1">;; does exist and the value is nil.</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">get </span><span class="nv">age</span> <span class="nv">thing</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Defined &quot;</span><span class="p">))</span>
  <span class="c1">;; This works just like the above. Output differs from Perl because</span>
  <span class="c1">;; 0 is not falsy.</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">age</span> <span class="nv">thing</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;True &quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="c1">;; Toddler: Exists Defined True</span>
<span class="c1">;; Unborn: Exists Defined True</span>
<span class="c1">;; Phantasm: Exists</span>
<span class="c1">;; Relic:</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">file-sizes</span> <span class="p">[</span><span class="nv">files</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">map </span><span class="nv">file</span><span class="p">]</span>
            <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">file</span> <span class="p">(</span><span class="nf">.trim</span> <span class="nv">file</span><span class="p">)]</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">contains? map </span><span class="nv">file</span><span class="p">)</span>
                <span class="nv">map</span>
                <span class="p">(</span><span class="nb">assoc map </span><span class="nv">file</span> <span class="p">(</span><span class="nf">.length</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="nv">file</span><span class="p">))))))</span>
          <span class="p">{}</span>
          <span class="nv">files</span><span class="p">))</span>

<span class="p">(</span><span class="nf">file-sizes</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">*in*</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_5.3 Deleting from a Hash</span>

<span class="c1">;; dissoc is used to &quot;remove&quot; (return a new map without the key)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-foods</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Keys:&quot;</span> <span class="p">(</span><span class="nf">string/join</span> <span class="s">&quot; &quot;</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Values: &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">food</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">food-color</span> <span class="nv">food</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s &quot;</span> <span class="p">(</span><span class="nf">food-color</span> <span class="nv">food</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">print </span><span class="s">&quot;(undef) &quot;</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;Initially:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;\nWith Banana undef&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">food-color</span> <span class="s">&quot;Banana&quot;</span> <span class="nv">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="p">(</span><span class="nb">println </span><span class="s">&quot;\nWith Banana deleted&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">(</span><span class="nb">dissoc </span><span class="nv">food-color</span> <span class="s">&quot;Banana&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="c1">;; Initially:</span>
<span class="c1">;; Keys: Carrot Banana Lemon Apple</span>
<span class="c1">;; Values: orange yellow yellow red</span>

<span class="c1">;; With Banana undef</span>
<span class="c1">;; Keys: Carrot Banana Lemon Apple</span>
<span class="c1">;; Values: orange (undef) yellow red</span>

<span class="c1">;; With Banana deleted</span>
<span class="c1">;; Keys: Carrot Lemon Apple</span>
<span class="c1">;; Values: orange yellow red</span>

<span class="p">(</span><span class="k">def </span><span class="nv">food-color</span> <span class="p">(</span><span class="nb">dissoc </span><span class="nv">food-color</span> <span class="s">&quot;Banana&quot;</span> <span class="s">&quot;Apple&quot;</span> <span class="s">&quot;Cabbage&quot;</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_5.4 Traversing a Hash</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[[</span><span class="nb">key </span><span class="nv">value</span><span class="p">]</span> <span class="nv">food-color</span><span class="p">]</span>
  <span class="c1">;; do something</span>
  <span class="p">)</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nb">key </span><span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">value</span> <span class="p">(</span><span class="nf">food-color</span> <span class="nv">key</span><span class="p">)]</span>
    <span class="c1">;; do something</span>
    <span class="p">))</span>

<span class="c1">;; food-color per the introduction</span>
<span class="p">(</span><span class="nb">doseq </span><span class="p">[[</span><span class="nv">food</span> <span class="nv">color</span><span class="p">]</span> <span class="nv">food-color</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s is %s.\n&quot;</span> <span class="nv">food</span> <span class="nv">color</span><span class="p">))</span>
<span class="c1">;; Carrot is orange.</span>
<span class="c1">;; Banana is yellow.</span>
<span class="c1">;; Lemon is yellow.</span>
<span class="c1">;; Apple is red.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">food</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">)]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">color</span> <span class="p">(</span><span class="nf">food-color</span> <span class="nv">food</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s is %s.\n&quot;</span> <span class="nv">food</span> <span class="nv">color</span><span class="p">)))</span>
<span class="c1">;; Carrot is orange.</span>
<span class="c1">;; Banana is yellow.</span>
<span class="c1">;; Lemon is yellow.</span>
<span class="c1">;; Apple is red.</span>

<span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">food</span> <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">keys </span><span class="nv">food-color</span><span class="p">))]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">color</span> <span class="p">(</span><span class="nf">food-color</span> <span class="nv">food</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s is %s.\n&quot;</span> <span class="nv">food</span> <span class="nv">color</span><span class="p">)))</span>
<span class="c1">;; Apple is red.</span>
<span class="c1">;; Banana is yellow.</span>
<span class="c1">;; Carrot is orange.</span>
<span class="c1">;; Lemon is yellow.</span>

<span class="c1">;; There isn&#39;t an idiomatic way to reset an iteration through a</span>
<span class="c1">;; collection in Clojure.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">countfrom</span> <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">lines</span> <span class="p">(</span><span class="nb">line-seq </span><span class="p">(</span><span class="nf">io/reader</span> <span class="nv">file</span><span class="p">))</span>
        <span class="nv">match-sender</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">line</span><span class="p">]</span>
                       <span class="p">(</span><span class="nb">second </span><span class="p">(</span><span class="nb">re-matches </span><span class="o">#</span><span class="s">&quot;^From: (.*)&quot;</span> <span class="nv">line</span><span class="p">)))</span>
        <span class="nv">from</span> <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">map </span><span class="nv">line</span><span class="p">]</span>
                       <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">sender</span> <span class="p">(</span><span class="nf">match-sender</span> <span class="nv">line</span><span class="p">)</span>
                             <span class="nv">cur</span> <span class="p">(</span><span class="nb">get map </span><span class="nv">sender</span> <span class="mi">0</span><span class="p">)]</span>
                         <span class="p">(</span><span class="nb">assoc map </span><span class="nv">sender</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">cur</span><span class="p">))))</span>
                     <span class="p">{}</span>
                     <span class="nv">lines</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">doseq </span><span class="p">[[</span><span class="nv">person</span> <span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nb">sort </span><span class="nv">from</span><span class="p">)]</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s: %d\n&quot;</span> <span class="nv">person</span> <span class="nv">n</span><span class="p">))))</span>
<span class="c1">;; FILE ACCESS</span>
<span class="c1">;; @@PLEAC@@_7.0 Introduction</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">pleac-section-7.0</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">])</span>
  <span class="p">(</span><span class="ss">:import</span> <span class="p">[</span><span class="nv">java.io</span> <span class="nv">BufferedReader</span> <span class="nv">FileReader</span><span class="p">]))</span>

<span class="c1">;; The perl version contains an or die &quot;Couldn&#39;t open filename: $!&quot;</span>
<span class="c1">;; after the file open, but this isn&#39;t quite as necessary</span>
<span class="c1">;; in languages with exceptions, such as Clojure.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">print-blue-lines-in-file</span> <span class="p">[</span><span class="nv">filename</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">reader</span> <span class="p">(</span><span class="nf">io/reader</span> <span class="nv">filename</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="nv">reader</span><span class="p">)]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">.contains</span> <span class="nv">line</span> <span class="s">&quot;blue&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">println </span><span class="nv">line</span><span class="p">)))))</span>

<span class="c1">;; =&gt; (print-blue-lines-in-file &quot;/usr/local/widgets/data&quot;)</span>
<span class="c1">;; blue</span>
<span class="c1">;; blue&#39;s</span>
<span class="c1">;; bluebell</span>
<span class="c1">;; ...</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; The Perl code shows how to use * to cast the STDIN file handle</span>
<span class="c1">;; to a scalar variable.  This is unnecessary in Clojure, the</span>
<span class="c1">;; stdin reader object is already bound to the name *in*, which</span>
<span class="c1">;; can be manipulated like any other symbol.</span>
<span class="p">(</span><span class="k">def </span><span class="nv">stdin-var</span> <span class="nv">*in*</span><span class="p">)</span>
<span class="p">(</span><span class="nf">mysub</span> <span class="nv">stdin-var</span> <span class="nv">logfile</span><span class="p">)</span>
<span class="c1">;; -----------------------------</span>

<span class="c1">;; Here&#39;s another way to do the blue line iterator.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">print-blue-lines-in-file</span> <span class="p">[</span><span class="nv">filename</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">compiled-regex</span> <span class="o">#</span><span class="s">&quot;blue&quot;</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">rdr</span> <span class="p">(</span><span class="nf">io/BufferedReader.</span> <span class="p">(</span><span class="nf">io/FileReader.</span> <span class="nv">filename</span><span class="p">))]</span>
      <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="nv">rdr</span><span class="p">)]</span>
        <span class="p">(</span><span class="nb">when-not </span><span class="p">(</span><span class="nb">re-find </span><span class="nv">compiled-regex</span> <span class="nv">line</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">line</span><span class="p">))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-digital-lines-from-stdin</span> <span class="p">[]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">digit-regex</span> <span class="s">&quot;#\d&quot;</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">reader</span> <span class="p">(</span><span class="nf">io/reader</span> <span class="nv">*in*</span><span class="p">)]</span>
      <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="nv">reader</span><span class="p">)]</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">re-find </span><span class="nv">digit-regex</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;Read: %s\n&quot;</span> <span class="nv">line</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">println </span><span class="nv">*err*</span> <span class="s">&quot;No digit found.&quot;</span><span class="p">))))))</span>

<span class="c1">;; -----------------------------</span>
<span class="c1">;; The Perl code shows how to assign a file handle to LOGFILE...</span>
<span class="p">(</span><span class="k">def </span><span class="nv">log-file-handle</span> <span class="p">(</span><span class="nf">io/writer</span> <span class="s">&quot;/tmp/log&quot;</span> <span class="ss">:append</span> <span class="nv">true</span><span class="p">))</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="nf">.close</span> <span class="nv">log-file-handle</span><span class="p">)</span>
<span class="c1">;; -----------------------------</span>
<span class="c1">;; ... but because unlike Perl, flow-control in Clojure can be</span>
<span class="c1">;; interupted with conditions and exceptions, it&#39;s a good idea to</span>
<span class="c1">;; use the with-open macro to ensure the file handle is closed.</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">log-file-handle</span> <span class="p">(</span><span class="nf">io/writer</span> <span class="s">&quot;/tmp/log&quot;</span> <span class="ss">:append</span> <span class="nv">true</span><span class="p">)]</span>
  <span class="c1">;; do stuff with log-file-handle.  Log-file-handle wlll be closed when</span>
  <span class="c1">;; evaluation of this expression terminates.</span>
  <span class="p">)</span>
<span class="c1">;; -----------------------------</span>

<span class="c1">;; The with-out-str macro redirects everything written to *out*</span>
<span class="c1">;; into a string.</span>
<span class="c1">;; mbac: rewrite as a macro so calling is less awkward.</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">append-stdout-to-file</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">filename</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">fh</span> <span class="p">(</span><span class="nf">io/writer</span> <span class="nv">filename</span> <span class="ss">:append</span> <span class="nv">true</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">.write</span> <span class="nv">fh</span> <span class="p">(</span><span class="nb">with-out-str </span><span class="p">(</span><span class="nf">f</span><span class="p">)))))</span>
<span class="c1">;; =&gt; (append-stdout-to-file (fn [] (printf &quot;foo bar baz\n&quot;)) &quot;/tmp/log.txt&quot;)</span>

<span class="c1">;; @@PLEAC@@_7.1 Opening a File</span>
<span class="c1">;; -----------------------------</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">pleac-section-7.1</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">])</span>
  <span class="p">(</span><span class="ss">:import</span> <span class="p">[</span><span class="nv">java.io</span> <span class="nv">BufferedReader</span> <span class="nv">FileReader</span><span class="p">]))</span>

<span class="c1">;; open PATH for reading</span>
<span class="p">(</span><span class="k">def </span><span class="nv">source</span> <span class="p">(</span><span class="nf">io/reader</span> <span class="nv">path</span><span class="p">))</span>

<span class="c1">;; open PATH for writing</span>
<span class="p">(</span><span class="k">def </span><span class="nv">sink</span> <span class="p">(</span><span class="nf">io/writer</span> <span class="nv">path</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">;; The Perl code makes POSIX open for read and open for write calls</span>
<span class="c1">;; which aren&#39;t directly accessible from Clojure.</span>
<span class="c1">;; mbac: maybe find a UNIX/POSIX module?</span>

<span class="c1">;; -----------------------------</span>

<span class="c1">;; The Perl code shows how to open files through an object oriented</span>
<span class="c1">;; interface to contrast the file handle interface.  Clojure already uses</span>
<span class="c1">;; objects.</span>

<span class="c1">;; mbac: maybe we can show interesting file openers from contrib instead?</span>

<span class="c1">;; -----------------------------</span>
<span class="c1">;; sysopen(FILEHANDLE, $name, $flags)         or die &quot;Can&#39;t open $name : $!&quot;;</span>
<span class="c1">;; sysopen(FILEHANDLE, $name, $flags, $perms) or die &quot;Can&#39;t open $name : $!&quot;;</span>
<span class="c1">;; #-----------------------------</span>
<span class="c1">;; open(FH, &quot;&lt; $path&quot;)                                 or die $!;</span>
<span class="c1">;; sysopen(FH, $path, O_RDONLY)                        or die $!;</span>
<span class="c1">;; #-----------------------------</span>
<span class="c1">;; open(FH, &quot;&gt; $path&quot;)                                 or die $!;</span>
<span class="c1">;; sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT)        or die $!;</span>
<span class="c1">;; sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT, 0600)  or die $!;</span>
<span class="c1">;; #-----------------------------</span>
<span class="c1">;; sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT)         or die $!;</span>
<span class="c1">;; sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT, 0600)   or die $!;</span>
<span class="c1">;; #-----------------------------</span>
<span class="c1">;; open(FH, &quot;&gt;&gt; $path&quot;)                                or die $!;</span>
<span class="c1">;; sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT)       or die $!;</span>
<span class="c1">;; sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT, 0600) or die $!;</span>
<span class="c1">;; #-----------------------------</span>
<span class="c1">;; sysopen(FH, $path, O_WRONLY|O_APPEND)               or die $!;</span>
<span class="c1">;; #-----------------------------</span>
<span class="c1">;; open(FH, &quot;+&lt; $path&quot;)                                or die $!;</span>
<span class="c1">;; sysopen(FH, $path, O_RDWR)                          or die $!;</span>
<span class="c1">;; #-----------------------------</span>
<span class="c1">;; sysopen(FH, $path, O_RDWR|O_CREAT)                  or die $!;</span>
<span class="c1">;; sysopen(FH, $path, O_RDWR|O_CREAT, 0600)            or die $!;</span>
<span class="c1">;; #-----------------------------</span>
<span class="c1">;; sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT)           or die $!;</span>
<span class="c1">;; sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT, 0600)     or die $!;</span>
<span class="c1">;; #-----------------------------</span>
<span class="o">@@</span><span class="nv">INCOMPLETE</span><span class="o">@@</span>
</pre></div>
</body>
</html>
