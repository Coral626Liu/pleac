<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Subroutines</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Groovy"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Directories"
HREF="directories.html"><LINK
REL="NEXT"
TITLE="References and Records"
HREF="referencesandrecords.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Groovy</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SUBROUTINES"
>10. Subroutines</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN536"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">def hello() {</span>
<span class="s">    greeted += 1</span>
<span class="s">    println &quot;hi there!&quot;</span>
<span class="s">}</span>

<span class="s">// We need to initialize greeted before it can be used, because &quot;+=&quot; assumes predefinition</span>
<span class="s">greeted = 0</span>
<span class="s">hello()</span>
<span class="s">println greeted</span>
<span class="s">// =&gt;</span>
<span class="s">// hi there</span>
<span class="s">// 1</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN539"
>Accessing Subroutine Arguments</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// basic method calling examples</span>
<span class="s">// In Groovy, parameters are named anyway</span>
<span class="s">def hypotenuse(side1, side2) {</span>
<span class="s">    Math.sqrt(side1**2 + side2**2)    // sqrt in Math package</span>
<span class="s">}</span>
<span class="s">diag = hypotenuse(3, 4)</span>
<span class="s">assert diag == 5</span>

<span class="s">// the star operator will magically convert an Array into a &quot;tuple&quot;</span>
<span class="s">a = [5, 12]</span>
<span class="s">assert hypotenuse(*a) == 13</span>

<span class="s">// both = men + women</span>

<span class="s">// In Groovy, all objects are references, so the same problem arises.</span>
<span class="s">// Typically we just return a new object. Especially for immutable objects</span>
<span class="s">// this style of processing is very common.</span>
<span class="s">nums = [1.4, 3.5, 6.7]</span>
<span class="s">def toInteger(n) {</span>
<span class="s">    n.collect { v -&gt; v.toInteger() }</span>
<span class="s">}</span>
<span class="s">assert toInteger(nums) == [1, 3, 6]</span>

<span class="s">orignums = [1.4, 3.5, 6.7]</span>
<span class="s">def truncMe(n) {</span>
<span class="s">    (0..&lt;n.size()).each{ idx -&gt; n[idx] = n[idx].toInteger() }</span>
<span class="s">}</span>
<span class="s">truncMe(orignums)</span>
<span class="s">assert orignums == [1, 3, 6]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN542"
>Making Variables Private to a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// variable scope examples</span>
<span class="s">def somefunc() {</span>
<span class="s">    def variableInMethod  // private is default in a method</span>
<span class="s">}</span>

<span class="s">def name // private is default for variable in a script</span>

<span class="s">bindingVar = 10 // this will be in the binding (sort of global)</span>
<span class="s">globalArray = []</span>

<span class="s">// In Groovy, run_check can&#39;t access a, b, or c until they are</span>
<span class="s">// explicitely defined global (using leading $), even if they are</span>
<span class="s">// both defined in the same scope</span>

<span class="s">def checkAccess(x) {</span>
<span class="s">    def y = 200</span>
<span class="s">    return x + y + bindingVar // access private, param, global</span>
<span class="s">}</span>
<span class="s">assert checkAccess(7) == 217</span>

<span class="s">def saveArray(ary) {</span>
<span class="s">    globalArray &lt;&lt; &#39;internal&#39;</span>
<span class="s">    globalArray += ary</span>
<span class="s">}</span>

<span class="s">saveArray([&#39;important&#39;])</span>
<span class="s">assert globalArray == [&quot;internal&quot;, &quot;important&quot;]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN545"
>Creating Persistent Private Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// you want a private persistent variable within a script method</span>

<span class="s">// you could use a helper class for this</span>
<span class="s">class CounterHelper {</span>
<span class="s">    private static counter = 0</span>
<span class="s">    def static next() { ++counter }</span>
<span class="s">}</span>
<span class="s">def greeting(s) {</span>
<span class="s">    def n = CounterHelper.next()</span>
<span class="s">    println &quot;Hello $s  (I have been called $n times)&quot;</span>
<span class="s">}</span>
<span class="s">greeting(&#39;tom&#39;)</span>
<span class="s">greeting(&#39;dick&#39;)</span>
<span class="s">greeting(&#39;harry&#39;)</span>
<span class="s">// =&gt;</span>
<span class="s">// Hello tom  (I have been called 1 times)</span>
<span class="s">// Hello dick  (I have been called 2 times)</span>
<span class="s">// Hello harry  (I have been called 3 times)</span>

<span class="s">// you could make it more fancy by having separate keys,</span>
<span class="s">// using synchronisation, singleton pattern, ThreadLocal, ...</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN548"
>Determining Current Function Name</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Determining Current Method Name</span>
<span class="s">// Getting class, package and static info is easy. Method info is just a little work.</span>
<span class="s">// From Java we can use:</span>
<span class="s">//     new Exception().stackTrace[0].methodName</span>
<span class="s">// or for Java 5 and above (saves relatively expensive exception creation)</span>
<span class="s">//     Thread.currentThread().stackTrace[3].methodName</span>
<span class="s">// But these give the Java method name. Groovy wraps its own runtime</span>
<span class="s">// system over the top. It&#39;s still a Java method, just a little bit further up the</span>
<span class="s">// stack from where we might expect. Getting the Groovy method name can be done in</span>
<span class="s">// an implementation specific way (subject to change as the language evolves):</span>
<span class="s">def myMethod() {</span>
<span class="s">    names = new Exception().stackTrace*.methodName</span>
<span class="s">    println groovyUnwrap(names)</span>
<span class="s">}</span>
<span class="s">def myMethod2() {</span>
<span class="s">    names = Thread.currentThread().stackTrace*.methodName</span>
<span class="s">    names = names[3..&lt;names.size()] // skip call to dumpThread</span>
<span class="s">    println groovyUnwrap(names)</span>
<span class="s">}</span>
<span class="s">def groovyUnwrap(names) { names[names.indexOf(&#39;invoke0&#39;)-1] }</span>
<span class="s">myMethod()  // =&gt; myMethod</span>
<span class="s">myMethod2() // =&gt; myMethod2</span>

<span class="s">// Discussion: If what you really wanted was a tracing mechanism, you could overrie</span>
<span class="s">// invokeMethod and print out method names before calling the original method. Or</span>
<span class="s">// you could use one of the Aspect-Oriented Programming packages for Java.</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN551"
>Passing Arrays and Hashes by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Passing Arrays and Hashes by Reference</span>
<span class="s">// In Groovy, every value is a reference to an object, thus there is</span>
<span class="s">// no such problem, just call: arrayDiff(array1, array2)</span>

<span class="s">// pairwise add (altered so it doesn&#39;t require equal sizes)</span>
<span class="s">def pairWiseAdd(a1, a2) {</span>
<span class="s">    s1 = a1.size(); s2 = a2.size()</span>
<span class="s">    (0..&lt;[s1,s2].max()).collect{</span>
<span class="s">        it &gt; s1-1 ? a2[it] : (it &gt; s2-1 ? a1[it] : a1[it] + a2[it])</span>
<span class="s">    }</span>
<span class="s">}</span>
<span class="s">a = [1, 2]</span>
<span class="s">b = [5, 8]</span>
<span class="s">assert pairWiseAdd(a, b) == [6, 10]</span>

<span class="s">// also works for unequal sizes</span>
<span class="s">b = [5, 8, -1]</span>
<span class="s">assert pairWiseAdd(a, b) == [6, 10, -1]</span>
<span class="s">b = [5]</span>
<span class="s">assert pairWiseAdd(a, b) == [6, 2]</span>

<span class="s">// We could check if both arguments were of a particular type, e.g.</span>
<span class="s">// (a1 instanceof List) or (a2.class.isArray()) but duck typing allows</span>
<span class="s">// it to work on other things as well, so while wouldn&#39;t normally do this</span>
<span class="s">// you do need to be a little careful when calling the method, e.g.</span>
<span class="s">// here we call it with two maps of strings and get back strings</span>
<span class="s">// the important thing here was that the arguments were indexed</span>
<span class="s">// 0..size-1 and that the items supported the &#39;+&#39; operator (as String does)</span>
<span class="s">a = [0:&#39;Green &#39;, 1:&#39;Grey &#39;]</span>
<span class="s">b = [0:&#39;Frog&#39;, 1:&#39;Elephant&#39;, 2:&#39;Dog&#39;]</span>
<span class="s">assert pairWiseAdd(a, b) == [&quot;Green Frog&quot;, &quot;Grey Elephant&quot;, &quot;Dog&quot;]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN554"
>Detecting Return Context</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Detecting Return Context</span>
<span class="s">// There is no exact equivalent of return context in Groovy but</span>
<span class="s">// you can behave differently when called under different circumstances</span>
<span class="s">def addValueOrSize(a1, a2) {</span>
<span class="s">     b1 = (a1 instanceof Number) ? a1 : a1.size()</span>
<span class="s">     b2 = (a2 instanceof Number) ? a2 : a2.size()</span>
<span class="s">     b1 + b2</span>
<span class="s">}</span>
<span class="s">assert (addValueOrSize(10, &#39;abcd&#39;)) == 14</span>
<span class="s">assert (addValueOrSize(10, [25, 50])) == 12</span>
<span class="s">assert (addValueOrSize(&#39;abc&#39;, [25, 50])) == 5</span>
<span class="s">assert (addValueOrSize(25, 50)) == 75</span>

<span class="s">// Of course, a key feature of many OO languages including Groovy is</span>
<span class="s">// method overloading so that responding to dofferent parameters has</span>
<span class="s">// a formal way of being captured in code with typed methods, e.g.</span>
<span class="s">class MakeBiggerHelper {</span>
<span class="s">    def triple(List iList) { iList.collect{ it * 3 } }</span>
<span class="s">    def triple(int i) { i * 3 }</span>
<span class="s">}</span>
<span class="s">mbh = new MakeBiggerHelper()</span>
<span class="s">assert mbh.triple([4, 5]) == [12, 15]</span>
<span class="s">assert mbh.triple(4) == 12</span>

<span class="s">// Of course with duck typing, we can rely on dynamic typing if we want</span>
<span class="s">def directTriple(arg) {</span>
<span class="s">    (arg instanceof Number) ? arg * 3 : arg.collect{ it * 3 }</span>
<span class="s">}</span>
<span class="s">assert directTriple([4, 5]) == [12, 15]</span>
<span class="s">assert directTriple(4) == 12</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN557"
>Passing by Named Parameter</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Passing by Named Parameter</span>
<span class="s">// Groovy supports named params or positional arguments with optional</span>
<span class="s">// defaults to simplify method calling</span>

<span class="s">// named arguments work by using a map</span>
<span class="s">def thefunc(Map args) {</span>
<span class="s">    // in this example, we just call the positional version</span>
<span class="s">    thefunc(args.start, args.end, args.step)</span>
<span class="s">}</span>

<span class="s">// positional arguments with defaults</span>
<span class="s">def thefunc(start=0, end=30, step=10) {</span>
<span class="s">    ((start..end).step(step))</span>
<span class="s">}</span>

<span class="s">assert thefunc()                        == [0, 10, 20, 30]</span>
<span class="s">assert thefunc(15)                      == [15, 25]</span>
<span class="s">assert thefunc(0,40)                    == [0, 10, 20, 30, 40]</span>
<span class="s">assert thefunc(start:5, end:20, step:5) == [5, 10, 15, 20]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN560"
>Skipping Selected Return Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Skipping Selected Return Values</span>
<span class="s">// Groovy 1.0 doesn&#39;t support multiple return types, so you always use</span>
<span class="s">// a holder class, array or collection to return multiple values.</span>
<span class="s">def getSystemInfo() {</span>
<span class="s">    def millis = System.currentTimeMillis()</span>
<span class="s">    def freemem = Runtime.runtime.freeMemory()</span>
<span class="s">    def version = System.getProperty(&#39;java.vm.version&#39;)</span>
<span class="s">    return [millis:millis, freemem:freemem, version:version]</span>
<span class="s">    // if you are likely to want all the information use a list</span>
<span class="s">    //     return [millis, freemem, version]</span>
<span class="s">    // or dedicated holder class</span>
<span class="s">    //     return new SystemInfo(millis, freemem, version)</span>
<span class="s">}</span>
<span class="s">result = getSystemInfo()</span>
<span class="s">println result.version</span>
<span class="s">// =&gt; 1.5.0_08-b03</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN563"
>Returning More Than One Array or Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Returning More Than One Array or Hash</span>
<span class="s">// As per 10.8, Groovy 1.0 doesn&#39;t support multiple return types but you</span>
<span class="s">// just use a holder class, array or collection. There are no limitations</span>
<span class="s">// on returning arbitrary nested values using this technique.</span>
<span class="s">def getInfo() {</span>
<span class="s">    def system = [millis:System.currentTimeMillis(),</span>
<span class="s">                  version:System.getProperty(&#39;java.vm.version&#39;)]</span>
<span class="s">    def runtime = [freemem:Runtime.runtime.freeMemory(),</span>
<span class="s">                   maxmem:Runtime.runtime.maxMemory()]</span>
<span class="s">    return [system:system, runtime:runtime]</span>
<span class="s">}</span>
<span class="s">println info.runtime.maxmem // =&gt; 66650112 (info automatically calls getInfo() here)</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN566"
>Returning Failure</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Returning Failure</span>
<span class="s">// This is normally done in a heavy-weight way via Java Exceptions</span>
<span class="s">// (see 10.12) or in a lightweight way by returning null</span>
<span class="s">def sizeMinusOne(thing) {</span>
<span class="s">    if (thing instanceof Number) return</span>
<span class="s">    thing.size() - 1</span>
<span class="s">}</span>
<span class="s">def check(thing) {</span>
<span class="s">    result = sizeMinusOne(thing)</span>
<span class="s">    println (result ? &quot;Worked with result: $result&quot; : &#39;Failed&#39;)</span>
<span class="s">}</span>
<span class="s">check(4)</span>
<span class="s">check([1, 2])</span>
<span class="s">check(&#39;abc&#39;)</span>
<span class="s">// =&gt;</span>
<span class="s">// Failed</span>
<span class="s">// Worked with result: 1</span>
<span class="s">// Worked with result: 2</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN569"
>Prototyping Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Prototyping Functions: Not supported by Groovy but arguably</span>
<span class="s">// not important given other language features.</span>

<span class="s">// Omitting Parentheses Scenario: Groovy only lets you leave out</span>
<span class="s">// parentheses in simple cases. If you had two methods sum(a1,a2,a3)</span>
<span class="s">// and sum(a1,a2), there would be no way to indicate that whether</span>
<span class="s">// &#39;sum sum 2, 3, 4, 5&#39; meant sum(sum(2,3),4,5) or sum(sum(2,3,4),5).</span>
<span class="s">// You would have to include the parentheses. Groovy does much less</span>
<span class="s">// auto flattening than some other languages; it provides a *args</span>
<span class="s">// operator, varargs style optional params and supports method</span>
<span class="s">// overloading and ducktyping. Perhaps these other features mean</span>
<span class="s">// that this scenario is always easy to avoid.</span>
<span class="s">def sum(a,b,c){ a+b+c*2 }</span>
<span class="s">def sum(a,b){ a+b }</span>
<span class="s">// sum sum 1,2,4,5</span>
<span class="s">// =&gt; compilation error</span>
<span class="s">sum sum(1,2),4,5</span>
<span class="s">sum sum(1,2,4),5</span>
<span class="s">// these work but if you try to do anything fancy you will run into trouble;</span>
<span class="s">// your best bet is to actually include all the parentheses:</span>
<span class="s">println sum(sum(1,2),4,5) // =&gt; 17</span>
<span class="s">println sum(sum(1,2,4),5) // =&gt; 16</span>

<span class="s">// Mimicking built-ins scenario: this is a mechanism to turn-off</span>
<span class="s">// auto flattening, Groovy only does flattening in restricted circumstances.</span>
<span class="s">// func(array, 1, 2, 3) is never coerced into a single list but varargs</span>
<span class="s">// and optional args can be used instead</span>
<span class="s">def push(list, Object[] optionals) {</span>
<span class="s">    optionals.each{ list.add(it) }</span>
<span class="s">}</span>
<span class="s">items = [1,2]</span>
<span class="s">newItems = [7, 8, 9]</span>
<span class="s">push items, 3, 4</span>
<span class="s">push items, 6</span>
<span class="s">push (items, *newItems) // brackets currently required, *=flattening</span>
<span class="s">                        // without *: items = [1, 2, 3, 4, 6, [7, 8, 9]]</span>
<span class="s">assert items == [1, 2, 3, 4, 6, 7, 8, 9]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN572"
>Handling Exceptions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Handling Exceptions</span>
<span class="s">// Same story as in Java but Groovy has some nice Checked -&gt; Unchecked</span>
<span class="s">// magic behind the scenes (Java folk will know what this means)</span>
<span class="s">// When writing methods:</span>
<span class="s">//     throw exception to raise it</span>
<span class="s">// When calling methods:</span>
<span class="s">//     try ... catch ... finally surrounds processing logic</span>
<span class="s">def getSizeMostOfTheTime(s) {</span>
<span class="s">    if (s =~ &#39;Full Moon&#39;) throw new RuntimeException(&#39;The world is ending&#39;)</span>
<span class="s">    s.size()</span>
<span class="s">}</span>
<span class="s">try {</span>
<span class="s">    println &#39;Size is: &#39; + getSizeMostOfTheTime(&#39;The quick brown fox&#39;)</span>
<span class="s">    println &#39;Size is: &#39; + getSizeMostOfTheTime(&#39;Beware the Full Moon&#39;)</span>
<span class="s">} catch (Exception ex) {</span>
<span class="s">    println &quot;Error was: $ex.message&quot;</span>
<span class="s">} finally {</span>
<span class="s">    println &#39;Doing common cleanup&#39;</span>
<span class="s">}</span>
<span class="s">// =&gt;</span>
<span class="s">// Size is: 19</span>
<span class="s">// Error was: The world is ending</span>
<span class="s">// Doing common cleanup</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN575"
>Saving Global Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Saving Global Values</span>
<span class="s">// We can just save the value and restore it later:</span>
<span class="s">def printAge() { println &quot;Age is $age&quot; }</span>

<span class="s">age = 18         // binding &quot;global&quot; variable</span>
<span class="s">printAge()       // =&gt; 18</span>

<span class="s">if (age &gt; 0) {</span>
<span class="s">    def origAge = age</span>
<span class="s">    age = 23</span>
<span class="s">    printAge()   // =&gt; 23</span>
<span class="s">    age = origAge</span>
<span class="s">}</span>
<span class="s">printAge()       // =&gt; 18</span>

<span class="s">// Depending on the circmstances we could enhance this in various ways</span>
<span class="s">// such as synchronizing, surrounding with try ... finally, using a</span>
<span class="s">// memento pattern, saving the whole binding, using a ThreadLocal ...</span>

<span class="s">// There is no need to use local() for filehandles or directory</span>
<span class="s">// handles in Groovy because filehandles are normal objects.</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN578"
>Redefining a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Redefining a Function</span>
<span class="s">// This can be done via a number of ways:</span>

<span class="s">// OO approach:</span>
<span class="s">// The standard trick using OO is to override methods in subclasses</span>
<span class="s">class Parent { def foo(){ println &#39;foo&#39; } }</span>
<span class="s">class Child extends Parent { def foo(){ println &#39;bar&#39; } }</span>
<span class="s">new Parent().foo()   // =&gt; foo</span>
<span class="s">new Child().foo()    // =&gt; bar</span>

<span class="s">// Category approach:</span>
<span class="s">// If you want to redefine a method from an existing library</span>
<span class="s">// you can use categories. This can be done to avoid name conflicts</span>
<span class="s">// or to patch functionality with local mods without changing</span>
<span class="s">// original code</span>
<span class="s">println new Date().toString()</span>
<span class="s">// =&gt; Sat Jan 06 16:44:55 EST 2007</span>
<span class="s">class DateCategory {</span>
<span class="s">    static toString(Date self) { &#39;not telling&#39; }</span>
<span class="s">}</span>
<span class="s">use (DateCategory) {</span>
<span class="s">    println new Date().toString()</span>
<span class="s">}</span>
<span class="s">// =&gt; not telling</span>

<span class="s">// Closure approach:</span>
<span class="s">// Groovy&#39;s closures let you have &quot;anonymous methods&quot; as objects.</span>
<span class="s">// This allows you to be very flexible with &quot;method&quot; redefinition, e.g.:</span>
<span class="s">colors = &#39;red yellow blue green&#39;.split(&#39; &#39;).toList()</span>
<span class="s">color2html = new Expando()</span>
<span class="s">colors.each { c -&gt;</span>
<span class="s">    color2html[c] = { args -&gt; &quot;&lt;FONT COLOR=&#39;$c&#39;&gt;$args&lt;/</span><span class="n">FONT</span><span class="o">&gt;</span><span class="s2">&quot; }</span>
<span class="s2">}</span>
<span class="s2">println color2html.yellow(&#39;error&#39;)</span>
<span class="s2">// =&gt; &lt;FONT COLOR=&#39;yellow&#39;&gt;error&lt;/FONT&gt;</span>
<span class="s2">color2html.yellow = { args -&gt; &quot;</span><span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span><span class="n">$args</span><span class="o">&lt;</span><span class="s">/b&gt;&quot; } // too hard to see yellow</span>
<span class="s">println color2html.yellow(&#39;error&#39;)</span>
<span class="s">// =&gt; &lt;b&gt;error&lt;/</span><span class="n">b</span><span class="o">&gt;</span>

<span class="c1">// Other approaches:</span>
<span class="c1">// you could use invokeMethod to intercept the original method and call</span>
<span class="c1">// your modified method on just particular input data</span>
<span class="c1">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN581"
>Trapping Undefined Function Calls with AUTOLOAD</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">//----------------------------------------------------------------------------------</span>
<span class="c1">// Trapping Undefined Function Calls</span>
<span class="kd">class</span> <span class="nc">FontHelper</span> <span class="o">{</span>
    <span class="c1">// we could define all the important colors explicitly like this</span>
    <span class="kt">def</span> <span class="nf">pink</span><span class="o">(</span><span class="n">info</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buildFont</span><span class="o">(</span><span class="s1">&#39;hot pink&#39;</span><span class="o">,</span> <span class="n">info</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="c1">// but this method will catch any undefined ones</span>
    <span class="kt">def</span> <span class="nf">invokeMethod</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buildFont</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">args</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s1">&#39; and &#39;</span><span class="o">))</span>
    <span class="o">}</span>
    <span class="kt">def</span> <span class="nf">buildFont</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">info</span><span class="o">)</span> <span class="o">{</span>
        <span class="s2">&quot;&lt;FONT COLOR=&#39;$name&#39;&gt;&quot;</span> <span class="o">+</span> <span class="n">info</span> <span class="o">+</span> <span class="s2">&quot;&lt;/FONT&gt;&quot;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">fh</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FontHelper</span><span class="o">()</span>
<span class="n">println</span> <span class="n">fh</span><span class="o">.</span><span class="na">pink</span><span class="o">(</span><span class="s2">&quot;panther&quot;</span><span class="o">)</span>
<span class="n">println</span> <span class="n">fh</span><span class="o">.</span><span class="na">chartreuse</span><span class="o">(</span><span class="s2">&quot;stuff&quot;</span><span class="o">,</span> <span class="s2">&quot;more stuff&quot;</span><span class="o">)</span>
<span class="c1">// =&gt;</span>
<span class="c1">// &lt;FONT COLOR=&#39;hot pink&#39;&gt;panther&lt;/FONT&gt;</span>
<span class="c1">// &lt;FONT COLOR=&#39;chartreuse&#39;&gt;stuff and more stuff&lt;/FONT&gt;</span>
<span class="c1">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN584"
>Nesting Subroutines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">//----------------------------------------------------------------------------------</span>
<span class="c1">// Simulating Nested Subroutimes: Using Closures within Methods</span>
<span class="kt">def</span> <span class="nf">outer</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">def</span> <span class="n">x</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">35</span>
    <span class="n">inner</span> <span class="o">=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">19</span> <span class="o">}</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">inner</span><span class="o">()</span>
<span class="o">}</span>
<span class="k">assert</span> <span class="nf">outer</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span> <span class="o">==</span> <span class="mi">900</span>
<span class="c1">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN587"
>Program: Sorting Your Mail</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">//----------------------------------------------------------------------------------</span>
<span class="c1">// Program: Sorting Your Mail</span>
<span class="err">#</span><span class="o">!</span><span class="s">/usr/</span><span class="n">bin</span><span class="s">/groovy</span>
<span class="s">import javax.mail.*</span>

<span class="s">// solution using mstor package (mstor.sf.net)</span>
<span class="s">session = Session.getDefaultInstance(new Properties())</span>
<span class="s">store = session.getStore(new URLName(&#39;mstor:/</span><span class="n">path_to_your_mbox_directory</span><span class="s1">&#39;))</span>
<span class="s1">store.connect()</span>

<span class="s1">// read messages from Inbox</span>
<span class="s1">inbox = store.defaultFolder.getFolder(&#39;</span><span class="n">Inbox</span><span class="s1">&#39;)</span>
<span class="s1">inbox.open(Folder.READ_ONLY)</span>
<span class="s1">messages = inbox.messages.toList()</span>

<span class="s1">// extractor closures</span>
<span class="s1">subject = { m -&gt; m.subject }</span>
<span class="s1">subjectExcludingReplyPrefix = { m -&gt; subject(m).replaceAll(/(?i)Re:\\s*/,&#39;&#39;) } // double slash to single outside triple quotes</span>
<span class="s1">date = { m -&gt; d = m.sentDate; new Date(d.year, d.month, d.date) } // ignore time fields</span>

<span class="s1">// sort by subject excluding &#39;</span><span class="nl">Re:</span><span class="s1">&#39; prefixs then print subject for first 6</span>
<span class="s1">println messages.sort{subjectExcludingReplyPrefix(it)}[0..5]*.subject.join(&#39;</span><span class="err">\</span><span class="n">n</span><span class="s1">&#39;)</span>
<span class="s1">// =&gt;</span>
<span class="s1">// Additional Resources for JDeveloper 10g (10.1.3)</span>
<span class="s1">// Amazon Web Services Developer Connection Newsletter #18</span>
<span class="s1">// Re: Ant 1.7.0?</span>
<span class="s1">// ARN Daily | 2007: IT predictions for the year ahead</span>
<span class="s1">// Big Changes at Gentleware</span>
<span class="s1">// BigPond Account Notification</span>

<span class="s1">// sort by date then subject (print first 6 entries)</span>
<span class="s1">sorted = messages.sort{ a,b -&gt;</span>
<span class="s1">    date(a) == date(b) ?</span>
<span class="s1">        subjectExcludingReplyPrefix(a) &lt;=&gt; subjectExcludingReplyPrefix(b) :</span>
<span class="s1">        date(a) &lt;=&gt; date(b)</span>
<span class="s1">}</span>
<span class="s1">sorted[0..5].each{ m -&gt; println &quot;$m.sentDate: $m.subject&quot; }</span>
<span class="s1">// =&gt;</span>
<span class="s1">// Wed Jan 03 08:54:15 EST 2007: ARN Daily | 2007: IT predictions for the year ahead</span>
<span class="s1">// Wed Jan 03 15:33:31 EST 2007: EclipseSource: RCP Adoption, Where Art Thou?</span>
<span class="s1">// Wed Jan 03 00:10:11 EST 2007: What&#39;</span><span class="n">s</span> <span class="n">New</span> <span class="n">at</span> <span class="n">Sams</span> <span class="n">Publishing</span><span class="o">?</span>
<span class="c1">// Fri Jan 05 08:31:11 EST 2007: Building a Sustainable Open Source Business</span>
<span class="c1">// Fri Jan 05 09:53:45 EST 2007: Call for Participation: Agile 2007</span>
<span class="c1">// Fri Jan 05 05:51:36 EST 2007: IBM developerWorks Weekly Edition, 4 January 2007</span>

<span class="c1">// group by date then print first 2 entries of first 2 dates</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">messages</span><span class="o">.</span><span class="na">groupBy</span><span class="o">{</span> <span class="n">date</span><span class="o">(</span><span class="n">it</span><span class="o">)</span> <span class="o">}</span>
<span class="n">groups</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">toList</span><span class="o">()[</span><span class="mi">0</span><span class="o">..</span><span class="mi">1</span><span class="o">].</span><span class="na">each</span><span class="o">{</span>
    <span class="n">println</span> <span class="n">it</span>
    <span class="n">println</span> <span class="n">groups</span><span class="o">[</span><span class="n">it</span><span class="o">][</span><span class="mi">0</span><span class="o">..</span><span class="mi">1</span><span class="o">].</span><span class="na">collect</span><span class="o">{</span> <span class="s1">&#39;    &#39;</span> <span class="o">+</span> <span class="n">it</span><span class="o">.</span><span class="na">subject</span> <span class="o">}.</span><span class="na">join</span><span class="o">(</span><span class="s1">&#39;\n&#39;</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// =&gt;</span>
<span class="c1">// Wed Jan 03 00:00:00 EST 2007</span>
<span class="c1">//     ARN Daily | 2007: IT predictions for the year ahead</span>
<span class="c1">//     EclipseSource: RCP Adoption, Where Art Thou?</span>
<span class="c1">// Fri Jan 05 00:00:00 EST 2007</span>
<span class="c1">//     Building a Sustainable Open Source Business</span>
<span class="c1">//     Call for Participation: Agile 2007</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Directories</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>References and Records</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>