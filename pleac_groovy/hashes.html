<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Hashes</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Groovy"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Arrays"
HREF="arrays.html"><LINK
REL="NEXT"
TITLE="Pattern Matching"
HREF="patternmatching.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Groovy</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="arrays.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="patternmatching.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="HASHES"
>5. Hashes</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN232"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// quotes are optional around the key</span>
<span class="s">age = [ Nat:24, Jules:25, Josh:17 ]</span>

<span class="s">assert age[&#39;Nat&#39;]  == 24</span>
<span class="s">// alternate syntax</span>
<span class="s">assert age.&quot;Jules&quot; == 25</span>

<span class="s">foodColor = [</span>
<span class="s">    Apple:  &#39;red&#39;,</span>
<span class="s">    Banana: &#39;yellow&#39;,</span>
<span class="s">    Lemon:  &#39;yellow&#39;,</span>
<span class="s">    Carrot: &#39;orange&#39;</span>
<span class="s">]</span>
<span class="s">assert foodColor.size() == 4</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN235"
>Adding an Element to a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">foodColor[&#39;Lemon&#39;] = &#39;green&#39;</span>
<span class="s">assert foodColor.size() == 4</span>
<span class="s">assert foodColor[&#39;Lemon&#39;] == &#39;green&#39;</span>
<span class="s">foodColor[&#39;Raspberry&#39;] = &#39;pink&#39;</span>
<span class="s">assert foodColor.size() == 5</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN238"
>Testing for the Presence of a Key in a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">assert [&#39;Banana&#39;, &#39;Martini&#39;].collect{ foodColor.containsKey(it)?&#39;food&#39;:&#39;drink&#39; } == [ &#39;food&#39;, &#39;drink&#39; ]</span>

<span class="s">age = [Toddler:3, Unborn:0, Phantasm:null]</span>
<span class="s">[&#39;Toddler&#39;, &#39;Unborn&#39;, &#39;Phantasm&#39;, &#39;Relic&#39;].each{ key -&gt;</span>
<span class="s">    print &quot;$key: &quot;</span>
<span class="s">    if (age.containsKey(key)) print &#39;has key &#39;</span>
<span class="s">    if (age.containsKey(key) &amp;&amp; age[key]!=null) print &#39;non-null &#39;</span>
<span class="s">    if (age.containsKey(key) &amp;&amp; age[key]) print &#39;true &#39;</span>
<span class="s">    println &#39;&#39;</span>
<span class="s">}</span>
<span class="s">// =&gt;</span>
<span class="s">// Toddler: has key non-null true</span>
<span class="s">// Unborn: has key non-null</span>
<span class="s">// Phantasm: has key</span>
<span class="s">// Relic:</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN241"
>Deleting from a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">assert foodColor.size() == 5</span>
<span class="s">foodColor.remove(&#39;Banana&#39;)</span>
<span class="s">assert foodColor.size() == 4</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN244"
>Traversing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">hash = [:]</span>
<span class="s">hash.each { key, value -&gt;</span>
<span class="s">    // do something with key and value</span>
<span class="s">}</span>

<span class="s">hash.each { entry -&gt;</span>
<span class="s">    // do something with entry</span>
<span class="s">}</span>

<span class="s">hash.keySet().each { key -&gt;</span>
<span class="s">    // do something with key</span>
<span class="s">}</span>

<span class="s">sb = new StringBuffer()</span>
<span class="s">foodColor.each { food, color -&gt;</span>
<span class="s">    sb &lt;&lt; &quot;$food is $color\n&quot;</span>
<span class="s">}</span>
<span class="s">assert &#39;\n&#39; + sb.toString() == &#39;&#39;&#39;</span>
<span class="s">Lemon is green</span>
<span class="s">Carrot is orange</span>
<span class="s">Apple is red</span>
<span class="s">Raspberry is pink</span>
<span class="s">&#39;&#39;&#39;</span>

<span class="s">foodColor.each { entry -&gt;</span>
<span class="s">    assert entry.key.size() &gt; 4 &amp;&amp; entry.value.size() &gt; 2</span>
<span class="s">}</span>

<span class="s">foodColorsSortedByFood = []</span>
<span class="s">foodColor.keySet().sort().each { k -&gt; foodColorsSortedByFood &lt;&lt; foodColor[k] }</span>
<span class="s">assert foodColorsSortedByFood == [&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;pink&quot;]</span>

<span class="s">fakedInput = &#39;&#39;&#39;</span>
<span class="s">From: someone@somewhere.com</span>
<span class="s">From: someone@spam.com</span>
<span class="s">From: someone@somewhere.com</span>
<span class="s">&#39;&#39;&#39;</span>

<span class="s">from = [:]</span>
<span class="s">fakedInput.split(&#39;\n&#39;).each{</span>
<span class="s">    matcher = (it =~ /^From:\s+([^\s&gt;]*)/)</span>
<span class="s">    if (matcher.matches()) {</span>
<span class="s">        sender = matcher[0][1]</span>
<span class="s">        if (from.containsKey(sender)) from[sender] += 1</span>
<span class="s">        else from[sender] = 1</span>
<span class="s">    }</span>
<span class="s">}</span>

<span class="s">// More useful to sort by number of received mail by person</span>
<span class="s">from.entrySet().sort { a,b -&gt; b.value&lt;=&gt;a.value}.each { e-&gt;</span>
<span class="s">    println &quot;${e.key}: ${e.value}&quot;</span>
<span class="s">}</span>
<span class="s">// =&gt;</span>
<span class="s">// someone@somewhere.com: 2</span>
<span class="s">// someone@spam.com: 1</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN247"
>Printing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">hash = [a:1, b:2, c:3]</span>
<span class="s">// Map#toString already produce a pretty decent output:</span>
<span class="s">println hash</span>
<span class="s">// =&gt; [&quot;b&quot;:2, &quot;a&quot;:1, &quot;c&quot;:3]</span>

<span class="s">// Or do it by longhand for customised formatting</span>
<span class="s">hash.each { k,v -&gt; println &quot;$k =&gt; $v&quot; }</span>
<span class="s">// =&gt;</span>
<span class="s">// b =&gt; 2</span>
<span class="s">// a =&gt; 1</span>
<span class="s">// c =&gt; 3</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN250"
>Retrieving from a Hash in Insertion Order</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// java.util.LinkedHashMap &quot;maintains a doubly-linked list running through all of its entries.</span>
<span class="s">// This linked list defines the iteration ordering, which is normally the order in which keys</span>
<span class="s">// were inserted into the map (insertion-order)&quot;.</span>
<span class="s">foodColor = new LinkedHashMap()</span>
<span class="s">foodColor[&#39;Banana&#39;] = &#39;Yellow&#39;</span>
<span class="s">foodColor[&#39;Apple&#39;] = &#39;Green&#39;</span>
<span class="s">foodColor[&#39;Lemon&#39;] = &#39;Yellow&#39;</span>

<span class="s">foodColor.keySet().each{ key -&gt; println key }</span>
<span class="s">// =&gt;</span>
<span class="s">// Banana</span>
<span class="s">// Apple</span>
<span class="s">// Lemon</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN253"
>Hashes with Multiple Values Per Key</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">foodsOfColor = [ Yellow:[&#39;Banana&#39;, &#39;Lemon&#39;], Green:[&#39;Apple&#39;] ]</span>
<span class="s">foodsOfColor[&#39;Green&#39;] += &#39;Melon&#39;</span>
<span class="s">assert foodsOfColor == [&quot;Green&quot;:[&quot;Apple&quot;, &quot;Melon&quot;], &quot;Yellow&quot;:[&quot;Banana&quot;, &quot;Lemon&quot;]]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN256"
>Inverting a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">surname = [Mickey: &#39;Mantle&#39;, Babe: &#39;Ruth&#39;]</span>
<span class="s">assert surname.findAll{ it.value == &#39;Mantle&#39; }.collect{ it.key } == [&quot;Mickey&quot;]</span>

<span class="s">firstname = [:]</span>
<span class="s">surname.each{ entry -&gt; firstname[entry.value] = entry.key }</span>
<span class="s">assert firstname == [&quot;Ruth&quot;:&quot;Babe&quot;, &quot;Mantle&quot;:&quot;Mickey&quot;]</span>

<span class="s">// foodfindScript:</span>
<span class="s">#!/usr/bin/groovy</span>
<span class="s">// usage: foodfind food_or_color&quot;</span>
<span class="s">color = [Apple:&#39;red&#39;, Banana:&#39;yellow&#39;, Lemon:&#39;yellow&#39;, Carrot:&#39;orange&#39;]</span>
<span class="s">given = args[0]</span>
<span class="s">if (color.containsKey(given))</span>
<span class="s">    println &quot;$given is a food with color ${color[given]}.&quot;</span>
<span class="s">if (color.containsValue(given)) {</span>
<span class="s">    // could use commify() here - see 4.2</span>
<span class="s">    foods = color.findAll{it.value == given}.collect{it.key}</span>
<span class="s">    join = foods.size() == 1 ? &#39;is a food&#39; : &#39;are foods&#39;</span>
<span class="s">    println &quot;${foods.join(&#39;, &#39;)} $join with color ${given}.&quot;</span>
<span class="s">}</span>
<span class="s">// foodfind red</span>
<span class="s">// =&gt; Apple is a food with color red.</span>
<span class="s">// foodfind yellow</span>
<span class="s">// =&gt; Lemon, Banana are foods with color yellow.</span>
<span class="s">// foodfind Carrot</span>
<span class="s">// =&gt; Carrot is a food with color orange.</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN259"
>Sorting a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">foodColor = [Apple:&#39;red&#39;, Carrot:&#39;orange&#39;, Banana:&#39;yellow&#39;, Cherry:&#39;black&#39;]</span>

<span class="s">// Sorted by keys</span>
<span class="s">assert foodColor.keySet().sort() == [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Carrot&quot;, &quot;Cherry&quot;]</span>
<span class="s">// you could now iterate through the hash with the sorted keys</span>
<span class="s">assert foodColor.values().sort() == [&quot;black&quot;, &quot;orange&quot;, &quot;red&quot;, &quot;yellow&quot;]</span>
<span class="s">assert foodColor.values().sort{it.size()} == [&quot;red&quot;, &quot;black&quot;, &quot;orange&quot;, &quot;yellow&quot;]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN262"
>Merging Hashes</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">//merged = a.clone.update(b)        # because Hash#update changes object in place</span>

<span class="s">drinkColor = [Galliano:&#39;yellow&#39;, &#39;Mai Tai&#39;:&#39;blue&#39;]</span>
<span class="s">ingestedColor = [:]</span>
<span class="s">ingestedColor.putAll(drinkColor)</span>
<span class="s">// overrides any common keys</span>
<span class="s">ingestedColor.putAll(foodColor)</span>

<span class="s">totalColors = ingestedColor.values().sort().unique()</span>
<span class="s">assert totalColors == [&quot;black&quot;, &quot;blue&quot;, &quot;orange&quot;, &quot;red&quot;, &quot;yellow&quot;]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN265"
>Finding Common or Different Keys in Two Hashes</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">foodColor[&#39;Lemon&#39;]=&#39;yellow&#39;</span>
<span class="s">citrusColor = [Lemon:&#39;yellow&#39;, Orange:&#39;orange&#39;, Lime:&#39;green&#39;]</span>
<span class="s">println foodColor</span>
<span class="s">println citrusColor</span>
<span class="s">common = foodColor.keySet().intersect(citrusColor.keySet())</span>
<span class="s">assert common == [&quot;Lemon&quot;]</span>

<span class="s">foodButNotCitrus = foodColor.keySet().toList() - citrusColor.keySet().toList()</span>
<span class="s">assert foodButNotCitrus == [&quot;Carrot&quot;, &quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN268"
>Hashing References</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// no problem here, Groovy handles any kind of object for key-ing</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN271"
>Presizing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// Groovy uses Java implementations for storing hashes and these</span>
<span class="s">// support setting an initial capacity and load factor (which determines</span>
<span class="s">// at what point the hash will be resized if needed)</span>
<span class="s">hash = [:]                              // Groovy shorthand gets defaults</span>
<span class="s">hash = new HashMap()                    // default capacity and load factor</span>
<span class="s">println hash.capacity()</span>
<span class="s">// =&gt; 16</span>
<span class="s">(&#39;A&#39;..&#39;Z&#39;).each{ hash[it] = it }</span>
<span class="s">println hash.capacity()</span>
<span class="s">// =&gt; 64</span>
<span class="s">hash = new HashMap(100)                 // initial capacity of 100 and default load factor</span>
<span class="s">hash = new HashMap(100, 0.8f)    // initial capacity of 100 and 0.8 load factor</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN274"
>Finding the Most Common Anything</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">count = [:]</span>
<span class="s">letters = []</span>
<span class="s">foodColor.values().each{ letters.addAll((it as String[]).toList()) }</span>
<span class="s">letters.each{ if (count.containsKey(it)) count[it] += 1 else count[it] = 1 }</span>
<span class="s">assert count == [&quot;o&quot;:3, &quot;d&quot;:1, &quot;k&quot;:1, &quot;w&quot;:2, &quot;r&quot;:2, &quot;c&quot;:1, &quot;l&quot;:5, &quot;g&quot;:1, &quot;b&quot;:1, &quot;a&quot;:2, &quot;y&quot;:2, &quot;n&quot;:1, &quot;e&quot;:4]</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN277"
>Representing Relationships Between Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">father = [</span>
<span class="s">    Cain:&#39;Adam&#39;,</span>
<span class="s">    Abel:&#39;Adam&#39;,</span>
<span class="s">    Seth:&#39;Adam&#39;,</span>
<span class="s">    Enoch:&#39;Cain&#39;,</span>
<span class="s">    Irad:&#39;Enoch&#39;,</span>
<span class="s">    Mehujael:&#39;Irad&#39;,</span>
<span class="s">    Methusael:&#39;Mehujael&#39;,</span>
<span class="s">    Lamech:&#39;Methusael&#39;,</span>
<span class="s">    Jabal:&#39;Lamech&#39;,</span>
<span class="s">    Jubal:&#39;Lamech&#39;,</span>
<span class="s">    Tubalcain:&#39;Lamech&#39;,</span>
<span class="s">    Enos:&#39;Seth&#39;</span>
<span class="s">]</span>

<span class="s">def upline(person) {</span>
<span class="s">    while (father.containsKey(person)) {</span>
<span class="s">        print person + &#39; &#39;</span>
<span class="s">        person = father[person]</span>
<span class="s">    }</span>
<span class="s">    println person</span>
<span class="s">}</span>

<span class="s">upline(&#39;Irad&#39;)</span>
<span class="s">// =&gt; Irad Enoch Cain Adam</span>

<span class="s">children = [:]</span>
<span class="s">father.each { k,v -&gt;</span>
<span class="s">    if (!children.containsKey(v)) children[v] = []</span>
<span class="s">    children[v] += k</span>
<span class="s">}</span>
<span class="s">def downline(person) {</span>
<span class="s">    println &quot;$person begat ${children.containsKey(person)?children[person].join(&#39;, &#39;):&#39;Nobody&#39;}.\n&quot;</span>
<span class="s">}</span>
<span class="s">downline(&#39;Tubalcain&#39;)</span>
<span class="s">// =&gt; Tubalcain begat Nobody.</span>
<span class="s">downline(&#39;Adam&#39;)</span>
<span class="s">// =&gt; Adam begat Abel, Seth, Cain.</span>

<span class="s">// This one doesn&#39;t recurse through subdirectories (as a simplification)</span>
<span class="s">// scriptToFindIncludeFilesWhichContainNoIncludesScript:</span>
<span class="s">dir = &#39;&lt;path_to_usr/include&gt;&#39;</span>
<span class="s">includes = [:]</span>
<span class="s">new File(dir).eachFile{ file -&gt;</span>
<span class="s">    if (file.directory) return</span>
<span class="s">    file.eachLine{ line -&gt;</span>
<span class="s">        matcher = (line =~ &#39;^\\s*#\\s*include\\s*&lt;([^&gt;]+)&gt;&#39;)</span>
<span class="s">        if (matcher.matches()) {</span>
<span class="s">            if (!includes.containsKey(file.name)) includes[file.name] = []</span>
<span class="s">            includes[file.name] += matcher[0][1]</span>
<span class="s">        }</span>
<span class="s">    }</span>
<span class="s">}</span>
<span class="s">// find referenced files which have no includes; assumes all files</span>
<span class="s">// were processed and none are missing</span>
<span class="s">println includes.values().sort().flatten().unique() - includes.keySet()</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN280"
>Program: dutree</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s"></span><span class="s">//----------------------------------------------------------------------------------</span>
<span class="s">// dutree - print sorted indented rendition of du output</span>
<span class="s">// obtaining this input is not shown, it is similar to other examples</span>
<span class="s">// on some unix systems it will be: duProcessFakedInput = &quot;du options&quot;.process().text</span>
<span class="s">duProcessFakedInput = &#39;&#39;&#39;</span>
<span class="s">11732   groovysoap/lib</span>
<span class="s">68      groovysoap/src/main/groovy/net/soap</span>
<span class="s">71      groovysoap/src/main/groovy/net</span>
<span class="s">74      groovysoap/src/main/groovy</span>
<span class="s">77      groovysoap/src/main</span>
<span class="s">9       groovysoap/src/examples</span>
<span class="s">8       groovysoap/src/examples/groovy</span>
<span class="s">102     groovysoap/src/test</span>
<span class="s">202     groovysoap/src</span>
<span class="s">11966   groovysoap</span>
<span class="s">&#39;&#39;&#39;</span>

<span class="s">// The DuNode class collects all information about a directory,</span>
<span class="s">class DuNode {</span>
<span class="s">    def name</span>
<span class="s">    def size</span>
<span class="s">    def kids = []</span>

<span class="s">    // support for sorting nodes with side</span>
<span class="s">    def compareTo(node2) { size &lt;=&gt; node2.size }</span>

<span class="s">    def getBasename() {</span>
<span class="s">        name.replaceAll(/.*\//, &#39;&#39;)</span>
<span class="s">    }</span>

<span class="s">    // returns substring before last &quot;/&quot;, otherwise null</span>
<span class="s">    def getParent() {</span>
<span class="s">        def p = name.replaceAll(/\/[^\/]+$/,&#39;&#39;)</span>
<span class="s">        return (p == name) ? null : p</span>
<span class="s">    }</span>
<span class="s">}</span>

<span class="s">// The DuTree does the actual work of</span>
<span class="s">// getting the input, parsing it, building up a tree</span>
<span class="s">// and formatting it for output</span>
<span class="s">class DuTree {</span>
<span class="s">    def input</span>
<span class="s">    def topdir</span>
<span class="s">    def nodes = [:]</span>
<span class="s">    def dirsizes = [:]</span>
<span class="s">    def kids = [:]</span>

<span class="s">    // get a node by name, create it if it does not exist yet</span>
<span class="s">    def getOrCreateNode(name) {</span>
<span class="s">        if (!nodes.containsKey(name))</span>
<span class="s">            nodes[name] = new DuNode(name:name)</span>
<span class="s">        return nodes[name]</span>
<span class="s">    }</span>

<span class="s">    // figure out how much is taken in each directory</span>
<span class="s">    // that isn&#39;t stored in the subdirectories. Add a new</span>
<span class="s">    // fake kid called &quot;.&quot; containing that much.</span>
<span class="s">    def getDots(node) {</span>
<span class="s">        def cursize = node.size</span>
<span class="s">        for (kid in node.kids) {</span>
<span class="s">            cursize -=  kid.size</span>
<span class="s">            getDots(kid)</span>
<span class="s">        }</span>
<span class="s">        if (node.size != cursize) {</span>
<span class="s">            def newnode = getOrCreateNode(node.name + &quot;/.&quot;)</span>
<span class="s">            newnode.size = cursize</span>
<span class="s">            node.kids += newnode</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    def processInput() {</span>
<span class="s">        def name = &#39;&#39;</span>
<span class="s">        input.split(&#39;\n&#39;).findAll{it.trim()}.each{ line -&gt;</span>
<span class="s">            def tokens = line.tokenize()</span>
<span class="s">            def size = tokens[0]</span>
<span class="s">            name = tokens[1]</span>
<span class="s">            def node = getOrCreateNode(name)</span>
<span class="s">            node.size = size.toInteger()</span>
<span class="s">            nodes[name] = node</span>
<span class="s">            def parent = node.parent</span>
<span class="s">            if (parent)</span>
<span class="s">                getOrCreateNode(parent).kids &lt;&lt; node</span>
<span class="s">        }</span>
<span class="s">        topdir = nodes[name]</span>
<span class="s">    }</span>

<span class="s">    // recursively output everything</span>
<span class="s">    // passing padding and number width as well</span>
<span class="s">    // on recursive calls</span>
<span class="s">    def output(node, prefix=&#39;&#39;, width=0) {</span>
<span class="s">        def line = node.size.toString().padRight(width) + &#39; &#39; + node.basename</span>
<span class="s">        println (prefix + line)</span>
<span class="s">        prefix += line.replaceAll(/\d /, &#39;| &#39;)</span>
<span class="s">        prefix = prefix.replaceAll(/[^|]/, &#39; &#39;)</span>
<span class="s">        if (node.kids.size() &gt; 0) {    // not a bachelor node</span>
<span class="s">            kids = node.kids</span>
<span class="s">            kids.sort{ a,b -&gt; b.compareTo(a) }</span>
<span class="s">            width = kids[0].size.toString().size()</span>
<span class="s">            for (kid in kids) output(kid, prefix, width)</span>
<span class="s">        }</span>
<span class="s">    }</span>
<span class="s">}</span>

<span class="s">tree = new DuTree(input:duProcessFakedInput)</span>
<span class="s">tree.processInput()</span>
<span class="s">tree.getDots(tree.topdir)</span>
<span class="s">tree.output(tree.topdir)</span>
<span class="s">// =&gt;</span>
<span class="s">// 11966 groovysoap</span>
<span class="s">//     |           11732 lib</span>
<span class="s">//     |           202   src</span>
<span class="s">//     |             |      102 test</span>
<span class="s">//     |             |      77  main</span>
<span class="s">//     |             |       |      74 groovy</span>
<span class="s">//     |             |       |       |       71 net</span>
<span class="s">//     |             |       |       |        |    68 soap</span>
<span class="s">//     |             |       |       |        |    3  .</span>
<span class="s">//     |             |       |       |       3  .</span>
<span class="s">//     |             |       |      3  .</span>
<span class="s">//     |             |      14  .</span>
<span class="s">//     |             |      9   examples</span>
<span class="s">//     |             |      |           8 groovy</span>
<span class="s">//     |             |      |           1 .</span>
<span class="s">//     |           32    .</span>
<span class="s">//----------------------------------------------------------------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="arrays.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="patternmatching.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Arrays</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Pattern Matching</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>