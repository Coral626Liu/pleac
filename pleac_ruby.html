<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=latin1">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span class="c1"># -*- ruby -*-</span>

<span class="c1"># Local variables:</span>
<span class="c1">#  indent-tabs-mode: nil</span>
<span class="c1">#  ruby-indent-level: 4</span>
<span class="c1"># End:</span>

<span class="c1"># @@PLEAC@@_NAME</span>
<span class="c1"># @@SKIP@@ Ruby</span>

<span class="c1"># @@PLEAC@@_WEB</span>
<span class="c1"># @@SKIP@@ http://www.ruby-lang.org</span>


<span class="c1"># @@PLEAC@@_1.0</span>
<span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;\n&#39;</span>                     <span class="c1"># two characters, \ and an n</span>
<span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;Jon \&#39;Maddog\&#39; Orwant&#39;</span>  <span class="c1"># literal single quotes</span>

<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>                     <span class="c1"># a &quot;newline&quot; character</span>
<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Jon </span><span class="se">\&quot;</span><span class="s2">Maddog</span><span class="se">\&quot;</span><span class="s2"> Orwant&quot;</span>  <span class="c1"># literal double quotes</span>

<span class="n">string</span> <span class="o">=</span> <span class="sx">%q/Jon &#39;Maddog&#39; Orwant/</span>  <span class="c1"># literal single quotes</span>

<span class="n">string</span> <span class="o">=</span> <span class="sx">%q[Jon &#39;Maddog&#39; Orwant]</span>  <span class="c1"># literal single quotes</span>
<span class="n">string</span> <span class="o">=</span> <span class="sx">%q{Jon &#39;Maddog&#39; Orwant}</span>  <span class="c1"># literal single quotes</span>
<span class="n">string</span> <span class="o">=</span> <span class="sx">%q(Jon &#39;Maddog&#39; Orwant)</span>  <span class="c1"># literal single quotes</span>
<span class="n">string</span> <span class="o">=</span> <span class="sx">%q&lt;Jon &#39;Maddog&#39; Orwant&gt;</span>  <span class="c1"># literal single quotes</span>

<span class="n">a</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="sh">&quot;</span><span class="no">EOF</span><span class="sh">&quot;</span>
<span class="sh">This is a multiline here document</span>
<span class="sh">terminated by EOF on a line by itself</span>
<span class="no">EOF</span>


<span class="c1"># @@PLEAC@@_1.1</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">string</span><span class="o">[</span><span class="n">offset</span><span class="p">,</span><span class="n">count</span><span class="o">]</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">string</span><span class="o">[</span><span class="n">offset</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>

<span class="n">string</span><span class="o">[</span><span class="n">offset</span><span class="p">,</span><span class="n">count</span><span class="o">]</span> <span class="o">=</span> <span class="n">newstring</span>
<span class="n">string</span><span class="o">[</span><span class="n">offset</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>   <span class="o">=</span> <span class="n">newtail</span>

<span class="c1"># in Ruby we can also specify intervals by their two offsets</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">string</span><span class="o">[</span><span class="n">offset</span><span class="o">.</span><span class="n">.offs2</span><span class="o">]</span>
<span class="n">string</span><span class="o">[</span><span class="n">offset</span><span class="o">.</span><span class="n">.offs2</span><span class="o">]</span> <span class="o">=</span> <span class="n">newstring</span>

<span class="n">leading</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">trailing</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;A5 x3 A8 A8 A*&quot;</span><span class="p">)</span>

<span class="n">fivers</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;A5&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="mi">5</span><span class="p">))</span>

<span class="n">chars</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;A1&quot;</span> <span class="o">*</span> <span class="n">string</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;This is what you have&quot;</span>
<span class="c1">#        +012345678901234567890  Indexing forwards  (left to right)</span>
<span class="c1">#         109876543210987654321- Indexing backwards (right to left)</span>
<span class="c1">#          note that 0 means 10 or 20, etc. above</span>

<span class="n">first</span>  <span class="o">=</span> <span class="n">string</span><span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span>       <span class="c1"># &quot;T&quot;</span>
<span class="n">start</span>  <span class="o">=</span> <span class="n">string</span><span class="o">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="o">]</span>       <span class="c1"># &quot;is&quot;</span>
<span class="n">rest</span>   <span class="o">=</span> <span class="n">string</span><span class="o">[</span><span class="mi">13</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>     <span class="c1"># &quot;you have&quot;</span>
<span class="n">last</span>   <span class="o">=</span> <span class="n">string</span><span class="o">[-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span>      <span class="c1"># &quot;e&quot;</span>
<span class="n">end_</span>   <span class="o">=</span> <span class="n">string</span><span class="o">[-</span><span class="mi">4</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>     <span class="c1"># &quot;have&quot;</span>
<span class="n">piece</span>  <span class="o">=</span> <span class="n">string</span><span class="o">[-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>      <span class="c1"># &quot;you&quot;</span>

<span class="n">string</span><span class="o">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;wasn&#39;t&quot;</span>     <span class="c1"># change &quot;is&quot; to &quot;wasn&#39;t&quot;</span>
<span class="n">string</span><span class="o">[-</span><span class="mi">12</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;ondrous&quot;</span> <span class="c1"># &quot;This wasn&#39;t wondrous&quot;</span>
<span class="n">string</span><span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>           <span class="c1"># delete first character</span>
<span class="n">string</span><span class="o">[-</span><span class="mi">10</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>  <span class="o">=</span> <span class="s2">&quot;&quot;</span>       <span class="c1"># delete last 10 characters</span>

<span class="k">if</span> <span class="n">string</span><span class="o">[-</span><span class="mi">10</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=~</span> <span class="sr">/pattern/</span>
    <span class="nb">puts</span> <span class="s2">&quot;Pattern matches in last 10 characters&quot;</span>
<span class="k">end</span>

<span class="n">string</span><span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="o">].</span><span class="n">gsub!</span><span class="p">(</span><span class="sr">/is/</span><span class="p">,</span> <span class="s1">&#39;at&#39;</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;make a hat&quot;</span>
<span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="n">a</span><span class="o">[-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;To be or not to be&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;x6 A6&quot;</span><span class="p">)</span>

<span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;x6 A2 X5 A2&quot;</span><span class="p">)</span>
<span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">b</span><span class="si">}</span><span class="se">\n</span><span class="si">#{</span><span class="n">c</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="k">def</span> <span class="nf">cut2fmt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="n">template</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">lastpos</span>  <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">place</span> <span class="k">in</span> <span class="n">args</span>
        <span class="n">template</span> <span class="o">+=</span> <span class="s2">&quot;A&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="n">place</span> <span class="o">-</span> <span class="n">lastpos</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
        <span class="n">lastpos</span>   <span class="o">=</span> <span class="n">place</span>
    <span class="k">end</span>
    <span class="n">template</span> <span class="o">+=</span> <span class="s2">&quot;A*&quot;</span>
    <span class="k">return</span> <span class="n">template</span>
<span class="k">end</span>

<span class="n">fmt</span> <span class="o">=</span> <span class="n">cut2fmt</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>


<span class="c1"># @@PLEAC@@_1.2</span>
<span class="c1"># careful! &quot;b is true&quot; doesn&#39;t mean &quot;b != 0&quot; (0 is true in Ruby)</span>
<span class="c1"># thus no problem of &quot;defined&quot; later since only nil is false</span>
<span class="c1"># the following sets to `c&#39; if `b&#39; is nil or false</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">||</span> <span class="n">c</span>

<span class="c1"># if you need Perl&#39;s behaviour (setting to `c&#39; if `b&#39; is 0) the most</span>
<span class="c1"># effective way is to use Numeric#nonzero? (thanks to Dave Thomas!)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">nonzero?</span> <span class="o">||</span> <span class="n">c</span>

<span class="c1"># you will still want to use defined? in order to test</span>
<span class="c1"># for scope existence of a given object</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">defined?</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">?</span> <span class="n">b</span> <span class="p">:</span> <span class="n">c</span>

<span class="n">dir</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">shift</span> <span class="o">||</span> <span class="s2">&quot;/tmp&quot;</span>


<span class="c1"># @@PLEAC@@_1.3</span>
<span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v1</span>

<span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">production</span> <span class="o">=</span> <span class="sx">%w(January March August)</span>
<span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">production</span> <span class="o">=</span> <span class="n">beta</span><span class="p">,</span> <span class="n">production</span><span class="p">,</span> <span class="n">alpha</span>


<span class="c1"># @@PLEAC@@_1.4</span>
<span class="n">num</span> <span class="o">=</span> <span class="n">char</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
<span class="n">char</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">chr</span>

<span class="c1"># Ruby also supports having a char from character constant</span>
<span class="n">num</span> <span class="o">=</span> <span class="sc">?r</span>

<span class="n">char</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">(</span><span class="s2">&quot;%c&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
<span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;Number %d is character %c</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

<span class="n">ascii</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;C*&quot;</span><span class="p">)</span>
<span class="n">string</span> <span class="o">=</span> <span class="n">ascii</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;C*&quot;</span><span class="p">)</span>

<span class="n">hal</span> <span class="o">=</span> <span class="s2">&quot;HAL&quot;</span>
<span class="n">ascii</span> <span class="o">=</span> <span class="n">hal</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;C*&quot;</span><span class="p">)</span>
<span class="c1"># We can&#39;t use Array#each since we can&#39;t mutate a Fixnum</span>
<span class="n">ascii</span><span class="o">.</span><span class="n">collect!</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>                         <span class="c1"># add one to each ASCII value</span>
<span class="p">}</span>                
<span class="n">ibm</span> <span class="o">=</span> <span class="n">ascii</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;C*&quot;</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">ibm</span>


<span class="c1"># @@PLEAC@@_1.5</span>
<span class="n">array</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

<span class="n">array</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;C*&quot;</span><span class="p">)</span>

<span class="n">string</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/./</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">b</span><span class="o">|</span>
    <span class="c1"># do something with b</span>
<span class="p">}</span>

<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;an apple a day&quot;</span>
<span class="nb">print</span> <span class="s2">&quot;unique chars are: &quot;</span><span class="p">,</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">uniq</span><span class="o">.</span><span class="n">sort</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">ascval</span> <span class="k">in</span> <span class="n">string</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;C*&quot;</span><span class="p">)</span> <span class="c1"># or use Array#each for a pure OO style :)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">ascval</span>
<span class="k">end</span>
<span class="nb">puts</span> <span class="s2">&quot;sum is </span><span class="si">#{</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="si">}</span><span class="s2">&quot;</span> <span class="c1"># since Ruby will go Bignum if necessary</span>

<span class="c1"># <font size="-1"><a href="http://pleac.sourceforge.net/include/ruby/slowcat.rb</span>">download the following standalone program</a></font>
<span class="c1">#!/usr/bin/ruby</span>
<span class="c1"># slowcat - emulate a   s l o w   line printer</span>
<span class="c1"># usage: slowcat [-DELAY] [files ...]</span>
<span class="c1"># the following line with &quot;&amp;&amp;&quot; works because all strings are true</span>
<span class="n">delay</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=~</span> <span class="sr">/^-([.\d]+)/</span> <span class="p">?</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">shift</span> <span class="o">&amp;&amp;</span> <span class="vg">$1</span><span class="o">.</span><span class="n">to_i</span> <span class="p">:</span> <span class="mi">1</span>
<span class="vg">$stdout</span><span class="o">.</span><span class="n">sync</span> <span class="o">=</span> <span class="kp">true</span>
<span class="k">while</span> <span class="nb">gets</span>
    <span class="k">for</span> <span class="n">b</span> <span class="k">in</span> <span class="nb">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span> <span class="n">b</span>
        <span class="nb">sleep</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mo">005</span> <span class="o">*</span> <span class="n">delay</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>



<span class="c1"># @@PLEAC@@_1.6</span>
<span class="n">revbytes</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">reverse</span>

<span class="n">revwords</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

<span class="n">revwords</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sr">/(\s+)/</span><span class="p">)</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">join</span>

<span class="c1"># using the fact that IO is Enumerable, you can directly &quot;select&quot; it</span>
<span class="n">long_palindromes</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;/usr/share/dict/words&quot;</span><span class="p">)</span><span class="o">.</span>
    <span class="nb">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">w</span><span class="o">|</span> <span class="n">w</span><span class="o">.</span><span class="n">chomp!</span><span class="p">;</span> <span class="n">w</span><span class="o">.</span><span class="n">reverse</span> <span class="o">==</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">}</span>


<span class="c1"># @@PLEAC@@_1.7</span>
<span class="k">while</span> <span class="n">string</span><span class="o">.</span><span class="n">sub!</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">+&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="vg">$&amp;</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">-</span> <span class="vg">$`</span><span class="o">.</span><span class="n">length</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>


<span class="c1"># @@PLEAC@@_1.8</span>
<span class="s1">&#39;You owe #{debt} to me&#39;</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/\</span><span class="si">#{</span><span class="p">(\</span><span class="n">w</span><span class="o">+</span><span class="p">)</span><span class="si">}</span><span class="sr">/</span><span class="p">)</span> <span class="p">{</span> <span class="nb">eval</span><span class="p">(</span><span class="vg">$1</span><span class="p">)</span> <span class="p">}</span>

<span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">80</span>
<span class="n">text</span> <span class="o">=</span> <span class="sx">%q(I am #{rows} high and #{cols} long)</span>
<span class="n">text</span><span class="o">.</span><span class="n">gsub!</span><span class="p">(</span><span class="sr">/\</span><span class="si">#{</span><span class="p">(\</span><span class="n">w</span><span class="o">+</span><span class="p">)</span><span class="si">}</span><span class="sr">/</span><span class="p">)</span> <span class="p">{</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="vg">$1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="n">text</span>

<span class="s1">&#39;I am 17 years old&#39;</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/\d+/</span><span class="p">)</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="vg">$&amp;</span><span class="o">.</span><span class="n">to_i</span> <span class="p">}</span>


<span class="c1"># @@PLEAC@@_1.9</span>
<span class="n">e</span> <span class="o">=</span> <span class="s2">&quot;bo peep&quot;</span><span class="o">.</span><span class="n">upcase</span>
<span class="n">e</span><span class="o">.</span><span class="n">downcase!</span>
<span class="n">e</span><span class="o">.</span><span class="n">capitalize!</span>

<span class="s2">&quot;thIS is a loNG liNE&quot;</span><span class="o">.</span><span class="n">gsub!</span><span class="p">(</span><span class="sr">/\w+/</span><span class="p">)</span> <span class="p">{</span> <span class="vg">$&amp;</span><span class="o">.</span><span class="n">capitalize</span> <span class="p">}</span>


<span class="c1"># @@PLEAC@@_1.10</span>
<span class="s2">&quot;I have </span><span class="si">#{</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> guanacos.&quot;</span>
<span class="nb">print</span> <span class="s2">&quot;I have &quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot; guanacos.&quot;</span>


<span class="c1"># @@PLEAC@@_1.11</span>
<span class="n">var</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="sh">&#39;</span><span class="no">EOF</span><span class="sh">&#39;</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/^\s+/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="sh">    your text</span>
<span class="sh">    goes here</span>
<span class="no">EOF</span>


<span class="c1"># @@PLEAC@@_1.12</span>
<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Folding and splicing is the work of an editor,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span>
    <span class="s2">&quot;not a mere collection of silicon</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span> 
    <span class="s2">&quot;and</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span>
    <span class="s2">&quot;mobile electrons!&quot;</span>

<span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">max_size</span><span class="p">)</span>
    <span class="n">all</span> <span class="o">=</span> <span class="o">[]</span>
    <span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">l</span> <span class="k">in</span> <span class="n">str</span><span class="o">.</span><span class="n">split</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="o">+</span><span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="n">max_size</span>
            <span class="n">all</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">end</span>
        <span class="n">line</span> <span class="o">+=</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="p">?</span> <span class="n">l</span> <span class="p">:</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">l</span>
    <span class="k">end</span>
    <span class="n">all</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="nb">print</span> <span class="n">wrap</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="c1">#=&gt; Folding and </span>
<span class="c1">#=&gt; splicing is the </span>
<span class="c1">#=&gt; work of an editor, </span>
<span class="c1">#=&gt; not a mere </span>
<span class="c1">#=&gt; collection of </span>
<span class="c1">#=&gt; silicon and mobile </span>
<span class="c1">#=&gt; electrons!</span>


<span class="c1"># @@PLEAC@@_1.13</span>
<span class="n">string</span> <span class="o">=</span> <span class="sx">%q(Mom said, &quot;Don&#39;t do that.&quot;)</span>
<span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/[&#39;&quot;]/</span><span class="p">)</span> <span class="p">{</span> <span class="s1">&#39;\\&#39;</span><span class="o">+</span><span class="vg">$&amp;</span> <span class="p">}</span>
<span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/[&#39;&quot;]/</span><span class="p">,</span> <span class="s1">&#39;\&amp;\&amp;&#39;</span><span class="p">)</span>
<span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/[^A-Z]/</span><span class="p">)</span> <span class="p">{</span> <span class="s1">&#39;\\&#39;</span><span class="o">+</span><span class="vg">$&amp;</span> <span class="p">}</span>
<span class="s2">&quot;is a test!&quot;</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/\W/</span><span class="p">)</span> <span class="p">{</span> <span class="s1">&#39;\\&#39;</span><span class="o">+</span><span class="vg">$&amp;</span> <span class="p">}</span>  <span class="c1"># no function like quotemeta?</span>


<span class="c1"># @@PLEAC@@_1.14</span>
<span class="n">string</span><span class="o">.</span><span class="n">strip!</span>


<span class="c1"># @@PLEAC@@_1.15</span>
<span class="k">def</span> <span class="nf">parse_csv</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="kp">new</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/&quot;([^\&quot;\\]*(?:\\.[^\&quot;\\]*)*)&quot;,?|([^,]+),?|,/</span><span class="p">)</span>
    <span class="kp">new</span> <span class="o">&lt;&lt;</span> <span class="kp">nil</span> <span class="k">if</span> <span class="n">text</span><span class="o">[-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">?,</span>
    <span class="kp">new</span><span class="o">.</span><span class="n">flatten</span><span class="o">.</span><span class="n">compact</span>
<span class="k">end</span>  

<span class="n">line</span> <span class="o">=</span> <span class="sx">%q&lt;XYZZY,&quot;&quot;,&quot;O&#39;Reilly, Inc&quot;,&quot;Wall, Larry&quot;,&quot;a \&quot;glug\&quot; bit,&quot;,5,&quot;Error, Core Dumped&quot;&gt;</span>
<span class="n">fields</span> <span class="o">=</span> <span class="n">parse_csv</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<span class="n">fields</span><span class="o">.</span><span class="n">each_with_index</span> <span class="p">{</span> <span class="o">|</span><span class="n">v</span><span class="p">,</span><span class="n">i</span><span class="o">|</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2"> : </span><span class="si">#{</span><span class="n">v</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1"># @@PLEAC@@_1.16</span>
<span class="c1"># Use the soundex.rb Library from Michael Neumann.</span>
<span class="c1"># http://www.s-direktnet.de/homepages/neumann/rb_prgs/Soundex.rb</span>
<span class="nb">require</span> <span class="s1">&#39;Soundex&#39;</span>

<span class="n">code</span> <span class="o">=</span> <span class="ss">Text</span><span class="p">:</span><span class="ss">:Soundex</span><span class="o">.</span><span class="n">soundex</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="n">codes</span> <span class="o">=</span> <span class="ss">Text</span><span class="p">:</span><span class="ss">:Soundex</span><span class="o">.</span><span class="n">soundex</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

<span class="c1"># substitution function for getpwent():</span>
<span class="c1"># returns an array of user entries,</span>
<span class="c1"># each entry contains the username and the full name</span>
<span class="k">def</span> <span class="nf">login_names</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">[]</span>
    <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;/etc/passwd&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span>
        <span class="n">file</span><span class="o">.</span><span class="n">each_line</span> <span class="p">{</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
            <span class="k">next</span> <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sr">/^#/</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">[</span><span class="n">cols</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">cols</span><span class="o">[</span><span class="mi">4</span><span class="o">]]</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">result</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="s2">&quot;Lookup user: &quot;</span>
<span class="n">user</span> <span class="o">=</span> <span class="no">STDIN</span><span class="o">.</span><span class="n">gets</span>
<span class="n">user</span><span class="o">.</span><span class="n">chomp!</span>
<span class="nb">exit</span> <span class="k">unless</span> <span class="n">user</span>
<span class="n">name_code</span> <span class="o">=</span> <span class="ss">Text</span><span class="p">:</span><span class="ss">:Soundex</span><span class="o">.</span><span class="n">soundex</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

<span class="n">splitter</span> <span class="o">=</span> <span class="no">Regexp</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;(\w+)[^,]*\b(\w+)&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">username</span><span class="p">,</span> <span class="n">fullname</span> <span class="k">in</span> <span class="n">login_names</span> <span class="k">do</span>
    <span class="n">firstname</span><span class="p">,</span> <span class="n">lastname</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">]</span>
    <span class="k">if</span> <span class="n">name_code</span> <span class="o">==</span> <span class="ss">Text</span><span class="p">:</span><span class="ss">:Soundex</span><span class="o">.</span><span class="n">soundex</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
        <span class="o">||</span> <span class="n">name_code</span> <span class="o">==</span> <span class="ss">Text</span><span class="p">:</span><span class="ss">:Soundex</span><span class="o">.</span><span class="n">soundex</span><span class="p">(</span><span class="n">firstname</span><span class="p">)</span>
        <span class="o">||</span> <span class="n">name_code</span> <span class="o">==</span> <span class="ss">Text</span><span class="p">:</span><span class="ss">:Soundex</span><span class="o">.</span><span class="n">soundex</span><span class="p">(</span><span class="n">lastname</span><span class="p">)</span>
    <span class="k">then</span>
        <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">username</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">firstname</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">lastname</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">end</span>
<span class="k">end</span>


<span class="c1"># @@PLEAC@@_1.17</span>
<span class="c1"># <font size="-1"><a href="http://pleac.sourceforge.net/include/ruby/fixstyle.rb</span>">download the following standalone program</a></font>
<span class="c1"># fixstyle - switch first set of &lt;DATA&gt; strings to second set</span>
<span class="c1">#   usage: $0 [-v] [files ...]</span>
<span class="c1">#   -v = verbose  prints &quot;a-&gt;b in file line N&quot; for every change.</span>
<span class="c1"># If no filenames are given, than the script runs as simple filter,</span>
<span class="c1"># else the files are edited in place, and a safety copy</span>
<span class="c1"># with the exentions &quot;.orig&quot; is created</span>

<span class="c1"># Regular expressions are objects in ruby, we have control</span>
<span class="c1"># when we compile them, so we don&#39;t need the eval hack</span>
<span class="c1"># from the perl solution.</span>
<span class="c1"># The changer class encapsulates the regular expression</span>
<span class="c1"># and its substitution string</span>
<span class="k">class</span> <span class="nc">Changer</span>
    
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
        <span class="vi">@regex</span> <span class="o">=</span> <span class="no">Regexp</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
        <span class="vi">@subst</span> <span class="o">=</span> <span class="n">subst</span>
    <span class="k">end</span>
    
    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">gsub!</span><span class="p">(</span><span class="vi">@regex</span><span class="p">,</span> <span class="vi">@subst</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">changed</span> <span class="o">&amp;&amp;</span> <span class="vg">$verbose</span>
            <span class="vg">$stderr</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@regex</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2"> changed to </span><span class="si">#{</span><span class="vi">@subst</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="vg">$FILENAME</span><span class="si">}</span><span class="s2"> line </span><span class="si">#{</span><span class="vg">$.</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
    
<span class="k">end</span>

<span class="c1"># get the lines from the Data section at the end of the file</span>
<span class="c1"># and put them in the list of Changer objects</span>
<span class="k">def</span> <span class="nf">get_subs_from_end</span><span class="p">()</span>
    <span class="n">changelist</span> <span class="o">=</span> <span class="o">[]</span>
    <span class="no">DATA</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span>
        <span class="n">line</span><span class="o">.</span><span class="n">chomp!</span>
        <span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sr">/\s*=&gt;\s*/</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pat</span> <span class="o">&amp;&amp;</span> <span class="n">subst</span>
            <span class="n">changelist</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="no">Changer</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">subst</span><span class="p">))</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">changelist</span>
<span class="k">end</span>

<span class="n">changelist</span> <span class="o">=</span> <span class="n">get_subs_from_end</span><span class="p">()</span>

<span class="k">if</span> <span class="no">ARGV</span> <span class="o">&amp;&amp;</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="s2">&quot;-v&quot;</span>
    <span class="no">ARGV</span><span class="o">.</span><span class="n">shift</span>
    <span class="vg">$verbose</span> <span class="o">=</span> <span class="kp">true</span>
<span class="k">else</span>
    <span class="vg">$verbose</span> <span class="o">=</span> <span class="kp">false</span>
<span class="k">end</span>

<span class="k">if</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="vg">$-i</span> <span class="o">=</span> <span class="s2">&quot;.orig&quot;</span>     <span class="c1"># enables in-place edit mode</span>
<span class="k">elsif</span> <span class="nb">test</span><span class="p">(</span><span class="sc">?e</span><span class="p">,</span> <span class="vg">$stdin</span><span class="p">)</span>
    <span class="vg">$stderr</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="vg">$0</span><span class="si">}</span><span class="s2">:Reading from stdin&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">while</span> <span class="n">line</span> <span class="o">=</span> <span class="nb">gets</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">changer</span> <span class="k">in</span> <span class="n">changelist</span>
        <span class="n">changer</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="nb">puts</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<span class="k">end</span>

<span class="cp">__END__</span>

<span class="cp"># analysed  =&gt; analyzed</span>
<span class="cp"># build-in  =&gt; builtin</span>
<span class="cp"># chastized =&gt; chatis</span>
<span class="cp"># commandline     =&gt; command-line</span>
<span class="cp"># de-allocate     =&gt; deallocate</span>
<span class="cp"># dropin          =&gt; drop-in</span>
<span class="cp"># hardcode        =&gt; hard-code</span>
<span class="cp"># meta-data       =&gt; metadata</span>
<span class="cp"># multicharacter  =&gt; multi-character</span>
<span class="cp"># multiway        =&gt; multi-way</span>
<span class="cp"># non-empty       =&gt; nonempty</span>
<span class="cp"># non-profit      =&gt; nonprofit</span>
<span class="cp"># non-trappable   =&gt; nontrappable</span>
<span class="cp"># pre-define      =&gt; predefine</span>
<span class="cp"># preextend       =&gt; pre-extend</span>
<span class="cp"># re-compiling    =&gt; recompiling</span>
<span class="cp"># reenter         =&gt; re-enter</span>
<span class="cp"># turnkey         =&gt; turn-key</span>



<span class="cp"># @@PLEAC@@_1.18</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/ruby/psgrep.rb</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># </span>
<span class="cp"># psgrep - print selected lines of ps output by</span>
<span class="cp">#          compiling user queries into code</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;~/sh\b/&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;command =~ /sh$/&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;uid &lt; 10&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;command =~ /^-/&#39; &#39;tty ne &quot;?&quot;&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;tty =~ /^[p-t]/&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;uid &amp;&amp; tty eq &quot;?&quot;&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;size &gt; 10 * 2**10&#39; &#39;uid != 0&#39;</span>
<span class="cp">#-----------------------------</span>

<span class="cp">class PS</span>
<span class="cp">    PS::Names = %w-flags uid pid ppid pri nice size</span>
<span class="cp">                   rss wchan stat tty time command-</span>
<span class="cp">    PS::Names.each {|sym| attr_accessor sym}</span>
<span class="cp">    attr_accessor :line</span>
<span class="cp">    def set_fields</span>
<span class="cp">        fields = line.split(&quot; &quot;,13)</span>
<span class="cp">        PS::Names.each_with_index do |sym,i|</span>
<span class="cp">            eval &quot;self.#{sym} = &quot; + </span>
<span class="cp">                ((0..7).include?(i) ? fields[i] : &quot;&#39;#{fields[i]}&#39;&quot;)</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">raise &lt;&lt;USAGE unless ARGV.size &gt; 0</span>
<span class="cp">    usage: $0 criterion ...</span>
<span class="cp">     #{PS::Names.join(&quot; &quot;)}</span>
<span class="cp">    All criteria must be met for a line to be printed</span>
<span class="cp">USAGE</span>

<span class="cp">PS.class_eval &lt;&lt;CRITERIA </span>
<span class="cp">    def is_desirable</span>
<span class="cp">        $_ = line</span>
<span class="cp">        #{ARGV.join(&quot; and &quot;)}</span>
<span class="cp">     end</span>
<span class="cp">CRITERIA</span>

<span class="cp">ps = PS.new</span>
<span class="cp">File.popen(&quot;ps wwaxl&quot;) do |f|</span>
<span class="cp">    puts f.gets</span>
<span class="cp">    f.each do |ps.line|</span>
<span class="cp">        ps.set_fields</span>
<span class="cp">        print ps.line if ps.is_desirable</span>
<span class="cp">    end</span>
<span class="cp">end</span>



<span class="cp"># @@PLEAC@@_2.1</span>
<span class="cp"># Matz tells that you can use Integer() for strict checked conversion.</span>
<span class="cp">Integer(&quot;abc&quot;)</span>
<span class="cp">#=&gt; `Integer&#39;: invalid value for Integer: &quot;abc&quot; (ArgumentError)</span>
<span class="cp">Integer(&quot;567&quot;)</span>
<span class="cp">#=&gt; 567</span>

<span class="cp"># You may use Float() for floating point stuff</span>
<span class="cp">Integer(&quot;56.7&quot;)</span>
<span class="cp">#=&gt; `Integer&#39;: invalid value for Integer: &quot;56.7&quot; (ArgumentError)</span>
<span class="cp">Float(&quot;56.7&quot;)</span>
<span class="cp">#=&gt; 56.7</span>

<span class="cp"># You may also use a regexp for that</span>
<span class="cp">if string =~ /^[+-]?\d+$/</span>
<span class="cp">    p &#39;is an integer&#39;</span>
<span class="cp">else</span>
<span class="cp">    p &#39;is not&#39;</span>
<span class="cp">end</span>

<span class="cp">if string =~ /^-?(?:\d+(?:\.\d*)?|\.\d+)$/</span>
<span class="cp">    p &#39;is a decimal number&#39;</span>
<span class="cp">else</span>
<span class="cp">    p &#39;is not&#39;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_2.2</span>
<span class="cp"># equal(num1, num2, accuracy) : returns true if num1 and num2 are</span>
<span class="cp">#   equal to accuracy number of decimal places</span>
<span class="cp">def equal(i, j, a)</span>
<span class="cp">    sprintf(&quot;%.#{a}g&quot;, i) == sprintf(&quot;%.#{a}g&quot;, j)</span>
<span class="cp">end</span>

<span class="cp">wage = 536                        # $5.36/hour</span>
<span class="cp">week = 40 * wage                  # $214.40</span>
<span class="cp">printf(&quot;One week&#39;s wage is: \$%.2f\n&quot;, week/100.0)</span>


<span class="cp"># @@PLEAC@@_2.3</span>
<span class="cp">num.round                         # rounds to integer</span>

<span class="cp">a = 0.255</span>
<span class="cp">b = sprintf(&quot;%.2f&quot;, a)</span>
<span class="cp">print  &quot;Unrounded: #{a}\nRounded: #{b}\n&quot;</span>
<span class="cp">printf &quot;Unrounded: #{a}\nRounded: %.2f\n&quot;, a</span>

<span class="cp">print &quot;number\tint\tfloor\tceil\n&quot;</span>
<span class="cp">a = [ 3.3 , 3.5 , 3.7, -3.3 ]</span>
<span class="cp">for n in a</span>
<span class="cp">    printf(&quot;% .1f\t% .1f\t% .1f\t% .1f\n&quot;,  # at least I don&#39;t fake my output :)</span>
<span class="cp">           n, n.to_i, n.floor, n.ceil)</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_2.4</span>
<span class="cp">def dec2bin(n)</span>
<span class="cp">    [n].pack(&quot;N&quot;).unpack(&quot;B32&quot;)[0].sub(/^0+(?=\d)/, &#39;&#39;)</span>
<span class="cp">end</span>

<span class="cp">def bin2dec(n)</span>
<span class="cp">    [(&quot;0&quot;*32+n.to_s)[-32..-1]].pack(&quot;B32&quot;).unpack(&quot;N&quot;)[0]</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_2.5</span>
<span class="cp">for i in x .. y</span>
<span class="cp">    # i is set to every integer from x to y, inclusive</span>
<span class="cp">end</span>

<span class="cp">x.step(y,7) { |i|</span>
<span class="cp">    # i is set to every integer from x to y, stepsize = 7</span>
<span class="cp">}</span>

<span class="cp">print &quot;Infancy is: &quot;</span>
<span class="cp">(0..2).each { |i|</span>
<span class="cp">    print i, &quot; &quot;</span>
<span class="cp">}</span>
<span class="cp">print &quot;\n&quot;</span>


<span class="cp"># @@PLEAC@@_2.6</span>
<span class="cp"># We can add conversion methods to the Integer class,</span>
<span class="cp"># this makes a roman number just a representation for normal numbers.</span>
<span class="cp">class Integer</span>
<span class="cp">    </span>
<span class="cp">    @@romanlist = [[&quot;M&quot;, 1000],</span>
<span class="cp">                   [&quot;CM&quot;, 900],</span>
<span class="cp">                   [&quot;D&quot;,  500],</span>
<span class="cp">                   [&quot;CD&quot;, 400],</span>
<span class="cp">                   [&quot;C&quot;,  100],</span>
<span class="cp">                   [&quot;XC&quot;,  90],</span>
<span class="cp">                   [&quot;L&quot;,   50],</span>
<span class="cp">                   [&quot;XL&quot;,  40],</span>
<span class="cp">                   [&quot;X&quot;,   10],</span>
<span class="cp">                   [&quot;IX&quot;,   9],</span>
<span class="cp">                   [&quot;V&quot;,    5],</span>
<span class="cp">                   [&quot;IV&quot;,   4],</span>
<span class="cp">                   [&quot;I&quot;,    1]]</span>
<span class="cp">    </span>
<span class="cp">    def to_roman</span>
<span class="cp">        remains = self</span>
<span class="cp">        roman = &quot;&quot;</span>
<span class="cp">        for sym, num in @@romanlist</span>
<span class="cp">            while remains &gt;= num</span>
<span class="cp">                remains -= num</span>
<span class="cp">                roman &lt;&lt; sym</span>
<span class="cp">            end</span>
<span class="cp">        end</span>
<span class="cp">        roman</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def Integer.from_roman(roman)</span>
<span class="cp">        ustr = roman.upcase</span>
<span class="cp">        sum = 0</span>
<span class="cp">        for entry in @@romanlist</span>
<span class="cp">            sym, num = entry[0], entry[1]</span>
<span class="cp">            while sym == ustr[0, sym.length]</span>
<span class="cp">                sum += num</span>
<span class="cp">                ustr.slice!(0, sym.length)</span>
<span class="cp">            end</span>
<span class="cp">        end</span>
<span class="cp">        sum</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">end</span>


<span class="cp">roman_fifteen = 15.to_roman</span>
<span class="cp">puts &quot;Roman for fifteen is #{roman_fifteen}&quot;</span>
<span class="cp">i = Integer.from_roman(roman_fifteen)</span>
<span class="cp">puts &quot;Converted back, #{roman_fifteen} is #{i}&quot;</span>

<span class="cp"># check</span>
<span class="cp">for i in (1..3900)</span>
<span class="cp">    r = i.to_roman</span>
<span class="cp">    j = Integer.from_roman(r)</span>
<span class="cp">    if i != j</span>
<span class="cp">        puts &quot;error: #{i} : #{r} - #{j}&quot;</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_2.7</span>
<span class="cp">random = rand(y-x+1)+x</span>

<span class="cp">chars = [&quot;A&quot;..&quot;Z&quot;,&quot;a&quot;..&quot;z&quot;,&quot;0&quot;..&quot;9&quot;].collect { |r| r.to_a }.join + %q(!@$%^&amp;*)</span>
<span class="cp">password = (1..8).collect { chars[rand(chars.size)] }.pack(&quot;C*&quot;)</span>


<span class="cp"># @@PLEAC@@_2.8</span>
<span class="cp">srand        # uses a combination of the time, the process id, and a sequence number</span>
<span class="cp">srand(val)   # for repeatable behaviour</span>


<span class="cp"># @@PLEAC@@_2.9</span>
<span class="cp"># from the randomr lib: </span>
<span class="cp"># http://raa.ruby-lang.org/project/randomr/</span>
<span class="cp">----&gt; http://raa.ruby-lang.org/project/randomr/</span>

<span class="cp">require &#39;random/mersenne_twister&#39;</span>
<span class="cp">mers = Random::MersenneTwister.new 123456789</span>
<span class="cp">puts mers.rand(0)    # 0.550321932544541</span>
<span class="cp">puts mers.rand(10)   # 2</span>

<span class="cp"># using online sources of random data via the realrand package:</span>
<span class="cp"># http://raa.ruby-lang.org/project/realrand/</span>
<span class="cp"># **Note**</span>
<span class="cp"># The following online services are used in this package:</span>
<span class="cp">#   http://www.random.org - source: atmospheric noise </span>
<span class="cp">#   http://www.fourmilab.ch/hotbits - source: radioactive decay timings</span>
<span class="cp">#   http://random.hd.org - source: entropy from local and network noise</span>
<span class="cp"># Please visit the sites and respect the rules of each service.</span>

<span class="cp">require &#39;random/online&#39;</span>

<span class="cp">generator1 = Random::RandomOrg.new</span>
<span class="cp">puts generator1.randbyte(5).join(&quot;,&quot;)</span>
<span class="cp">puts generator1.randnum(10, 1, 6).join(&quot;,&quot;)  # Roll dice 10 times.</span>

<span class="cp">generator2 = Random::FourmiLab.new</span>
<span class="cp">puts generator2.randbyte(5).join(&quot;,&quot;)</span>
<span class="cp"># randnum is not supported.</span>

<span class="cp">generator3 = Random::EntropyPool.new</span>
<span class="cp">puts generator3.randbyte(5).join(&quot;,&quot;)</span>
<span class="cp"># randnum is not supported.</span>


<span class="cp"># @@PLEAC@@_2.10</span>
<span class="cp">def gaussian_rand</span>
<span class="cp">    begin</span>
<span class="cp">        u1 = 2 * rand() - 1</span>
<span class="cp">        u2 = 2 * rand() - 1</span>
<span class="cp">        w = u1*u1 + u2*u2</span>
<span class="cp">    end while (w &gt;= 1)</span>
<span class="cp">    w = Math.sqrt((-2*Math.log(w))/w)</span>
<span class="cp">    [ u2*w, u1*w ]</span>
<span class="cp">end</span>

<span class="cp">mean = 25</span>
<span class="cp">sdev = 2</span>
<span class="cp">salary = gaussian_rand[0] * sdev + mean</span>
<span class="cp">printf(&quot;You have been hired at \$%.2f\n&quot;, salary)</span>


<span class="cp"># @@PLEAC@@_2.11</span>
<span class="cp">def deg2rad(d)</span>
<span class="cp">    (d/180.0)*Math::PI</span>
<span class="cp">end</span>

<span class="cp">def rad2deg(r)</span>
<span class="cp">    (r/Math::PI)*180</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_2.12</span>
<span class="cp">sin_val = Math.sin(angle)</span>
<span class="cp">cos_val = Math.cos(angle)</span>
<span class="cp">tan_val = Math.tan(angle)</span>

<span class="cp"># AFAIK Ruby&#39;s Math module doesn&#39;t provide acos/asin</span>
<span class="cp"># While we&#39;re at it, let&#39;s also define missing hyperbolic functions</span>
<span class="cp">module Math</span>
<span class="cp">    def Math.asin(x)</span>
<span class="cp">        atan2(x, sqrt(1 - x**2))</span>
<span class="cp">    end</span>
<span class="cp">    def Math.acos(x)</span>
<span class="cp">        atan2(sqrt(1 - x**2), x)</span>
<span class="cp">    end</span>
<span class="cp">    def Math.atan(x)</span>
<span class="cp">        atan2(x, 1)</span>
<span class="cp">    end</span>
<span class="cp">    def Math.sinh(x)</span>
<span class="cp">        (exp(x) - exp(-x)) / 2</span>
<span class="cp">    end</span>
<span class="cp">    def Math.cosh(x)</span>
<span class="cp">        (exp(x) + exp(-x)) / 2</span>
<span class="cp">    end</span>
<span class="cp">    def Math.tanh(x)</span>
<span class="cp">        sinh(x) / cosh(x)</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># The support for Complex numbers is not built-in</span>
<span class="cp">y = Math.acos(3.7)</span>
<span class="cp">#=&gt; in `sqrt&#39;: square root for negative number (ArgumentError)</span>

<span class="cp"># There is an implementation of Complex numbers in &#39;complex.rb&#39; in current</span>
<span class="cp"># Ruby distro, but it doesn&#39;t support atan2 with complex args, so it doesn&#39;t</span>
<span class="cp"># solve this problem.</span>


<span class="cp"># @@PLEAC@@_2.13</span>
<span class="cp">log_e = Math.log(val)</span>
<span class="cp">log_10 = Math.log10(val)</span>

<span class="cp">def log_base(base, val)</span>
<span class="cp">    Math.log(val)/Math.log(base)</span>
<span class="cp">end</span>

<span class="cp">answer = log_base(10, 10_000)</span>
<span class="cp">puts &quot;log10(10,000) = #{answer}&quot;</span>


<span class="cp"># @@PLEAC@@_2.14</span>
<span class="cp">require &#39;matrix.rb&#39;</span>

<span class="cp">a = Matrix[[3, 2, 3], [5, 9, 8]]</span>
<span class="cp">b = Matrix[[4, 7], [9, 3], [8, 1]]</span>
<span class="cp">c = a * b</span>

<span class="cp">a.row_size</span>
<span class="cp">a.column_size</span>

<span class="cp">c.det</span>
<span class="cp">a.transpose</span>


<span class="cp"># @@PLEAC@@_2.15</span>
<span class="cp">require &#39;complex.rb&#39;</span>
<span class="cp">require &#39;rational.rb&#39;</span>

<span class="cp">a = Complex(3, 5)              # 3 + 5i</span>
<span class="cp">b = Complex(2, -2)             # 2 - 2i</span>
<span class="cp">puts &quot;c = #{a*b}&quot;</span>

<span class="cp">c = a * b</span>
<span class="cp">d = 3 + 4*Complex::I</span>

<span class="cp">printf &quot;sqrt(#{d}) = %s\n&quot;, Math.sqrt(d)</span>


<span class="cp"># @@PLEAC@@_2.16</span>
<span class="cp">number = hexadecimal.hex</span>
<span class="cp">number = octal.oct</span>

<span class="cp">print &quot;Gimme a number in decimal, octal, or hex: &quot;</span>
<span class="cp">num = gets.chomp</span>
<span class="cp">exit unless defined?(num)</span>
<span class="cp">num = num.oct if num =~ /^0/  # does both oct and hex  </span>
<span class="cp">printf &quot;%d %x %o\n&quot;, num, num, num</span>

<span class="cp">print &quot;Enter file permission in octal: &quot;</span>
<span class="cp">permissions = gets.chomp</span>
<span class="cp">raise &quot;Exiting ...\n&quot; unless defined?(permissions)</span>
<span class="cp">puts &quot;The decimal value is #{permissions.oct}&quot;</span>


<span class="cp"># @@PLEAC@@_2.17</span>
<span class="cp">def commify(n)</span>
<span class="cp">    n.to_s =~ /([^\.]*)(\..*)?/</span>
<span class="cp">    int, dec = $1.reverse, $2 ? $2 : &quot;&quot;</span>
<span class="cp">    while int.gsub!(/(,|\.|^)(\d{3})(\d)/, &#39;\1\2,\3&#39;)</span>
<span class="cp">    end</span>
<span class="cp">    int.reverse + dec</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_2.18</span>
<span class="cp">printf &quot;It took %d hour%s\n&quot;, time, time == 1 ? &quot;&quot; : &quot;s&quot;</span>

<span class="cp"># dunno if an equivalent to Lingua::EN::Inflect exists...</span>


<span class="cp"># @@PLEAC@@_2.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># bigfact - calculating prime factors</span>
<span class="cp">def factorize(orig)</span>
<span class="cp">    factors = {}</span>
<span class="cp">    factors.default = 0     # return 0 instead nil if key not found in hash</span>
<span class="cp">    n = orig</span>
<span class="cp">    i = 2</span>
<span class="cp">    sqi = 4                 # square of i</span>
<span class="cp">    while sqi &lt;= n do</span>
<span class="cp">        while n.modulo(i) == 0 do</span>
<span class="cp">            n /= i</span>
<span class="cp">            factors[i] += 1</span>
<span class="cp">            # puts &quot;Found factor #{i}&quot;</span>
<span class="cp">        end</span>
<span class="cp">        # we take advantage of the fact that (i +1)**2 = i**2 + 2*i +1</span>
<span class="cp">        sqi += 2 * i + 1</span>
<span class="cp">        i += 1</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    if (n != 1) &amp;&amp; (n != orig)</span>
<span class="cp">        factors[n] += 1</span>
<span class="cp">    end</span>
<span class="cp">    factors</span>
<span class="cp">end</span>

<span class="cp">def printfactorhash(orig, factorcount)</span>
<span class="cp">    print format(&quot;%-10d &quot;, orig)</span>
<span class="cp">    if factorcount.length == 0</span>
<span class="cp">        print &quot;PRIME&quot;</span>
<span class="cp">    else</span>
<span class="cp">        # sorts after number, because the hash keys are numbers</span>
<span class="cp">        factorcount.sort.each { |factor,exponent|</span>
<span class="cp">            print factor</span>
<span class="cp">            if exponent &gt; 1</span>
<span class="cp">                print &quot;**&quot;, exponent</span>
<span class="cp">            end</span>
<span class="cp">            print &quot; &quot;</span>
<span class="cp">        }</span>
<span class="cp">    end</span>
<span class="cp">    puts</span>
<span class="cp">end</span>

<span class="cp">for arg in ARGV</span>
<span class="cp">    n = arg.to_i</span>
<span class="cp">    mfactors = factorize(n)</span>
<span class="cp">    printfactorhash(n, mfactors)</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_3.0</span>
<span class="cp">puts Time.now</span>

<span class="cp">print &quot;Today is day &quot;, Time.now.yday, &quot; of the current year.\n&quot;</span>
<span class="cp">print &quot;Today is day &quot;, Time.now.day, &quot; of the current month.\n&quot;</span>


<span class="cp"># @@PLEAC@@_3.1</span>
<span class="cp">day, month, year = Time.now.day, Time.now.month, Time.now.year</span>
<span class="cp"># or</span>
<span class="cp">day, month, year = Time.now.to_a[3..5]</span>

<span class="cp">tl = Time.now.localtime</span>
<span class="cp">printf(&quot;The current date is %04d %02d %02d\n&quot;, tl.year, tl.month, tl.day)</span>

<span class="cp">Time.now.localtime.strftime(&quot;%Y-%m-%d&quot;)</span>


<span class="cp"># @@PLEAC@@_3.2</span>
<span class="cp">Time.local(year, month, day, hour, minute, second).tv_sec</span>
<span class="cp">Time.gm(year, month, day, hour, minute, second).tv_sec</span>


<span class="cp"># @@PLEAC@@_3.3</span>
<span class="cp">sec, min, hour, day, month, year, wday, yday, isdst, zone = Time.at(epoch_secs).to_a</span>


<span class="cp"># @@PLEAC@@_3.4</span>
<span class="cp">when_ = now + difference         # now -&gt; Time ; difference -&gt; Numeric (delta in seconds)</span>
<span class="cp">then_ = now - difference</span>


<span class="cp"># @@PLEAC@@_3.5</span>
<span class="cp">bree = 361535725</span>
<span class="cp">nat  =  96201950</span>

<span class="cp">difference = bree - nat</span>
<span class="cp">puts &quot;There were #{difference} seconds between Nat and Bree&quot;</span>

<span class="cp">seconds    =  difference % 60</span>
<span class="cp">difference = (difference - seconds) / 60</span>
<span class="cp">minutes    =  difference % 60</span>
<span class="cp">difference = (difference - minutes) / 60</span>
<span class="cp">hours      =  difference % 24</span>
<span class="cp">difference = (difference - hours)   / 24</span>
<span class="cp">days       =  difference % 7</span>
<span class="cp">weeks      = (difference - days)    /  7</span>

<span class="cp">puts &quot;(#{weeks} weeks, #{days} days, #{hours}:#{minutes}:#{seconds})&quot;</span>


<span class="cp"># @@PLEAC@@_3.6</span>
<span class="cp">monthday, weekday, yearday = date.mday, date.wday, date.yday</span>

<span class="cp"># AFAIK the week number is not just a division since week boundaries are on sundays</span>
<span class="cp">weeknum = d.strftime(&quot;%U&quot;).to_i + 1</span>

<span class="cp">year  = 1981</span>
<span class="cp">month = &quot;jun&quot;                     # or `6&#39; if you want to emulate a broken language</span>
<span class="cp">day   = 16</span>
<span class="cp">t = Time.mktime(year, month, day)</span>
<span class="cp">print &quot;#{month}/#{day}/#{year} was a &quot;, t.strftime(&quot;%A&quot;), &quot;\n&quot;</span>


<span class="cp"># @@PLEAC@@_3.7</span>
<span class="cp">yyyy, mm, dd = $1, $2, $3 if &quot;1998-06-25&quot; =~ /(\d+)-(\d+)-(\d+)/</span>

<span class="cp">epoch_seconds = Time.mktime(yyyy, mm, dd).tv_sec</span>

<span class="cp"># dunno an equivalent to Date::Manip#ParseDate</span>


<span class="cp"># @@PLEAC@@_3.8</span>
<span class="cp">string = Time.at(epoch_secs)</span>
<span class="cp">Time.at(1234567890).gmtime        # gives: Fri Feb 13 23:31:30 UTC 2009</span>

<span class="cp">time = Time.mktime(1973, &quot;jan&quot;, 18, 3, 45, 50)</span>
<span class="cp">print &quot;In localtime it gives: &quot;, time.localtime, &quot;\n&quot;</span>


<span class="cp"># @@PLEAC@@_3.9</span>
<span class="cp"># Ruby provides micro-seconds in Time object</span>
<span class="cp">Time.now.usec</span>

<span class="cp"># Ruby gives the seconds in floating format when substracting two Time objects</span>
<span class="cp">before = Time.now</span>
<span class="cp">line = gets</span>
<span class="cp">elapsed = Time.now - before</span>
<span class="cp">puts &quot;You took #{elapsed} seconds.&quot;</span>

<span class="cp"># On my Celeron-400 with Linux-2.2.19-14mdk, average for three execs are:</span>
<span class="cp">#   This Ruby version:       average 0.00321 sec</span>
<span class="cp">#   Cookbook&#39;s Perl version: average 0.00981 sec</span>
<span class="cp">size = 500</span>
<span class="cp">number_of_times = 100</span>
<span class="cp">total_time = 0</span>
<span class="cp">number_of_times.times {</span>
<span class="cp">    # populate array</span>
<span class="cp">    array = []</span>
<span class="cp">    size.times { array &lt;&lt; rand }</span>
<span class="cp">    # sort it</span>
<span class="cp">    begin_ = Time.now</span>
<span class="cp">    array.sort!</span>
<span class="cp">    time = Time.now - begin_</span>
<span class="cp">    total_time += time</span>
<span class="cp">}</span>
<span class="cp">printf &quot;On average, sorting %d random numbers takes %.5f seconds\n&quot;,</span>
<span class="cp">    size, (total_time/Float(number_of_times))</span>


<span class="cp"># @@PLEAC@@_3.10</span>
<span class="cp">sleep(0.005)                      # Ruby is definitely not as broken as Perl :)</span>
<span class="cp"># (may be interrupted by sending the process a SIGALRM)</span>


<span class="cp"># @@PLEAC@@_3.11</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># hopdelta - feed mail header, produce lines</span>
<span class="cp">#            showing delay at each hop.</span>
<span class="cp">require &#39;time&#39;</span>
<span class="cp">class MailHopDelta</span>

<span class="cp">    def initialize(mail)</span>
<span class="cp">        @head = mail.gsub(/\n\s+/,&#39; &#39;)</span>
<span class="cp">        @topline = %w-Sender Recipient Time Delta-</span>
<span class="cp">        @start_from = mail.match(/^From.*\@([^\s&gt;]*)/)[1]</span>
<span class="cp">        @date = Time.parse(mail.match(/^Date:\s+(.*)/)[1])</span>
<span class="cp">    end</span>

<span class="cp">    def out(line)</span>
<span class="cp">         &quot;%-20.20s %-20.20s %-20.20s  %s&quot; % line</span>
<span class="cp">    end</span>

<span class="cp">    def hop_date(day)</span>
<span class="cp">        day.strftime(&quot;%I:%M:%S %Y/%m/%d&quot;)</span>
<span class="cp">    end</span>

<span class="cp">    def puts_hops</span>
<span class="cp">        puts out(@topline) </span>
<span class="cp">        puts out([&#39;Start&#39;, @start_from, hop_date(@date),&#39;&#39;])</span>
<span class="cp">        @head.split(/\n/).reverse.grep(/^Received:/).each do |hop|</span>
<span class="cp">            hop.gsub!(/\bon (.*?) (id.*)/,&#39;; \1&#39;)</span>
<span class="cp">            whence = hop.match(/;\s+(.*)$/)[1]</span>
<span class="cp">            unless whence</span>
<span class="cp">                warn &quot;Bad received line: #{hop}&quot;</span>
<span class="cp">                next</span>
<span class="cp">            end</span>
<span class="cp">            from = $+ if hop =~ /from\s+(\S+)|\((.*?)\)/</span>
<span class="cp">            by   = $1 if hop =~ /by\s+(\S+\.\S+)/</span>
<span class="cp">            next unless now = Time.parse(whence).localtime</span>
<span class="cp">            delta = now - @date</span>
<span class="cp">            puts out([from, by, hop_date(now), hop_time(delta)])</span>
<span class="cp">            @date = now</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">    def hop_time(secs)</span>
<span class="cp">        sign = secs &lt; 0 ? -1 : 1</span>
<span class="cp">        days, secs = secs.abs.divmod(60 * 60 * 24)</span>
<span class="cp">        hours,secs = secs.abs.divmod(60 * 60)</span>
<span class="cp">        mins, secs = secs.abs.divmod(60)</span>
<span class="cp">        rtn =  &quot;%3ds&quot; % [secs  * sign]</span>
<span class="cp">        rtn &lt;&lt; &quot;%3dm&quot; % [mins  * sign] if mins  != 0</span>
<span class="cp">        rtn &lt;&lt; &quot;%3dh&quot; % [hours * sign] if hours != 0</span>
<span class="cp">        rtn &lt;&lt; &quot;%3dd&quot; % [days  * sign] if days  != 0 </span>
<span class="cp">        rtn</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">$/ = &quot;&quot;</span>
<span class="cp">mail = MailHopDelta.new(ARGF.gets).puts_hops</span>


<span class="cp"># @@PLEAC@@_4.0</span>
<span class="cp">single_level = [ &quot;this&quot;, &quot;that&quot;, &quot;the&quot;, &quot;other&quot; ]</span>

<span class="cp"># Ruby directly supports nested arrays</span>
<span class="cp">double_level = [ &quot;this&quot;, &quot;that&quot;, [ &quot;the&quot;, &quot;other&quot; ] ]</span>
<span class="cp">still_single_level = [ &quot;this&quot;, &quot;that&quot;, [ &quot;the&quot;, &quot;other&quot; ] ].flatten</span>


<span class="cp"># @@PLEAC@@_4.1</span>
<span class="cp">a = [ &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot; ]</span>
<span class="cp">a = %w(Why are you teasing me?)</span>

<span class="cp">lines = &lt;&lt;&quot;END_OF_HERE_DOC&quot;.gsub(/^\s*(.+)/, &#39;\1&#39;)</span>
<span class="cp">    The boy stood on the burning deck,</span>
<span class="cp">    It was as hot as glass.</span>
<span class="cp">END_OF_HERE_DOC</span>

<span class="cp">bigarray = IO.readlines(&quot;mydatafile&quot;).collect { |l| l.chomp }</span>

<span class="cp">name = &quot;Gandalf&quot;</span>
<span class="cp">banner = %Q(Speak, #{name}, and welcome!)</span>

<span class="cp">host_info  = `host #{his_host}`</span>

<span class="cp">%x(ps #{$$})</span>

<span class="cp">banner = &#39;Costs only $4.95&#39;.split(&#39; &#39;)</span>

<span class="cp">rax = %w! ( ) &lt; &gt; { } [ ] !</span>


<span class="cp"># @@PLEAC@@_4.2</span>
<span class="cp">def commify_series(arr)</span>
<span class="cp">    return &#39;&#39; if not arr</span>
<span class="cp">    case arr.size</span>
<span class="cp">        when 0 then &#39;&#39;</span>
<span class="cp">        when 1 then arr[0]</span>
<span class="cp">        when 2 then arr.join(&#39; and &#39;)</span>
<span class="cp">        else arr[0..-2].join(&#39;, &#39;) + &#39;, and &#39; + arr[-1]</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">array = [ &quot;red&quot;, &quot;yellow&quot;, &quot;green&quot; ]</span>

<span class="cp">print &quot;I have &quot;, array, &quot; marbles\n&quot;</span>
<span class="cp"># -&gt; I have redyellowgreen marbles</span>

<span class="cp"># But unlike Perl:</span>
<span class="cp">print &quot;I have #{array} marbles\n&quot;</span>
<span class="cp"># -&gt; I have redyellowgreen marbles</span>
<span class="cp"># So, needs:</span>
<span class="cp">print &quot;I have #{array.join(&#39; &#39;)} marbles\n&quot;</span>
<span class="cp"># -&gt; I have red yellow green marbles</span>

<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># communify_series - show proper comma insertion in list output</span>

<span class="cp">def commify_series(arr)</span>
<span class="cp">    return &#39;&#39; if not arr</span>
<span class="cp">    sepchar = arr.find { |p| p =~ /,/ } ? &#39;; &#39; : &#39;, &#39;</span>
<span class="cp">    case arr.size</span>
<span class="cp">        when 0 then &#39;&#39;</span>
<span class="cp">        when 1 then arr[0]</span>
<span class="cp">        when 2 then arr.join(&#39; and &#39;)</span>
<span class="cp">        else arr[0..-2].join(sepchar) + sepchar + &#39;and &#39; + arr[-1]</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">lists = [</span>
<span class="cp">    [ &#39;just one thing&#39; ],</span>
<span class="cp">    %w(Mutt Jeff),</span>
<span class="cp">    %w(Peter Paul Mary),</span>
<span class="cp">    [ &#39;To our parents&#39;, &#39;Mother Theresa&#39;, &#39;God&#39; ],</span>
<span class="cp">    [ &#39;pastrami&#39;, &#39;ham and cheese&#39;, &#39;peanut butter and jelly&#39;, &#39;tuna&#39; ],</span>
<span class="cp">    [ &#39;recycle tired, old phrases&#39;, &#39;ponder big, happy thoughts&#39; ],</span>
<span class="cp">    [ &#39;recycle tired, old phrases&#39;,</span>
<span class="cp">      &#39;ponder big, happy thoughts&#39;,</span>
<span class="cp">      &#39;sleep and dream peacefully&#39; ],</span>
<span class="cp">]</span>

<span class="cp">for list in lists do</span>
<span class="cp">    puts &quot;The list is: #{commify_series(list)}.&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_4.3</span>
<span class="cp">#   (note: AFAIK Ruby doesn&#39;t allow gory change of Array length)</span>
<span class="cp"># grow the array by assigning nil to past the end of array</span>
<span class="cp">ary[new_size-1] = nil</span>
<span class="cp"># shrink the array by slicing it down</span>
<span class="cp">ary.slice!(new_size..-1)</span>
<span class="cp"># init the array with given size</span>
<span class="cp">Array.new(number_of_elems)</span>
<span class="cp"># assign to an element past the original end enlarges the array</span>
<span class="cp">ary[index_new_last_elem] = value</span>

<span class="cp">def what_about_that_array(a)</span>
<span class="cp">    print &quot;The array now has &quot;, a.size, &quot; elements.\n&quot;</span>
<span class="cp">    # Index of last element is not really interesting in Ruby</span>
<span class="cp">    print &quot;Element #3 is `#{a[3]}&#39;.\n&quot;</span>
<span class="cp">end</span>
<span class="cp">people = %w(Crosby Stills Nash Young)</span>
<span class="cp">what_about_that_array(people)</span>


<span class="cp"># @@PLEAC@@_4.4</span>
<span class="cp"># OO style</span>
<span class="cp">bad_users.each { |user|</span>
<span class="cp">    complain(user)</span>
<span class="cp">}</span>
<span class="cp"># or, functional style</span>
<span class="cp">for user in bad_users</span>
<span class="cp">    complain(user)</span>
<span class="cp">end</span>

<span class="cp">for var in ENV.keys.sort</span>
<span class="cp">    puts &quot;#{var}=#{ENV[var]}&quot;</span>
<span class="cp">end</span>

<span class="cp">for user in all_users</span>
<span class="cp">    disk_space = get_usage(user)</span>
<span class="cp">    if (disk_space &gt; MAX_QUOTA)</span>
<span class="cp">        complain(user)</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">for l in IO.popen(&quot;who&quot;).readlines</span>
<span class="cp">    print l if l =~ /^gc/ </span>
<span class="cp">end</span>

<span class="cp"># we can mimic the obfuscated Perl way</span>
<span class="cp">while fh.gets               # $_ is set to the line just read</span>
<span class="cp">    chomp                   # $_ has a trailing \n removed, if it had one</span>
<span class="cp">    split.each { |w|        # $_ is split on whitespace</span>
<span class="cp">                            # but $_ is not set to each chunk as in Perl</span>
<span class="cp">        print w.reverse</span>
<span class="cp">    }</span>
<span class="cp">end</span>
<span class="cp"># ...or use a cleaner way</span>
<span class="cp">for l in fh.readlines</span>
<span class="cp">    l.chomp.split.each { |w| print w.reverse }</span>
<span class="cp">end</span>

<span class="cp"># same drawback as in problem 1.4, we can&#39;t mutate a Numeric...</span>
<span class="cp">array.collect! { |v| v - 1 }</span>

<span class="cp">a = [ .5, 3 ]; b = [ 0, 1 ]</span>
<span class="cp">for ary in [ a, b ]</span>
<span class="cp">    ary.collect! { |v| v * 7 }</span>
<span class="cp">end</span>
<span class="cp">puts &quot;#{a.join(&#39; &#39;)} #{b.join(&#39; &#39;)}&quot;</span>

<span class="cp"># we can mutate Strings, cool; we need a trick for the scalar</span>
<span class="cp">for ary in [ [ scalar ], array, hash.values ]</span>
<span class="cp">    ary.each { |v| v.strip! }     # String#strip rules :)</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_4.5</span>
<span class="cp"># not relevant in Ruby since we have always references</span>
<span class="cp">for item in array</span>
<span class="cp">    # do somethingh with item</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_4.6</span>
<span class="cp">unique = list.uniq</span>

<span class="cp"># generate a list of users logged in, removing duplicates</span>
<span class="cp">users = `who`.collect { |l| l =~ /(\w+)/; $1 }.sort.uniq</span>
<span class="cp">puts(&quot;users logged in: #{commify_series(users)}&quot;)  # see 4.2 for commify_series</span>


<span class="cp"># @@PLEAC@@_4.7</span>
<span class="cp">a - b</span>
<span class="cp"># [ 1, 1, 2, 2, 3, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  -&gt;  [3, 5]</span>


<span class="cp"># @@PLEAC@@_4.8</span>
<span class="cp">union = a | b</span>
<span class="cp">intersection = a &amp; b</span>
<span class="cp">difference = a - b</span>


<span class="cp"># @@PLEAC@@_4.9</span>
<span class="cp">array1.concat(array2)</span>
<span class="cp"># if you will assign to another object, better use:</span>
<span class="cp">new_ary = array1 + array2</span>

<span class="cp">members = [ &quot;Time&quot;, &quot;Flies&quot; ]</span>
<span class="cp">initiates =  [ &quot;An&quot;, &quot;Arrow&quot; ]</span>
<span class="cp">members += initiates</span>

<span class="cp">members = [ &quot;Time&quot;, &quot;Flies&quot; ]</span>
<span class="cp">initiates = [ &quot;An&quot;, &quot;Arrow&quot; ]</span>
<span class="cp">members[2,0] = [ &quot;Like&quot;, initiates ].flatten</span>

<span class="cp">members[0] = &quot;Fruit&quot;</span>
<span class="cp">members[3,2] = &quot;A&quot;, &quot;Banana&quot;</span>


<span class="cp"># @@PLEAC@@_4.10</span>
<span class="cp">reversed = ary.reverse</span>

<span class="cp">ary.reverse_each { |e|</span>
<span class="cp">    # do something with e</span>
<span class="cp">}</span>

<span class="cp">descending = ary.sort.reverse</span>
<span class="cp">descending = ary.sort { |a,b| b &lt;=&gt; a }</span>


<span class="cp"># @@PLEAC@@_4.11</span>
<span class="cp"># remove n elements from front of ary (shift n)</span>
<span class="cp">front = ary.slice!(0, n)</span>

<span class="cp"># remove n elements from the end of ary (pop n)</span>
<span class="cp">end_ = ary.slice!(-n .. -1)</span>

<span class="cp"># let&#39;s extend the Array class, to make that useful</span>
<span class="cp">class Array</span>
<span class="cp">    def shift2()</span>
<span class="cp">        slice!(0 .. 1)     # more symetric with pop2...</span>
<span class="cp">    end</span>
<span class="cp">    def pop2()</span>
<span class="cp">        slice!(-2 .. -1)</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">friends = %w(Peter Paul Mary Jim Tim)</span>
<span class="cp">this, that = friends.shift2</span>

<span class="cp">beverages = %w(Dew Jolt Cola Sprite Fresca)</span>
<span class="cp">pair = beverages.pop2</span>


<span class="cp"># @@PLEAC@@_4.12</span>
<span class="cp"># use Enumerable#detect (or the synonym Enumerable#find)</span>
<span class="cp">highest_eng = employees.detect { |emp| emp.category == &#39;engineer&#39; }</span>


<span class="cp"># @@PLEAC@@_4.13</span>
<span class="cp"># use Enumerable#select (or the synonym Enumerable#find_all)</span>
<span class="cp">bigs = nums.select { |i| i &gt; 1_000_000 }</span>
<span class="cp">pigs = users.keys.select { |k| users[k] &gt; 1e7 }</span>

<span class="cp">matching = `who`.select { |u| u =~ /^gnat / }</span>

<span class="cp">engineers = employees.select { |e| e.position == &#39;Engineer&#39; }</span>

<span class="cp">secondary_assistance = applicants.select { |a|</span>
<span class="cp">    a.income &gt;= 26_000 &amp;&amp; a.income &lt; 30_000</span>
<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_4.14</span>
<span class="cp"># normally you would have an array of Numeric (Float or</span>
<span class="cp"># Fixnum or Bignum), so you would use:</span>
<span class="cp">sorted = unsorted.sort</span>
<span class="cp"># if you have strings representing Integers or Floats</span>
<span class="cp"># you may specify another sort method:</span>
<span class="cp">sorted = unsorted.sort { |a,b| a.to_f &lt;=&gt; b.to_f }</span>

<span class="cp"># let&#39;s use the list of my own PID&#39;s</span>
<span class="cp">`ps ux`.split(&quot;\n&quot;)[1..-1].</span>
<span class="cp">    select { |i| i =~ /^#{ENV[&#39;USER&#39;]}/ }.</span>
<span class="cp">    collect { |i| i.split[1] }.</span>
<span class="cp">    sort { |a,b| a.to_i &lt;=&gt; b.to_i }.each { |i| puts i }</span>
<span class="cp">puts &quot;Select a process ID to kill:&quot;</span>
<span class="cp">pid = gets.chomp</span>
<span class="cp">raise &quot;Exiting ... \n&quot; unless pid &amp;&amp; pid =~ /^\d+$/</span>
<span class="cp">Process.kill(&#39;TERM&#39;, pid.to_i)</span>
<span class="cp">sleep 2</span>
<span class="cp">Process.kill(&#39;KILL&#39;, pid.to_i)</span>

<span class="cp">descending = unsorted.sort { |a,b| b.to_f &lt;=&gt; a.to_f }</span>


<span class="cp"># @@PLEAC@@_4.15</span>
<span class="cp">ordered = unordered.sort { |a,b| compare(a,b) }</span>

<span class="cp">precomputed = unordered.collect { |e| [compute, e] }</span>
<span class="cp">ordered_precomputed = precomputed.sort { |a,b| a[0] &lt;=&gt; b[0] }</span>
<span class="cp">ordered = ordered_precomputed.collect { |e| e[1] }</span>

<span class="cp">ordered = unordered.collect { |e| [compute, e] }.</span>
<span class="cp">    sort { |a,b| a[0] &lt;=&gt; b[0] }.</span>
<span class="cp">    collect { |e| e[1] }</span>

<span class="cp">for employee in employees.sort { |a,b| a.name &lt;=&gt; b.name }</span>
<span class="cp">    print employee.name, &quot; earns \$ &quot;, employee.salary, &quot;\n&quot;</span>
<span class="cp">end</span>

<span class="cp"># Beware! `0&#39; is true in Ruby.</span>
<span class="cp"># For chaining comparisons, you may use Numeric#nonzero?, which</span>
<span class="cp"># returns num if num is not zero, nil otherwise</span>
<span class="cp">sorted = employees.sort { |a,b| (a.name &lt;=&gt; b.name).nonzero? || b.age &lt;=&gt; a.age }</span>

<span class="cp">users = []</span>
<span class="cp"># getpwent is not wrapped in Ruby... let&#39;s fallback</span>
<span class="cp">IO.readlines(&#39;/etc/passwd&#39;).each { |u| users &lt;&lt; u.split(&#39;:&#39;) }</span>
<span class="cp">users.sort! { |a,b| a[0] &lt;=&gt; b[0] }</span>
<span class="cp">for user in users</span>
<span class="cp">    puts user[0]</span>
<span class="cp">end</span>

<span class="cp">sorted = names.sort { |a,b| a[1, 1] &lt;=&gt; b[1, 1] }</span>
<span class="cp">sorted = strings.sort { |a,b| a.length &lt;=&gt; b.length }</span>

<span class="cp"># let&#39;s show only the compact version</span>
<span class="cp">ordered = strings.collect { |e| [e.length, e] }.</span>
<span class="cp">    sort { |a,b| a[0] &lt;=&gt; b[0] }.</span>
<span class="cp">    collect { |e| e[1] }</span>

<span class="cp">ordered = strings.collect { |e| [/\d+/.match(e)[0].to_i, e] }.</span>
<span class="cp">    sort { |a,b| a[0] &lt;=&gt; b[0] }.</span>
<span class="cp">    collect { |e| e[1] }</span>

<span class="cp">print `cat /etc/passwd`.collect { |e| [e, e.split(&#39;:&#39;).indexes(3,2,0)].flatten }.</span>
<span class="cp">    sort { |a,b| (a[1] &lt;=&gt; b[1]).nonzero? || (a[2] &lt;=&gt; b[2]).nonzero? || a[3] &lt;=&gt; b[3] }.</span>
<span class="cp">    collect { |e| e[0] }</span>


<span class="cp"># @@PLEAC@@_4.16</span>
<span class="cp">circular.unshift(circular.pop)        # the last shall be first</span>
<span class="cp">circular.push(circular.shift)         # and vice versa</span>

<span class="cp">def grab_and_rotate(l)</span>
<span class="cp">    l.push(ret = l.shift)</span>
<span class="cp">    ret</span>
<span class="cp">end</span>

<span class="cp">processes = [1, 2, 3, 4, 5]</span>
<span class="cp">while (1)</span>
<span class="cp">    process = grab_and_rotate(processes)</span>
<span class="cp">    puts &quot;Handling process #{process}&quot;</span>
<span class="cp">    sleep 1</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_4.17</span>
<span class="cp">def fisher_yates_shuffle(a)</span>
<span class="cp">    (a.size-1).downto(1) { |i|</span>
<span class="cp">        j = rand(i+1)</span>
<span class="cp">        a[i], a[j] = a[j], a[i] if i != j</span>
<span class="cp">    }</span>
<span class="cp">end</span>

<span class="cp">def naive_shuffle(a)</span>
<span class="cp">    for i in 0...a.size</span>
<span class="cp">        j = rand(a.size)</span>
<span class="cp">        a[i], a[j] = a[j], a[i]</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_4.18</span>
<span class="cp">#!/usr/bin/env ruby</span>
<span class="cp"># example 4-2 words</span>
<span class="cp"># words - gather lines, present in colums</span>

<span class="cp"># class to encapsulate the word formatting from the input</span>
<span class="cp">class WordFormatter</span>
<span class="cp">    def initialize(cols)</span>
<span class="cp">        @cols = cols</span>
<span class="cp">    end</span>

<span class="cp">    # helper to return the length of the longest word in the wordlist</span>
<span class="cp">    def maxlen(wordlist)</span>
<span class="cp">        max = 1</span>
<span class="cp">        for word in wordlist</span>
<span class="cp">            if word.length &gt; max</span>
<span class="cp">                max = word.length</span>
<span class="cp">            end</span>
<span class="cp">        end</span>
<span class="cp">        max</span>
<span class="cp">    end</span>

<span class="cp">    # process the wordlist and print it formmated into columns</span>
<span class="cp">    def output(wordlist)</span>
<span class="cp">        collen = maxlen(wordlist) + 1</span>
<span class="cp">        columns = @cols / collen</span>
<span class="cp">        columns = 1 if columns == 0</span>
<span class="cp">        rows = (wordlist.length + columns - 1) / columns</span>
<span class="cp">        # now process each item, picking out proper piece for this position</span>
<span class="cp">        0.upto(rows * columns - 1) { |item|</span>
<span class="cp">            target = (item % columns) * rows + (item / columns)</span>
<span class="cp">            eol = ((item+1) % columns == 0)</span>
<span class="cp">            piece = wordlist[target] || &quot;&quot;</span>
<span class="cp">            piece = piece.ljust(collen) unless eol</span>
<span class="cp">            print piece</span>
<span class="cp">            puts if eol</span>
<span class="cp">        }</span>
<span class="cp">        # no need to finish it up, because eol is always true for the last element</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># get nr of chars that fit in window or console, see PLEAC 15.4</span>
<span class="cp"># not portable -- linux only (?)</span>
<span class="cp">def getWinCharWidth()</span>
<span class="cp">    buf = &quot;\0&quot; * 8</span>
<span class="cp">    $stdout.ioctl(0x5413, buf)</span>
<span class="cp">    ws_row, ws_col, ws_xpixel, ws_ypixel = buf.unpack(&quot;$4&quot;)</span>
<span class="cp">    ws_col || 80</span>
<span class="cp">rescue</span>
<span class="cp">    80</span>
<span class="cp">end</span>

<span class="cp"># main program</span>
<span class="cp">cols = getWinCharWidth()</span>
<span class="cp">formatter = WordFormatter.new(cols)</span>
<span class="cp">words = readlines()</span>
<span class="cp">words.collect! { |line|</span>
<span class="cp">    line.chomp</span>
<span class="cp">}</span>
<span class="cp">formatter.output(words)</span>


<span class="cp"># @@PLEAC@@_4.19</span>
<span class="cp"># In ruby, Fixnum&#39;s are automatically converted to Bignum&#39;s when</span>
<span class="cp"># needed, so there is no need for an extra module</span>
<span class="cp">def factorial(n)</span>
<span class="cp">    s = 1</span>
<span class="cp">    while n &gt; 0</span>
<span class="cp">        s *= n</span>
<span class="cp">        n -= 1</span>
<span class="cp">    end</span>
<span class="cp">    s</span>
<span class="cp">end</span>

<span class="cp">puts factorial(500)</span>

<span class="cp">#---------------------------------------------------------</span>
<span class="cp"># Example 4-3. tsc-permute</span>
<span class="cp"># tsc_permute: permute each word of input</span>
<span class="cp">def permute(items, perms)</span>
<span class="cp">    unless items.length &gt; 0</span>
<span class="cp">        puts perms.join(&quot; &quot;)</span>
<span class="cp">    else</span>
<span class="cp">        for i in items</span>
<span class="cp">            newitems = items.dup</span>
<span class="cp">            newperms = perms.dup</span>
<span class="cp">            newperms.unshift(newitems.delete(i))</span>
<span class="cp">            permute(newitems, newperms)</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp"># In ruby the main program must be after all definitions it is using</span>
<span class="cp">permute(ARGV, [])</span>

<span class="cp">#---------------------------------------------------------</span>
<span class="cp"># mjd_permute: permute each word of input</span>

<span class="cp">def factorial(n)</span>
<span class="cp">    s = 1</span>
<span class="cp">    while n &gt; 0</span>
<span class="cp">        s *= n</span>
<span class="cp">        n -= 1</span>
<span class="cp">    end</span>
<span class="cp">    s</span>
<span class="cp">end</span>

<span class="cp"># we use a class with a class variable store the private cache</span>
<span class="cp"># for the results of the factorial function.</span>
<span class="cp">class Factorial</span>
<span class="cp">    @@fact = [ 1 ]</span>
<span class="cp">    def Factorial.compute(n)</span>
<span class="cp">        if @@fact[n]</span>
<span class="cp">            @@fact[n]</span>
<span class="cp">        else</span>
<span class="cp">            @@fact[n] = n * Factorial.compute(n - 1)</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">#---------------------------------------------------------</span>
<span class="cp"># Example 4-4- mjd-permute</span>
<span class="cp"># n2pat(n, len): produce the N-th pattern of length len</span>

<span class="cp"># We must use a lower case letter as parameter N, otherwise it is</span>
<span class="cp"># handled as constant Length is the length of the resulting</span>
<span class="cp"># array, not the index of the last element (length -1) like in</span>
<span class="cp"># the perl example.</span>
<span class="cp">def n2pat(n, length)</span>
<span class="cp">    pat = []</span>
<span class="cp">    i = 1</span>
<span class="cp">    while i &lt;= length</span>
<span class="cp">        pat.push(n % i)</span>
<span class="cp">        n /= i</span>
<span class="cp">        i += 1</span>
<span class="cp">    end</span>
<span class="cp">    pat</span>
<span class="cp">end</span>

<span class="cp"># pat2perm(pat): turn pattern returned by n2pat() into</span>
<span class="cp"># permutation of integers.</span>
<span class="cp">def pat2perm(pat)</span>
<span class="cp">    source = (0 .. pat.length - 1).to_a</span>
<span class="cp">    perm = []</span>
<span class="cp">    perm.push(source.slice!(pat.pop)) while pat.length &gt; 0</span>
<span class="cp">    perm</span>
<span class="cp">end</span>

<span class="cp">def n2perm(n, len)</span>
<span class="cp">    pat2perm(n2pat(n,len))</span>
<span class="cp">end</span>

<span class="cp"># In ruby the main program must be after all definitions</span>
<span class="cp">while gets</span>
<span class="cp">    data = split</span>
<span class="cp">    # the perl solution has used $#data, which is length-1</span>
<span class="cp">    num_permutations = Factorial.compute(data.length())</span>
<span class="cp">    0.upto(num_permutations - 1) do |i|</span>
<span class="cp">        # in ruby we can not use an array as selector for an array</span>
<span class="cp">        # but by exchanging the two arrays, we can use the collect method</span>
<span class="cp">        # which returns an array with the result of all block invocations</span>
<span class="cp">        permutation = n2perm(i, data.length).collect {</span>
<span class="cp">            |j| data[j]</span>
<span class="cp">        }</span>
<span class="cp">        puts permutation.join(&quot; &quot;)</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_5.0</span>
<span class="cp">age = { &quot;Nat&quot;,   24,</span>
<span class="cp">        &quot;Jules&quot;, 25,</span>
<span class="cp">        &quot;Josh&quot;,  17  }</span>

<span class="cp">age[&quot;Nat&quot;]   = 24</span>
<span class="cp">age[&quot;Jules&quot;] = 25</span>
<span class="cp">age[&quot;Josh&quot;]  = 17</span>

<span class="cp">food_color = {</span>
<span class="cp">    &quot;Apple&quot;  =&gt; &quot;red&quot;,</span>
<span class="cp">    &quot;Banana&quot; =&gt; &quot;yellow&quot;,</span>
<span class="cp">    &quot;Lemon&quot;  =&gt; &quot;yellow&quot;,</span>
<span class="cp">    &quot;Carrot&quot; =&gt; &quot;orange&quot;</span>
<span class="cp">             }</span>

<span class="cp"># In Ruby, you cannot avoid the double or simple quoting</span>
<span class="cp"># while manipulatin hashes</span>


<span class="cp"># @@PLEAC@@_5.1</span>
<span class="cp">hash[key] = value</span>

<span class="cp">food_color[&quot;Raspberry&quot;] = &quot;pink&quot;</span>
<span class="cp">puts &quot;Known foods:&quot;, food_color.keys</span>


<span class="cp"># @@PLEAC@@_5.2</span>
<span class="cp"># does hash have a value for key ?</span>
<span class="cp">if (hash.has_key?(key))</span>
<span class="cp">    # it exists</span>
<span class="cp">else</span>
<span class="cp">    # it doesn&#39;t</span>
<span class="cp">end</span>

<span class="cp">[ &quot;Banana&quot;, &quot;Martini&quot; ].each { |name|</span>
<span class="cp">    print name, &quot; is a &quot;, food_color.has_key?(name) ? &quot;food&quot; : &quot;drink&quot;, &quot;\n&quot;</span>
<span class="cp">}</span>

<span class="cp">age = {}</span>
<span class="cp">age[&#39;Toddler&#39;] = 3</span>
<span class="cp">age[&#39;Unborn&#39;] = 0</span>
<span class="cp">age[&#39;Phantasm&#39;] = nil</span>

<span class="cp">for thing in [&#39;Toddler&#39;, &#39;Unborn&#39;, &#39;Phantasm&#39;, &#39;Relic&#39;]</span>
<span class="cp">    print &quot;#{thing}: &quot;</span>
<span class="cp">    print &quot;Has-key &quot; if age.has_key?(thing)</span>
<span class="cp">    print &quot;True &quot; if age[thing]</span>
<span class="cp">    print &quot;Nonzero &quot; if age[thing] &amp;&amp; age[thing].nonzero?</span>
<span class="cp">    print &quot;\n&quot;</span>
<span class="cp">end</span>

<span class="cp">#=&gt;</span>
<span class="cp"># Toddler: Has-key True Nonzero </span>
<span class="cp"># Unborn: Has-key True </span>
<span class="cp"># Phantasm: Has-key </span>
<span class="cp"># Relic: </span>

<span class="cp"># You use Hash#has_key? when you use Perl&#39;s exists -&gt; it checks</span>
<span class="cp"># for existence of a key in a hash.</span>
<span class="cp"># All Numeric are &quot;True&quot; in ruby, so the test doesn&#39;t have the</span>
<span class="cp"># same semantics as in Perl; you would use Numeric#nonzero? to</span>
<span class="cp"># achieve the same semantics (false if 0, true otherwise).</span>


<span class="cp"># @@PLEAC@@_5.3</span>
<span class="cp">food_color.delete(&quot;Banana&quot;)</span>


<span class="cp"># @@PLEAC@@_5.4</span>
<span class="cp">hash.each { |key, value|</span>
<span class="cp">    # do something with key and value</span>
<span class="cp">}</span>

<span class="cp">hash.each_key { |key|</span>
<span class="cp">    # do something with key</span>
<span class="cp">}</span>

<span class="cp">food_color.each { |food, color|</span>
<span class="cp">    puts &quot;#{food} is #{color}&quot;</span>
<span class="cp">}</span>

<span class="cp">food_color.each_key { |food|</span>
<span class="cp">    puts &quot;#{food} is #{food_color[food]}&quot;</span>
<span class="cp">}</span>

<span class="cp"># IMO this demonstrates that OO style is by far more readable</span>
<span class="cp">food_color.keys.sort.each { |food|</span>
<span class="cp">    puts &quot;#{food} is #{food_color[food]}.&quot;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># countfrom - count number of messages from each sender</span>

<span class="cp"># Default value is 0</span>
<span class="cp">from = Hash.new(0)</span>
<span class="cp">while gets</span>
<span class="cp">    /^From: (.*)/ and from[$1] += 1</span>
<span class="cp">end</span>

<span class="cp"># More useful to sort by number of received mail by person</span>
<span class="cp">from.sort {|a,b| b[1]&lt;=&gt;a[1]}.each { |v|</span>
<span class="cp">    puts &quot;#{v[1]}: #{v[0]}&quot;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_5.5</span>
<span class="cp"># You may use the built-in &#39;inspect&#39; method this way:</span>
<span class="cp">p hash</span>

<span class="cp"># Or do it the Cookbook way:</span>
<span class="cp">hash.each { |k,v| puts &quot;#{k} =&gt; #{v}&quot; }</span>

<span class="cp"># Sorted by keys</span>
<span class="cp">hash.sort.each { |e| puts &quot;#{e[0]} =&gt; #{e[1]}&quot; }</span>
<span class="cp"># Sorted by values</span>
<span class="cp">hash.sort{|a,b| a[1]&lt;=&gt;b[1]}.each { |e| puts &quot;#{e[0]} =&gt; #{e[1]}&quot; }</span>


<span class="cp"># @@PLEAC@@_5.6</span>
<span class="cp"># Use the OrderedHash module (part of the GoodLibs RubyGem):</span>
<span class="cp">require &#39;rubygems&#39;</span>
<span class="cp">require &#39;ordered_hash&#39;</span>
<span class="cp">hash = OrderedHash.new;</span>
<span class="cp"># manipulate hash</span>
<span class="cp">keys = hash.keys                # keys is in insertion order</span>

<span class="cp"># initialize</span>
<span class="cp">require &#39;rubygems&#39;</span>
<span class="cp">require &#39;ordered_hash&#39;</span>

<span class="cp">food_color = OrderedHash.new</span>
<span class="cp">food_color[&quot;Banana&quot;] = &quot;Yellow&quot;</span>
<span class="cp">food_color[&quot;Apple&quot;]  = &quot;Green&quot;</span>
<span class="cp">food_color[&quot;Lemon&quot;]  = &quot;Yellow&quot;</span>

<span class="cp">puts &quot;In insertion order, the foods are:&quot;</span>
<span class="cp">food_color.each_key { |food|</span>
<span class="cp">    puts &quot;  #{food}&quot;</span>
<span class="cp">}</span>

<span class="cp">puts &quot;Still in insertion order, the foods&#39; colors are:&quot;</span>
<span class="cp">food_color.each { |food, color|</span>
<span class="cp">    puts &quot;#{food} is colored #{color}.&quot;</span>
<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_5.7</span>
<span class="cp">ttys = Hash.new</span>
<span class="cp">for i in `who`</span>
<span class="cp">    user, tty = i.split</span>
<span class="cp">    (ttys[user] ||= []) &lt;&lt; tty               # see problems_ruby for more infos</span>
<span class="cp">end</span>
<span class="cp">ttys.keys.sort.each { |k|</span>
<span class="cp">    puts &quot;#{k}: #{commify_series(ttys[k])}&quot;  # from 4.2</span>
<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_5.8</span>
<span class="cp">surname = { &quot;Mickey&quot; =&gt; &quot;Mantle&quot;, &quot;Babe&quot; =&gt; &quot;Ruth&quot; }</span>
<span class="cp">puts surname.index(&quot;Mantle&quot;)</span>

<span class="cp"># If you really needed to &#39;invert&#39; the whole hash, use Hash#invert</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># foodfind - find match for food or color</span>

<span class="cp">given = ARGV.shift or raise &quot;usage: foodfind food_or_color&quot;</span>

<span class="cp">color = {</span>
<span class="cp">    &quot;Apple&quot;  =&gt; &quot;red&quot;,</span>
<span class="cp">    &quot;Banana&quot; =&gt; &quot;yellow&quot;,</span>
<span class="cp">    &quot;Lemon&quot;  =&gt; &quot;yellow&quot;,</span>
<span class="cp">    &quot;Carrot&quot; =&gt; &quot;orange&quot;,</span>
<span class="cp">}</span>

<span class="cp">if (color.has_key?(given))</span>
<span class="cp">    puts &quot;#{given} is a food with color #{color[given]}.&quot;</span>
<span class="cp">end</span>
<span class="cp">if (color.has_value?(given))</span>
<span class="cp">    puts &quot;#{color.index(given)} is a food with color #{given}.&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_5.9</span>
<span class="cp"># Sorted by keys (Hash#sort gives an Array of pairs made of each key,value)</span>
<span class="cp">food_color.sort.each { |f|</span>
<span class="cp">    puts &quot;#{f[0]} is #{f[1]}.&quot;</span>
<span class="cp">}</span>

<span class="cp"># Sorted by values</span>
<span class="cp">food_color.sort { |a,b| a[1] &lt;=&gt; b[1] }.each { |f|</span>
<span class="cp">    puts &quot;#{f[0]} is #{f[1]}.&quot;</span>
<span class="cp">}</span>

<span class="cp"># Sorted by length of values</span>
<span class="cp">food_color.sort { |a,b| a[1].length &lt;=&gt; b[1].length }.each { |f|</span>
<span class="cp">    puts &quot;#{f[0]} is #{f[1]}.&quot;</span>
<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_5.10</span>
<span class="cp">merged = a.clone.update(b)        # because Hash#update changes object in place</span>

<span class="cp">drink_color = { &quot;Galliano&quot;  =&gt; &quot;yellow&quot;, &quot;Mai Tai&quot; =&gt; &quot;blue&quot; }</span>
<span class="cp">ingested_color = drink_color.clone.update(food_color)</span>

<span class="cp">substance_color = {}</span>
<span class="cp">for i in [ food_color, drink_color ]</span>
<span class="cp">    i.each_key { |k|</span>
<span class="cp">        if substance_color.has_key?(k)</span>
<span class="cp">            puts &quot;Warning: #{k} seen twice.  Using the first definition.&quot;</span>
<span class="cp">            next</span>
<span class="cp">        end</span>
<span class="cp">        substance_color[k] = 1</span>
<span class="cp">    }</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_5.11</span>
<span class="cp">common = hash1.keys &amp; hash2.keys</span>

<span class="cp">this_not_that = hash1.keys - hash2.keys</span>


<span class="cp"># @@PLEAC@@_5.12</span>
<span class="cp"># no problem here, Ruby handles any kind of object for key-ing</span>
<span class="cp"># (it takes Object#hash, which defaults to Object#id)</span>


<span class="cp"># @@PLEAC@@_5.13</span>
<span class="cp"># AFAIK, not possible in Ruby</span>


<span class="cp"># @@PLEAC@@_5.14</span>
<span class="cp"># Be careful, the following is possible only because Fixnum objects are</span>
<span class="cp"># special (documentation says: there is effectively only one Fixnum object</span>
<span class="cp"># instance for any given integer value).</span>
<span class="cp">count = Hash.new(0)</span>
<span class="cp">array.each { |e|</span>
<span class="cp">    count[e] += 1</span>
<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_5.15</span>
<span class="cp">father = {</span>
<span class="cp">    &quot;Cain&quot;      , &quot;Adam&quot;,</span>
<span class="cp">    &quot;Abel&quot;      , &quot;Adam&quot;,</span>
<span class="cp">    &quot;Seth&quot;      , &quot;Adam&quot;,</span>
<span class="cp">    &quot;Enoch&quot;     , &quot;Cain&quot;,</span>
<span class="cp">    &quot;Irad&quot;      , &quot;Enoch&quot;,</span>
<span class="cp">    &quot;Mehujael&quot;  , &quot;Irad&quot;,</span>
<span class="cp">    &quot;Methusael&quot; , &quot;Mehujael&quot;,</span>
<span class="cp">    &quot;Lamech&quot;    , &quot;Methusael&quot;,</span>
<span class="cp">    &quot;Jabal&quot;     , &quot;Lamech&quot;,</span>
<span class="cp">    &quot;Jubal&quot;     , &quot;Lamech&quot;,</span>
<span class="cp">    &quot;Tubalcain&quot; , &quot;Lamech&quot;,</span>
<span class="cp">    &quot;Enos&quot;      , &quot;Seth&quot;,</span>
<span class="cp">}</span>

<span class="cp">while gets</span>
<span class="cp">    chomp</span>
<span class="cp">    begin</span>
<span class="cp">        print $_, &quot; &quot;</span>
<span class="cp">    end while $_ = father[$_]</span>
<span class="cp">    puts</span>
<span class="cp">end</span>

<span class="cp">children = {}</span>
<span class="cp">father.each { |k,v|</span>
<span class="cp">    (children[v] ||= []) &lt;&lt; k</span>
<span class="cp">}</span>
<span class="cp">while gets</span>
<span class="cp">    chomp</span>
<span class="cp">    puts &quot;#{$_} begat #{(children[$_] || [&#39;Nobody&#39;]).join(&#39;, &#39;)}.\n&quot;</span>
<span class="cp">end</span>

<span class="cp">includes = {}</span>
<span class="cp">files.each { |f|</span>
<span class="cp">    begin</span>
<span class="cp">        for l in IO.readlines(f)</span>
<span class="cp">            next unless l =~ /^\s*#\s*include\s*&lt;([^&gt;]+)&gt;/</span>
<span class="cp">            (includes[$1] ||= []) &lt;&lt; f</span>
<span class="cp">        end</span>
<span class="cp">    rescue SystemCallError</span>
<span class="cp">        $stderr.puts &quot;#$! (skipping)&quot;</span>
<span class="cp">    end</span>
<span class="cp">}</span>

<span class="cp">include_free = includes.values.flatten.uniq - includes.keys</span>


<span class="cp"># @@PLEAC@@_5.16</span>
<span class="cp"># dutree - print sorted intented rendition of du output</span>
<span class="cp">#% dutree</span>
<span class="cp">#% dutree /usr</span>
<span class="cp">#% dutree -a</span>
<span class="cp">#% dutree -a /bin</span>

<span class="cp"># The DuNode class collects all information about a directory,</span>
<span class="cp"># and provides some convenience methods</span>
<span class="cp">class DuNode</span>

<span class="cp">    attr_reader :name</span>
<span class="cp">    attr_accessor :size</span>
<span class="cp">    attr_accessor :kids</span>

<span class="cp">    def initialize(name)</span>
<span class="cp">        @name = name</span>
<span class="cp">        @kids = []</span>
<span class="cp">        @size = 0</span>
<span class="cp">    end</span>

<span class="cp">    # support for sorting nodes with side</span>
<span class="cp">    def size_compare(node2)</span>
<span class="cp">        @size &lt;=&gt; node2.size</span>
<span class="cp">    end</span>

<span class="cp">    def basename</span>
<span class="cp">        @name.sub(/.*\//, &quot;&quot;)</span>
<span class="cp">    end</span>

<span class="cp">    #returns substring before last &quot;/&quot;, nil if not there</span>
<span class="cp">    def parent</span>
<span class="cp">        p = @name.sub(/\/[^\/]+$/,&quot;&quot;)</span>
<span class="cp">        if p == @name</span>
<span class="cp">            nil</span>
<span class="cp">        else</span>
<span class="cp">            p</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">end</span>

<span class="cp"># The DuTree does the acdtual work of</span>
<span class="cp"># getting the input, parsing it, builging up a tree</span>
<span class="cp"># and format it for output</span>
<span class="cp">class Dutree</span>

<span class="cp">    attr_reader :topdir</span>

<span class="cp">    def initialize</span>
<span class="cp">        @nodes = Hash.new</span>
<span class="cp">        @dirsizes = Hash.new(0)</span>
<span class="cp">        @kids = Hash.new([])</span>
<span class="cp">    end</span>

<span class="cp">    # get a node by name, create it if it does not exist yet</span>
<span class="cp">    def get_create_node(name)</span>
<span class="cp">        if @nodes.has_key?(name)</span>
<span class="cp">            @nodes[name]</span>
<span class="cp">        else</span>
<span class="cp">            node = DuNode.new(name)</span>
<span class="cp">            @nodes[name] = node</span>
<span class="cp">            node</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">    # run du, read in input, save sizes and kids</span>
<span class="cp">    # stores last directory read in instance variable topdir</span>
<span class="cp">    def input(arguments)</span>
<span class="cp">        name = &quot;&quot;</span>
<span class="cp">        cmd = &quot;du &quot; + arguments.join(&quot; &quot;)</span>
<span class="cp">        IO.popen(cmd) { |pipe|</span>
<span class="cp">            pipe.each { |line|</span>
<span class="cp">                size, name = line.chomp.split(/\s+/, 2)</span>
<span class="cp">                node = get_create_node(name)</span>
<span class="cp">                node.size = size.to_i</span>
<span class="cp">                @nodes[name] = node</span>
<span class="cp">                parent = node.parent</span>
<span class="cp">                if parent</span>
<span class="cp">                    get_create_node(parent).kids.push(node)</span>
<span class="cp">                end</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">        @topdir = @nodes[name]</span>
<span class="cp">    end</span>

<span class="cp">    # figure out how much is taken in each directory</span>
<span class="cp">    # that isn&#39;t stored in the subdirectories. Add a new</span>
<span class="cp">    # fake kid called &quot;.&quot; containing that much.</span>
<span class="cp">    def get_dots(node)</span>
<span class="cp">        cursize = node.size</span>
<span class="cp">        for kid in node.kids</span>
<span class="cp">            cursize -=  kid.size</span>
<span class="cp">            get_dots(kid)</span>
<span class="cp">        end</span>
<span class="cp">        if node.size != cursize</span>
<span class="cp">            newnode = get_create_node(node.name + &quot;/.&quot;)</span>
<span class="cp">            newnode.size = cursize</span>
<span class="cp">            node.kids.push(newnode)</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">    # recursively output everything</span>
<span class="cp">    # passing padding and number width as well</span>
<span class="cp">    # on recursive calls</span>
<span class="cp">    def output(node, prefix=&quot;&quot;, width=0)</span>
<span class="cp">        line = sprintf(&quot;%#{width}d %s&quot;, node.size, node.basename)</span>
<span class="cp">        puts(prefix + line)</span>
<span class="cp">        prefix += line.sub(/\d /, &quot;| &quot;)</span>
<span class="cp">        prefix.gsub!(/[^|]/, &quot; &quot;)</span>
<span class="cp">        if node.kids.length &gt; 0     # not a bachelor node</span>
<span class="cp">            kids = node.kids</span>
<span class="cp">            kids.sort! { |a,b|</span>
<span class="cp">                b.size_compare(a)</span>
<span class="cp">            }</span>
<span class="cp">            width = kids[0].size.to_s.length</span>
<span class="cp">            for kid in kids</span>
<span class="cp">                output(kid, prefix, width)</span>
<span class="cp">            end</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">end</span>

<span class="cp">tree = Dutree.new</span>
<span class="cp">tree.input(ARGV)</span>
<span class="cp">tree.get_dots(tree.topdir)</span>
<span class="cp">tree.output(tree.topdir)</span>


<span class="cp"># @@PLEAC@@_6.0</span>
<span class="cp"># The verbose version are match, sub, gsub, sub! and gsub!;</span>
<span class="cp"># pattern needs to be a Regexp object; it yields a MatchData</span>
<span class="cp"># object.</span>
<span class="cp">pattern.match(string)</span>
<span class="cp">string.sub(pattern, replacement)</span>
<span class="cp">string.gsub(pattern, replacement)</span>
<span class="cp"># As usual in Ruby, sub! does the same as sub but also modifies</span>
<span class="cp"># the object, the same for gsub!/gsub.</span>

<span class="cp"># Sugared syntax yields the position of the match (or nil if no</span>
<span class="cp"># match). Note that the object at the right of the operator needs</span>
<span class="cp"># not to be a Regexp object (it can be a String). The &quot;dont</span>
<span class="cp"># match&quot; operator yields true or false.</span>
<span class="cp">meadow =~ /sheep/   # position of the match, nil if no match</span>
<span class="cp">meadow !~ /sheep/   # true if doesn&#39;t match, false if it does</span>
<span class="cp"># There is no sugared version for the substitution</span>

<span class="cp">meadow =~ /\bovines?\b/i and print &quot;Here be sheep!&quot;</span>

<span class="cp">string = &quot;good food&quot;</span>
<span class="cp">string.sub!(/o*/, &#39;e&#39;)</span>

<span class="cp"># % echo ababacaca | ruby -ne &#39;puts $&amp; if /(a|ba|b)+(a|ac)+/&#39;</span>
<span class="cp"># ababa</span>

<span class="cp"># The &quot;global&quot; (or &quot;multiple&quot;) match is handled by String#scan</span>
<span class="cp">scan (/(\d+)/) {</span>
<span class="cp">    puts &quot;Found number #{$1}&quot;</span>
<span class="cp">}</span>

<span class="cp"># String#scan yields an Array if not used with a block</span>
<span class="cp">numbers = scan(/\d+/)</span>

<span class="cp">digits = &quot;123456789&quot;</span>
<span class="cp">nonlap = digits.scan(/(\d\d\d)/)</span>
<span class="cp">yeslap = digits.scan(/(?=(\d\d\d))/)</span>
<span class="cp">puts &quot;Non-overlapping:  #{nonlap.join(&#39; &#39;)}&quot;</span>
<span class="cp">puts &quot;Overlapping:      #{yeslap.join(&#39; &#39;)}&quot;;</span>
<span class="cp"># Non-overlapping:  123 456 789</span>
<span class="cp"># Overlapping:      123 234 345 456 567 678 789</span>

<span class="cp">string = &quot;And little lambs eat ivy&quot;</span>
<span class="cp">string =~ /l[^s]*s/</span>
<span class="cp">puts &quot;(#$`) (#$&amp;) (#$&#39;)&quot;</span>
<span class="cp"># (And ) (little lambs) ( eat ivy)</span>


<span class="cp"># @@PLEAC@@_6.1</span>
<span class="cp"># Ruby doesn&#39;t have the same problem:</span>
<span class="cp">dst = src.sub(&#39;this&#39;, &#39;that&#39;)</span>

<span class="cp">progname = $0.sub(&#39;^.*/&#39;, &#39;&#39;)</span>

<span class="cp">bindirs = %w(/usr/bin /bin /usr/local/bin)</span>
<span class="cp">libdirs = bindirs.map { |l| l.sub(&#39;bin&#39;, &#39;lib&#39;) }</span>


<span class="cp"># @@PLEAC@@_6.3</span>
<span class="cp">/\S+/               # as many non-whitespace bytes as possible</span>
<span class="cp">/[A-Za-z&#39;-]+/       # as many letters, apostrophes, and hyphens</span>

<span class="cp">/\b([A-Za-z]+)\b/   # usually best</span>
<span class="cp">/\s([A-Za-z]+)\s/   # fails at ends or w/ punctuation</span>


<span class="cp"># @@PLEAC@@_6.4</span>
<span class="cp">require &#39;socket&#39;</span>
<span class="cp">str = &#39;www.ruby-lang.org and www.rubygarden.org&#39;</span>
<span class="cp">re = /</span>
<span class="cp">      (               # capture the hostname in $1</span>
<span class="cp">        (?:           # these parens for grouping only</span>
<span class="cp">          (?! [-_] )  # lookahead for neither underscore nor dash</span>
<span class="cp">          [\w-] +     # hostname component</span>
<span class="cp">          \.          # and the domain dot</span>
<span class="cp">        ) +           # now repeat that whole thing a bunch of times</span>
<span class="cp">        [A-Za-z]      # next must be a letter</span>
<span class="cp">        [\w-] +       # now trailing domain part</span>
<span class="cp">      )               # end of $1 capture</span>
<span class="cp">     /x               # /x for nice formatting</span>

<span class="cp">str.gsub! re do       # pass a block to execute replacement</span>
<span class="cp">    host = TCPsocket.gethostbyname($1)</span>
<span class="cp">    &quot;#{$1} [#{host[3]}]&quot;</span>
<span class="cp">end</span>

<span class="cp">puts str</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># to match whitespace or #-characters in an extended re you need to escape</span>
<span class="cp"># them.</span>

<span class="cp">foo = 42</span>
<span class="cp">str = &#39;blah #foo# blah&#39;</span>
<span class="cp">str.gsub! %r/       # replace</span>
<span class="cp">              \#    #   a pound sign</span>
<span class="cp">              (\w+) #   the variable name</span>
<span class="cp">              \#    #   another pound sign</span>
<span class="cp">          /x do</span>
<span class="cp">              eval $1           # with the value of a local variable</span>
<span class="cp">          end</span>
<span class="cp">puts str  # =&gt; blah 42 blah</span>


<span class="cp"># @@PLEAC@@_6.5</span>
<span class="cp"># The &#39;g&#39; modifier doesn&#39;t exist in Ruby, a regexp can&#39;t be used</span>
<span class="cp"># directly in a while loop; instead, use String#scan { |match| .. } </span>
<span class="cp">fish = &#39;One fish two fish red fish blue fish&#39;</span>
<span class="cp">WANT = 3</span>
<span class="cp">count = 0</span>
<span class="cp">fish.scan(/(\w+)\s+fish\b/i) {</span>
<span class="cp">    if (count += 1) == WANT</span>
<span class="cp">        puts &quot;The third fish is a #{$1} one.&quot;</span>
<span class="cp">    end</span>
<span class="cp">}</span>

<span class="cp">if fish =~ /(?:\w+\s+fish\s+){2}(\w+)\s+fish/i</span>
<span class="cp">    puts &quot;The third fish is a #{$1} one.&quot;</span>
<span class="cp">end</span>

<span class="cp">pond = &#39;One fish two fish red fish blue fish&#39;</span>
<span class="cp"># String#scan without a block gives an array of matches, each match</span>
<span class="cp"># being an array of all the specified groups</span>
<span class="cp">colors = pond.scan(/(\w+)\s+fish\b/i).flatten  # get all matches</span>
<span class="cp">color  = colors[2]                          # then the one we want</span>
<span class="cp"># or without a temporary array</span>
<span class="cp">color = pond.scan(/(\w+)\s+fish\b/i).flatten[2]  # just grab element 3</span>
<span class="cp">puts &quot;The third fish in the pond is #{color}.&quot;</span>

<span class="cp">count = 0</span>
<span class="cp">fishes = &#39;One fish two fish red fish blue fish&#39;</span>
<span class="cp">evens = fishes.scan(/(\w+)\s+fish\b/i).select { (count+=1) % 2 == 0 }</span>
<span class="cp">print &quot;Even numbered fish are #{evens.join(&#39; &#39;)}.&quot;</span>

<span class="cp">count = 0</span>
<span class="cp">fishes.gsub(/</span>
<span class="cp">   \b               # makes next \w more efficient</span>
<span class="cp">   ( \w+ )          # this is what we\&#39;ll be changing</span>
<span class="cp">   (</span>
<span class="cp">     \s+ fish \b</span>
<span class="cp">   )</span>
<span class="cp">            /x) {</span>
<span class="cp">    if (count += 1) == 4</span>
<span class="cp">        &#39;sushi&#39; + $2</span>
<span class="cp">    else</span>
<span class="cp">        $1 + $2</span>
<span class="cp">    end</span>
<span class="cp">}</span>

<span class="cp">pond = &#39;One fish two fish red fish blue fish swim here.&#39;</span>
<span class="cp">puts &quot;Last fish is #{pond.scan(/\b(\w+)\s+fish\b/i).flatten[-1]}&quot;</span>

<span class="cp">/</span>
<span class="cp">    A               # find some pattern A</span>
<span class="cp">    (?!             # mustn\&#39;t be able to find</span>
<span class="cp">        .*          # something</span>
<span class="cp">        A           # and A</span>
<span class="cp">    )</span>
<span class="cp">    $               # through the end of the string</span>
<span class="cp">/x</span>

<span class="cp"># The &quot;s&quot; perl modifier is &quot;m&quot; in Ruby (not very nice since there is</span>
<span class="cp"># also an &quot;m&quot; in perl..)</span>
<span class="cp">pond = &quot;One fish two fish red fish blue fish swim here.&quot;</span>
<span class="cp">if (pond =~ /</span>
<span class="cp">                    \b  (  \w+) \s+ fish \b</span>
<span class="cp">                (?! .* \b fish \b )</span>
<span class="cp">            /mix)</span>
<span class="cp">    puts &quot;Last fish is #{$1}.&quot;</span>
<span class="cp">else</span>
<span class="cp">    puts &quot;Failed!&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_6.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># killtags - very bad html killer</span>
<span class="cp">$/ = nil;                              # each read is whole file</span>
<span class="cp">while file = gets() do</span>
<span class="cp">    file.gsub!(/&lt;.*?&gt;/m,&#39;&#39;);           # strip tags (terribly)</span>
<span class="cp">    puts file                          # print file to STDOUT</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp">#headerfy - change certain chapter headers to html</span>
<span class="cp">$/ = &#39;&#39;</span>
<span class="cp">while file = gets() do</span>
<span class="cp">    pattern = /</span>
<span class="cp">                  \A                   # start of record</span>
<span class="cp">                  (                    # capture in $1</span>
<span class="cp">                      Chapter          # text string</span>
<span class="cp">                      \s+              # mandatory whitespace</span>
<span class="cp">                      \d+              # decimal number</span>
<span class="cp">                      \s*              # optional whitespace</span>
<span class="cp">                      :                # a real colon</span>
<span class="cp">                      . *              # anything not a newline till end of line</span>
<span class="cp">                  )</span>
<span class="cp">               /x</span>
<span class="cp">    puts file.gsub(pattern,&#39;&lt;H1&gt;\1&lt;/H1&gt;&#39;)</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ruby -00pe &quot;gsub!(/\A(Chapter\s+\d+\s*:.*)/,&#39;&lt;H1&gt;\1&lt;/H1&gt;&#39;)&quot; datafile</span>

<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for file in ARGV</span>
<span class="cp">    file = File.open(ARGV.shift)</span>
<span class="cp">    while file.gets(&#39;&#39;) do             # each read is a paragraph</span>
<span class="cp">        print &quot;chunk #{$.} in $ARGV has &lt;&lt;#{$1}&gt;&gt;\n&quot; while /^START(.*?)^END/m</span>
<span class="cp">    end                                # /m activates the multiline mode</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># @@PLEAC@@_6.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = nil;</span>
<span class="cp">file = File.open(&quot;datafile&quot;)</span>
<span class="cp">chunks = file.gets.split(/pattern/)</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># .Ch, .Se and .Ss divide chunks of STDIN</span>
<span class="cp">chunks = gets(nil).split(/^\.(Ch|Se|Ss)$/)</span>
<span class="cp">print &quot;I read #{chunks.size} chunks.\n&quot;</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_6.8</span>
<span class="cp">while gets</span>
<span class="cp">    if ~/BEGIN/ .. ~/END/</span>
<span class="cp">        # line falls between BEGIN and END inclusive</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">while gets</span>
<span class="cp">    if ($. == firstnum) .. ($. == lastnum)</span>
<span class="cp">        # operate between firstnum and lastnum line number</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># in ruby versions prior to 1.8, the above two conditional</span>
<span class="cp"># expressions could be shortened to:</span>
<span class="cp">#     if /BEGIN/ .. /END/</span>
<span class="cp"># and</span>
<span class="cp">#     if firstnum .. lastnum</span>
<span class="cp"># but these now only work this way from the command line  </span>

<span class="cp">#-----------------------------</span>

<span class="cp">while gets</span>
<span class="cp">    if ~/BEGIN/ ... ~/END/</span>
<span class="cp">        # line falls between BEGIN and END on different lines</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">while gets</span>
<span class="cp">    if ($. == first) ... ($. == last)</span>
<span class="cp">        # operate between first and last line number on different lines</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># command-line to print lines 15 through 17 inclusive (see below)</span>
<span class="cp">ruby -ne &#39;print if 15 .. 17&#39; datafile</span>

<span class="cp"># print out all &lt;XMP&gt; .. &lt;/XMP&gt; displays from HTML doc</span>
<span class="cp">while gets</span>
<span class="cp">    print if ~%r#&lt;XMP&gt;#i .. ~%r#&lt;/XMP&gt;#i;</span>
<span class="cp">end</span>
<span class="cp">    </span>
<span class="cp"># same, but as shell command</span>
<span class="cp"># ruby -ne &#39;print if %r#&lt;XMP&gt;#i .. %r#&lt;/XMP&gt;#i&#39; document.html</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># ruby -ne &#39;BEGIN { $top=3; $bottom=5 }; \</span>
<span class="cp">#     print if $top .. $bottom&#39; /etc/passwd                 #  FAILS</span>
<span class="cp"># ruby -ne &#39;BEGIN { $top=3; $bottom=5 }; \</span>
<span class="cp">#     print if $. == $top .. $. ==  $bottom&#39; /etc/passwd    # works</span>
<span class="cp"># ruby -ne &#39;print if 3 .. 5&#39; /etc/passwd                    # also works</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print if ~/begin/ .. ~/end/;</span>
<span class="cp">print if ~/begin/ ... ~/end/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while gets</span>
<span class="cp">    $in_header = $. == 1  .. ~/^$/ ? true : false</span>
<span class="cp">    $in_body   = ~/^$/ .. ARGF.eof ? true : false</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">seen = {}</span>
<span class="cp">ARGF.each do |line|</span>
<span class="cp">    next unless line =~ /^From:?\s/i .. line =~ /^$/;</span>
<span class="cp">    line.scan(%r/([^&lt;&gt;(),;\s]+\@[^&lt;&gt;(),;\s]+)/).each do |addr|</span>
<span class="cp">        puts addr unless seen[addr]</span>
<span class="cp">        seen[addr] ||= 1 </span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_6.9</span>
<span class="cp">def glob2pat(globstr)</span>
<span class="cp">    patmap = {</span>
<span class="cp">        &#39;*&#39; =&gt; &#39;.*&#39;,</span>
<span class="cp">        &#39;?&#39; =&gt; &#39;.&#39;,</span>
<span class="cp">        &#39;[&#39; =&gt; &#39;[&#39;,</span>
<span class="cp">        &#39;]&#39; =&gt; &#39;]&#39;,</span>
<span class="cp">    }</span>
<span class="cp">    globstr.gsub!(/(.)/) { |c| patmap[c] || Regexp::escape(c) }</span>
<span class="cp">    &#39;^&#39; + globstr + &#39;$&#39;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_6.10</span>
<span class="cp"># avoid interpolating patterns like this if the pattern</span>
<span class="cp"># isn&#39;t going to change:</span>
<span class="cp">pattern = ARGV.shift</span>
<span class="cp">ARGF.each do |line|</span>
<span class="cp">    print line if line =~ /#{pattern}/</span>
<span class="cp">end</span>

<span class="cp"># the above creates a new regex each iteration. Instead,</span>
<span class="cp"># use the /o modifier so the regex is compiled only once</span>

<span class="cp">pattern = ARGV.shift</span>
<span class="cp">ARGF.each do |line|</span>
<span class="cp">    print line if line =~ /#{pattern}/o</span>
<span class="cp">end</span>

<span class="cp">#-----------------------------</span>

<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># popgrep1 - grep for abbreviations of places that say &quot;pop&quot;</span>
<span class="cp"># version 1: slow but obvious way</span>
<span class="cp">popstates = %w(CO ON MI WI MN)</span>
<span class="cp">ARGF.each do |line|</span>
<span class="cp">    popstates.each do |state|</span>
<span class="cp">        if line =~ /\b#{state}\b/</span>
<span class="cp">            print line</span>
<span class="cp">            last</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># popgrep2 - grep for abbreviations of places that say &quot;pop&quot;</span>
<span class="cp"># version 2: eval strings; fast but hard to quote</span>
<span class="cp">popstates = %w(CO ON MI WI MN)</span>
<span class="cp">code = &quot;ARGF.each do |line|\n&quot;</span>
<span class="cp">popstates.each do |state|</span>
<span class="cp">    code += &quot;\tif line =~ /\\b#{state}\\b/; print(line); next; end\n&quot;</span>
<span class="cp">end</span>
<span class="cp">code += &quot;end\n&quot;</span>
<span class="cp">print &quot;CODE IS\n---\n#{code}\n---\n&quot; if false # turn on for debugging</span>
<span class="cp">eval code</span>

<span class="cp"># CODE IS</span>
<span class="cp"># ---</span>
<span class="cp"># ARGF.each do |line|</span>
<span class="cp">#         if line =~ /\bCO\b/; print(line); next; end</span>
<span class="cp">#         if line =~ /\bON\b/; print(line); next; end</span>
<span class="cp">#         if line =~ /\bMI\b/; print(line); next; end</span>
<span class="cp">#         if line =~ /\bWI\b/; print(line); next; end</span>
<span class="cp">#         if line =~ /\bMN\b/; print(line); next; end</span>
<span class="cp"># end</span>
<span class="cp"># </span>
<span class="cp"># ---</span>

<span class="cp">## alternatively, the same idea as above but compiling </span>
<span class="cp">## to a case statement: (not in perlcookbook)</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># popgrep2.5 - grep for abbreviations of places that say &quot;pop&quot;</span>
<span class="cp"># version 2.5: eval strings; fast but hard to quote</span>
<span class="cp">popstates = %w(CO ON MI WI MN)</span>
<span class="cp">code = &quot;ARGF.each do |line|\n    case line\n&quot;</span>
<span class="cp">popstates.each do |state|</span>
<span class="cp">    code += &quot;        when /\\b#{state}\\b/ : print line\n&quot;</span>
<span class="cp">end</span>
<span class="cp">code += &quot;    end\nend\n&quot;</span>
<span class="cp">print &quot;CODE IS\n---\n#{code}\n---\n&quot; if false # turn on for debugging</span>
<span class="cp">eval code</span>

<span class="cp"># CODE IS</span>
<span class="cp"># ---</span>
<span class="cp"># ARGF.each do |line|</span>
<span class="cp">#     case line</span>
<span class="cp">#         when /\bCO\b/ : print line</span>
<span class="cp">#         when /\bON\b/ : print line</span>
<span class="cp">#         when /\bMI\b/ : print line</span>
<span class="cp">#         when /\bWI\b/ : print line</span>
<span class="cp">#         when /\bMN\b/ : print line</span>
<span class="cp">#     end</span>
<span class="cp"># end</span>
<span class="cp"># </span>
<span class="cp"># ---</span>

<span class="cp"># Note: (above) Ruby 1.8+ allows the &#39;when EXP : EXPR&#39; on one line</span>
<span class="cp"># with the colon separator.</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># popgrep3 - grep for abbreviations of places that say &quot;pop&quot;</span>
<span class="cp"># version3: build a match_any function</span>
<span class="cp">popstates = %w(CO ON MI WI MN)</span>
<span class="cp">expr = popstates.map{|e|&quot;line =~ /\\b#{e}\\b/&quot;}.join(&#39;||&#39;)</span>
<span class="cp">eval &quot;def match_any(line); #{expr};end&quot;</span>
<span class="cp">ARGF.each do |line|</span>
<span class="cp">    print line if match_any(line)</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>

<span class="cp">##  building a match_all function is a trivial</span>
<span class="cp">##  substitution of &amp;&amp; for ||</span>
<span class="cp">##  here is a generalized example:</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp">## grepauth - print lines that mention both foo and bar</span>
<span class="cp">class MultiMatch </span>
<span class="cp">    def initialize(*patterns)</span>
<span class="cp">        _any = build_match(&#39;||&#39;,patterns)</span>
<span class="cp">        _all = build_match(&#39;&amp;&amp;&#39;,patterns)</span>
<span class="cp">        eval &quot;def match_any(line);#{_any};end\n&quot;</span>
<span class="cp">        eval &quot;def match_all(line);#{_all};end\n&quot;</span>
<span class="cp">      end</span>
<span class="cp">    def build_match(sym,args)</span>
<span class="cp">        args.map{|e|&quot;line =~ /#{e}/&quot;}.join(sym)</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">mm = MultiMatch.new(&#39;foo&#39;,&#39;bar&#39;)</span>
<span class="cp">ARGF.each do |line|</span>
<span class="cp">    print line if mm.match_all(line)</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>

<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># popgrep4 - grep for abbreviations of places that say &quot;pop&quot;</span>
<span class="cp"># version4: pretty fast, but simple: compile all re&#39;s first:</span>
<span class="cp">popstates = %w(CO ON MI WI MN)</span>
<span class="cp">popstates = popstates.map{|re| %r/\b#{re}\b/}</span>
<span class="cp">ARGF.each do |line|</span>
<span class="cp">    popstates.each do |state_re|</span>
<span class="cp">        if line =~ state_re</span>
<span class="cp">            print line</span>
<span class="cp">            break</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">## speeds trials on the jargon file(412): 26006 lines, 1.3MB</span>
<span class="cp">## popgrep1   =&gt; 7.040s</span>
<span class="cp">## popgrep2   =&gt; 0.656s</span>
<span class="cp">## popgrep2.5 =&gt; 0.633s</span>
<span class="cp">## popgrep3   =&gt; 0.675s</span>
<span class="cp">## popgrep4   =&gt; 1.027s</span>

<span class="cp"># unless speed is criticial, the technique in popgrep4 is a</span>
<span class="cp"># reasonable balance between speed and logical simplicity.</span>


<span class="cp"># @@PLEAC@@_6.11</span>
<span class="cp">begin</span>
<span class="cp">    print &quot;Pattern? &quot;</span>
<span class="cp">    pat = $stdin.gets.chomp</span>
<span class="cp">    Regexp.new(pat)</span>
<span class="cp">rescue </span>
<span class="cp">    warn &quot;Invalid Pattern&quot;</span>
<span class="cp">    retry</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_6.13</span>
<span class="cp"># uses the &#39;amatch&#39; extension found on:</span>
<span class="cp"># http://raa.ruby-lang.org/project/amatch/</span>
<span class="cp">require &#39;amatch&#39;</span>
<span class="cp">matcher = Amatch.new(&#39;balast&#39;)</span>
<span class="cp">#$relative, $distance = 0, 1</span>
<span class="cp">File.open(&#39;/usr/share/dict/words&#39;).each_line do |line|</span>
<span class="cp">    print line if matcher.search(line) &lt;= 1</span>
<span class="cp">end</span>
<span class="cp">__END__</span>
<span class="cp">ballast</span>
<span class="cp">ballasts</span>
<span class="cp">balustrade</span>
<span class="cp">balustrades</span>
<span class="cp">blast</span>
<span class="cp">blasted</span>
<span class="cp">blaster</span>
<span class="cp">blasters</span>
<span class="cp">blasting</span>
<span class="cp">blasts</span>


<span class="cp"># @@PLEAC@@_6.14</span>
<span class="cp">str.scan(/\G(\d)/).each do |token|</span>
<span class="cp">    puts &quot;found #{token}&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">n = &quot;   49 here&quot;</span>
<span class="cp">n.gsub!(/\G /,&#39;0&#39;)</span>
<span class="cp">puts n</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str = &quot;3,4,5,9,120&quot;</span>
<span class="cp">str.scan(/\G,?(\d+)/).each do |num|</span>
<span class="cp">    puts &quot;Found number: #{num}&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Ruby doesn&#39;t have the String.pos or a /c re modifier like Perl </span>
<span class="cp"># But it does have StringScanner in the standard library (strscn)</span>
<span class="cp"># which allows similar functionality:</span>

<span class="cp">require &#39;strscan&#39;</span>
<span class="cp">text = &#39;the year 1752 lost 10 days on the 3rd of September&#39;</span>
<span class="cp">sc = StringScanner.new(text)</span>
<span class="cp">while sc.scan(/.*?(\d+)/)</span>
<span class="cp">    print &quot;found: #{sc[1]}\n&quot;   </span>
<span class="cp">end</span>
<span class="cp">if sc.scan(/\S+/)</span>
<span class="cp">    puts &quot;Found #{sc[0]} after last number&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># assuming continuing from above:</span>
<span class="cp">puts &quot;The position in &#39;text&#39; is: #{sc.pos}&quot;</span>
<span class="cp">sc.pos = 30</span>
<span class="cp">puts &quot;The position in &#39;text&#39; is: #{sc.pos}&quot;</span>


<span class="cp"># @@PLEAC@@_6.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># greedy pattern</span>
<span class="cp">str.gsub!(/&lt;.*&gt;/m,&#39;&#39;)   # not good</span>

<span class="cp"># non-greedy (minimal) pattern</span>
<span class="cp">str.gsub!(/&lt;.*?&gt;/m,&#39;&#39;)   # not great</span>


<span class="cp">#-----------------------------</span>
<span class="cp">#&lt;b&gt;&lt;i&gt;this&lt;/i&gt; and &lt;i&gt;that&lt;/i&gt; are important&lt;/b&gt; Oh, &lt;b&gt;&lt;i&gt;me too!&lt;/i&gt;&lt;/b&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r{ &lt;b&gt;&lt;i&gt;(.*?)&lt;/i&gt;&lt;/b&gt; }mx</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r/BEGIN((?:(?!BEGIN).)*)END/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r{ &lt;b&gt;&lt;i&gt;(  (?: (?!&lt;/b&gt;|&lt;/i&gt;). )*  ) &lt;/i&gt;&lt;/b&gt; }mx</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r{ &lt;b&gt;&lt;i&gt;(  (?: (?!&lt;/[ib]&gt;). )*  ) &lt;/i&gt;&lt;/b&gt; }mx</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r{</span>
<span class="cp">    &lt;b&gt;&lt;i&gt; </span>
<span class="cp">    [^&lt;]*  # stuff not possibly bad, and not possibly the end.</span>
<span class="cp">    (?:</span>
<span class="cp"> # at this point, we can have &#39;&lt;&#39; if not part of something bad</span>
<span class="cp">     (?!  &lt;/?[ib]&gt;  )   # what we can&#39;t have</span>
<span class="cp">     &lt;                  # okay, so match the &#39;&lt;&#39;</span>
<span class="cp">     [^&lt;]*              # and continue with more safe stuff</span>
<span class="cp">    ) *</span>
<span class="cp">    &lt;/i&gt;&lt;/b&gt;</span>
<span class="cp"> }mx</span>


<span class="cp"># @@PLEAC@@_6.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = &quot;&quot;</span>
<span class="cp">ARGF.each do |para|</span>
<span class="cp">    para.scan %r/</span>
<span class="cp">                  \b     # start at word boundary</span>
<span class="cp">                  (\S+)  # find chunk of non-whitespace</span>
<span class="cp">                  \b     # until a word boundary</span>
<span class="cp">                  (      </span>
<span class="cp">                    \s+  # followed by whitespace</span>
<span class="cp">                    \1   # and that same chunk again</span>
<span class="cp">                    \b   # and a word boundary</span>
<span class="cp">                  ) +    # one or more times</span>
<span class="cp">                /xi do</span>
<span class="cp">        puts &quot;dup word &#39;#{$1}&#39; at paragraph #{$.}&quot; </span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">astr = &#39;nobody&#39;</span>
<span class="cp">bstr = &#39;bodysnatcher&#39;</span>
<span class="cp">if &quot;#{astr} #{bstr}&quot; =~ /^(\w+)(\w+) \2(\w+)$/</span>
<span class="cp">    print &quot;#{$2} overlaps in #{$1}-#{$2}-#{$3}&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># prime_pattern -- find prime factors of argument using patterns</span>
<span class="cp">ARGV &lt;&lt; 180</span>
<span class="cp">cap = &#39;o&#39; * ARGV.shift</span>
<span class="cp">while cap =~ /^(oo+?)\1+$/</span>
<span class="cp">    print $1.size, &quot; &quot;</span>
<span class="cp">    cap.gsub!(/#{$1}/,&#39;o&#39;)</span>
<span class="cp">end</span>
<span class="cp">puts cap.size</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#diophantine</span>
<span class="cp"># solve for 12x + 15y + 16z = 281, maximizing x</span>
<span class="cp">if (&#39;o&#39; * 281).match(/^(o*)\1{11}(o*)\2{14}(o*)\3{15}$/)</span>
<span class="cp">    x, y, z = $1.size, $2.size, $3.size</span>
<span class="cp">    puts &quot;One solution is: x=#{x}; y=#{y}; z=#{z}&quot;</span>
<span class="cp">else </span>
<span class="cp">    puts &quot;No solution.&quot;</span>
<span class="cp">end</span>
<span class="cp">#    =&gt; One solution is: x=17; y=3; z=2</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># using different quantifiers:</span>
<span class="cp">(&#39;o&#39; * 281).match(/^(o+)\1{11}(o+)\2{14}(o+)\3{15}$/)</span>
<span class="cp">#    =&gt; One solution is: x=17; y=3; z=2</span>

<span class="cp">(&#39;o&#39; * 281).match(/^(o*?)\1{11}(o*)\2{14}(o*)\3{15}$/)</span>
<span class="cp">#    =&gt; One solution is: x=0; y=7; z=11</span>

<span class="cp">(&#39;o&#39; * 281).match(/^(o+?)\1{11}(o*)\2{14}(o*)\3{15}$/)</span>
<span class="cp">#    =&gt; One solution is: x=1; y=3; z=14</span>


<span class="cp"># @@PLEAC@@_6.17</span>
<span class="cp"># alpha OR beta</span>
<span class="cp">%r/alpha|beta/</span>

<span class="cp"># alpha AND beta</span>
<span class="cp">%r/(?=.*alpha)(?=.*beta)/m</span>

<span class="cp"># alpha AND beta,  no overlap</span>
<span class="cp">%r/alpha.*beta|beta.*alpha/m</span>

<span class="cp"># NOT beta</span>
<span class="cp">%r/^(?:(?!beta).)*$/m</span>

<span class="cp"># NOT bad BUT good</span>
<span class="cp">%r/(?=(?:(?!BAD).)*$)GOOD/m</span>
<span class="cp">#-----------------------------</span>

<span class="cp">if !(string =~ /pattern/)   # ugly</span>
<span class="cp">    something()</span>
<span class="cp">end</span>

<span class="cp">if string !~ /pattern/   # preferred</span>
<span class="cp">    something()</span>
<span class="cp">end</span>


<span class="cp">#-----------------------------</span>
<span class="cp">if string =~ /pat1/  &amp;&amp; string =~ /pat2/</span>
<span class="cp">    something()</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if string =~ /pat1/ || string =~ /pat2/</span>
<span class="cp">    something()</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># minigrep - trivial grep</span>
<span class="cp">pat = ARGV.shift</span>
<span class="cp">ARGF.each do |line|</span>
<span class="cp">    print line if line =~ /#{pat}/o</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp"> &quot;labelled&quot; =~ /^(?=.*bell)(?=.*lab)/m</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$string =~ /bell/ &amp;&amp; $string =~ /lab/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$murray_hill = &quot;blah bell blah &quot;</span>
<span class="cp">if $murray_hill =~ %r{</span>
<span class="cp">                         ^              # start of string</span>
<span class="cp">                        (?=             # zero-width lookahead</span>
<span class="cp">                            .*          # any amount of intervening stuff</span>
<span class="cp">                            bell        # the desired bell string</span>
<span class="cp">                        )               # rewind, since we were only looking</span>
<span class="cp">                        (?=             # and do the same thing</span>
<span class="cp">                            .*          # any amount of intervening stuff</span>
<span class="cp">                            lab         # and the lab part</span>
<span class="cp">                        )</span>
<span class="cp">                     }mx                # /m means . can match newline</span>

<span class="cp">    print &quot;Looks like Bell Labs might be in Murray Hill!\n&quot;;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">&quot;labelled&quot; =~ /(?:^.*bell.*lab)|(?:^.*lab.*bell)/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$brand = &quot;labelled&quot;;</span>
<span class="cp">if $brand =~ %r{</span>
<span class="cp">                (?:                 # non-capturing grouper</span>
<span class="cp">                    ^ .*?           # any amount of stuff at the front</span>
<span class="cp">                      bell          # look for a bell</span>
<span class="cp">                      .*?           # followed by any amount of anything</span>
<span class="cp">                      lab           # look for a lab</span>
<span class="cp">                  )                 # end grouper</span>
<span class="cp">            |                       # otherwise, try the other direction</span>
<span class="cp">                (?:                 # non-capturing grouper</span>
<span class="cp">                    ^ .*?           # any amount of stuff at the front</span>
<span class="cp">                      lab           # look for a lab</span>
<span class="cp">                      .*?           # followed by any amount of anything</span>
<span class="cp">                      bell          # followed by a bell</span>
<span class="cp">                  )                 # end grouper</span>
<span class="cp">            }mx                     # /m means . can match newline</span>
<span class="cp">    print &quot;Our brand has bell and lab separate.\n&quot;;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$map =~ /^(?:(?!waldo).)*$/s</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$map = &quot;the great baldo&quot;</span>
<span class="cp">if $map =~ %r{</span>
<span class="cp">                ^                   # start of string</span>
<span class="cp">                (?:                 # non-capturing grouper</span>
<span class="cp">                    (?!             # look ahead negation</span>
<span class="cp">                        waldo       # is he ahead of us now?</span>
<span class="cp">                    )               # is so, the negation failed</span>
<span class="cp">                    .               # any character (cuzza /s)</span>
<span class="cp">                ) *                 # repeat that grouping 0 or more</span>
<span class="cp">                $                   # through the end of the string</span>
<span class="cp">             }mx                    # /m means . can match newline</span>
<span class="cp">    print &quot;There&#39;s no waldo here!\n&quot;;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp"> 7:15am  up 206 days, 13:30,  4 users,  load average: 1.04, 1.07, 1.04</span>

<span class="cp">USER     TTY      FROM              LOGIN@  IDLE   JCPU   PCPU  WHAT</span>

<span class="cp">tchrist  tty1                       5:16pm 36days 24:43   0.03s  xinit</span>

<span class="cp">tchrist  tty2                       5:19pm  6days  0.43s  0.43s  -tcsh</span>

<span class="cp">tchrist  ttyp0    chthon            7:58am  3days 23.44s  0.44s  -tcsh</span>

<span class="cp">gnat     ttyS4    coprolith         2:01pm 13:36m  0.30s  0.30s  -tcsh</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% w | minigrep &#39;^(?!.*ttyp).*tchrist&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r{</span>
<span class="cp">    ^                       # anchored to the start</span>
<span class="cp">    (?!                     # zero-width look-ahead assertion</span>
<span class="cp">        .*                  # any amount of anything (faster than .*?)</span>
<span class="cp">        ttyp                # the string you don&#39;t want to find</span>
<span class="cp">    )                       # end look-ahead negation; rewind to start</span>
<span class="cp">    .*                      # any amount of anything (faster than .*?)</span>
<span class="cp">    tchrist                 # now try to find Tom</span>
<span class="cp">}x</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% w | grep tchrist | grep -v ttyp</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% grep -i &#39;pattern&#39; files</span>
<span class="cp">#% minigrep &#39;(?i)pattern&#39; files</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_6.20</span>
<span class="cp">ans = $stdin.gets.chomp</span>
<span class="cp">re = %r/^#{Regexp.quote(ans)}/</span>
<span class="cp">case </span>
<span class="cp">    when &quot;SEND&quot;  =~ re : puts &quot;Action is send&quot;</span>
<span class="cp">    when &quot;STOP&quot;  =~ re : puts &quot;Action is stop&quot;</span>
<span class="cp">    when &quot;ABORT&quot; =~ re : puts &quot;Action is abort&quot;</span>
<span class="cp">    when &quot;EDIT&quot;  =~ re : puts &quot;Action is edit&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require &#39;abbrev&#39;</span>
<span class="cp">table = Abbrev.abbrev %w-send stop abort edit-</span>
<span class="cp">loop do</span>
<span class="cp">    print &quot;Action: &quot;</span>
<span class="cp">    ans = $stdin.gets.chomp</span>
<span class="cp">    puts &quot;Action for #{ans} is #{table[ans.downcase]}&quot;</span>
<span class="cp">end</span>


<span class="cp">#-----------------------------</span>
<span class="cp"># dummy values are defined for &#39;file&#39;, &#39;PAGER&#39;, and</span>
<span class="cp"># the &#39;invoke_editor&#39; and &#39;deliver_message&#39; methods</span>
<span class="cp"># do not do anything interesting in this example.</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp">require &#39;abbrev&#39;</span>

<span class="cp">file = &#39;pleac_ruby.data&#39;</span>
<span class="cp">PAGER = &#39;less&#39;</span>

<span class="cp">def invoke_editor</span>
<span class="cp">    puts &quot;invoking editor&quot;</span>
<span class="cp">end</span>

<span class="cp">def deliver_message</span>
<span class="cp">    puts &quot;delivering message&quot;</span>
<span class="cp">end</span>

<span class="cp">actions = {</span>
<span class="cp">    &#39;edit&#39;  =&gt; self.method(:invoke_editor),</span>
<span class="cp">    &#39;send&#39;  =&gt; self.method(:deliver_message),</span>
<span class="cp">    &#39;list&#39;  =&gt; proc {system(PAGER, file)},</span>
<span class="cp">    &#39;abort&#39; =&gt; proc {puts &quot;See ya!&quot;; exit},</span>
<span class="cp">    &quot;&quot;      =&gt; proc {puts &quot;Unknown Command&quot;}</span>
<span class="cp">}</span>

<span class="cp">dtable = Abbrev.abbrev(actions.keys)</span>
<span class="cp">loop do</span>
<span class="cp">    print &quot;Action: &quot;</span>
<span class="cp">    ans = $stdin.gets.chomp.delete(&quot; \t&quot;)</span>
<span class="cp">    actions[ dtable[ans.downcase] || &quot;&quot; ].call</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_6.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># basically, the Perl Cookbook categorizes this as an</span>
<span class="cp"># unsolvable problem ...</span>
<span class="cp">#-----------------------------</span>
<span class="cp">1 while addr.gsub!(/\([^()]*\)/,&#39;&#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">Dear someuser@host.com,</span>

<span class="cp">Please confirm the mail address you gave us Wed May  6 09:38:41</span>
<span class="cp">MDT 1998 by replying to this message.  Include the string</span>
<span class="cp">&quot;Rumpelstiltskin&quot; in that reply, but spelled in reverse; that is,</span>
<span class="cp">start with &quot;Nik...&quot;.  Once this is done, your confirmed address will</span>
<span class="cp">be entered into our records.</span>


<span class="cp"># @@PLEAC@@_6.21</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% gunzip -c ~/mail/archive.gz | urlify &gt; archive.urlified</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% urlify ~/mail/*.inbox &gt; ~/allmail.urlified</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># urlify - wrap HTML links around URL-like constructs</span>

<span class="cp">urls = &#39;(https?|telnet|gopher|file|wais|ftp)&#39;;</span>
<span class="cp">ltrs = &#39;\w&#39;;</span>
<span class="cp">gunk = &#39;/#~:.?+=&amp;%@!\-&#39;;</span>
<span class="cp">punc = &#39;.:?\-&#39;;</span>
<span class="cp">any  = &quot;#{ltrs}#{gunk}#{punc}&quot;;</span>

<span class="cp">ARGF.each do |line|</span>
<span class="cp">    line.gsub! %r/</span>
<span class="cp">        \b                    # start at word boundary</span>
<span class="cp">        (                     # begin $1  {</span>
<span class="cp">         #{urls}     :        # need resource and a colon</span>
<span class="cp">         [#{any}] +?          # followed by on or more</span>
<span class="cp">                              #  of any valid character, but</span>
<span class="cp">                              #  be conservative and take only</span>
<span class="cp">                              #  what you need to....</span>
<span class="cp">        )                     # end   $1  }</span>
<span class="cp">        (?=                   # look-ahead non-consumptive assertion</span>
<span class="cp">         [#{punc}]*           # either 0 or more punctuation</span>
<span class="cp">         [^#{any}]            #   followed by a non-url char</span>
<span class="cp">         |                    # or else</span>
<span class="cp">         $                    #   then end of the string</span>
<span class="cp">        )</span>
<span class="cp">    /iox do </span>
<span class="cp">        %Q|&lt;A HREF=&quot;#{$1}&quot;&gt;#{$1}&lt;/A&gt;|</span>
<span class="cp">    end</span>
<span class="cp">    print line</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_6.23</span>
<span class="cp">%r/^m*(d?c{0,3}|c[dm])(l?x{0,3}|x[lc])(v?i{0,3}|i[vx])$/i</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.sub!(/(\S+)(\s+)(\S+)/, &#39;\3\2\1&#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r/(\w+)\s*=\s*(.*)\s*$/             # keyword is $1, value is $2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r/.{80,}/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r|(\d+)/(\d+)/(\d+) (\d+):(\d+):(\d+)|</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.gsub!(%r|/usr/bin|,&#39;/usr/local/bin&#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.gsub!(/%([0-9A-Fa-f][0-9A-Fa-f])/){ $1.hex.chr }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.gsub!(%r{</span>
<span class="cp">    /\*                    # Match the opening delimiter</span>
<span class="cp">    .*?                    # Match a minimal number of characters</span>
<span class="cp">    \*/                    # Match the closing delimiter</span>
<span class="cp">}xm,&#39;&#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.sub!(/^\s+/, &#39;&#39;)</span>
<span class="cp">str.sub!(/\s+$/, &#39;&#39;)</span>

<span class="cp"># but really, in Ruby we&#39;d just do:</span>
<span class="cp">str.strip!</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.gsub!(/\\n/,&quot;\n&quot;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.sub!(/^.*::/, &#39;&#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r/^([01]?\d\d|2[0-4]\d|25[0-5])\.([01]?\d\d|2[0-4]\d|25[0-5])\.</span>
<span class="cp">    ([01]?\d\d|2[0-4]\d|25[0-5])\.([01]?\d\d|2[0-4]\d|25[0-5])$/x</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.sub!(%r|^.*/|, &#39;&#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">cols = ( (ENV[&#39;TERMCAP&#39;] || &quot; &quot;) =~ /:co#(\d+):/ ) ? $1 : 80;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">name = &quot; #{$0} #{ARGV}&quot;.gsub(%r| /\S+/|, &#39; &#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require &#39;rbconfig&#39;</span>
<span class="cp">include Config</span>
<span class="cp">raise &quot;This isn&#39;t Linux&quot; unless CONFIG[&#39;target_os&#39;] =~ /linux/i;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.gsub!(%r/\n\s+/, &#39; &#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">nums = str.scan(/(\d+\.?\d*|\.\d+)/)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">capwords = str.scan(%r/(\b[^\Wa-z0-9_]+\b)/)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">lowords = str.scan(%r/(\b[^\WA-Z0-9_]+\b)/)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">icwords = str.scan(%r/(\b[^\Wa-z0-9_][^\WA-Z0-9_]*\b)/)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">links = str.scan(%r/&lt;A[^&gt;]+?HREF\s*=\s*[&quot;&#39;]?([^&#39;&quot; &gt;]+?)[ &#39;&quot;]?&gt;/mi)   #&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">initial = str =~ /^\S+\s+(\S)\S*\s+\S/ ? $1 : &quot;&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">str.gsub!(%r/&quot;([^&quot;]*)&quot;/, %q-``\1&#39;&#39;-)   #&quot;</span>
<span class="cp">#-----------------------------</span>

<span class="cp">$/ = &quot;&quot;</span>
<span class="cp">sentences = []</span>
<span class="cp">ARGF.each do |para|</span>
<span class="cp">    para.gsub!(/\n/, &#39; &#39;)</span>
<span class="cp">    para.gsub!(/ {3,}/,&#39;  &#39;)</span>
<span class="cp">    sentences &lt;&lt; para.scan(/(\S.*?[!?.])(?=  |\Z)/)</span>
<span class="cp">end</span>

<span class="cp">#-----------------------------</span>
<span class="cp">%r/(\d{4})-(\d\d)-(\d\d)/            # YYYY in $1, MM in $2, DD in $3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r/ ^</span>
<span class="cp">      (?:</span>
<span class="cp">       1 \s (?: \d\d\d \s)?            # 1, or 1 and area code</span>
<span class="cp">       |                               # ... or ...</span>
<span class="cp">       \(\d\d\d\) \s                   # area code with parens</span>
<span class="cp">       |                               # ... or ...</span>
<span class="cp">       (?: \+\d\d?\d? \s)?             # optional +country code</span>
<span class="cp">       \d\d\d ([\s\-])                 # and area code</span>
<span class="cp">      )</span>
<span class="cp">      \d\d\d (\s|\1)                   # prefix (and area code separator)</span>
<span class="cp">      \d\d\d\d                         # exchange</span>
<span class="cp">        $</span>
<span class="cp"> /x</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%r/\boh\s+my\s+gh?o(d(dess(es)?|s?)|odness|sh)\b/i</span>
<span class="cp">#-----------------------------</span>
<span class="cp">lines = []</span>
<span class="cp">lines &lt;&lt; $1 while input.sub!(/^([^\012\015]*)(\012\015?|\015\012?)/,&#39;&#39;)</span>


<span class="cp"># @@PLEAC@@_7.0</span>
<span class="cp"># An IO object being Enumerable, we can use &#39;each&#39; directly on it</span>
<span class="cp">File.open(&quot;/usr/local/widgets/data&quot;).each { |line|</span>
<span class="cp">    puts line if line =~ /blue/</span>
<span class="cp">}</span>

<span class="cp">logfile = File.new(&quot;/var/log/rubylog.txt&quot;, &quot;w&quot;)</span>
<span class="cp">mysub($stdin, logfile)</span>

<span class="cp"># The method IO#readline is similar  to IO#gets</span>
<span class="cp"># but throws an exception when it reaches EOF</span>
<span class="cp">f = File.new(&quot;bla.txt&quot;)</span>
<span class="cp">begin</span>
<span class="cp">    while (line = f.readline)</span>
<span class="cp">        line.chomp</span>
<span class="cp">        $stdout.print line if line =~ /blue/</span>
<span class="cp">    end</span>
<span class="cp">rescue EOFError</span>
<span class="cp">    f.close</span>
<span class="cp">end</span>

<span class="cp">while $stdin.gets                        # reads from STDIN</span>
<span class="cp">    unless (/\d/) </span>
<span class="cp">        $stderr.puts &quot;No digit found.&quot;   # writes to STDERR</span>
<span class="cp">    end</span>
<span class="cp">    puts &quot;Read: #{$_}&quot;                   # writes to STDOUT</span>
<span class="cp">end</span>

<span class="cp">logfile = File.new(&quot;/tmp/log&quot;, &quot;w&quot;)</span>

<span class="cp">logfile.close</span>

<span class="cp"># $defout (or its synonym &#39;$&gt;&#39;) is the destination of output</span>
<span class="cp"># for Kernel#print, Kernel#puts, and family functions</span>
<span class="cp">logfile = File.new(&quot;log.txt&quot;, &quot;w&quot;)</span>
<span class="cp">old = $defout</span>
<span class="cp">$defout = logfile                 # switch to logfile for output</span>
<span class="cp">puts &quot;Countdown initiated ...&quot;</span>
<span class="cp">$defout = old                     # return to original output</span>
<span class="cp">puts &quot;You have 30 seconds to reach minimum safety distance.&quot;</span>


<span class="cp"># @@PLEAC@@_7.1</span>
<span class="cp">source = File.new(path, &quot;r&quot;)  # open file &quot;path&quot; for reading only</span>
<span class="cp">sink   = File.new(path, &quot;w&quot;)  # open file &quot;path&quot; for writing only</span>

<span class="cp">source = File.open(path, File::RDONLY)  # open file &quot;path&quot; for reading only</span>
<span class="cp">sink   = File.open(path, File::WRONLY)  # open file &quot;path&quot; for writing only</span>

<span class="cp">file   = File.open(path, &quot;r+&quot;)  # open &quot;path&quot; for reading and writing</span>
<span class="cp">file   = File.open(path, flags) # open &quot;path&quot; with the flags &quot;flags&quot; (see examples below for flags)</span>

<span class="cp"># open file &quot;path&quot; read only</span>
<span class="cp">file   = File.open(path, &quot;r&quot;)</span>
<span class="cp">file   = File.open(path, File::RDONLY)</span>

<span class="cp"># open file &quot;path&quot; write only, create it if it does not exist</span>
<span class="cp"># truncate it to zero length if it exists</span>
<span class="cp">file   = File.open(path, &quot;w&quot;)</span>
<span class="cp">file   = File.open(path, File::WRONLY|File::TRUNC|File::CREAT) </span>
<span class="cp">file   = File.open(path, File::WRONLY|File::TRUNC|File::CREAT, 0666)  # with permission 0666</span>

<span class="cp"># open file &quot;path&quot; write only, fails if file exists</span>
<span class="cp">file   = File.open(path, File::WRONLY|File::EXCL|File::CREAT) </span>
<span class="cp">file   = File.open(path, File::WRONLY|File::EXCL|File::CREAT, 0666) </span>

<span class="cp"># open file &quot;path&quot; for appending</span>
<span class="cp">file   = File.open(path, &quot;a&quot;)</span>
<span class="cp">file   = File.open(path, File::WRONLY|File::APPEND|File::CREAT) </span>
<span class="cp">file   = File.open(path, File::WRONLY|File::APPEND|File::CREAT, 0666) </span>

<span class="cp"># open file &quot;path&quot; for appending only when file exists</span>
<span class="cp">file   = File.open(path, File::WRONLY|File::APPEND) </span>

<span class="cp"># open file &quot;path&quot; for reading and writing</span>
<span class="cp">file   = File.open(path, &quot;r+&quot;)</span>
<span class="cp">file   = File.open(path, File::RDWR)</span>

<span class="cp"># open file for reading and writing, create a new file if it does not exist</span>
<span class="cp">file   = File.open(path, File::RDWR|File::CREAT)</span>
<span class="cp">file   = File.open(path, File::RDWR|File::CREAT, 0600)</span>

<span class="cp"># open file &quot;path&quot; reading and writing, fails if file exists</span>
<span class="cp">file   = File.open(path, File::RDWR|File::EXCL|File::CREAT)</span>
<span class="cp">file   = File.open(path, File::RDWR|File::EXCL|File::CREAT, 0600)</span>


<span class="cp"># @@PLEAC@@_7.2</span>
<span class="cp"># No problem with Ruby since the filename doesn&#39;t contain characters with</span>
<span class="cp"># special meaning; like Perl&#39;s sysopen</span>
<span class="cp">File.open(filename, &#39;r&#39;)</span>


<span class="cp"># @@PLEAC@@_7.3</span>
<span class="cp">File.expand_path(&#39;~root/tmp&#39;)</span>
<span class="cp">#=&gt; &quot;/root/tmp&quot;</span>
<span class="cp">File.expand_path(&#39;~rpcuser&#39;)</span>
<span class="cp">#=&gt; &quot;/var/lib/nfs&quot;</span>

<span class="cp"># To expand ~/.. it explicitely needs the environment variable HOME</span>
<span class="cp">File.expand_path(&#39;~/tmp&#39;)</span>
<span class="cp">#=&gt; &quot;/home/gc/tmp&quot;</span>


<span class="cp"># @@PLEAC@@_7.4</span>
<span class="cp"># The exception raised in Ruby reports the filename</span>
<span class="cp">File.open(&#39;afile&#39;)</span>


<span class="cp"># @@PLEAC@@_7.5</span>
<span class="cp"># Standard Ruby distribution provides the following useful extension</span>
<span class="cp">require &#39;tempfile&#39;</span>
<span class="cp"># With the Tempfile class, the file is automatically deleted on garbage</span>
<span class="cp"># collection, so you won&#39;t need to remove it, later on.</span>
<span class="cp">tf = Tempfile.new(&#39;tmp&#39;)   # a name is required to create the filename</span>

<span class="cp"># If you need to pass the filename to an external program you can use</span>
<span class="cp"># File#path, but don&#39;t forget to File#flush in order to flush anything</span>
<span class="cp"># living in some buffer somewhere.</span>
<span class="cp">tf.flush</span>
<span class="cp">system(&quot;/usr/bin/dowhatever #{tf.path}&quot;)</span>

<span class="cp">fh = Tempfile.new(&#39;tmp&#39;)</span>
<span class="cp">fh.sync = true                # autoflushes</span>
<span class="cp">10.times { |i| fh.puts i }</span>
<span class="cp">fh.rewind</span>
<span class="cp">puts &#39;Tmp file has: &#39;, fh.readlines</span>


<span class="cp"># @@PLEAC@@_7.6</span>
<span class="cp">while (DATA.gets) do</span>
<span class="cp">    # process the line  </span>
<span class="cp">end</span>
<span class="cp">__END__</span>
<span class="cp"># your data goes here</span>

<span class="cp"># __DATA__ doesn&#39;t exist in Ruby</span>

<span class="cp"># get info about the script (size, date of last modification)</span>
<span class="cp">kilosize = DATA.stat.size / 1024</span>
<span class="cp">last_modif = DATA.stat.mtime</span>
<span class="cp">puts &quot;&lt;P&gt;Script size is #{kilosize}&quot;</span>
<span class="cp">puts &quot;&lt;P&gt;Last script update: #{last_modif}&quot;</span>
<span class="cp">__END__</span>
<span class="cp"># DO NOT REMOVE THE PRECEEDING LINE.</span>
<span class="cp"># Everything else in this file will be ignored.</span>


<span class="cp"># @@PLEAC@@_7.7</span>
<span class="cp">while line = gets do</span>
<span class="cp">    # do something with line.</span>
<span class="cp">end</span>

<span class="cp">#  or </span>
<span class="cp">while gets do</span>
<span class="cp">    # do something with $_</span>
<span class="cp">end</span>

<span class="cp"># or more rubyish</span>
<span class="cp">$stdin.each do |line|</span>
<span class="cp">    # do stuff with line</span>
<span class="cp">end</span>


<span class="cp"># ARGF may makes this more easy</span>
<span class="cp"># this is skipped if ARGV.size==0</span>
<span class="cp">ARGV.each do |filename| </span>
<span class="cp">    # closing and exception handling are done by the block</span>
<span class="cp">    open(filename) do |fd| </span>
<span class="cp">        fd.each do |line|</span>
<span class="cp">            # do stuff with line</span>
<span class="cp">        end   </span>
<span class="cp">    end rescue abort(&quot;can&#39;t open %s&quot; % filename)</span>
<span class="cp">end</span>

<span class="cp"># globbing is done in the Dir module</span>
<span class="cp">ARGV = Dir[&quot;*.[Cch]&quot;] if ARGV.empty?</span>

<span class="cp"># note: optparse is the preferred way to handle this</span>
<span class="cp">if (ARGV[0] == &#39;-c&#39;)  </span>
<span class="cp">    chop_first += 1</span>
<span class="cp">    ARGV.shift</span>
<span class="cp">end</span>


<span class="cp"># processing numerical options</span>
<span class="cp">if ARGV[0] =~ /^-(\d+)$/</span>
<span class="cp">    columns = $1</span>
<span class="cp">    ARGV.shift</span>
<span class="cp">end</span>

<span class="cp"># again, better to use optparse:</span>
<span class="cp">require &#39;optparse&#39;</span>
<span class="cp">nostdout = 0</span>
<span class="cp">append = 0</span>
<span class="cp">unbuffer = 0</span>
<span class="cp">ignore_ints = 0</span>
<span class="cp">ARGV.options do |opt|</span>
<span class="cp">    opt.on(&#39;-n&#39;) { nostdout +=1 }</span>
<span class="cp">    opt.on(&#39;-a&#39;) { append   +=1 }</span>
<span class="cp">    opt.on(&#39;-u&#39;) { unbuffer +=1 }</span>
<span class="cp">    opt.on(&#39;-i&#39;) { ignore_ints +=1 }</span>
<span class="cp">    opt.parse!</span>
<span class="cp">end or abort(&quot;usage: &quot; + __FILE__ + &quot; [-ainu] [filenames]&quot;)</span>

<span class="cp"># no need to do undef $/, we have File.read</span>
<span class="cp">str = File.read(ARGV[0])</span>

<span class="cp"># again we have File.read</span>
<span class="cp">str = File.read(ARGV[0])</span>

<span class="cp"># not sure what this should do:</span>
<span class="cp"># I believe open the file, print filename, lineno and line:</span>
<span class="cp">ARGF.each_with_index do |line, idx|</span>
<span class="cp">    print ARGF.filename, &quot;:&quot;, idx, &quot;;&quot;, line</span>
<span class="cp">end</span>

<span class="cp"># print all the lines in every file passed via command line that contains login</span>
<span class="cp">ARGF.each do |line|</span>
<span class="cp">    puts line if line =~ /login/</span>
<span class="cp">end</span>
<span class="cp">#</span>
<span class="cp"># even this would fit</span>
<span class="cp">#%ruby -ne &quot;print if /f/&quot; 2.log</span>
<span class="cp">#</span>

<span class="cp">ARGF.each { |l| puts l.downcase! }</span>

<span class="cp">#------------------</span>
<span class="cp">#!/usr/bin/ruby -p</span>
<span class="cp"># just like perl&#39;s -p</span>
<span class="cp">$_.downcase!</span>
<span class="cp">#</span>

<span class="cp"># I don&#39;t know who should I trust. </span>
<span class="cp"># perl&#39;s version splits on \w+ while python&#39;s on \w.</span>

<span class="cp">chunks = 0</span>

<span class="cp">File.read(ARGV[0]).split.each do |word|</span>
<span class="cp">    next if word =~ /^#/</span>
<span class="cp">    break if [&quot;__DATA__&quot;, &quot;__END__&quot;].member? word</span>
<span class="cp">    chunks += 1 </span>
<span class="cp">end</span>

<span class="cp">print &quot;Found &quot;, chunks, &quot; chunks\n&quot;</span>


<span class="cp"># @@PLEAC@@_7.8</span>
<span class="cp">old = File.open(old_file)</span>
<span class="cp">new = File.open(new_file, &quot;w&quot;)</span>
<span class="cp">while old.gets do</span>
<span class="cp">    # change $_, then...</span>
<span class="cp">    new.print $_</span>
<span class="cp">end</span>
<span class="cp">old.close</span>
<span class="cp">new.close</span>
<span class="cp">File.rename(old_file, &quot;old.orig&quot;)</span>
<span class="cp">File.rename(new_file, old_file)</span>

<span class="cp">while old.gets do</span>
<span class="cp">    if $. == 20 then # we are at the 20th line</span>
<span class="cp">        new.puts &quot;Extra line 1&quot;</span>
<span class="cp">        new.puts &quot;Extra line 2&quot;</span>
<span class="cp">    end</span>
<span class="cp">    new.print $_</span>
<span class="cp">end</span>

<span class="cp">while old.gets do</span>
<span class="cp">    next if 20..30 # skip the 20th line to the 30th</span>
<span class="cp">                   # Ruby (and Perl) permit to write if 20..30 </span>
<span class="cp">                   # instead of if (20 &lt;= $.) and ($. &lt;= 30)</span>
<span class="cp">    new.print $_</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_7.9</span>
<span class="cp">#% ruby -i.orig -pe &#39;FILTER COMMAND&#39; file1 file2 file3 ...</span>
<span class="cp">#</span>
<span class="cp">#-----------------------------</span>
<span class="cp">##!/usr/bin/ruby -i.orig -p</span>
<span class="cp"># filter commands go here</span>
<span class="cp">#-----------------------------</span>

<span class="cp">#% ruby -pi.orig -e &#39;gsub!(/DATE/){Time.now)&#39;</span>

<span class="cp"># effectively becomes:</span>
<span class="cp">ARGV &lt;&lt; &#39;I&#39;</span>
<span class="cp">oldfile = &quot;&quot;</span>
<span class="cp">while gets</span>
<span class="cp">    if ARGF.filename != oldfile</span>
<span class="cp">        newfile = ARGF.filename</span>
<span class="cp">        File.rename(newfile, newfile + &quot;.orig&quot;)</span>
<span class="cp">        $stdout = File.open(newfile,&#39;w&#39;)</span>
<span class="cp">        oldfile = newfile</span>
<span class="cp">    end</span>
<span class="cp">    gsub!(/DATE/){Time.now}</span>
<span class="cp">    print </span>
<span class="cp">end</span>
<span class="cp">$stdout = STDOUT</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ruby -i.old -pe &#39;gsub!(%r{\bhisvar\b}, &#39;hervar&#39;)&#39; *.[Cchy]</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># set up to iterate over the *.c files in the current directory,</span>
<span class="cp"># editing in place and saving the old file with a .orig extension</span>
<span class="cp">$-i = &#39;.orig&#39;                       # set up -i mode</span>
<span class="cp">ARGV.replace(Dir[&#39;*.[Cchy]&#39;])</span>
<span class="cp">while gets</span>
<span class="cp">    if $. == 1</span>
<span class="cp">        print &quot;This line should appear at the top of each file\n&quot;</span>
<span class="cp">    end</span>
<span class="cp">    gsub!(/\b(p)earl\b/i, &#39;\1erl&#39;)    # Correct typos, preserving case</span>
<span class="cp">    print</span>
<span class="cp">    ARGF.close if ARGF.eof</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_7.10</span>
<span class="cp">File.open(&#39;itest&#39;, &#39;r+&#39;) do |f|   # open file for update</span>
<span class="cp">    lines = f.readlines           # read into array of lines</span>
<span class="cp">    lines.each do |it|            # modify lines</span>
<span class="cp">        it.gsub!(/foo/, &#39;QQQ&#39;)</span>
<span class="cp">    end</span>
<span class="cp">    f.pos = 0                     # back to start</span>
<span class="cp">    f.print lines                 # write out modified lines</span>
<span class="cp">    f.truncate(f.pos)             # truncate to new length</span>
<span class="cp">end                               # file is automatically closed</span>
<span class="cp">#-----------------------------</span>
<span class="cp">File.open(&#39;itest&#39;, &#39;r+&#39;) do |f|   </span>
<span class="cp">    out = &quot;&quot;</span>
<span class="cp">    f.each do |line|</span>
<span class="cp">        out &lt;&lt; line.gsub(/DATE/) {Time.now}</span>
<span class="cp">    end</span>
<span class="cp">    f.pos = 0                     </span>
<span class="cp">    f.print out</span>
<span class="cp">    f.truncate(f.pos)             </span>
<span class="cp">end</span>

<span class="cp"># @@PLEAC@@_7.11</span>
<span class="cp">File.open(&#39;infile&#39;, &#39;r+&#39;) do |f|</span>
<span class="cp">    f.flock File::LOCK_EX</span>
<span class="cp">    # update file</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">File::LOCK_SH     # shared lock (for reading)</span>
<span class="cp">File::LOCK_EX     # exclusive lock (for writing)</span>
<span class="cp">File::LOCK_NB     # non-blocking request</span>
<span class="cp">File::LOCK_UN     # free lock</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unless f.flock File::LOCK_EX | File::LOCK_NB</span>
<span class="cp">    warn &quot;can&#39;t get immediate lock: blocking ...&quot;</span>
<span class="cp">    f.flock File::LOCK_EX </span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">File.open(&#39;numfile&#39;, File::RDWR|File::CREAT) do |f|</span>
<span class="cp">    f.flock(File::LOCK_EX)</span>
<span class="cp">    num = f.gets.to_i || 0</span>
<span class="cp">    f.pos = 0</span>
<span class="cp">    f.truncate 0</span>
<span class="cp">    f.puts num + 1q</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_7.12</span>
<span class="cp">output_handle.sync = true</span>
<span class="cp"># Please note that like in Perl, $stderr is already unbuffered</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># seeme - demo stdio output buffering</span>
<span class="cp">$stdout.sync = ARGV.size &gt; 0</span>
<span class="cp">print &quot;Now you don&#39;t see it...&quot;</span>
<span class="cp">sleep 2</span>
<span class="cp">puts &quot;now you do&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$stderr.sync = true</span>
<span class="cp">afile.sync = false</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># assume &#39;remote_con&#39; is an interactive socket handle,</span>
<span class="cp"># but &#39;disk_file&#39; is a handle to a regular file.</span>
<span class="cp">remote_con.sync = true       # unbuffer for clarity</span>
<span class="cp">disk_file.sync = false       # buffered for speed</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require &#39;socket&#39;</span>
<span class="cp">sock = TCPSocket.new(&#39;www.ruby-lang.org&#39;, 80)</span>
<span class="cp">sock.sync = true</span>
<span class="cp">sock.puts &quot;GET /en/ HTTP/1.0 \n\n&quot;</span>
<span class="cp">resp = sock.read</span>
<span class="cp">print &quot;DOC IS: #{resp}\n&quot;</span>


<span class="cp"># @@PLEAC@@_7.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># assumes fh1, fh2, fh2 are oen IO objects</span>
<span class="cp">nfound = select([$stdin, fh1, fh2, fh3], nil, nil, 0)</span>
<span class="cp">nfound[0].each do |file|</span>
<span class="cp">    case file</span>
<span class="cp">        when fh1</span>
<span class="cp">            # do something with fh1</span>
<span class="cp">        when fh2</span>
<span class="cp">            # do something with fh2</span>
<span class="cp">        when fh3</span>
<span class="cp">            # do something with fh3</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">input_files = []</span>
<span class="cp"># repeat next line for all in-files to poll</span>
<span class="cp">input_files &lt;&lt; fh1</span>
<span class="cp">if nfound = select(input_files, nil, nil, 0)</span>
<span class="cp">    # input ready on files in nfound[0]</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_7.14</span>
<span class="cp"># It throws exception on EOF, instead of sysread, you can use read_nonblock(), too.</span>
<span class="cp">begin</span>
<span class="cp">   File.open fname, (File::RDONLY | File::NONBLOCK) do |io|</span>
<span class="cp">     puts io.sysread(4096) # throws exception</span>
<span class="cp">   end</span>
<span class="cp">rescue EOFError</span>
<span class="cp">rescue IOError =&gt; e</span>
<span class="cp">   puts e.exception</span>
<span class="cp">rescue Errno::ENOENT</span>
<span class="cp">   puts &quot;no such file #{fname}&quot;</span>
<span class="cp">end</span>

<span class="cp"># return nil on EOF</span>
<span class="cp">begin</span>
<span class="cp">   File.open fname, (File::RDONLY | File::NONBLOCK) do |io|</span>
<span class="cp">     puts io.read(4096) # returns nil</span>
<span class="cp">   end</span>
<span class="cp">rescue Errno::ENOENT</span>
<span class="cp">   puts &quot;no such file #{fname}&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_7.16</span>
<span class="cp"># filehandles are normal variables, so they behave properly</span>
<span class="cp">def subroutine(fh):</span>
<span class="cp">  fh.print &quot;Hello, file&quot;</span>
<span class="cp">end</span>

<span class="cp">variable = fh</span>
<span class="cp">subroutine(variable)</span>


<span class="cp"># @@PLEAC@@_7.18</span>
<span class="cp">#----------------------------</span>
<span class="cp">filehandles.each do |filehandle|</span>
<span class="cp">  filehandle.print stuff_to_print</span>
<span class="cp">end</span>
<span class="cp">#----------------------------</span>
<span class="cp"># NOTE: this is unix specific</span>
<span class="cp">IO.popen(&quot;tee file1 file2 file3 &gt;/dev/null&quot;, &quot;w&quot;) do |many|</span>
<span class="cp">  many.puts &quot;data&quot;</span>
<span class="cp">end</span>
<span class="cp">#----------------------------</span>
<span class="cp"># (really a Perl issue here, no problem in ruby)</span>
<span class="cp">[fh1 fh2 fh3].each {|fh| fh.puts &quot;whatever&quot; }</span>
<span class="cp">#----------------------------</span>
<span class="cp"># redirect to stdout to use print/puts directly</span>
<span class="cp">$stdout = IO.popen(&quot;tee file1 file2 file3&quot;, &quot;w&quot;)</span>
<span class="cp">puts &quot;whatever&quot;</span>
<span class="cp">$stdout.close</span>
<span class="cp">$stdout = STDOUT   # get things back to the way they were</span>
<span class="cp">#----------------------------</span>
<span class="cp"># create a class/object to encapsulate the behavior in ruby</span>
<span class="cp">class MultiDispatcher &lt; BasicObject # inherit from BasicObject in 1.9.x only</span>
<span class="cp"> def initialize(targets)</span>
<span class="cp">   @targets = targets</span>
<span class="cp"> end</span>

<span class="cp"> def method_missing(*a,&amp;b)</span>
<span class="cp">   @targets.each {|tgt| tgt.send(*a,&amp;b)}</span>
<span class="cp"> end</span>
<span class="cp">end</span>

<span class="cp">md = MultiDispatcher.new [$stdout, $stderr]</span>
<span class="cp">4.times {|i| md.printf &quot;%3d\n&quot;, i}</span>
<span class="cp">md.close</span>


<span class="cp"># @@PLEAC@@_8.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># datafile is a file or IO object</span>
<span class="cp">datafile.readlines.each { |line|</span>
<span class="cp">    line.chomp!</span>
<span class="cp">    size = line.length</span>
<span class="cp">    puts size</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">datafile.readlines.each { |line|</span>
<span class="cp">    puts line.chomp!.length</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">lines = datafile.readlines</span>
<span class="cp">#-----------------------------</span>
<span class="cp">whole_file = file.read</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># ruby -040 -e &#39;word = gets; puts &quot;First word is #{word}&quot;&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># ruby -ne &#39;BEGIN { $/=&quot;%%\n&quot; }; $_.chomp; puts $_ if( $_=~/Unix/i)&#39; fortune.dat</span>
<span class="cp">#-----------------------------</span>
<span class="cp">handle.print &quot;one&quot;, &quot;two&quot;, &quot;three&quot; # &quot;onetwothree&quot;</span>
<span class="cp">puts &quot;Baa baa black sheep.&quot;        # sent to $stdout</span>
<span class="cp">#-----------------------------</span>
<span class="cp">buffer = handle.read(4096)</span>
<span class="cp">rv     = buffer.length</span>
<span class="cp">#-----------------------------</span>
<span class="cp">handle.truncate(length)</span>
<span class="cp">open(&quot;/tmp#{$$}.pid&quot;, &#39;w&#39;) { |handle| handle.truncate(length) }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">pos = datafile.pos  # tell is an alias of pos</span>
<span class="cp">puts &quot;I&#39;m #{pos} bytes from the start of datafile&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">logfile.seek(0, IO::SEEK_END)</span>
<span class="cp">datafile.seek(pos)  #  IO::SEEK_SET is the default</span>
<span class="cp">out.seek(-20, IO::SEEK_CUR)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">written = datafile.syswrite(mystring)</span>
<span class="cp">raise RunTimeError unless written == mystring.length</span>
<span class="cp">block = infile.sysread(256)   # no equivalent to perl offset parameter in sysread</span>
<span class="cp">puts &quot;only read #{block.length} bytes&quot; if 256 != block.length</span>
<span class="cp">#-----------------------------</span>
<span class="cp">pos = handle.sysseek(0, IO::SEEK_CUR)  # don&#39;t change position</span>


<span class="cp"># @@PLEAC@@_8.1</span>
<span class="cp">while (line = fh.gets)</span>
<span class="cp">    line.chomp!</span>
<span class="cp">    nextline = nil</span>
<span class="cp">    line.gsub!(/\\$/) { |match| nextline = fh.gets; &#39;&#39; }</span>
<span class="cp">    if (nextline != nil)</span>
<span class="cp">        line += nextline </span>
<span class="cp">        redo</span>
<span class="cp">    end</span>
<span class="cp">    # process full record in line here</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) \</span>
<span class="cp">#         $(TEXINFOS) $(INFOS) $(MANS) $(DATA)</span>
<span class="cp"># DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) \</span>
<span class="cp">#         $(TEXINFOS) $(INFO_DEPS) $(MANS) $(DATA) \</span>
<span class="cp">#         $(EXTRA_DIST)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">line.gsub!(/\\\s*$/, &#39;&#39;) {</span>
<span class="cp">    # as before</span>
<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_8.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">count = `wc -l &lt; #{filename}`</span>
<span class="cp">fail &quot;wc failed: #{$?}&quot; if $? != 0</span>
<span class="cp">count.chomp!</span>
<span class="cp">#-----------------------------</span>
<span class="cp">count = 0</span>
<span class="cp">File.open(file, &#39;r&#39;) { |fh|</span>
<span class="cp">    count += 1 while fh.gets</span>
<span class="cp">}</span>
<span class="cp"># count now holds the number of lines read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">count = 0</span>
<span class="cp">while (chunk = file.sysread(2**16)) </span>
<span class="cp">    count += chunk.count(&quot;\n&quot;)</span>
<span class="cp">end rescue EOFError</span>
<span class="cp">#-----------------------------</span>
<span class="cp">File.open(filename,&#39;r&#39;) { |fh|</span>
<span class="cp">    count += 1 while fh.gets</span>
<span class="cp">}</span>
<span class="cp"># count now holds the number of lines read</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># As ruby doesn&#39;t quite have an equivalent to using a for</span>
<span class="cp"># statement as in perl, I threw this in</span>
<span class="cp">count = File.readlines(filename).size</span>
<span class="cp">#-----------------------------</span>
<span class="cp">1 while file.gets</span>
<span class="cp">count = $.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = &#39;&#39;</span>
<span class="cp">open(filename, &#39;r&#39;) { |fh|</span>
<span class="cp">    1 while fh.gets</span>
<span class="cp">    para_count = $.</span>
<span class="cp">} rescue fail(&quot;can&#39;t open #{filename}: $!&quot;) </span>
<span class="cp">#-----------------------------</span>


<span class="cp"># ^^PLEAC^^_8.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (gets)</span>
<span class="cp">    split.each { |chunk|</span>
<span class="cp">        # do something with chunk</span>
<span class="cp">    }</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (gets)</span>
<span class="cp">    gsub(/(\w[\w&#39;-]*)/) { |word|</span>
<span class="cp">        # do something with word</span>
<span class="cp">    }</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Make a word frequency count</span>
<span class="cp"># normally hashes can be created using {} or just Hash.new</span>
<span class="cp"># but we want the default value of an entry to be 0 instead </span>
<span class="cp"># of nil. (nil can&#39;t be incremented)</span>
<span class="cp">seen = Hash.new(0)</span>
<span class="cp">while (gets)</span>
<span class="cp">    gsub(/(\w[\w&#39;-]*)/) { |word|</span>
<span class="cp">        seen[word.downcase] += 1</span>
<span class="cp">    }</span>
<span class="cp">end</span>
<span class="cp"># output hash in a descending numeric sort of its values</span>
<span class="cp">seen.sort { |a,b| b[1] &lt;=&gt; a[1] }.each do |k,v|</span>
<span class="cp">    printf(&quot;%5d %s\n&quot;, v, k )</span>
<span class="cp">end</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># Line frequency count</span>
<span class="cp">seen = Hash.new(0)</span>
<span class="cp">while (gets)</span>
<span class="cp">    seen[$_.downcase] += 1</span>
<span class="cp">end</span>
<span class="cp">seen.sort { |a,b| b[1] &lt;=&gt; a[1] }.each do |k,v|</span>
<span class="cp">    printf(&quot;%5d %s\n&quot;, v, k )</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_8.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># instead of file handle FILE, we can just</span>
<span class="cp"># use a string containing the filename</span>
<span class="cp">File.readlines(file).each { |line|</span>
<span class="cp">    # do something with line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">File.readlines(file).reverse_each { |line|</span>
<span class="cp">    # do something with line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># the variable lines might have been created</span>
<span class="cp"># this way</span>
<span class="cp"># lines = File.readlines(file)</span>
<span class="cp">#</span>
<span class="cp"># normally one would use the reverse_each, but</span>
<span class="cp"># if you insist on using a numerical index to</span>
<span class="cp"># iterate over the lines array...</span>
<span class="cp">(lines.size - 1).downto(0) { |i|</span>
<span class="cp">    line = lines[i]</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># the second readlines argument is a the </span>
<span class="cp"># record separator $/, just like perl, a blank</span>
<span class="cp"># separator splits the records into paragraphs</span>
<span class="cp">File.readlines(file, &#39;&#39;).each { |paragraph|</span>
<span class="cp">    # do something with paragraph</span>
<span class="cp">    puts &quot;-&gt;Paragraph #{paragraph}&quot;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_8.5</span>
<span class="cp"># This shows both reading the growing file and a fall back (exit) when the file is deleted.</span>
<span class="cp">file = File.open(&#39;growing.txt&#39;) # Open the file, default mode is reading.</span>
<span class="cp">while File.exists?(file.path) # Check if the file exists, exit if not.</span>
<span class="cp">    puts file.gets while !file.eof? # Print file contents until the end-of-file is reached.</span>
<span class="cp">    sleep(1) # Wait 1 second, so the file might grow in the meantime.</span>
<span class="cp">    # No need to seek  - eof will be reset automatically if the file grows.</span>
<span class="cp">end</span>

<span class="cp"># Another option - reopen the file if current position is greater then the length of the file.</span>
<span class="cp">filename = &#39;growing.txt&#39;</span>
<span class="cp">file = File.open(filename)</span>
<span class="cp">while File.exists?(file.path)</span>
<span class="cp">    if File.size(filename) &lt; file.pos</span>
<span class="cp">        puts &quot;File truncated -  reopening.&quot;</span>
<span class="cp">        file = File.open(filename)</span>
<span class="cp">    end</span>
<span class="cp">    puts file.gets while !file.eof?</span>
<span class="cp">    sleep(1)</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_8.6</span>
<span class="cp">$/ = &quot;%\n&quot;</span>
<span class="cp">srand</span>

<span class="cp">File.open(&#39;/usr/share/fortune/humorists&#39;).each do |line|</span>
<span class="cp">    adage = line if rand($.) &lt; 1</span>
<span class="cp">end</span>

<span class="cp">puts adage</span>


<span class="cp"># @@PLEAC@@_8.7</span>
<span class="cp"># Helper function from chapter 4.17: Randomizing an Array</span>
<span class="cp">def fisher_yates_shuffle(a)</span>
<span class="cp">    (a.size-1).downto(1) { |i|</span>
<span class="cp">        j = rand(i+1)</span>
<span class="cp">        a[i], a[j] = a[j], a[i] if i != j</span>
<span class="cp">    }</span>
<span class="cp">end</span>

<span class="cp"># Open the file, default mode is reading. Read all lines into an array.</span>
<span class="cp">lines = File.open(&#39;to_randomize.txt&#39;).collect</span>

<span class="cp"># Shuffle them.</span>
<span class="cp">fisher_yates_shuffle(lines)</span>

<span class="cp"># Print the shuffled lines.</span>
<span class="cp">puts lines </span>


<span class="cp"># @@PLEAC@@_8.10</span>
<span class="cp">begin</span>
<span class="cp">    fh = File.open(file, &quot;r+&quot;)</span>
<span class="cp">    addr = fh.tell unless fh.eof while fh.gets</span>
<span class="cp">    fh.truncate(addr)</span>
<span class="cp">rescue SystemCallError</span>
<span class="cp">    $stderr.puts &quot;#$!&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_9.0</span>
<span class="cp">entry = File.stat(&quot;/usr/bin/vi&quot;)</span>
<span class="cp">entry = File.stat(&quot;/usr/bin&quot;)</span>
<span class="cp">entry = File.stat(INFILE)</span>

<span class="cp">entry = File.stat(&quot;/usr/bin/vi&quot;)</span>
<span class="cp">ctime = entry.ctime</span>
<span class="cp">size  = entry.size</span>

<span class="cp">f = File.open(filename, &quot;r&quot;)</span>

<span class="cp">## There is no -T equivalent in Ruby, but we can still test emptiness</span>
<span class="cp">if test(?s, filename)</span>
<span class="cp">  puts &quot;#{filename} doesn&#39;t have text in it.&quot;</span>
<span class="cp">  exit</span>
<span class="cp">end</span>

<span class="cp">Dir.new(&quot;/usr/bin&quot;).each do |filename|</span>
<span class="cp">  puts &quot;Inside /usr/bin is something called #{filename}&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_9.1</span>
<span class="cp">file = File.stat(&quot;filename&quot;)</span>
<span class="cp">readtime, writetime = file.atime, file.mtime</span>
<span class="cp">file.utime(readtime, writetime)  </span>

<span class="cp">SECONDS_PER_DAY = 60 * 60 * 24</span>
<span class="cp">file = File.stat(&quot;filename&quot;)</span>
<span class="cp">atime, mtime = file.atime, file.mtime</span>

<span class="cp">atime -= 7 * SECONDS_PER_DAY</span>
<span class="cp">mtime -= 7 * SECONDS_PER_DAY</span>

<span class="cp">File.utime(atime, mtime, file)</span>
<span class="cp">mtime = File.stat(file).mtime</span>
<span class="cp">File.utime(Time.new, mtime, file)</span>
<span class="cp">File.utime(Time.new, File.stat(&quot;testfile&quot;).mtime, file)</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp">## uvi - vi a file without changing it&#39;s access times</span>

<span class="cp">if ARGV.length != 1</span>
<span class="cp">  puts &quot;usage: uvi filename&quot;</span>
<span class="cp">  exit</span>
<span class="cp">end</span>
<span class="cp">file = ARGV[0]</span>
<span class="cp">atime, mtime = File.stat(file).atime, File.stat(file).mtime</span>
<span class="cp">system(ENV[&quot;EDITOR&quot;] || &quot;vi&quot;, file)</span>
<span class="cp">File.utime(atime, mtime, file)</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_9.2</span>
<span class="cp">File.unlink(FILENAME)</span>

<span class="cp">err_flg = false</span>
<span class="cp">filenames.each do |file|</span>
<span class="cp">  begin</span>
<span class="cp">    File.unlink(file)</span>
<span class="cp">  rescue</span>
<span class="cp">    err_flg = $!</span>
<span class="cp">  end</span>
<span class="cp">end</span>
<span class="cp">err_flg and raise &quot;Couldn&#39;t unlink all of #{filenames.join(&quot; &quot;)}: #{err_flg}&quot;</span>

<span class="cp">File.unlink(file)</span>

<span class="cp">count = filenames.length</span>
<span class="cp">filenames.each do |file|</span>
<span class="cp">  begin</span>
<span class="cp">    File.unlink(file)</span>
<span class="cp">  rescue</span>
<span class="cp">    count -= 1</span>
<span class="cp">  end</span>
<span class="cp">end</span>
<span class="cp">if count != filenames.length</span>
<span class="cp">  STDERR.puts &quot;could only delete #{count} of #{filenames.length} files&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_9.3</span>
<span class="cp">require &quot;ftools&quot;</span>
<span class="cp">File.copy(oldfile, newfile)</span>

<span class="cp">infile  = File.open(oldfile, &quot;r&quot;)</span>
<span class="cp">outfile = File.open(newfile, &quot;w&quot;)</span>

<span class="cp">blksize = infile.stat.blksize</span>
<span class="cp"># This doesn&#39;t handle partial writes or ^Z</span>
<span class="cp"># like the Perl version does.</span>
<span class="cp">while (line = infile.read(blksize))</span>
<span class="cp">  outfile.write(line)</span>
<span class="cp">end</span>

<span class="cp">infile.close</span>
<span class="cp">outfile.close</span>

<span class="cp">system(&quot;cp #{oldfile} #{newfile}&quot;)    # unix</span>
<span class="cp">system(&quot;copy #{oldfile} #{newfile}&quot;)  # dos, vms</span>

<span class="cp">require &quot;ftools&quot;</span>
<span class="cp">File.copy(&quot;datafile.dat&quot;, &quot;datafile.bak&quot;)</span>
<span class="cp">File.move(&quot;datafile.new&quot;, &quot;datafile.dat&quot;)</span>


<span class="cp"># @@PLEAC@@_9.4</span>
<span class="cp">$seen = {} # must use global var to be seen inside of method below</span>

<span class="cp">def do_my_thing(filename)</span>
<span class="cp">    dev, ino = File.stat(filename).dev, File.stat(filename).ino</span>
<span class="cp">    unless $seen[[dev, ino]]</span>
<span class="cp">        # do something with $filename because we haven&#39;t</span>
<span class="cp">        # seen it before</span>
<span class="cp">    end</span>
<span class="cp">    $seen[[dev, ino]] = $seen[[dev, ino]].to_i + 1</span>
<span class="cp">end</span>

<span class="cp">files.each do |filename|</span>
<span class="cp">    dev, ino = File.stat(filename).dev, File.stat(filename).ino</span>
<span class="cp">    if !$seen.has_key?([dev, ino])</span>
<span class="cp">        $seen[[dev, ino]] = []</span>
<span class="cp">    end</span>
<span class="cp">    $seen[[dev, ino]].push(filename)</span>
<span class="cp">end</span>

<span class="cp">$seen.keys.sort.each do |devino|</span>
<span class="cp">    ino, dev = devino</span>
<span class="cp">    if $seen[devino].length &gt; 1</span>
<span class="cp">        # $seen[devino] is a list of filenames for the same file</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_9.5</span>
<span class="cp">Dir.open(dirname) do |dir|</span>
<span class="cp">    dir.each do |file|</span>
<span class="cp">        # do something with dirname/file</span>
<span class="cp">        puts file</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp"># Dir.close is automatic</span>

<span class="cp"># No -T equivalent in Ruby</span>

<span class="cp">dir.each do |file|</span>
<span class="cp">    next if file =~ /^\.\.?$/</span>
<span class="cp">    # ...</span>
<span class="cp">end</span>

<span class="cp">def plainfiles(dir)</span>
<span class="cp">    dh = Dir.open(dir)</span>
<span class="cp">    dh.entries.grep(/^[^.]/).</span>
<span class="cp">        map      {|file| &quot;#{dir}/#{file}&quot;}.</span>
<span class="cp">        find_all {|file| test(?f, file)}.</span>
<span class="cp">        sort</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_9.6</span>
<span class="cp">list = Dir.glob(&quot;*.c&quot;)</span>

<span class="cp">dir = Dir.open(path)</span>
<span class="cp">files = dir.entries.grep(/\.c$/)</span>
<span class="cp">dir.close</span>

<span class="cp">files = Dir.glob(&quot;*.c&quot;)</span>
<span class="cp">files = Dir.open(path).entries.grep(/\.[ch]$/i)</span>

<span class="cp">dir = Dir.new(path)</span>
<span class="cp">files = dir.entries.grep(/\.[ch]$/i)</span>

<span class="cp">begin</span>
<span class="cp">  d = Dir.open(dir)</span>
<span class="cp">rescue Errno::ENOENT</span>
<span class="cp">  raise &quot;Couldn&#39;t open #{dir} for reading: #{$!}&quot;</span>
<span class="cp">end</span>

<span class="cp">files = []</span>
<span class="cp">d.each do |file|</span>
<span class="cp">  puts file</span>
<span class="cp">  next unless file =~ /\.[ch]$/i</span>

<span class="cp">  filename = &quot;#{dir}/#{file}&quot;</span>
<span class="cp">  # There is no -T equivalent in Ruby, but we can still test emptiness</span>
<span class="cp">  files.push(filename) if test(?s, filename)</span>
<span class="cp">end</span>

<span class="cp">dirs.entries.grep(/^\d+$/).</span>
<span class="cp">             map    { |file| [file, &quot;#{path}/#{file}&quot;]} .</span>
<span class="cp">             select { |file| test(?d, file[1]) }.</span>
<span class="cp">             sort   { |a,b|  a[0] &lt;=&gt; b[0] }.</span>
<span class="cp">             map    { |file| file[1] }</span>


<span class="cp"># @@PLEAC@@_9.7</span>
<span class="cp">require &#39;find&#39;</span>
<span class="cp">Find.find(dirlist) do |file|</span>
<span class="cp">  # do whatever</span>
<span class="cp">end</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">Find.find(*argv) do |file|</span>
<span class="cp">  print file, (test(?d, file) ? &quot;/\n&quot; : &quot;\n&quot;)</span>
<span class="cp">end</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">sum = 0</span>
<span class="cp">Find.find(*argv) do |file|</span>
<span class="cp">  size = test(?s, file) || 0</span>
<span class="cp">  sum += size</span>
<span class="cp">end</span>
<span class="cp">puts &quot;#{argv.join(&#39; &#39;)} contains #{sum} bytes&quot;</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">saved_size, saved_name = -1, &quot;&quot;</span>
<span class="cp">Find.find(*argv) do |file|</span>
<span class="cp">  size = test(?s, file) || 0</span>
<span class="cp">  next unless test(?f, file) &amp;&amp; size &gt; saved_size</span>
<span class="cp">  saved_size = size</span>
<span class="cp">  saved_name = file</span>
<span class="cp">end</span>
<span class="cp">puts &quot;Biggest file #{saved_name} in #{argv.join(&#39; &#39;)} is #{saved_size}&quot;</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">age, name = nil</span>
<span class="cp">Find.find(*argv) do |file|</span>
<span class="cp">  mtime = File.stat(file).mtime</span>
<span class="cp">  next if age &amp;&amp; age &gt; mtime</span>
<span class="cp">  age = mtime</span>
<span class="cp">  name = file</span>
<span class="cp">end</span>
<span class="cp">puts &quot;#{name} #{age}&quot;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># fdirs - find all directories</span>
<span class="cp">require &#39;find&#39;</span>
<span class="cp">argv = ARGV.empty? ? %w{.} : ARGV</span>
<span class="cp">File.find(*argv) { |file| puts file if test(?d, file) }</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_9.8</span>
<span class="cp">require &#39;fileutils&#39;</span>

<span class="cp">puts &quot;Usage #{$0} dir ...&quot; if ARGV.empty?</span>
<span class="cp">ARGV.each do |dir|</span>
<span class="cp">  FileUtils.rmtree(dir)</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_9.9</span>
<span class="cp">require &#39;ftools&#39;</span>
<span class="cp">names.each do |file|</span>
<span class="cp">  newname = file</span>
<span class="cp">  begin</span>
<span class="cp">    File.move(file, newname)</span>
<span class="cp">  rescue Errno::EPERM</span>
<span class="cp">    $stderr.puts &quot;Couldn&#39;t rename #{file} to #{newname}: #{$!}&quot;</span>
<span class="cp">  end</span>
<span class="cp">end</span>

<span class="cp">require &#39;ftools&#39;</span>
<span class="cp">op = ARGV.empty? ? (raise &quot;Usage: rename expr [files]\n&quot;) : ARGV.shift</span>
<span class="cp">argv = ARGV.empty? ? $stdin.readlines.map { |f| f.chomp } : ARGV</span>
<span class="cp">argv.each do |file|</span>
<span class="cp">  was = file</span>
<span class="cp">  file = eval(&quot;file.#{op}&quot;)</span>
<span class="cp">  File.move(was, file) unless was == file</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_9.10</span>
<span class="cp">base = File.basename(path)</span>
<span class="cp">dir  = File.dirname(path)</span>
<span class="cp"># ruby has no fileparse equivalent</span>
<span class="cp">dir, base = File.split(path)</span>
<span class="cp">ext = base.scan(/\..*$/).to_s</span>

<span class="cp">path = &#39;/usr/lib/libc.a&#39;</span>
<span class="cp">file = File.basename(path)</span>
<span class="cp">dir  = File.dirname(path)</span>

<span class="cp">puts &quot;dir is #{dir}, file is #{file}&quot;</span>
<span class="cp"># dir is /usr/lib, file is libc.a</span>

<span class="cp">path = &#39;/usr/lib/libc.a&#39;</span>
<span class="cp">dir, filename = File.split(path)</span>
<span class="cp">name, ext = filename.split(/(?=\.)/)</span>
<span class="cp">puts &quot;dir is #{dir}, name is #{name}, ext is #{ext}&quot;</span>
<span class="cp">#   NOTE: The Ruby code prints</span>
<span class="cp">#   dir is /usr/lib, name is libc, extension is .a</span>
<span class="cp">#     while the Perl code prints a &#39;/&#39; after the directory name</span>
<span class="cp">#   dir is /usr/lib/, name is libc, extension is .a</span>

<span class="cp"># No fileparse_set_fstype() equivalent in ruby</span>

<span class="cp">def extension(path)</span>
<span class="cp">    ext = path.scan(/\..*$/).to_s</span>
<span class="cp">    ext.sub(/^\./, &quot;&quot;)</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_9.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># symirror - build spectral forest of symlinks</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">require &#39;fileutils&#39;</span>

<span class="cp">raise &quot;usage: #{$0} realdir mirrordir&quot; unless ARGV.size == 2</span>

<span class="cp">srcdir,dstdir = ARGV</span>
<span class="cp">srcmode = File::stat(srcdir).mode</span>
<span class="cp">Dir.mkdir(dstdir, srcmode &amp; 07777) unless test(?d, dstdir)</span>

<span class="cp"># fix relative paths</span>
<span class="cp">Dir.chdir(srcdir) {srcdir = Dir.pwd}</span>
<span class="cp">Dir.chdir(dstdir) {dstdir = Dir.pwd}</span>

<span class="cp">Find.find(srcdir) do |srcfile| </span>
<span class="cp">    if test(?d, srcfile)</span>
<span class="cp">        dest = srcfile.sub(/^#{srcdir}/, dstdir)</span>
<span class="cp">        dmode = File::stat(srcfile).mode &amp; 07777</span>
<span class="cp">        Dir.mkdir(dest, dmode) unless test(?d, dest)</span>
<span class="cp">        a = Dir[&quot;#{srcfile}/*&quot;].reject{|f| test(?d, f)}</span>
<span class="cp">        FileUtils.ln_s(a, dest)</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_9.12</span>
<span class="cp"># we use the Getopt/Declare library here for convenience:</span>
<span class="cp">#   http://raa.ruby-lang.org/project/getoptdeclare/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># lst - list sorted directory contents (depth first)</span>

<span class="cp">require &#39;find&#39;</span>
<span class="cp">require &#39;etc&#39;</span>
<span class="cp">require &quot;Getopt/Declare&quot;</span>

<span class="cp"># Note: in the option-spec below there must by at least one hard</span>
<span class="cp"># tab in between each -option and its description. For example</span>
<span class="cp">#    -i &lt;tab&gt; read from stdin</span>

<span class="cp">opts = Getopt::Declare.new(&lt;&lt;&#39;EOPARAM&#39;)</span>
<span class="cp">    ============</span>
<span class="cp">    Input Format:</span>
<span class="cp">        -i	read from stdin</span>
<span class="cp">    ============</span>
<span class="cp">    Output Format:</span>
<span class="cp">        -l	long listing</span>
<span class="cp">        -r	reverse listing</span>
<span class="cp">    ============</span>
<span class="cp">    Sort on: (one of)</span>
<span class="cp">        -m	mtime (modify time - default)</span>
<span class="cp">                {$sort_criteria = :mtime}</span>
<span class="cp">        -u	atime (access time)</span>
<span class="cp">                {$sort_criteria = :atime}</span>
<span class="cp">        -c	ctime (inode change time)</span>
<span class="cp">                {$sort_criteria = :ctime}</span>
<span class="cp">        -s	size</span>
<span class="cp">                {$sort_criteria = :size}</span>
<span class="cp">        [mutex: -m -u -c -s]</span>

<span class="cp">EOPARAM</span>

<span class="cp">$sort_criteria ||= :mtime</span>
<span class="cp">files = {}</span>
<span class="cp">DIRS = opts[&#39;-i&#39;] ? $stdin.readlines.map{|f|f.chomp!} : ARGV</span>
<span class="cp">DIRS.each do |dir|</span>
<span class="cp">    Find.find(dir) do |ent|</span>
<span class="cp">        files[ent] = File::stat(ent)</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp">entries = files.keys.sort_by{|f| files[f].send($sort_criteria)}</span>
<span class="cp">entries = entries.reverse unless opts[&#39;-r&#39;]</span>

<span class="cp">entries.each do |ent|</span>
<span class="cp">    unless opts[&#39;-l&#39;]</span>
<span class="cp">        puts ent</span>
<span class="cp">        next</span>
<span class="cp">    end</span>
<span class="cp">    stats = files[ent]</span>
<span class="cp">    ftime = stats.send($sort_criteria == :size ? :mtime : $sort_criteria)</span>
<span class="cp">    printf &quot;%6d %04o %6d %8s %8s %8d %s %s\n&quot;,</span>
<span class="cp">        stats.ino,</span>
<span class="cp">        stats.mode &amp; 07777,</span>
<span class="cp">        stats.nlink,</span>
<span class="cp">        ETC::PASSWD[stats.uid].name,</span>
<span class="cp">        ETC::GROUP[stats.gid].name,</span>
<span class="cp">        stats.size,</span>
<span class="cp">        ftime.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;),</span>
<span class="cp">        ent</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_10.0</span>
<span class="cp">def hello</span>
<span class="cp">    $greeted += 1      # in Ruby, a variable beginning with $ is global (can be any type of course)</span>
<span class="cp">    puts &quot;hi there!&quot;</span>
<span class="cp">end</span>

<span class="cp"># We need to initialize $greeted before it can be used, because &quot;+=&quot; is waiting a Numeric object</span>
<span class="cp">$greeted = 0</span>
<span class="cp">hello                  # note that appending () is optional to function calls with no parameters</span>


<span class="cp"># @@PLEAC@@_10.1</span>
<span class="cp"># In Ruby, parameters are named anyway</span>
<span class="cp">def hypotenuse(side1, side2)</span>
<span class="cp">    Math.sqrt(side1**2 + side2**2)    # the sqrt function comes from the Math module</span>
<span class="cp">end</span>
<span class="cp">diag = hypotenuse(3, 4)</span>

<span class="cp">puts hypotenuse(3, 4)</span>

<span class="cp">a = [3, 4]</span>
<span class="cp">print hypotenuse(*a)                  # the star operator will magically convert an Array into a &quot;tuple&quot;</span>

<span class="cp">both = men + women</span>

<span class="cp"># In Ruby, all objects are references, so the same problem arises; we then return a new object</span>
<span class="cp">nums = [1.4, 3.5, 6.7]</span>
<span class="cp">def int_all(n)</span>
<span class="cp">    n.collect { |v| v.to_i }</span>
<span class="cp">end</span>
<span class="cp">ints = int_all(nums)</span>

<span class="cp">nums = [1.4, 3.5, 6.7]</span>
<span class="cp">def trunc_em(n)</span>
<span class="cp">    n.collect! { |v| v.to_i }         # the bang-version of collect modifies the object</span>
<span class="cp">end</span>
<span class="cp">trunc_em(nums)</span>

<span class="cp"># Ruby has two chomp version:</span>
<span class="cp"># ``chomp&#39;&#39; chomps the record separator and returns what&#39;s expected</span>
<span class="cp"># ``chomp!&#39;&#39; does the same but also modifies the parameter object</span>


<span class="cp"># @@PLEAC@@_10.2</span>
<span class="cp">def somefunc</span>
<span class="cp">    variable = something  # variable is local by default</span>
<span class="cp">end</span>

<span class="cp">name, age = ARGV</span>
<span class="cp">start     = fetch_time</span>

<span class="cp">a, b = pair               # will succeed if pair is an Array object (like ARGV is)</span>
<span class="cp">c = fetch_time</span>

<span class="cp"># In ruby, run_check can&#39;t access a, b, or c until they are</span>
<span class="cp"># explicitely defined global (using leading $), even if they are</span>
<span class="cp"># both defined in the same scope</span>

<span class="cp">def check_x(x)</span>
<span class="cp">    y = &quot;whatever&quot;</span>
<span class="cp">    run_check</span>
<span class="cp">    if $condition</span>
<span class="cp">        puts &quot;got $x&quot;</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># The following will keep a reference to the array, though the</span>
<span class="cp"># results will be slightly different from perl: the last element</span>
<span class="cp"># of $global_array will be itself an array</span>
<span class="cp">def save_array(ary)</span>
<span class="cp">    $global_array &lt;&lt; ary</span>
<span class="cp">end</span>

<span class="cp"># The following gives the same results as in Perl for $global_array,</span>
<span class="cp"># though it doesn&#39;t illustrate anymore the way to keep a reference</span>
<span class="cp"># to an object: $global_array is extended with the elements of ary</span>
<span class="cp">def save_array(ary)</span>
<span class="cp">    $global_array += ary</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_10.3</span>
<span class="cp"># In Ruby, AFAIK a method cannot access &quot;local variables&quot; defined</span>
<span class="cp"># upper scope; mostly because everything is an object, so you&#39;ll</span>
<span class="cp"># do the same by defining an attribute or a static attribute</span>

<span class="cp"># In Ruby the BEGIN also exists:</span>
<span class="cp">BEGIN { puts &quot;hello from BEGIN&quot; }</span>
<span class="cp">puts &quot;hello from main&quot;</span>
<span class="cp">BEGIN { puts &quot;hello from 2nd BEGIN&quot; }</span>
<span class="cp"># gives:</span>
<span class="cp">#   hello from BEGIN</span>
<span class="cp">#   hello from 2nd BEGIN</span>
<span class="cp">#   hello from main</span>

<span class="cp"># In Ruby, it can be written as a static method and a static</span>
<span class="cp"># variable</span>
<span class="cp">class Counter</span>
<span class="cp">    @@counter = 0</span>
<span class="cp">    def Counter.next_counter; @@counter += 1; end</span>
<span class="cp">end</span>

<span class="cp"># There is no need of BEGIN since the variable will get</span>
<span class="cp"># initialized when parsing</span>
<span class="cp">class Counter</span>
<span class="cp">    @@counter = 42</span>
<span class="cp">    def Counter.next_counter; @@counter += 1; end</span>
<span class="cp">    def Counter.prev_counter; @@counter -= 1; end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_10.4</span>
<span class="cp"># You can either get the whole trace as an array of strings, each</span>
<span class="cp"># string telling which file, line and method is calling:</span>
<span class="cp">caller</span>

<span class="cp"># ...or only the last caller</span>
<span class="cp">caller[0]</span>

<span class="cp"># We need to extract just the method name of the backtrace:</span>
<span class="cp">def whoami;  caller()[0] =~ /in `([^&#39;]+)&#39;/ ? $1 : &#39;(anonymous)&#39;; end</span>
<span class="cp">def whowasi; caller()[1] =~ /in `([^&#39;]+)&#39;/ ? $1 : &#39;(anonymous)&#39;; end</span>


<span class="cp"># @@PLEAC@@_10.5</span>
<span class="cp"># In Ruby, every value is a reference on an object, thus there is</span>
<span class="cp"># no such problem</span>
<span class="cp">array_diff(array1, array2)</span>

<span class="cp">def add_vecpair(a1, a2)</span>
<span class="cp">    results = []</span>
<span class="cp">    a1.each_index { |i| results &lt;&lt; (a1[i] + a2[i]) }</span>
<span class="cp">    results</span>
<span class="cp">end</span>
<span class="cp">a = [1, 2]</span>
<span class="cp">b = [5, 8]</span>
<span class="cp">c = add_vecpair(a, b)</span>
<span class="cp">p c</span>

<span class="cp"># Add this to the beginning of the function to check if we were</span>
<span class="cp"># given two arrays</span>
<span class="cp">a1.type == Array &amp;&amp; a2.type == Array or</span>
<span class="cp">    raise &quot;usage: add_vecpair array1 array2 (was used with: #{a1.type} #{a2.type})&quot;</span>


<span class="cp"># @@PLEAC@@_10.6</span>
<span class="cp"># There is no return context in Ruby</span>


<span class="cp"># @@PLEAC@@_10.7</span>
<span class="cp"># Like in Perl, we need to fake with a hash, but it&#39;s dirty :-(</span>
<span class="cp">def thefunc(param_args)</span>
<span class="cp">    args = { &#39;INCREMENT&#39; =&gt; &#39;10s&#39;, &#39;FINISH&#39; =&gt; &#39;0&#39;, &#39;START&#39; =&gt; 0 }</span>
<span class="cp">    args.update(param_args)</span>
<span class="cp">    if (args[&#39;INCREMENT&#39;]  =~ /m$/ )</span>
<span class="cp">        # .....</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">thefunc({ &#39;INCREMENT&#39; =&gt; &#39;20s&#39;, &#39;START&#39; =&gt; &#39;+5m&#39;, &#39;FINISH&#39; =&gt; &#39;+30m&#39; })</span>
<span class="cp">thefunc({})</span>


<span class="cp"># @@PLEAC@@_10.8</span>
<span class="cp"># there is no &quot;undef&quot; direct equivalent but there is the slice equiv:</span>
<span class="cp">a, c = func.indexes(0, 2)</span>


<span class="cp"># @@PLEAC@@_10.9</span>
<span class="cp"># Ruby has no such limitation:</span>
<span class="cp">def somefunc</span>
<span class="cp">    ary = []</span>
<span class="cp">    hash = {}</span>
<span class="cp">    # ...</span>
<span class="cp">    return ary, hash</span>
<span class="cp">end</span>
<span class="cp">arr, dict = somefunc</span>

<span class="cp">array_of_hashes = fn</span>
<span class="cp">h1, h2, h3      = fn</span>


<span class="cp"># @@PLEAC@@_10.10</span>
<span class="cp">return</span>
<span class="cp"># or (equivalent)</span>
<span class="cp">return nil</span>


<span class="cp"># @@PLEAC@@_10.11</span>
<span class="cp"># You can&#39;t prototype in Ruby regarding types :-(</span>
<span class="cp"># Though, you can force the number of arguments:</span>
<span class="cp">def func_with_no_arg; end</span>
<span class="cp">def func_with_no_arg(); end</span>
<span class="cp">def func_with_one_arg(a1); end</span>
<span class="cp">def func_with_two_args(a1, a2); end</span>
<span class="cp">def func_with_any_number_of_args(*args); end</span>


<span class="cp"># @@PLEAC@@_10.12</span>
<span class="cp">raise &quot;some message&quot;        # raise exception</span>

<span class="cp">begin</span>
<span class="cp">    val = func</span>
<span class="cp">rescue Exception =&gt; msg</span>
<span class="cp">    $stderr.puts &quot;func raised an exception: #{msg}&quot;</span>
<span class="cp">end</span>

<span class="cp"># In Ruby the rescue statement uses an exception class, every</span>
<span class="cp"># exception which is not matched is still continuing</span>
<span class="cp">begin</span>
<span class="cp">    val = func</span>
<span class="cp">rescue FullMoonError</span>
<span class="cp">    ...</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_10.13</span>
<span class="cp"># Saving Global Values</span>
<span class="cp"># Of course we can just save the value and restore it later:</span>
<span class="cp">def print_age</span>
<span class="cp">    puts &quot;Age is #{$age}&quot;</span>
<span class="cp">end</span>

<span class="cp">$age = 18         # global variable</span>
<span class="cp">print_age()</span>
<span class="cp">if condition</span>
<span class="cp">    safeage = $age</span>
<span class="cp">    $age = 23</span>
<span class="cp">    print_age()</span>
<span class="cp">    $age = safeage</span>
<span class="cp">end</span>

<span class="cp"># We can also use a method that saves the global variable and</span>
<span class="cp"># restores it automatically when the block is left:</span>

<span class="cp">def local(var)</span>
<span class="cp">    eval(&quot;save = #{var.id2name}&quot;)</span>
<span class="cp">    begin</span>
<span class="cp">        result = yield</span>
<span class="cp">    ensure</span>
<span class="cp">        # we want to call this even if we got an exception</span>
<span class="cp">        eval(&quot;#{var.id2name} = save&quot;)</span>
<span class="cp">    end</span>
<span class="cp">    result</span>
<span class="cp">end</span>

<span class="cp">condition = true</span>
<span class="cp">$age = 18</span>
<span class="cp">print_age()</span>
<span class="cp">if condition</span>
<span class="cp">    local(:$age) {</span>
<span class="cp">        $age = 23</span>
<span class="cp">        print_age()</span>
<span class="cp">    }</span>
<span class="cp">end</span>
<span class="cp">print_age()</span>

<span class="cp"># There is no need to use local() for filehandles or directory</span>
<span class="cp"># handles in ruby because filehandles are normal objects.</span>


<span class="cp"># @@PLEAC@@_10.14</span>
<span class="cp"># In Ruby you may redefine a method [but not overload it :-(]</span>
<span class="cp"># just by defining again with the same name.</span>
<span class="cp">def foo; puts &#39;foo&#39;; end</span>
<span class="cp">def foo; puts &#39;bar&#39;; end</span>
<span class="cp">foo</span>
<span class="cp">#=&gt; bar</span>

<span class="cp"># You can also take a reference to an existing method before</span>
<span class="cp"># redefining a new one, using the `alias&#39; keyword</span>
<span class="cp">def foo; puts &#39;foo&#39;; end</span>
<span class="cp">alias foo_orig foo</span>
<span class="cp">def foo; puts &#39;bar&#39;; end</span>
<span class="cp">foo_orig</span>
<span class="cp">foo</span>
<span class="cp">#=&gt; foo</span>
<span class="cp">#=&gt; bar</span>

<span class="cp"># AFAIK, there is no direct way to create a new method whose name</span>
<span class="cp"># comes from a variable, so use &quot;eval&quot;</span>
<span class="cp">colors = %w(red blue green yellow orange purple violet)</span>
<span class="cp">colors.each { |c|</span>
<span class="cp">    eval &lt;&lt;-EOS</span>
<span class="cp">    def #{c}(*a)</span>
<span class="cp">        &quot;&lt;FONT COLOR=&#39;#{c}&#39;&gt;&quot; + a.to_s + &quot;&lt;/FONT&gt;&quot;</span>
<span class="cp">    end</span>
<span class="cp">    EOS</span>
<span class="cp">} </span>


<span class="cp"># @@PLEAC@@_10.15</span>
<span class="cp">def method_missing(name, *args)</span>
<span class="cp">    &quot;&lt;FONT COLOR=&#39;#{name}&#39;&gt;&quot; + args.join(&#39; &#39;) + &quot;&lt;/FONT&gt;&quot;</span>
<span class="cp">end</span>
<span class="cp">puts chartreuse(&quot;stuff&quot;)</span>


<span class="cp"># @@PLEAC@@_10.16</span>
<span class="cp">def outer(arg)</span>
<span class="cp">    x = arg + 35</span>
<span class="cp">    inner = proc { x * 19 }</span>
<span class="cp">    x + inner.call()</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_10.17</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># mailsort - sort mbox by different criteria</span>
<span class="cp">require &#39;English&#39;</span>
<span class="cp">require &#39;Date&#39;</span>

<span class="cp"># Objects of class Mail represent a single mail.</span>
<span class="cp">class Mail</span>
<span class="cp">    attr_accessor :no</span>
<span class="cp">    attr_accessor :subject</span>
<span class="cp">    attr_accessor :fulltext</span>
<span class="cp">    attr_accessor :date</span>

<span class="cp">    def initialize</span>
<span class="cp">        @fulltext = &quot;&quot;</span>
<span class="cp">        @subject = &quot;&quot;</span>
<span class="cp">    end</span>

<span class="cp">    def append(para)</span>
<span class="cp">        @fulltext &lt;&lt; para</span>
<span class="cp">    end</span>

<span class="cp">    # this is called if you call puts(mail)</span>
<span class="cp">    def to_s</span>
<span class="cp">        @fulltext</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># represents a list of mails.</span>
<span class="cp">class Mailbox &lt; Array</span>

<span class="cp">    Subjectpattern = Regexp.new(&#39;Subject:\s*(?:Re:\s*)*(.*)\n&#39;)</span>
<span class="cp">    Datepattern = Regexp.new(&#39;Date:\s*(.*)\n&#39;)</span>

<span class="cp">    # reads mails from open file and stores them</span>
<span class="cp">    def read(file)</span>
<span class="cp">        $INPUT_RECORD_SEPARATOR = &#39;&#39;  # paragraph reads</span>
<span class="cp">        msgno = -1</span>
<span class="cp">        file.each { |para|</span>
<span class="cp">            if para =~ /^From/</span>
<span class="cp">                mail = Mail.new</span>
<span class="cp">                mail.no = (msgno += 1)</span>
<span class="cp">                md = Subjectpattern.match(para)</span>
<span class="cp">                if md</span>
<span class="cp">                    mail.subject = md[1]</span>
<span class="cp">                end</span>
<span class="cp">                md = Datepattern.match(para)</span>
<span class="cp">                if md</span>
<span class="cp">                    mail.date = DateTime.parse(md[1])</span>
<span class="cp">                else</span>
<span class="cp">                    mail.date = DateTime.now</span>
<span class="cp">                end</span>
<span class="cp">                self.push(mail)</span>
<span class="cp">            end</span>
<span class="cp">            mail.append(para) if mail</span>
<span class="cp">        }</span>
<span class="cp">    end</span>

<span class="cp">    def sort_by_subject_and_no</span>
<span class="cp">        self.sort_by { |m|</span>
<span class="cp">            [m.subject, m.no]</span>
<span class="cp">        }</span>
<span class="cp">    end</span>

<span class="cp">    # sorts by a list of attributs of mail, given as symbols</span>
<span class="cp">    def sort_by_attributs(*attrs)</span>
<span class="cp">        # you can sort an Enumerable by an array of</span>
<span class="cp">        # values, they would be compared</span>
<span class="cp">        # from ary[0] to ary[n]t, say:</span>
<span class="cp">        # [&#39;b&#39;,1] &gt; [&#39;a&#39;,10] &gt; [&#39;a&#39;,9]</span>
<span class="cp">        self.sort_by { |elem|</span>
<span class="cp">            attrs.map { |attr|</span>
<span class="cp">                elem.send(attr)</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">    end</span>

<span class="cp">end</span>

<span class="cp">mailbox = Mailbox.new</span>
<span class="cp">mailbox.read(ARGF)</span>

<span class="cp"># print only subjects sorted by subject and number</span>
<span class="cp">for m in mailbox.sort_by_subject_and_no</span>
<span class="cp">    puts(m.subject)</span>
<span class="cp">end</span>

<span class="cp"># print complete mails sorted by date, then subject, then number</span>
<span class="cp">for m in mailbox.sort_by_attributs(:date, :subject)</span>
<span class="cp">    puts(m)</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_11.2</span>
<span class="cp"># In Ruby, everything is an object (i.e. reference), including arrays.</span>
<span class="cp"># Arrays are, thus, directly supported as values of a hash.</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Assumes an array was already put into hash[&quot;KEYNAME&quot;], e.g.:</span>
<span class="cp"># hash = {}</span>
<span class="cp"># hash[&quot;KEYNAME&quot;] = [5, 10, 15]</span>
<span class="cp">hash[&quot;KEYNAME&quot;] &lt;&lt; &quot;new value&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Join is used to separate elements of the array with commas.</span>
<span class="cp">hash.each { |key, value|</span>
<span class="cp">    puts &quot;#{key}: #{value.join(&#39;, &#39;)}&quot;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">hash[&quot;a key&quot;] = [3, 4, 5]</span>
<span class="cp">#-----------------------------</span>
<span class="cp">values = hash[&quot;a key&quot;]</span>
<span class="cp">#-----------------------------</span>
<span class="cp">hash[&quot;a key&quot;] &lt;&lt; value</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Example hash:</span>
<span class="cp"># phone2name = { 123555888 =&gt; [&quot;Joe&quot;, &quot;Jenny&quot;], 888555444 =&gt; [&quot;Anne&quot;, &quot;Mark&quot;] }</span>
<span class="cp">residents = phone2name[number]</span>
<span class="cp">#-----------------------------</span>
<span class="cp">residents = phone2name.has_key?(number) ? phone2name[number] : []</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_11.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">record = {</span>
<span class="cp">    :NAME   =&gt; &quot;Jason&quot;,</span>
<span class="cp">    :EMPNO  =&gt; 132,</span>
<span class="cp">    :TITLE  =&gt; &quot;deputy peon&quot;,</span>
<span class="cp">    :AGE    =&gt; 23,</span>
<span class="cp">    :SALARY =&gt; 37.000,</span>
<span class="cp">    :PALS   =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;]</span>
<span class="cp">}</span>

<span class="cp">puts &quot;I am #{record[:NAME]}, and my pals are #{record[:PALS].join(&#39;, &#39;)}.&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># store record</span>
<span class="cp">byname = {}</span>
<span class="cp">byname[record[:NAME]] = record</span>

<span class="cp"># later on, look up by name</span>
<span class="cp">rp = byname[&quot;Aron&quot;]</span>
<span class="cp">puts &quot;Aron is employee #{rp[:EMPNO]}.&quot; if rp</span>

<span class="cp"># give jason a new pal</span>
<span class="cp">byname[&quot;Jason&quot;][:PALS] &lt;&lt; &quot;Theodore&quot;</span>
<span class="cp">puts &quot;Jason now has #{byname[&quot;Jason&quot;][:PALS].length} pals&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Go through all records</span>
<span class="cp">byname.each do |name, record|</span>
<span class="cp">    puts &quot;#{name} is employee number #{record[:EMPNO]}&quot;</span>
<span class="cp">end    </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># store record</span>
<span class="cp">employees = {}</span>
<span class="cp">employees[record[:EMPNO]] = record</span>

<span class="cp"># lookup by id</span>
<span class="cp">rp = employees[132]</span>
<span class="cp">puts &quot;employee number 132 is #{rp[:NAME]}&quot; if rp</span>
<span class="cp">#-----------------------------</span>
<span class="cp">byname[&quot;Jason&quot;][:SALARY] *= 1.035</span>
<span class="cp">#-----------------------------</span>
<span class="cp">peons = employees.values.select { |record| record[:TITLE] =~ /peon/i }</span>
<span class="cp">tsevens = employees.values.select { |record| record[:AGE] == 27 }</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Go through all records</span>
<span class="cp">byname.values.sort { |a, b| a[:AGE] &lt;=&gt; b[:AGE] }.each do |rp|</span>
<span class="cp">        puts &quot;#{rp[:NAME]} is age #{rp[:AGE]}.&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># A little different then Perl: we can use hash in Ruby.</span>
<span class="cp"># use @byage, _a hash_ of arrays of records</span>
<span class="cp">byage = {}</span>
<span class="cp">byage[record[:AGE]] = [] if byage[record[:AGE]] == nil</span>
<span class="cp">byage[record[:AGE]] &lt;&lt; record</span>
<span class="cp">#-----------------------------</span>
<span class="cp">byage.each do |age, rps|</span>
<span class="cp">    print &quot;Age #{age}: &quot;</span>
<span class="cp">    rps.each do |rp|</span>
<span class="cp">        print rp[:NAME], &quot; &quot;</span>
<span class="cp">    end</span>
<span class="cp">    print &quot;\n&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">byage.each do |age, rps|</span>
<span class="cp">    puts &quot;Age #{age}: #{byage[age].collect { |e| e[:NAME] }.join(&#39;, &#39;)}&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_11.7</span>
<span class="cp">def mkcounter(count)</span>
<span class="cp">    start  = count </span>
<span class="cp">    bundle = { </span>
<span class="cp">        &quot;NEXT&quot;   =&gt; proc { count += 1 },</span>
<span class="cp">        &quot;PREV&quot;   =&gt; proc { count -= 1 },</span>
<span class="cp">        &quot;RESET&quot;  =&gt; proc { count = start }</span>
<span class="cp">    }</span>
<span class="cp">    bundle[&quot;LAST&quot;] = bundle[&quot;PREV&quot;]</span>
<span class="cp">    return bundle</span>
<span class="cp">end</span>

<span class="cp">c1 = mkcounter(20)</span>
<span class="cp">c2 = mkcounter(77)</span>

<span class="cp">puts &quot;next c1: #{c1[&quot;NEXT&quot;].call}&quot;  # 21 </span>
<span class="cp">puts &quot;next c2: #{c2[&quot;NEXT&quot;].call}&quot;  # 78 </span>
<span class="cp">puts &quot;next c1: #{c1[&quot;NEXT&quot;].call}&quot;  # 22 </span>
<span class="cp">puts &quot;last c1: #{c1[&quot;PREV&quot;].call}&quot;  # 21 </span>
<span class="cp">puts &quot;last c1: #{c1[&quot;LAST&quot;].call}&quot;  # 20 </span>
<span class="cp">puts &quot;old  c2: #{c2[&quot;RESET&quot;].call}&quot; # 77 </span>


<span class="cp"># @@PLEAC@@_11.15</span>
<span class="cp">class Binary_tree</span>
<span class="cp">    def initialize(val)</span>
<span class="cp">        @value = val</span>
<span class="cp">        @left = nil</span>
<span class="cp">        @right = nil</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    # insert given value into proper point of</span>
<span class="cp">    # provided tree.  If no tree provided, </span>
<span class="cp">    # use implicit pass by reference aspect of @_</span>
<span class="cp">    # to fill one in for our caller.</span>
<span class="cp">    def insert(val)</span>
<span class="cp">        if val &lt; @value then</span>
<span class="cp">            if @left then</span>
<span class="cp">                @left.insert(val)</span>
<span class="cp">            else</span>
<span class="cp">                @left = Binary_tree.new(val)</span>
<span class="cp">            end</span>
<span class="cp">        elsif val &gt; @value then</span>
<span class="cp">            if @right then</span>
<span class="cp">                @right.insert(val)</span>
<span class="cp">            else</span>
<span class="cp">                @right = Binary_tree.new(val)</span>
<span class="cp">            end</span>
<span class="cp">        else</span>
<span class="cp">            puts &quot;double&quot;</span>
<span class="cp">            # do nothing, no double values</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">    # recurse on left child, </span>
<span class="cp">    # then show current value, </span>
<span class="cp">    # then recurse on right child.  </span>
<span class="cp">    def in_order</span>
<span class="cp">        @left.in_order if @left</span>
<span class="cp">        print @value, &quot; &quot;</span>
<span class="cp">        @right.in_order if @right</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    # show current value, </span>
<span class="cp">    # then recurse on left child, </span>
<span class="cp">    # then recurse on right child.</span>
<span class="cp">    def pre_order</span>
<span class="cp">        print @value, &quot; &quot;</span>
<span class="cp">        @left.pre_order if @left</span>
<span class="cp">        @right.pre_order if @right</span>
<span class="cp">    end</span>

<span class="cp">    # recurse on left child, </span>
<span class="cp">    # then recurse on right child,</span>
<span class="cp">    # then show current value.</span>
<span class="cp">    def post_order</span>
<span class="cp">        @left.post_order if @left</span>
<span class="cp">        @right.post_order if @right</span>
<span class="cp">        print @value, &quot; &quot;</span>
<span class="cp">    end</span>

<span class="cp">    # find out whether provided value is in the tree.</span>
<span class="cp">    # if so, return the node at which the value was found.</span>
<span class="cp">    # cut down search time by only looking in the correct</span>
<span class="cp">    # branch, based on current value.</span>
<span class="cp">    def search(val)</span>
<span class="cp">        if val == @value then</span>
<span class="cp">            return self</span>
<span class="cp">        elsif val &lt; @value then</span>
<span class="cp">            return @left.search(val) if @left</span>
<span class="cp">            return nil</span>
<span class="cp">        else</span>
<span class="cp">            return @right.search(val) if @right</span>
<span class="cp">            return nil</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># first generate 20 random inserts</span>
<span class="cp">test = Binary_tree.new(0)</span>
<span class="cp">for a in 0..20</span>
<span class="cp">    test.insert(rand(1000)) </span>
<span class="cp">end</span>

<span class="cp"># now dump out the tree all three ways</span>
<span class="cp">print &quot;Pre order:  &quot;;  test.pre_order;  puts &quot;&quot;</span>
<span class="cp">print &quot;In order:  &quot;;  test.in_order;  puts &quot;&quot;</span>
<span class="cp">print &quot;Post order:  &quot;;  test.post_order;  puts &quot;&quot;</span>

<span class="cp">print &quot;search?&quot;</span>
<span class="cp">while gets</span>
<span class="cp">    print test.search($_.to_i)</span>
<span class="cp">    print &quot;\nsearch?&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_12.0</span>
<span class="cp"># class and module names need to have the first letter capitalized</span>
<span class="cp">module Alpha</span>
<span class="cp">    NAME = &#39;first&#39;</span>
<span class="cp">end</span>
<span class="cp">module Omega</span>
<span class="cp">    NAME = &#39;last&#39;</span>
<span class="cp">end</span>
<span class="cp">puts &quot;Alpha is #{Alpha::NAME}, Omega is #{Omega::NAME}&quot;</span>

<span class="cp"># ruby doesn&#39;t differentiate beteen compile-time and run-time</span>
<span class="cp">require &#39;getoptlong.rb&#39;</span>
<span class="cp">require &#39;getoptlong&#39;     # assumes the .rb</span>
<span class="cp">require &#39;cards/poker.rb&#39;</span>
<span class="cp">require &#39;cards/poker&#39;    # assumes the .rb</span>
<span class="cp">load    &#39;cards/poker&#39;    # require only loads the file once</span>

<span class="cp">module Cards</span>
<span class="cp">    module Poker</span>
<span class="cp">        @card_deck = Array.new # or @card_deck = []</span>
<span class="cp">        def shuffle</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_12.1</span>
<span class="cp"># a module exports all of its functions</span>
<span class="cp">module Your_Module</span>
<span class="cp">    def self.function</span>
<span class="cp">        # this would be called as Your_Module.function</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def Your_Module.another</span>
<span class="cp">        # this is the same as above, but more specific</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># @@PLEAC@@_12.2</span>
<span class="cp">begin</span>
<span class="cp">    require &#39;nonexistent&#39;</span>
<span class="cp">rescue LoadError</span>
<span class="cp">    puts &quot;Couldn&#39;t load #{$!}&quot;  # $! contains the last error string</span>
<span class="cp">end</span>

<span class="cp"># @@PLEAC@@_12.4</span>
<span class="cp"># module variables are private unless access functions are defined</span>
<span class="cp">module Alpha</span>
<span class="cp">    @aa = 10</span>
<span class="cp">    @bb = 11</span>
<span class="cp">    </span>
<span class="cp">    def self.put_aa</span>
<span class="cp">        puts @aa</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def self.bb=(val)</span>
<span class="cp">        @bb = val</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">Alpha.bb = 12</span>
<span class="cp"># Alpha.aa = 10 # error, no aa=method</span>


<span class="cp"># @@PLEAC@@_12.5</span>
<span class="cp"># caller provides a backtrace of the call stack</span>
<span class="cp">module MyModule</span>
<span class="cp">    def find_caller</span>
<span class="cp">        caller</span>
<span class="cp">    end</span>

<span class="cp">    def find_caller2(i)</span>
<span class="cp">        caller(i) # an argument limits the size of the stack returned</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_12.6</span>
<span class="cp">BEGIN {</span>
<span class="cp">    $logfile = &#39;/tmp/mylog&#39; unless defined? $logfile</span>
<span class="cp">    $LF = File.open($logfile, &#39;a&#39;)</span>
<span class="cp">}</span>

<span class="cp">module Logger</span>
<span class="cp">    def self.logmsg(msg)</span>
<span class="cp">        $LF.puts msg</span>
<span class="cp">    end</span>

<span class="cp">    logmsg(&#39;startup&#39;)</span>
<span class="cp">end</span>

<span class="cp">END {</span>
<span class="cp">    Logger::logmsg(&#39;shutdown&#39;)</span>
<span class="cp">    $LF.close</span>
<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_12.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># results may be different on your system</span>
<span class="cp"># % ruby -e &quot;$LOAD_PATH.each_index { |i| printf(&quot;%d %s\n&quot;, i, $LOAD_PATH[i] }</span>
<span class="cp">#0 /usr/local/lib/site_ruby/1.6</span>
<span class="cp">#1 /usr/local/lib/site_ruby/1.6/i386-linux</span>
<span class="cp">#2 /usr/local/lib/site_ruby/</span>
<span class="cp">#3 /usr/lib/ruby/1.6</span>
<span class="cp">#4 /usr/lib/ruby/1.6/i136-linux</span>
<span class="cp">#5 .</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># syntax for sh, bash, ksh, or zsh</span>
<span class="cp">#$ export RUBYLIB=$HOME/rubylib</span>

<span class="cp"># syntax for csh or tcsh</span>
<span class="cp"># % setenv RUBYLIB ~/rubylib</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$LOAD_PATH.unshift &quot;/projects/spectre/lib&quot;;</span>


<span class="cp"># @@PLEAC@@_12.8</span>
<span class="cp"># equivalents in ruby are mkmf, SWIG, or Ruby/DL depending on usage</span>


<span class="cp"># @@PLEAC@@_12.9</span>
<span class="cp"># no equivalent in ruby</span>


<span class="cp"># @@PLEAC@@_12.10</span>
<span class="cp"># no equivalent in ruby</span>


<span class="cp"># @@PLEAC@@_12.11</span>
<span class="cp">module FineTime</span>
<span class="cp">    def self.time</span>
<span class="cp">        # to be defined later</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp">module FineTime</span>
<span class="cp">    def self.time</span>
<span class="cp">        &quot;its a fine time&quot;</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">puts FineTime.time #=&gt; &quot;its a fine time&quot;</span>


<span class="cp"># @@PLEAC@@_12.12</span>
<span class="cp">def even_only(n)</span>
<span class="cp">    raise &quot;#{n} is not even&quot; if (n &amp; 1) != 0  # one way to test</span>
<span class="cp">    # ...</span>
<span class="cp">end</span>
<span class="cp">def even_only(n)</span>
<span class="cp">    $stderr.puts &quot;#{n} is not even&quot; if (n &amp; 1) != 0</span>
<span class="cp">    # ...</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_12.17</span>
<span class="cp"># The library archive for ruby is called Ruby Application archive,</span>
<span class="cp"># or shorter RAA, and can be found at http://raa.ruby-lang.org.</span>
<span class="cp"># A typical library is installed like this:</span>
<span class="cp"># % gunzip some-module-4.54.tar.gz</span>
<span class="cp"># % tar xf some-module-4.54.tar</span>
<span class="cp"># % cd some-module-4.54.tar</span>
<span class="cp"># % ruby install.rb config</span>
<span class="cp"># % ruby install.rb setup</span>
<span class="cp"># get superuser previleges here if needed for next step</span>
<span class="cp"># % ruby install.rb install</span>

<span class="cp"># Some modules use a different process,</span>
<span class="cp"># you should find details in the documentation</span>
<span class="cp"># Here is an example of such a different process</span>
<span class="cp"># % ruby extconf.rb</span>
<span class="cp"># % make</span>
<span class="cp"># % make install</span>

<span class="cp"># If you want the module installed in your own directory:</span>
<span class="cp"># For ruby version specific libraries</span>
<span class="cp"># % ruby install.rb config --site-ruby=~/lib</span>
<span class="cp"># For version independent libraries</span>
<span class="cp"># % ruby install.rb config --site-ruby-common=~/lib</span>

<span class="cp"># Information about possible options for config</span>
<span class="cp"># % ruby install.rb --help</span>

<span class="cp"># If you have your own complete distribution</span>
<span class="cp"># % ruby install.rb --prefix=path=~/ruby-private</span>


<span class="cp"># @@PLEAC@@_13.0</span>
<span class="cp"># Classes and objects in Ruby are rather straigthforward</span>
<span class="cp">class Person</span>
<span class="cp">    # Class variables (also called static attributes) are prefixed by @@</span>
<span class="cp">    @@person_counter=0</span>
<span class="cp">    </span>
<span class="cp">    # object constructor</span>
<span class="cp">    def initialize(age, name, alive = true)     # Default arg like in C++</span>
<span class="cp">        @age, @name, @alive = age, name, alive  # Object attributes are prefixed by &#39;@&#39;</span>
<span class="cp">        @@person_counter += 1</span>
<span class="cp">          # There is no &#39;++&#39; operator in Ruby. The &#39;++&#39;/&#39;--&#39;  operators are in fact </span>
<span class="cp">          # hidden assignments which affect variables, not objects. You cannot accomplish</span>
<span class="cp">          # assignment via method. Since everything in Ruby is object, &#39;++&#39; and &#39;--&#39; </span>
<span class="cp">          # contradict Ruby OO ideology. Instead &#39;-=&#39; and &#39;+=&#39; are used.</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    attr_accessor :name, :age   # This creates setter and getter methods for @name</span>
<span class="cp">                                # and @age. See 13.3 for detailes.</span>
<span class="cp">    </span>
<span class="cp">    # methods modifying the receiver object usually have the &#39;!&#39; suffix</span>
<span class="cp">    def die!</span>
<span class="cp">        @alive = false</span>
<span class="cp">        puts &quot;#{@name} has died at the age of #{@age}.&quot;</span>
<span class="cp">        @alive</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def kill(anotherPerson)</span>
<span class="cp">        print @name, &#39; is killing &#39;, anotherPerson.name, &quot;.\n&quot;</span>
<span class="cp">        anotherPerson.die!</span>
<span class="cp">    end</span>

<span class="cp">    # methods used as queries</span>
<span class="cp">    # usually have the &#39;?&#39; suffix    </span>
<span class="cp">    def alive?</span>
<span class="cp">        @alive &amp;&amp; true</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def year_of_birth</span>
<span class="cp">        Time.now.year - @age</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    # Class method (also called static method)</span>
<span class="cp">    def Person.number_of_people</span>
<span class="cp">        @@person_counter</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># Using the class:</span>
<span class="cp"># Create objects of class Person</span>
<span class="cp">lecter = Person.new(47, &#39;Hannibal&#39;)</span>
<span class="cp">starling = Person.new(29, &#39;Clarice&#39;, true)</span>
<span class="cp">pazzi = Person.new(40, &#39;Rinaldo&#39;, true)</span>

<span class="cp"># Calling a class method</span>
<span class="cp">print &quot;There are &quot;, Person.number_of_people, &quot; Person objects\n&quot;</span>

<span class="cp">print pazzi.name, &#39; is &#39;, (pazzi.alive?) ? &#39;alive&#39; : &#39;dead&#39;, &quot;.\n&quot;</span>
<span class="cp">lecter.kill(pazzi)</span>
<span class="cp">print pazzi.name, &#39; is &#39;, (pazzi.alive?) ? &#39;alive&#39; : &#39;dead&#39;, &quot;.\n&quot;</span>

<span class="cp">print starling.name , &#39; was born in &#39;, starling.year_of_birth, &quot;\n&quot;</span>


<span class="cp"># @@PLEAC@@_13.1</span>
<span class="cp"># If you don&#39;t need any initialisation in the constructor,</span>
<span class="cp"># you don&#39;t need to write a constructor.</span>
<span class="cp">class MyClass</span>
<span class="cp">end</span>

<span class="cp">class MyClass</span>
<span class="cp">    def initialize</span>
<span class="cp">        @start = Time.new</span>
<span class="cp">        @age = 0</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">class MyClass</span>
<span class="cp">    def initialize(inithash)</span>
<span class="cp">        @start = Time.new</span>
<span class="cp">        @age = 0</span>
<span class="cp">        for key, value in inithash</span>
<span class="cp">            instance_variable_set(&quot;@#{key}&quot;, value)</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># @@PLEAC@@_13.2</span>
<span class="cp"># Objects are destroyed by the garbage collector.</span>
<span class="cp"># The time of destroying is not predictable.</span>
<span class="cp"># The ruby garbage collector can handle circular references,</span>
<span class="cp"># so there is no need to write destructor for that.</span>

<span class="cp"># There is no direct support for destructor.</span>
<span class="cp"># You can call a custom function, or more specific a proc object, when the</span>
<span class="cp"># garbage collector is about to destruct the object, but it is unpredictable</span>
<span class="cp"># when this occurs.</span>
<span class="cp"># Also if such a finalizer object has a reference to the orignal object,</span>
<span class="cp"># this may prevent the original object to get garbage collected.</span>
<span class="cp"># Because of this problem the finalize method below is</span>
<span class="cp"># a class method and not a instance method.</span>
<span class="cp"># So if you need to free resources for an object, like</span>
<span class="cp"># closing a socket or kill a spawned subprocess,</span>
<span class="cp"># you should do it explicitly.</span>

<span class="cp">class MyClass</span>
<span class="cp">    def initialize</span>
<span class="cp">        ObjectSpace.define_finalizer(self,</span>
<span class="cp">                                     self.class.method(:finalize).to_proc)</span>
<span class="cp">    end</span>
<span class="cp">    def MyClass.finalize(id)</span>
<span class="cp">        puts &quot;Object #{id} dying at #{Time.new}&quot;</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># test code</span>
<span class="cp">3.times {</span>
<span class="cp">    MyClass.new</span>
<span class="cp">}</span>
<span class="cp">ObjectSpace.garbage_collect</span>


<span class="cp"># @@PLEAC@@_13.3</span>
<span class="cp"># You can write getter and setter methods in a natural way:</span>
<span class="cp">class Person</span>
<span class="cp">    def name</span>
<span class="cp">        @name</span>
<span class="cp">    end</span>
<span class="cp">    def name=(name)</span>
<span class="cp">        @name = name</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># But there is a better and shorter way</span>
<span class="cp">class Person</span>
<span class="cp">    attr_reader :age</span>
<span class="cp">    attr_writer :name  </span>
<span class="cp">    # attr_reader and attr_writer are actually methods in class Class</span>
<span class="cp">    # which set getter and setter methods for you.</span>
<span class="cp">end</span>

<span class="cp"># There is also attr_accessor to create both setters and getters</span>
<span class="cp">class Person</span>
<span class="cp">    attr_accessor :age, :name</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_13.4</span>
<span class="cp">class Person</span>
<span class="cp">    # Class variables (also called static attributes) are prefixed by @@</span>
<span class="cp">    @@person_counter = 0</span>
<span class="cp">    </span>
<span class="cp">    def Person.population</span>
<span class="cp">        @@person_counter</span>
<span class="cp">    end</span>
<span class="cp">    def initialize</span>
<span class="cp">        @@person_counter += 1</span>
<span class="cp">        ObjectSpace.define_finalizer(self,</span>
<span class="cp">                                     self.class.method(:finalize).to_proc)</span>
<span class="cp">    end</span>
<span class="cp">    def Person.finalize(id)</span>
<span class="cp">        @@person_counter -= 1</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp">people = []</span>
<span class="cp">10.times {</span>
<span class="cp">    people.push(Person.new)</span>
<span class="cp">}</span>
<span class="cp">printf(&quot;There are %d people alive&quot;, Person.population)</span>


<span class="cp">FixedArray.class_max_bounds = 100</span>
<span class="cp">alpha = FixedArray.new</span>
<span class="cp">puts &quot;Bound on alpha is #{alpha.max_bounds}&quot;</span>

<span class="cp">beta = FixedArray.new</span>
<span class="cp">beta.max_bounds = 50                    # calls the instance method</span>
<span class="cp">beta.class.class_max_bounds = 50        # alternative, calls the class method</span>
<span class="cp">puts &quot;Bound on alpha is #{alpha.max_bounds}&quot;</span>
<span class="cp">    </span>
<span class="cp">class FixedArray</span>
<span class="cp">    @@bounds = 7</span>
<span class="cp">    </span>
<span class="cp">    def max_bounds</span>
<span class="cp">        @@max_bounds</span>
<span class="cp">    end</span>
<span class="cp">    # instance method, which sets the class variable</span>
<span class="cp">    def max_bounds=(value)</span>
<span class="cp">        @@max_bounds = value</span>
<span class="cp">    end</span>
<span class="cp">    # class method. This can only be called on a class,</span>
<span class="cp">    # but not on the instances</span>
<span class="cp">    def FixedArray.class_max_bounds=(value)</span>
<span class="cp">        @@max_bounds = value</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_13.5</span>
<span class="cp">PersonStruct = Struct.new(&quot;Person&quot;, :name, :age, :peers)</span>
<span class="cp"># creates a class &quot;Person::Struct&quot;, which is accessiable with the</span>
<span class="cp"># constant &quot;PersonStruct&quot;</span>
<span class="cp">p = PersonStruct.new</span>
<span class="cp">p = Struct::Person.new                      # alternative using the classname</span>
<span class="cp">p.name = &quot;Jason Smythe&quot;</span>
<span class="cp">p.age = 13</span>
<span class="cp">p.peers = [&quot;Wilbur&quot;, &quot;Ralph&quot;, &quot;Fred&quot;]</span>
<span class="cp">p[:peers] = [&quot;Wilbur&quot;, &quot;Ralph&quot;, &quot;Fred&quot;]     # alternative access using symbol</span>
<span class="cp">p[&quot;peers&quot;] = [&quot;Wilbur&quot;, &quot;Ralph&quot;, &quot;Fred&quot;]    # alternative access using name of field</span>
<span class="cp">p[2] = [&quot;Wilbur&quot;, &quot;Ralph&quot;, &quot;Fred&quot;]          # alternative access using index of field</span>
<span class="cp">puts &quot;At age #{p.age}, #{p.name}&#39;s first friend is #{p.peers[0]}&quot;</span>

<span class="cp"># The fields of a struct have no special type, like other ruby variables</span>
<span class="cp"># you can put any objects in. Therefore the discussions how to specify</span>
<span class="cp"># the types of the fields do not apply to ruby.</span>

<span class="cp">FamilyStruct = Struct.new(&quot;Family&quot;, :head, :address, :members)</span>
<span class="cp">folks = FamilyStruct.new</span>
<span class="cp">folks.head = PersonStruct.new</span>
<span class="cp">dad = folks.head</span>
<span class="cp">dad.name = &quot;John&quot;</span>
<span class="cp">dad.age = 34</span>

<span class="cp"># supply of own accessor method for the struct for error checking</span>
<span class="cp">class PersonStruct</span>
<span class="cp">    def age=(value)</span>
<span class="cp">        if !value.kind_of?(Integer)</span>
<span class="cp">            raise(ArgumentError, &quot;Age #{value} isn&#39;t an Integer&quot;)</span>
<span class="cp">        elsif value &gt; 150</span>
<span class="cp">            raise(ArgumentError, &quot;Age #{value} is unreasonable&quot;)</span>
<span class="cp">        end</span>
<span class="cp">        @age = value</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_13.6</span>
<span class="cp"># The ruby Object class defines a dup and a clone method.</span>
<span class="cp"># The dup method is recommended for prototype object creation.</span>
<span class="cp"># The default implementation makes a shallow copy,</span>
<span class="cp"># but each class can override it, for example to make a deep copy.</span>

<span class="cp"># If you want to call &#39;new&#39; directly on the instances,</span>
<span class="cp"># you can create a instance method &quot;new&quot;, which returns a new duplicate.</span>
<span class="cp"># This method is distinct from the class method new.</span>
<span class="cp">#</span>
<span class="cp">class A</span>
<span class="cp">    def new</span>
<span class="cp">        dup</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">ob1 = A.new</span>
<span class="cp"># later on</span>
<span class="cp">ob2 = ob1.new</span>


<span class="cp"># @@PLEAC@@_13.7</span>
<span class="cp">methname = &#39;flicker&#39;</span>
<span class="cp">obj.send(methname, 10)      # calls obj.flicker(10)</span>

<span class="cp"># call three methods on the object, by name</span>
<span class="cp">[&#39;start&#39;, &#39;run&#39;, &#39;stop&#39;].each do |method_string|</span>
<span class="cp">    obj.send(method_string)</span>
<span class="cp">end</span>

<span class="cp"># Another way is to create a Method object</span>
<span class="cp">method_obj = obj.method(&#39;flicker&#39;)</span>
<span class="cp"># And then call it</span>
<span class="cp">method_obj.call(10)</span>


<span class="cp"># @@PLEAC@@_13.8</span>
<span class="cp"># All classes in Ruby inherit from class Object</span>
<span class="cp"># and thus all objects share methods defined in this class</span>

<span class="cp"># the class of the object</span>
<span class="cp">puts any_object.type</span>

<span class="cp"># Ruby classes are actually objects of class Class and they</span>
<span class="cp"># respond to methods defined in Object class as well</span>

<span class="cp"># the superclass of this class</span>
<span class="cp">puts any_object.class.superclass</span>

<span class="cp"># ask an object whether it is an instance of particular class</span>
<span class="cp">n = 4.7</span>
<span class="cp">puts n.instance_of?(Float)    # true</span>
<span class="cp">puts n.instance_of?(Numeric)  # false</span>

<span class="cp"># ask an object whether it is an instance of class, one of the</span>
<span class="cp"># superclasses of the object, or modules included in it</span>
<span class="cp">puts n.kind_of?(Float)       # true (the class)</span>
<span class="cp">puts n.kind_of?(Numeric)     # true (an ancestor class)</span>
<span class="cp">puts n.kind_of?(Comparable)  # true (a mixin module)</span>
<span class="cp">puts n.kind_of?(String)      # false</span>

<span class="cp"># ask an object whether it can respond to a particular method</span>
<span class="cp">puts n.respond_to?(&#39;+&#39;)      # true</span>
<span class="cp">puts n.respond_to?(&#39;length&#39;) # false</span>

<span class="cp"># all methods an object can respond to</span>
<span class="cp">&#39;just a string&#39;.methods.each { |m| puts m }</span>


<span class="cp"># @@PLEAC@@_13.9</span>
<span class="cp"># Actually any class in Ruby is inheritable</span>
<span class="cp">class Person        </span>
<span class="cp">    attr_accessor :age, :name</span>
<span class="cp">    def initialize</span>
<span class="cp">        @name</span>
<span class="cp">        @age</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">dude = Person.new</span>
<span class="cp">dude.name = &#39;Jason&#39;</span>
<span class="cp">dude.age = 23</span>
<span class="cp">printf &quot;%s is age %d.\n&quot;, dude.name, dude.age</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Inheriting from Person</span>
<span class="cp">class Employee &lt; Person</span>
<span class="cp">    attr_accessor :salary</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">empl = Employee.new</span>
<span class="cp">empl.name = &#39;Jason&#39;</span>
<span class="cp">empl.age = 23</span>
<span class="cp">empl.salary = 200</span>
<span class="cp">printf &quot;%s is age %d, the salary is %d.\n&quot;, empl.name, empl.age, empl.salary</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Any built-in class can be inherited the same way</span>
<span class="cp">class WeirdString &lt; String  </span>
<span class="cp">    def initialize(obj)</span>
<span class="cp">        super obj</span>
<span class="cp">    end</span>
<span class="cp">    def +(anotherObj)   # + method in this class is overridden</span>
<span class="cp">        # to return the sum of string lengths</span>
<span class="cp">        self.length + anotherObj.length  # &#39;self&#39; can be omitted</span>
<span class="cp">    end  </span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">a = WeirdString.new(&#39;hello&#39;)</span>
<span class="cp">b = WeirdString.new(&#39;bye&#39;)</span>

<span class="cp">puts a + b    # the overridden +</span>
<span class="cp">#=&gt; 8</span>
<span class="cp">puts a.length # method from the superclass, String</span>
<span class="cp">#=&gt; 5</span>


<span class="cp"># @@PLEAC@@_13.11</span>
<span class="cp"># In ruby you can override the method_missing method</span>
<span class="cp"># to have a solution similar to perls AUTOLOAD.</span>
<span class="cp">class Person</span>

<span class="cp">    def initialize</span>
<span class="cp">        @ok_fields = %w(name age peers parent)</span>
<span class="cp">    end</span>

<span class="cp">    def valid_attribute?(name)</span>
<span class="cp">        @ok_fields.include?(name)</span>
<span class="cp">    end</span>

<span class="cp">    def method_missing(namesymbol, *params)</span>
<span class="cp">        name = namesymbol.to_s</span>
<span class="cp">        return if name =~ /^A-Z/</span>
<span class="cp">        if name.to_s[-1] == (&#39;=&#39;[0])       # we have a setter</span>
<span class="cp">            isSetter = true</span>
<span class="cp">            name.sub!(/=$/, &#39;&#39;)</span>
<span class="cp">        end</span>
<span class="cp">        if valid_attribute?(name)</span>
<span class="cp">            if isSetter</span>
<span class="cp">                instance_variable_set(&quot;@#{name}&quot;, *params)</span>
<span class="cp">            else</span>
<span class="cp">                instance_variable_get(&quot;@#{name}&quot;, *params)</span>
<span class="cp">            end</span>
<span class="cp">        else</span>
<span class="cp">            # if no annestor is responsible,</span>
<span class="cp">            # the Object class will throw a NoMethodError exception</span>
<span class="cp">            super(namesymbol, *params)</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">    def new</span>
<span class="cp">        kid = Person.new</span>
<span class="cp">        kid.parent = self</span>
<span class="cp">        kid</span>
<span class="cp">    end</span>

<span class="cp">end</span>

<span class="cp">dad = Person.new</span>
<span class="cp">dad.name = &quot;Jason&quot;</span>
<span class="cp">dad.age = 23</span>
<span class="cp">kid = dad.new</span>
<span class="cp">kid.name = &quot;Rachel&quot;</span>
<span class="cp">kid.age = 2</span>
<span class="cp">puts &quot;Kid&#39;s parent is #{kid.parent.name}&quot;</span>
<span class="cp">puts dad</span>
<span class="cp">puts kid</span>

<span class="cp">class Employee &lt; Person</span>
<span class="cp">    def initialize</span>
<span class="cp">        super</span>
<span class="cp">        @ok_fields.push(&quot;salary&quot;, &quot;boss&quot;)</span>
<span class="cp">    end</span>
<span class="cp">    def ok_fields</span>
<span class="cp">        @ok_fields</span>
<span class="cp">    end</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_13.13</span>
<span class="cp"># The ruby garbage collector pretends to cope with circular structures.</span>
<span class="cp"># You can test it with this code:</span>
<span class="cp">class RingNode</span>
<span class="cp">    attr_accessor :next</span>
<span class="cp">    attr_accessor :prev</span>
<span class="cp">    attr_reader :name</span>

<span class="cp">    def initialize(aName)</span>
<span class="cp">        @name = aName</span>
<span class="cp">        ObjectSpace.define_finalizer(self,</span>
<span class="cp">                                     self.class.method(:finalize).to_proc)</span>
<span class="cp">    end</span>

<span class="cp">    def RingNode.finalize(id)</span>
<span class="cp">        puts &quot;Node #{id} dying&quot;</span>
<span class="cp">    end</span>

<span class="cp">    def RingNode.show_all_objects</span>
<span class="cp">        ObjectSpace.each_object {|id|</span>
<span class="cp">            puts id.name if id.class == RingNode</span>
<span class="cp">        }</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">def create_test</span>
<span class="cp">    a = RingNode.new(&quot;Node A&quot;)</span>
<span class="cp">    b = RingNode.new(&quot;Node B&quot;)</span>
<span class="cp">    c = RingNode.new(&quot;Node C&quot;)</span>
<span class="cp">    a.next = b</span>
<span class="cp">    b.next = c</span>
<span class="cp">    c.next = a</span>
<span class="cp">    a.prev = c</span>
<span class="cp">    c.prev = b</span>
<span class="cp">    b.prev = a</span>

<span class="cp">    a = nil</span>
<span class="cp">    b = nil</span>
<span class="cp">    c = nil</span>
<span class="cp">end</span>

<span class="cp">create_test</span>
<span class="cp">RingNode.show_all_objects</span>
<span class="cp">ObjectSpace.garbage_collect</span>
<span class="cp">puts &quot;After garbage collection&quot;</span>
<span class="cp">RingNode.show_all_objects</span>


<span class="cp"># @@PLEAC@@_13.14</span>
<span class="cp">class String</span>
<span class="cp">    def &lt;=&gt;(other)</span>
<span class="cp">        self.casecmp other</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp"># There is no way to directly overload the &#39;&quot;&quot;&#39; (stringify) </span>
<span class="cp"># operator in Ruby.  However, by convention, classes which </span>
<span class="cp"># can reasonably be converted to a String will define a </span>
<span class="cp"># &#39;to_s&#39; method as in the TimeNumber class defined below.</span>
<span class="cp"># The &#39;puts&#39; method will automatcally call an object&#39;s</span>
<span class="cp"># &#39;to_s&#39; method as is demonstrated below.</span>
<span class="cp"># Furthermore, if a class defines a to_str method, an object of that</span>
<span class="cp"># class can be used most any place where the interpreter is looking </span>
<span class="cp"># for a String value.</span>

<span class="cp">#---------------------------------------</span>
<span class="cp"># NOTE: Ruby has a builtin Time class which would usually be used </span>
<span class="cp"># to manipulate time objects, the following is supplied for</span>
<span class="cp"># educational purposes to demonstrate operator overloading.</span>
<span class="cp">#</span>
<span class="cp">class TimeNumber</span>
<span class="cp">    attr_accessor  :hours,:minutes,:seconds</span>
<span class="cp">    def initialize( hours, minutes, seconds)</span>
<span class="cp">        @hours = hours</span>
<span class="cp">        @minutes = minutes</span>
<span class="cp">        @seconds = seconds</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def to_s</span>
<span class="cp">        return sprintf( &quot;%d:%02d:%02d&quot;, @hours, @minutes, @seconds)</span>
<span class="cp">    end</span>

<span class="cp">    def to_str</span>
<span class="cp">        to_s</span>
<span class="cp">    end</span>

<span class="cp">    def +( other)</span>
<span class="cp">        seconds = @seconds + other.seconds</span>
<span class="cp">        minutes = @minutes + other.minutes</span>
<span class="cp">        hours = @hours + other.hours</span>
<span class="cp">        if seconds &gt;= 60</span>
<span class="cp">            seconds %= 60</span>
<span class="cp">            minutes += 1</span>
<span class="cp">        end</span>
<span class="cp">        if minutes &gt;= 60</span>
<span class="cp">            minutes %= 60</span>
<span class="cp">            hours += 1</span>
<span class="cp">        end</span>
<span class="cp">        return TimeNumber.new(hours, minutes, seconds)</span>
<span class="cp">    end</span>

<span class="cp">    def -(other)</span>
<span class="cp">        raise NotImplementedError</span>
<span class="cp">    end</span>

<span class="cp">    def *(other)</span>
<span class="cp">        raise NotImplementedError</span>
<span class="cp">    end</span>

<span class="cp">    def /( other)</span>
<span class="cp">        raise NotImplementedError</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">t1 = TimeNumber.new(0, 58, 59)</span>
<span class="cp">sec = TimeNumber.new(0, 0, 1)</span>
<span class="cp">min = TimeNumber.new(0, 1, 0)</span>
<span class="cp">puts t1 + sec + min + min</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># StrNum class example: Ruby&#39;s builtin String class already has the </span>
<span class="cp"># capabilities outlined in StrNum Perl example, however the &#39;*&#39; operator</span>
<span class="cp"># on Ruby&#39;s String class acts differently: It creates a string which</span>
<span class="cp"># is the original string repeated N times.</span>
<span class="cp">#</span>
<span class="cp"># Using Ruby&#39;s String class as is in this example:</span>
<span class="cp">x = &quot;Red&quot;; y = &quot;Black&quot;</span>
<span class="cp">z = x+y</span>
<span class="cp">r = z*3 # r is &quot;RedBlackRedBlackRedBlack&quot;</span>
<span class="cp">puts &quot;values are #{x}, #{y}, #{z}, and #{r}&quot;</span>
<span class="cp">print &quot;#{x} is &quot;, x &lt; y ? &quot;LT&quot; : &quot;GE&quot;, &quot; #{y}\n&quot;</span>
<span class="cp"># prints:</span>
<span class="cp"># values are Red, Black, RedBlack, and RedBlackRedBlackRedBlack</span>
<span class="cp"># Red is GE Black</span>

<span class="cp">#-----------------------------</span>
<span class="cp">class FixNum</span>
<span class="cp">    REGEX = /(\.\d*)/</span>
<span class="cp">    DEFAULT_PLACES = 0</span>
<span class="cp">    attr_accessor :value, :places</span>
<span class="cp">    def initialize(value, places = nil)</span>
<span class="cp">        @value = value</span>
<span class="cp">        if places</span>
<span class="cp">            @places = places</span>
<span class="cp">        else</span>
<span class="cp">            m = REGEX.match(value.to_s) </span>
<span class="cp">            if m</span>
<span class="cp">                @places = m[0].length - 1</span>
<span class="cp">            else</span>
<span class="cp">                @places = DEFAULT_PLACES</span>
<span class="cp">            end</span>
<span class="cp">        end</span>
<span class="cp">    end</span>

<span class="cp">    def +(other)</span>
<span class="cp">        FixNum.new(@value + other.value, max(@places, other.places))</span>
<span class="cp">    end</span>

<span class="cp">    def *(other)</span>
<span class="cp">        FixNum.new(@value * other.value, max(@places, other.places))</span>
<span class="cp">    end</span>

<span class="cp">    def /(other)</span>
<span class="cp">        puts &quot;Divide: #{@value.to_f/other.value.to_f}&quot;</span>
<span class="cp">        result = FixNum.new(@value.to_f/other.value.to_f)</span>
<span class="cp">        result.places = max(result.places,other.places) </span>
<span class="cp">        result</span>
<span class="cp">    end</span>

<span class="cp">    def to_s</span>
<span class="cp">        sprintf(&quot;STR%s: %.*f&quot;, self.class.to_s , @places, @value)   #.</span>
<span class="cp">    end  </span>

<span class="cp">    def to_str</span>
<span class="cp">        to_s</span>
<span class="cp">    end</span>

<span class="cp">    def to_i #convert to int</span>
<span class="cp">        @value.to_i</span>
<span class="cp">    end</span>

<span class="cp">    def to_f #convert to float`</span>
<span class="cp">        @value.to_f</span>
<span class="cp">    end</span>

<span class="cp">    private</span>
<span class="cp">    def max(a,b)</span>
<span class="cp">        a &gt; b ? a : b</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">def demo()</span>
<span class="cp">    x = FixNum.new(40)</span>
<span class="cp">    y = FixNum.new(12, 0)</span>

<span class="cp">    puts &quot;sum of #{x} and #{y} is  #{x+y}&quot;</span>
<span class="cp">    puts &quot;product of #{x} and #{y} is #{x*y}&quot;</span>

<span class="cp">    z = x/y</span>
<span class="cp">    puts &quot;#{z} has #{z.places} places&quot;</span>
<span class="cp">    unless z.places</span>
<span class="cp">        z.places = 2</span>
<span class="cp">    end</span>

<span class="cp">    puts &quot;div of #{x} by #{y} is #{z}&quot;</span>
<span class="cp">    puts &quot;square of that is  #{z*z}&quot;</span>
<span class="cp">end</span>

<span class="cp">if __FILE__ == $0</span>
<span class="cp">    demo()</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_14.1</span>
<span class="cp"># There are dbm, sdbm, gdbm modules</span>
<span class="cp"># and the bdb module for accessing the berkeley db</span>
<span class="cp"># sdbm seem to be available on the most systems,</span>
<span class="cp"># so we use it here</span>
<span class="cp">#</span>
<span class="cp">require &quot;sdbm&quot;</span>
<span class="cp">SDBM.open(&quot;filename&quot;, 0666) { |dbobj|</span>
<span class="cp">    # raises exception if open error</span>
<span class="cp">    </span>
<span class="cp">    # the returned sdbm-dbobj has most of the methods of a hash</span>
<span class="cp">    v = dbobj[&quot;key&quot;]</span>
<span class="cp">    dbobj[&quot;key&quot;] = &quot;newvalue&quot;</span>
<span class="cp">    if dbobj.has_key?(&quot;key&quot;)</span>
<span class="cp">        # ...</span>
<span class="cp">    end</span>
<span class="cp">    dbobj.delete(&quot;key2&quot;)</span>
<span class="cp">}</span>
<span class="cp"># database is open only inside the block.</span>

<span class="cp"># It is also possible to use a open .. close pair:</span>
<span class="cp">dbobj = SDBM.open(&quot;filename&quot;, 0666)</span>
<span class="cp">#.. do something with dbobj</span>
<span class="cp">dbobj.close</span>

<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># userstats - generate statistics on who is logged in</span>
<span class="cp"># call with usernames as argument to display the totals</span>
<span class="cp"># for the given usernames, call with &quot;ALL&quot; to display all users</span>

<span class="cp">require &quot;sdbm&quot;</span>
<span class="cp">filename = &#39;/tmp/userstats.db&#39;</span>
<span class="cp">SDBM.open(filename, 0666) { |dbobj|</span>
<span class="cp">    if ARGV.length &gt; 0</span>
<span class="cp">        if ARGV[0] == &quot;ALL&quot;</span>
<span class="cp">            # ARGV is constant, so we need the variable userlist</span>
<span class="cp">            userlist = dbobj.keys().sort()</span>
<span class="cp">        else</span>
<span class="cp">            userlist = ARGV</span>
<span class="cp">        end</span>
<span class="cp">        userlist.each { |user|</span>
<span class="cp">            print &quot;#{user}\t#{dbobj[user]}\n&quot;</span>
<span class="cp">        }</span>
<span class="cp">    else</span>
<span class="cp">        who = `who`</span>
<span class="cp">        who.split(&quot;\n&quot;).each { |line|</span>
<span class="cp">            md = /^(\S+)/.match(line)</span>
<span class="cp">            raise &quot;Bad line from who: #{line}&quot; unless md</span>
<span class="cp">            # sdbm stores only strings, so &quot;+=&quot; doesn&#39;t work,</span>
<span class="cp">            # we need to convert them expicitly back to integer.</span>
<span class="cp">            if dbobj.has_key?(md[0])</span>
<span class="cp">                dbobj[md[0]] = dbobj[md[0]].to_i + 1</span>
<span class="cp">            else</span>
<span class="cp">                dbobj[md[0]] = &quot;1&quot;</span>
<span class="cp">            end</span>
<span class="cp">        }</span>
<span class="cp">    end</span>
<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_14.2</span>
<span class="cp"># using open and clear</span>
<span class="cp">dbobj = SDBM.open(&quot;filename&quot;, 0666)</span>
<span class="cp">dbobj.clear()</span>
<span class="cp">dbobj.close()</span>
<span class="cp"># deleting file and recreating it</span>
<span class="cp"># the filenames depend on the flavor of dbm you use,</span>
<span class="cp"># for example sdbm has two files named filename.pag and filename.dir,</span>
<span class="cp"># so you need to delete both files</span>
<span class="cp">begin</span>
<span class="cp">    File.delete(&quot;filename&quot;)</span>
<span class="cp">    # raises Exception if not exist</span>
<span class="cp">    dbobj = SDBM.open(&quot;filename&quot;, 0666)</span>
<span class="cp">rescue</span>
<span class="cp">    # add error handling here</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_14.3</span>
<span class="cp"># sdbm2gdbm: converts sdbm database to a gdbm database</span>
<span class="cp">require &quot;sdbm&quot;</span>
<span class="cp">require &quot;gdbm&quot;</span>

<span class="cp">unless ARGV.length == 2</span>
<span class="cp">    fail &quot;usage: sdbm2gdbm infile outfile&quot;</span>
<span class="cp">end</span>
<span class="cp">infile = ARGV[0]</span>
<span class="cp">outfile = ARGV[1]</span>

<span class="cp">sdb = SDBM.open(infile)</span>
<span class="cp">gdb = GDBM.open(outfile, 0666)</span>
<span class="cp">sdb.each { |key, val|</span>
<span class="cp">    gdb[key] = val</span>
<span class="cp">}</span>
<span class="cp">gdb.close</span>
<span class="cp">sdb.close</span>


<span class="cp"># @@PLEAC@@_14.4</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># dbmmerge: merges two dbm databases</span>
<span class="cp">require &quot;sdbm&quot;</span>

<span class="cp">unless ARGV.length == 3</span>
<span class="cp">    fail &quot;usage: dbmmerge indb1 indb2 outdb&quot;</span>
<span class="cp">end</span>
<span class="cp">infile1 = ARGV[0]</span>
<span class="cp">infile2 = ARGV[0]</span>
<span class="cp">outfile = ARGV[2]</span>

<span class="cp">in1 = SDBM.open(infile1, nil)</span>
<span class="cp">in2 = SDBM.open(infile2, nil)</span>
<span class="cp">outdb = SDBM.open(outfile, 0666)</span>

<span class="cp">[in1, in2].each { |indb|</span>
<span class="cp">    indb.each { |key, val|</span>
<span class="cp">        if outdb.has_key?(key)</span>
<span class="cp">            # decide which value to set.</span>
<span class="cp">            # set outdb[key] if necessary</span>
<span class="cp">        else</span>
<span class="cp">            outdb[key] = val</span>
<span class="cp">        end</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">in1.close</span>
<span class="cp">in2.close</span>
<span class="cp">outdb.close</span>


<span class="cp"># @@PLEAC@@_14.7</span>
<span class="cp"># we write a tie method that extends the Array class.</span>
<span class="cp"># It reads the file into the memory, executes the code block</span>
<span class="cp"># in which you can manipulate the array as needed, and writes</span>
<span class="cp"># the array back to the file after the end of the block execution</span>
<span class="cp">class Array</span>
<span class="cp">    def tie(filename, flags)</span>
<span class="cp">        File.open(filename, flags) { |f|</span>
<span class="cp">            f.each_line { |line|</span>
<span class="cp">                self.push(line.chomp)</span>
<span class="cp">            }</span>
<span class="cp">            yield</span>
<span class="cp">            f.rewind</span>
<span class="cp">            each { |line|</span>
<span class="cp">                if line</span>
<span class="cp">                    f.puts(line)</span>
<span class="cp">                else</span>
<span class="cp">                    f.puts &quot;&quot;</span>
<span class="cp">                end</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">array = Array.new</span>
<span class="cp">array.tie(&quot;/tmp/textfile.txt&quot;, File::RDWR|File::CREAT) {</span>
<span class="cp">    array[4] = &quot;a new line 4&quot;</span>
<span class="cp">}</span>

<span class="cp"># The tied array can be manipulated like a normal array,</span>
<span class="cp"># so there is no need for a special API, and the recno_demo program</span>
<span class="cp"># to demonstrate is API is useless</span>


<span class="cp"># tied array demo: show how to use array with a tied file</span>
<span class="cp">filename = &quot;db_file.txt&quot;</span>
<span class="cp">lines = Array.new</span>
<span class="cp">File.unlink(filename) if File.exists?(filename)</span>
<span class="cp">lines.tie(filename, File::RDWR | File::CREAT) {</span>
<span class="cp">    # first create a textfile to play with</span>
<span class="cp">    lines[0] = &quot;zero&quot;</span>
<span class="cp">    lines[1] = &quot;one&quot;</span>
<span class="cp">    lines[2] = &quot;two&quot;</span>
<span class="cp">    lines[3] = &quot;three&quot;</span>
<span class="cp">    lines[4] = &quot;four&quot;</span>

<span class="cp">    # print the records in order.</span>
<span class="cp">    # Opposed to perl, the tied array behaves exactly as a normal array</span>
<span class="cp">    puts &quot;\nOriginal&quot;</span>
<span class="cp">    for i in 0..(lines.length-1)</span>
<span class="cp">        puts &quot;#{i}: #{lines[i]}&quot;</span>
<span class="cp">    end</span>

<span class="cp">    #use push and pop</span>
<span class="cp">    a = lines.pop</span>
<span class="cp">    lines.push(&quot;last&quot;)</span>
<span class="cp">    puts(&quot;The last line was [#{a}]&quot;)</span>

<span class="cp">    #use shift and unshift</span>
<span class="cp">    a = lines.shift</span>
<span class="cp">    lines.unshift(&quot;first&quot;)</span>
<span class="cp">    puts(&quot;The first line was [#{a}]&quot;)</span>

<span class="cp">    # add record after record 2</span>
<span class="cp">    i = 2</span>
<span class="cp">    lines.insert(i + 1, &quot;Newbie&quot;)</span>

<span class="cp">    # add record before record one</span>
<span class="cp">    i = 1</span>
<span class="cp">    lines.insert(i, &quot;New One&quot;)</span>

<span class="cp">    # delete record 3</span>
<span class="cp">    lines.delete_at(3)</span>

<span class="cp">    #now print the records in reverse order</span>
<span class="cp">    puts &quot;\nReverse&quot;</span>
<span class="cp">    (lines.length - 1).downto(0){ |i|</span>
<span class="cp">        puts &quot;#{i}: #{lines[i]}&quot;</span>
<span class="cp">    }</span>

<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_14.8</span>
<span class="cp"># example to store complex data in a database</span>
<span class="cp"># uses marshall from the standard library</span>
<span class="cp">require &quot;sdbm&quot;</span>
<span class="cp">db = SDBM.open(&quot;pleac14-8-database&quot;, 0666)</span>

<span class="cp"># convert the Objects into strings and back by using the Marshal module.</span>
<span class="cp"># Most normal objects can be converted out of the box,</span>
<span class="cp"># but not special things like procedure objects,</span>
<span class="cp"># IO instance variables, singleton objects</span>

<span class="cp">db[&quot;Tom Christiansen&quot;] = Marshal.dump([&quot;book author&quot;,  &quot;tchrist@perl.com&quot;])</span>
<span class="cp">db[&quot;Tom Boutell&quot;] = Marshal.dump([&quot;shareware author&quot;,</span>
<span class="cp">&quot;boutell@boutell.com&quot;])</span>

<span class="cp">name1 = &quot;Tom Christiansen&quot;</span>
<span class="cp">name2 = &quot;Tom Boutell&quot;</span>

<span class="cp">tom1 = Marshal.load(db[name1])</span>
<span class="cp">tom2 = Marshal.load(db[name2])</span>

<span class="cp">puts &quot;Two Toming: #{tom1} #{tom2}&quot;</span>

<span class="cp">if tom1[0] == tom2[0] &amp;&amp; tom1[1] == tom2[1]</span>
<span class="cp">   puts &quot;You&#39;re having runtime fun with one Tom made two.&quot;</span>
<span class="cp">else</span>
<span class="cp">   puts &quot;No two Toms are ever alike&quot;</span>
<span class="cp">end</span>

<span class="cp"># To change parts of an entry, get the whole entry, change the parts,</span>
<span class="cp"># and save the whole entry back</span>
<span class="cp">entry = Marshal.load(db[&quot;Tom Boutell&quot;])</span>
<span class="cp">entry[0] = &quot;Poet Programmer&quot;</span>
<span class="cp">db[&quot;Tom Boutell&quot;] = Marshal.dump(entry)</span>
<span class="cp">db.close</span>


<span class="cp"># @@PLEAC@@_14.9</span>
<span class="cp"># example to make data persistent</span>
<span class="cp"># uses Marshal from the standard lib</span>
<span class="cp"># Stores the data in a simple file,</span>
<span class="cp"># see 14.8 on how to store it in a dbm file</span>

<span class="cp"># The BEGIN block is executed before the rest of the script</span>
<span class="cp"># we use global variables here because local variables</span>
<span class="cp"># will go out of scope and are not accessible from the main script</span>

<span class="cp">BEGIN {</span>
<span class="cp">   $persistent_store = &quot;persitence.dat&quot;</span>
<span class="cp">   begin</span>
<span class="cp">     File.open($persistent_store) do |f|</span>
<span class="cp">       $stringvariable1 = Marshal.load(f)</span>
<span class="cp">       $arrayvariable2 = Marshal.load(f)</span>
<span class="cp">     end</span>
<span class="cp">   rescue</span>
<span class="cp">     puts &quot;Can not open #{$persistent_store}&quot;</span>
<span class="cp">     # Initialisation if this script runs the first time</span>
<span class="cp">     $stringvariable1 = &quot;&quot;</span>
<span class="cp">     $arrayvariable2 = []</span>
<span class="cp">   end</span>
<span class="cp">}</span>

<span class="cp">END {</span>
<span class="cp">   File.open($persistent_store, &quot;w+&quot;) do |f|</span>
<span class="cp">     Marshal.dump($stringvariable1, f)</span>
<span class="cp">     Marshal.dump($arrayvariable2, f)</span>
<span class="cp">   end</span>
<span class="cp">}</span>

<span class="cp"># simple test program</span>
<span class="cp">puts $stringvariable1</span>
<span class="cp">puts $arrayvariable2</span>
<span class="cp">$stringvariable1 = &quot;Hello World&quot;</span>
<span class="cp">$arrayvariable2.push(5)</span>
<span class="cp">puts $stringvariable1</span>
<span class="cp">puts $arrayvariable2</span>


<span class="cp"># @@PLEAC@@_14.10</span>
<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># Ruby has a dbi module with an architecture similar</span>
<span class="cp"># to the Perl dbi module: the dbi module provides an unified</span>
<span class="cp"># interface and uses specialized drivers for each dbms vendor</span>
<span class="cp">#</span>
<span class="cp">begin</span>
<span class="cp">    DBI.connect(&quot;DBI:driver:driverspecific&quot;, &quot;username&quot;, &quot;auth&quot;) {</span>
<span class="cp">        |dbh|</span>

<span class="cp">        dbh.do(SQL1)</span>

<span class="cp">        dbh.prepare(SQL2){ |sth|</span>
<span class="cp">            sth.execute</span>
<span class="cp">            sth.fetch {|row|</span>
<span class="cp">                # ...</span>
<span class="cp">            }</span>
<span class="cp">        } # end of block finishes the statement handle</span>
<span class="cp">    } # end of block closes the database connection</span>
<span class="cp">rescue DBI::DatabaseError =&gt; e</span>
<span class="cp">    puts &quot;dbi error occurred&quot;</span>
<span class="cp">    puts &quot;Error code: #{e.err}&quot;</span>
<span class="cp">    puts &quot;Error message: #{e.errstr}&quot;</span>
<span class="cp">end</span>

<span class="cp">#!/usr/bin/ruby -w</span>
<span class="cp"># dbusers - example for mysql which creates a table,</span>
<span class="cp"># fills it with values, retrieves the values back,</span>
<span class="cp"># and finally destroys the table.</span>

<span class="cp">require &quot;dbi&quot;</span>

<span class="cp"># replacement for the User::pwnt module</span>
<span class="cp">def getpwent</span>
<span class="cp">    result = []</span>
<span class="cp">    File.open(&quot;/etc/passwd&quot;) {|file|</span>
<span class="cp">        file.each_line {|line|</span>
<span class="cp">            next if line.match(/^#/)</span>
<span class="cp">            cols = line.split(&quot;:&quot;)</span>
<span class="cp">            result.push([cols[2], cols[0]])</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">    result</span>
<span class="cp">end</span>

<span class="cp">begin</span>
<span class="cp">    DBI.connect(&quot;DBI:Mysql:pleacdatabase&quot;, &quot;pleac&quot;, &quot;pleacpassword&quot;) {</span>
<span class="cp">        |conn|</span>

<span class="cp">        conn.do(&quot;CREATE TABLE users (uid INT, login CHAR(8))&quot;)</span>

<span class="cp">        users = getpwent</span>

<span class="cp">        conn.prepare(&quot;INSERT INTO users VALUES (?,?)&quot;) {|sth|</span>
<span class="cp">            users.each {|entry|</span>
<span class="cp">                sth.execute(entry[0], entry[1])</span>
<span class="cp">            }</span>
<span class="cp">        }</span>

<span class="cp">        conn.execute(&quot;SELECT uid, login FROM users WHERE uid &lt; 50&quot;) {|sth|</span>
<span class="cp">            sth.fetch {|row|</span>
<span class="cp">                puts row.collect {|col|</span>
<span class="cp">                    if col.nil?</span>
<span class="cp">                        &quot;(null)&quot;</span>
<span class="cp">                    else</span>
<span class="cp">                        col</span>
<span class="cp">                    end</span>
<span class="cp">                }.join(&quot;, &quot;)</span>
<span class="cp">            }</span>
<span class="cp">        }</span>

<span class="cp">        conn.do(&quot;DROP TABLE users&quot;)</span>
<span class="cp">    }</span>
<span class="cp">rescue DBI::DatabaseError =&gt; e</span>
<span class="cp">    puts &quot;dbi error occurred&quot;</span>
<span class="cp">    puts &quot;Error code: #{e.err}&quot;</span>
<span class="cp">    puts &quot;Error message: #{e.errstr}&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_15.1</span>
<span class="cp"># This test program demonstrates parsing program arguments.</span>
<span class="cp"># It uses the optparse library, which is included with ruby 1.8</span>
<span class="cp"># It handles classic unix style and gnu style options</span>
<span class="cp">require &#39;optparse&#39;</span>

<span class="cp">@debugmode = false</span>
<span class="cp">@verbose = false</span>

<span class="cp">ARGV.options do |opts|</span>
<span class="cp">    opts.banner = &quot;Usage: ruby #{$0} [OPTIONS] INPUTFILES&quot;</span>

<span class="cp">    opts.on(&quot;-h&quot;, &quot;--help&quot;, &quot;show this message&quot;) {</span>
<span class="cp">        puts opts</span>
<span class="cp">        exit</span>
<span class="cp">    }</span>
<span class="cp">    # The OptionParser#on method is called with a specification of short</span>
<span class="cp">    # options, of long options, a data type spezification and user help</span>
<span class="cp">    # messages for this option.</span>
<span class="cp">    # The method analyses the given parameter and decides what it is,</span>
<span class="cp">    # so you can leave out the long option if you don&#39;t need it</span>
<span class="cp">    opts.on(&quot;-v&quot;, &quot;--[no-]verbose=[FLAG]&quot;, TrueClass, &quot;run verbosly&quot;) {</span>
<span class="cp">        |@verbose|   # sets @verbose to true or false</span>
<span class="cp">    }</span>
<span class="cp">    opts.on(&quot;-D&quot;, &quot;--DEBUG&quot;, TrueClass, &quot;turns on debug mode&quot; ){</span>
<span class="cp">        |@debugmode|   # sets @debugmode to true</span>
<span class="cp">    }</span>
<span class="cp">    opts.on(&quot;-c&quot;, &quot;--count=NUMBER&quot;, Integer, &quot;how many times we do it&quot; ){</span>
<span class="cp">        |@count|      # sets @count to given integer</span>
<span class="cp">    }</span>
<span class="cp">    opts.on(&quot;-o&quot;, &quot;--output=FILE&quot;, String, &quot;file to write output to&quot;){</span>
<span class="cp">        |@outputfile|   # sets @outputfile to given string</span>
<span class="cp">    }</span>
<span class="cp">    opts.parse!</span>
<span class="cp">end</span>

<span class="cp"># example to use the options in the main program</span>
<span class="cp">puts &quot;Verbose is on&quot; if @verbose</span>
<span class="cp">puts &quot;Debugmode is on&quot; if @debugmode</span>
<span class="cp">puts &quot;Outfile is #{@outputfile}&quot; if defined? @outputfile</span>
<span class="cp">puts &quot;Count is #{@count}&quot; if defined? @count</span>
<span class="cp">ARGV.each { |param|</span>
<span class="cp">    puts &quot;Got parameter #{param}&quot;</span>
<span class="cp">}</span>


<span class="cp"># @@PLEAC@@_15.4</span>
<span class="cp">buf = &quot;\0&quot; * 8</span>
<span class="cp">$stdout.ioctl(0x5413, buf)</span>
<span class="cp">ws_row, ws_col, ws_xpixel, ws_ypixel = buf.unpack(&quot;S4&quot;)</span>

<span class="cp">raise &quot;You must have at least 20 characters&quot; unless ws_col &gt;= 20</span>
<span class="cp">max = 0</span>
<span class="cp">values = (1..5).collect { rand(20) }  # generate an array[5] of rand values</span>
<span class="cp">for i in values</span>
<span class="cp">    max = i if max &lt; i</span>
<span class="cp">end</span>
<span class="cp">ratio = Float(ws_col-12)/max          # chars per unit</span>
<span class="cp">for i in values</span>
<span class="cp">    printf &quot;%8.1f %s\n&quot;, i, &quot;*&quot; * (ratio*i)</span>
<span class="cp">end</span>

<span class="cp"># gives, for example:</span>
<span class="cp">#   15.0 *******************************</span>
<span class="cp">#   10.0 *********************</span>
<span class="cp">#    5.0 **********</span>
<span class="cp">#   14.0 *****************************</span>
<span class="cp">#   18.0 **************************************</span>


<span class="cp"># @@PLEAC@@_15.5</span>
<span class="cp"># Ruby&#39;s standard distribution doesn&#39;t have an ANSI color module, but we can use</span>
<span class="cp"># Term::ANSIColor (http://term-ansicolor.rubyforge.org/) instead.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require &#39;term/ansicolor&#39;</span>
<span class="cp">include Term::ANSIColor</span>

<span class="cp"># Text can be colored using constants</span>
<span class="cp">print red, &quot;Danger Will Robinson!&quot;, reset, &quot;\n&quot;</span>
<span class="cp">print &quot;This is just normal text\n&quot;</span>
<span class="cp">print blink, &quot;Do you hurt yet?&quot;, reset, &quot;\n&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Or by using functions. Functions automatically reset colors at the end.</span>
<span class="cp">print red(&quot;Danger Will Ronbinson!&quot;), &quot;\n&quot;</span>
<span class="cp">print red( on_black( &quot;venom lack&quot; )), &quot;\n&quot;</span>
<span class="cp">print red( on_yellow( &quot;kill that fellow&quot; )), &quot;\n&quot;</span>
<span class="cp">print green( on_cyan( blink( &quot;garish!&quot; ))), &quot;\n&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Or by using block forms. Block forms automatically reset colors at the end.</span>
<span class="cp">print red { &quot;Danger Will Robinson!&quot; }, &quot;\n&quot;</span>
<span class="cp">print red { on_black { &quot;venom lack&quot; } }, &quot;\n&quot;</span>
<span class="cp">print red { on_yellow { &quot;kill that fellow&quot; } }, &quot;\n&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Or by using a String Mixin</span>
<span class="cp">class String</span>
<span class="cp">    include Term::ANSIColor</span>
<span class="cp">end</span>

<span class="cp">print &quot;Danger Will Robinson!&quot;.red, &quot;\n&quot;</span>
<span class="cp">print &quot;venom lack&quot;.red.on_black, &quot;\n&quot;</span>
<span class="cp">print &quot;kill that fellow&quot;.red.on_yellow, &quot;\n&quot;</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># To color text without using a third party library, constants can be created</span>
<span class="cp"># manually using ANSI escape codes. (A complete list of all codes can be found</span>
<span class="cp"># at http://en.wikipedia.org/wiki/Ansi_escape_codes)</span>
<span class="cp"># Note that \e means \033 (The escape character)</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Foreground constants</span>
<span class="cp">BLACK = &quot;\e[30m&quot;</span>
<span class="cp">RED = &quot;\e[31m&quot;</span>
<span class="cp">GREEN = &quot;\e[32m&quot;</span>
<span class="cp">WHITE = &quot;\e[37m&quot;</span>

<span class="cp"># Background constants</span>
<span class="cp">ON_BLACK = &quot;\e[40m&quot;</span>
<span class="cp">ON_WHITE = &quot;\e[47m&quot;</span>
<span class="cp">ON_YELLOW = &quot;\e[43m&quot;</span>
<span class="cp">ON_CYAN = &quot;\e[46m&quot;</span>

<span class="cp"># Style constants</span>
<span class="cp">BLINK = &quot;\e[5m&quot;</span>
<span class="cp">NOBLINK = &quot;\e[25m&quot;</span>
<span class="cp">BOLD = &quot;\e[1m&quot;</span>
<span class="cp">NOBOLD = &quot;\e[22m&quot;</span>

<span class="cp">RESET = &quot;\e[0m&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">puts &quot;#{RED}Danger Will Ronbinson!#{RESET}&quot;</span>
<span class="cp">puts &quot;This is just normal text.&quot;</span>
<span class="cp">puts &quot;#{BLINK}Do you hurt yet?#{NOBLINK}&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">puts &quot;#{RED}Danger Will Ronbinson!#{RESET}&quot;</span>
<span class="cp">puts &quot;#{RED}#{ON_BLACK}venom lack&quot;</span>
<span class="cp">puts &quot;#{RED}#{ON_YELLOW}kill that fellow&quot;</span>
<span class="cp">puts &quot;#{GREEN}#{ON_CYAN}#{BLINK}garish!&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print BLACK, ON_WHITE, &quot;black on white\n&quot;</span>
<span class="cp">print WHITE, ON_BLACK, &quot;white on black\n&quot;</span>
<span class="cp">print GREEN, ON_CYAN, BLINK, &quot;garish!\n&quot;</span>

<span class="cp">print RESET</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_16.1</span>
<span class="cp">output = `program args`       # collect output into one multiline string</span>
<span class="cp">output = `program args`.to_a  # collect output into array, one line per element</span>

<span class="cp">output = &quot;&quot;</span>
<span class="cp">IO.popen(&quot;ls&quot;) do |readme|</span>
<span class="cp">  readme.each do |line|</span>
<span class="cp">    output &lt;&lt; line</span>
<span class="cp">  end</span>
<span class="cp">end</span>

<span class="cp">`fsck -y /dev/rsd1a`  # BAD AND SCARY in Perl because it&#39;s managed by the shell</span>
<span class="cp">                      # I donna in Ruby ...</span>

<span class="cp"># so the &quot;clean and secure&quot; version</span>
<span class="cp">readme, writeme = IO.pipe</span>
<span class="cp">pid = fork {</span>
<span class="cp">    # child</span>
<span class="cp">    $stdout.reopen writeme</span>
<span class="cp">    readme.close</span>
<span class="cp">    exec(&#39;find&#39;, &#39;..&#39;)</span>
<span class="cp">}</span>
<span class="cp"># parent</span>
<span class="cp">writeme.close</span>
<span class="cp">readme.each do |line|</span>
<span class="cp">    # do something with &#39;line&#39;</span>
<span class="cp">end</span>
<span class="cp">Process.waitpid(pid)</span>


<span class="cp"># @@PLEAC@@_16.2</span>
<span class="cp">status = system(&quot;xemacs #{myfile}&quot;)</span>

<span class="cp">status = system(&quot;xemacs&quot;, myfile)</span>

<span class="cp">system(&quot;cmd1 args | cmd2 | cmd3 &gt;outfile&quot;)</span>
<span class="cp">system(&quot;cmd args &lt;infile &gt;outfile 2&gt;errfile&quot;)</span>

<span class="cp"># stop if the command fails</span>
<span class="cp">abort &quot;$program exited funny: #{$?}&quot; unless system(&quot;cmd&quot;, &quot;args1&quot;, &quot;args2&quot;)</span>

<span class="cp"># get the value of the signal sent to the child</span>
<span class="cp"># even if it is a SIGINT or SIGQUIT</span>
<span class="cp">arglist = [&#39;ruby&#39;, &#39;-e&#39;, &#39;5.times {|i| p i}&#39;]</span>
<span class="cp">system(*arglist)</span>
<span class="cp">raise &quot;program killed by signal #{$?}&quot; if ($? &amp; 127) != 0</span>

<span class="cp">pid = fork {</span>
<span class="cp">    trap(&quot;SIGINT&quot;, &quot;IGNORE&quot;)</span>
<span class="cp">    exec(&quot;sleep&quot;, &quot;10&quot;)</span>
<span class="cp">}</span>
<span class="cp">trap (&quot;SIGINT&quot;) {</span>
<span class="cp">    puts &quot;Tsk tsk, no process interruptus&quot;</span>
<span class="cp">}</span>
<span class="cp">Process.waitpid(pid, 0)</span>

<span class="cp"># Ruby permits to lie to the program called by a &#39;system&#39;.</span>
<span class="cp"># (ie specify what return argv[0] in C, $0 in Perl/Ruby ...)</span>
<span class="cp">system [&#39;bash&#39;, &#39;fake&#39;], &#39;-c&#39;, &#39;echo $0&#39;</span>


<span class="cp"># @@PLEAC@@_16.3</span>
<span class="cp">exec(&quot;archive *.data&quot;)</span>

<span class="cp">exec(&quot;archive&quot;, &quot;accounting.data&quot;)</span>

<span class="cp">exec(&quot;archive accounting.data&quot;)</span>


<span class="cp"># @@PLEAC@@_16.4</span>
<span class="cp"># read the output of a program</span>
<span class="cp">IO.popen(&quot;ls&quot;) {|readme|</span>
<span class="cp">    while readme.gets do</span>
<span class="cp">        # ...</span>
<span class="cp">    end</span>
<span class="cp">}</span>
<span class="cp"># or</span>
<span class="cp">readme = IO.popen(&quot;ls&quot;)</span>
<span class="cp">while readme.gets do</span>
<span class="cp">    # ...</span>
<span class="cp">end</span>
<span class="cp">readme.close</span>

<span class="cp"># &quot;write&quot; in a program</span>
<span class="cp">IO.popen(&quot;cmd args&quot;,&quot;w&quot;) {|pipe|</span>
<span class="cp">    pipe.puts(&quot;data&quot;)</span>
<span class="cp">    pipe.puts(&quot;foo&quot;)</span>
<span class="cp">}</span>

<span class="cp"># close wait for the end of the process</span>
<span class="cp">read = IO.popen(&quot;sleep 10000&quot;) # child goes to sleep</span>
<span class="cp">read.close                     # and the parent goes to lala land</span>

<span class="cp">writeme = IO.popen(&quot;cmd args&quot;, &quot;w&quot;)</span>
<span class="cp">writeme.puts &quot;hello&quot; # program will get hello\n on STDIN</span>
<span class="cp">writeme.close        # program will get EOF on STDIN</span>

<span class="cp"># send in a pager (eg less) all output</span>
<span class="cp">$stdout = IO.popen(&quot;/usr/bin/less&quot;,&quot;w&quot;)</span>
<span class="cp">print &quot;huge string\n&quot; * 10000</span>


<span class="cp"># @@PLEAC@@_16.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">def head(lines = 20)</span>
<span class="cp">    pid = open(&quot;|-&quot;,&quot;w&quot;)</span>
<span class="cp">    if pid == nil</span>
<span class="cp">        return</span>
<span class="cp">    else</span>
<span class="cp">        while gets() do</span>
<span class="cp">            pid.print</span>
<span class="cp">            lines -= 1</span>
<span class="cp">            break if lines == 0</span>
<span class="cp">        end</span>
<span class="cp">    end</span>
<span class="cp">    exit</span>
<span class="cp">end</span>

<span class="cp">head(100)</span>
<span class="cp">while gets() do</span>
<span class="cp">    print</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">1: &gt; Welcome to Linux, version 2.0.33 on a i686</span>

<span class="cp">2: &gt; </span>

<span class="cp">3: &gt;     &quot;The software required `Windows 95 or better&#39;, </span>

<span class="cp">4: &gt;      so I installed Linux.&quot;  </span>
<span class="cp">#-----------------------------</span>
<span class="cp">&gt; 1: Welcome to Linux, Kernel version 2.0.33 on a i686</span>

<span class="cp">&gt; 2: </span>

<span class="cp">&gt; 3:     &quot;The software required `Windows 95 or better&#39;, </span>

<span class="cp">&gt; 4:      so I installed Linux.&quot;  </span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># qnumcat - demo additive output filters</span>

<span class="cp">def number()</span>
<span class="cp">    pid = open(&quot;|-&quot;,&quot;w&quot;)</span>
<span class="cp">    if pid == nil</span>
<span class="cp">        return</span>
<span class="cp">    else</span>
<span class="cp">        while gets() do pid.printf(&quot;%d: %s&quot;, $., $_); end</span>
<span class="cp">    end</span>
<span class="cp">    exit</span>
<span class="cp">end</span>

<span class="cp">def quote()</span>
<span class="cp">    pid = open(&quot;|-&quot;,&quot;w&quot;)</span>
<span class="cp">    if pid == nil</span>
<span class="cp">        return</span>
<span class="cp">    else</span>
<span class="cp">        while gets() do pid.print &quot;&gt; #{$_}&quot; end</span>
<span class="cp">    end</span>
<span class="cp">    exit</span>
<span class="cp">end</span>

<span class="cp">number()</span>
<span class="cp">quote()</span>

<span class="cp">while gets() do</span>
<span class="cp">    print</span>
<span class="cp">end</span>
<span class="cp">$stdout.close</span>
<span class="cp">exit</span>


<span class="cp"># @@PLEAC@@_16.6</span>
<span class="cp">ARGV.map! { |arg|</span>
<span class="cp">    arg =~ /\.(gz|Z)$/ ? &quot;|gzip -dc #{arg}&quot; : arg</span>
<span class="cp">}</span>
<span class="cp">for file in ARGV</span>
<span class="cp">    fh = open(file)</span>
<span class="cp">    while fh.gets() do</span>
<span class="cp">        # .......</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">ARGV.map! { |arg|</span>
<span class="cp">    arg =~ %r#^\w+://# ? &quot;|GET #{arg}&quot; : arg   #</span>
<span class="cp">}</span>
<span class="cp">for file in ARGV</span>
<span class="cp">    fh = open(file)</span>
<span class="cp">    while fh.gets() do</span>
<span class="cp">        # .......</span>
<span class="cp">    end</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">pwdinfo = (`domainname` =~ /^(\(none\))?$/) ? &#39;/etc/passwd&#39; : &#39;|ypcat  passwd&#39;;</span>
<span class="cp">pwd = open(pwdinfo);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">puts &quot;File, please? &quot;;</span>
<span class="cp">file = gets().chomp();</span>
<span class="cp">fh = open(file);</span>


<span class="cp"># @@PLEAC@@_16.7</span>
<span class="cp">output = `cmd 2&gt;&amp;1`                            # with backticks</span>
<span class="cp"># or</span>
<span class="cp">ph = open(&quot;|cmd 2&gt;&amp;1&quot;)                         # with an open pipe</span>
<span class="cp">while ph.gets() { }                            # plus a read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">output = `cmd 2&gt;/dev/null`                     # with backticks</span>
<span class="cp"># or</span>
<span class="cp">ph = open(&quot;|cmd 2&gt;/dev/null&quot;)                  # with an open pipe</span>
<span class="cp">while ph.gets() { }                            # plus a read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">output = `cmd 2&gt;&amp;1 1&gt;/dev/null`                # with backticks</span>
<span class="cp"># or</span>
<span class="cp">ph = open(&quot;|cmd 2&gt;&amp;1 1&gt;/dev/null&quot;)             # with an open pipe</span>
<span class="cp">while ph.gets() { }                            # plus a read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`             # with backticks</span>
<span class="cp"># or</span>
<span class="cp">ph = open(&quot;|cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-&quot;)          # with an open pipe</span>
<span class="cp">while ph.gets() { }                            # plus a read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">system(&quot;program args 1&gt;/tmp/program.stdout 2&gt;/tmp/program.stderr&quot;) </span>
<span class="cp">#-----------------------------</span>
<span class="cp">output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`  </span>
<span class="cp">#-----------------------------</span>
<span class="cp">fd3 = fd1 </span>
<span class="cp">fd1 = fd2 </span>
<span class="cp">fd2 = fd3 </span>
<span class="cp">fd3 = undef </span>
<span class="cp">#-----------------------------</span>
<span class="cp">system(&quot;prog args 1&gt;tmpfile 2&gt;&amp;1&quot;) </span>
<span class="cp">system(&quot;prog args 2&gt;&amp;1 1&gt;tmpfile&quot;) </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># system (&quot;prog args 1&gt;tmpfile 2&gt;&amp;1&quot;) </span>
<span class="cp">fd1 = &quot;tmpfile&quot;          # change stdout destination first</span>
<span class="cp">fd2 = fd1                # now point stderr there, too</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># system(&quot;prog args 2&gt;&amp;1 1&gt;tmpfile&quot;) </span>
<span class="cp">fd2 = fd1                # stderr same destination as stdout</span>
<span class="cp">fd1 = &quot;tmpfile&quot;          # but change stdout destination </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># It is often better not to rely on the shell, </span>
<span class="cp"># because of portability, possible security problems </span>
<span class="cp"># and bigger resource usage. So, it is often better to use the open3 library. </span>
<span class="cp"># See below for an example.</span>
<span class="cp"># opening stdin, stdout, stderr</span>
<span class="cp">require &quot;open3&quot;</span>
<span class="cp">stdin, stdout, stderr = Open3.popen(&#39;cmd&#39;)</span>


<span class="cp"># @@PLEAC@@_16.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Contrary to perl, we don&#39;t need to use a module in Ruby</span>
<span class="cp">fh = Kernel.open(&quot;|&quot; + program, &quot;w+&quot;)</span>
<span class="cp">fh.puts &quot;here&#39;s your input\n&quot;</span>
<span class="cp">output = fh.gets()</span>
<span class="cp">fh.close()</span>
<span class="cp">#-----------------------------</span>
<span class="cp">Kernel.open(&quot;|program&quot;),&quot;w+&quot;)    # RIGHT !</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Ruby has already object methods for I/O handles</span>
<span class="cp">#-----------------------------</span>
<span class="cp">begin</span>
<span class="cp">    fh = Kernel.open(&quot;|&quot; + program_and_options, &quot;w+&quot;)</span>
<span class="cp">rescue</span>
<span class="cp">    if ($@ ~= /^open/)</span>
<span class="cp">        $stderr.puts &quot;open failed : #{$!} \n #{$@} \n&quot;</span>
<span class="cp">        break</span>
<span class="cp">    end</span>
<span class="cp">    raise      # reraise unforseen exception</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_16.13</span>
<span class="cp">#% kill -l</span>
<span class="cp">#HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE</span>
<span class="cp">#ALRM TERM CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM</span>
<span class="cp">#PROF WINCH POLL PWR</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ruby -e &#39;puts Signal.list.keys.join(&quot; &quot;)&#39;</span>
<span class="cp">#PWR USR1 BUS USR2 TERM SEGV KILL POLL STOP SYS TRAP IOT HUP INT                                                                          #</span>
<span class="cp">#WINCH XCPU TTIN CLD TSTP FPE IO TTOU PROF CHLD CONT PIPE ABRT</span>
<span class="cp">#VTALRM QUIT ILL XFSZ URG ALRM</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># After that, the perl script create an hash equivalent to Signal.list, </span>
<span class="cp"># and an array. The array can be obtained by :</span>
<span class="cp">signame = []</span>
<span class="cp">Signal.list.each { |name, i| signame[i] = name }</span>


<span class="cp"># @@PLEAC@@_16.14</span>
<span class="cp">Process.kill(9, pid)                    # send $pid a signal 9</span>
<span class="cp">Process.kill(-1, Process.getpgrp())     # send whole job a signal 1</span>
<span class="cp">Process.kill(&quot;USR1&quot;, $$)                # send myself a SIGUSR1</span>
<span class="cp">Process.kill(&quot;HUP&quot;, pid1, pid2, pid3)   # send a SIGHUP to processes in @pids</span>
<span class="cp">#-----------------------------</span>
<span class="cp">begin</span>
<span class="cp">    Process.kill(0, minion)</span>
<span class="cp">    puts &quot;#{minion} is alive!&quot;</span>
<span class="cp">rescue Errno::EPERM                     # changed uid</span>
<span class="cp">    puts &quot;#{minion} has escaped my control!&quot;;</span>
<span class="cp">rescue Errno::ESRCH</span>
<span class="cp">    puts &quot;#{minion} is deceased.&quot;;      # or zombied</span>
<span class="cp">rescue</span>
<span class="cp">    puts &quot;Odd; I couldn&#39;t check the status of #{minion} : #{$!}&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_16.15</span>
<span class="cp">Kernel.trap(&quot;QUIT&quot;, got_sig_quit)       # got_sig_quit = Proc.new { puts &quot;Quit\n&quot; }</span>
<span class="cp">trap(&quot;PIPE&quot;, &quot;got_sig_quit&quot;)            # def got_sig_pipe ...</span>
<span class="cp">trap(&quot;INT&quot;) { ouch++ }                  # increment ouch for every SIGINT</span>
<span class="cp">#-----------------------------</span>
<span class="cp">trap(&quot;INT&quot;, &quot;IGNORE&quot;)                   # ignore the signal INT</span>
<span class="cp">#-----------------------------</span>
<span class="cp">trap(&quot;STOP&quot;, &quot;DEFAULT&quot;)                 # restore default STOP signal handling</span>


<span class="cp"># @@PLEAC@@_16.16</span>
<span class="cp"># the signal handler</span>
<span class="cp">def ding</span>
<span class="cp">    trap(&quot;INT&quot;, &quot;ding&quot;)</span>
<span class="cp">    puts &quot;\aEnter your name!&quot;</span>
<span class="cp">end</span>

<span class="cp"># prompt for name, overriding SIGINT</span>
<span class="cp">def get_name</span>
<span class="cp">    save = trap(&quot;INT&quot;, &quot;ding&quot;)</span>

<span class="cp">    puts &quot;Kindly Stranger, please enter your name: &quot;</span>
<span class="cp">    name = gets().chomp()</span>
<span class="cp">    trap(&quot;INT&quot;, save)</span>
<span class="cp">    name</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_16.21</span>
<span class="cp"># implemented thanks to http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/1760</span>
<span class="cp">require &#39;timeout&#39;</span>

<span class="cp"># we&#39;ll do something vastly more useful than cookbook to demonstrate timeouts</span>
<span class="cp">begin</span>
<span class="cp">    timeout(5) {</span>
<span class="cp">        waitsec = rand(10)</span>
<span class="cp">        puts &quot;Let&#39;s see if a sleep of #{waitsec} seconds is longer than 5 seconds...&quot;</span>
<span class="cp">        system(&quot;sleep #{waitsec}&quot;)</span>
<span class="cp">    }</span>
<span class="cp">    puts &quot;Timeout didn&#39;t occur&quot;</span>
<span class="cp">rescue Timeout::Error    </span>
<span class="cp">    puts &quot;Timed out!&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_17.1</span>
<span class="cp"># A basic TCP client connection</span>
<span class="cp">require &#39;socket&#39;</span>
<span class="cp">begin</span>
<span class="cp">    t = TCPSocket.new(&#39;www.ruby-lang.org&#39;, &#39;www&#39;)</span>
<span class="cp">rescue</span>
<span class="cp">    puts &quot;error: #{$!}&quot;</span>
<span class="cp">else</span>
<span class="cp">    # ... do something with the socket</span>
<span class="cp">    t.print &quot;GET / HTTP/1.0\n\n&quot;</span>
<span class="cp">    answer = t.gets(nil)</span>
<span class="cp">    # and terminate the connection when we&#39;re done</span>
<span class="cp">    t.close</span>
<span class="cp">end</span>

<span class="cp"># Using the evil low level socket API</span>
<span class="cp">require &#39;socket&#39;</span>
<span class="cp"># create a socket</span>
<span class="cp">s = Socket.new(Socket::AF_INET, Socket::SOCK_STREAM, 0)</span>
<span class="cp"># build the address of the remote machine</span>
<span class="cp">sockaddr_server = [Socket::AF_INET, 80,</span>
<span class="cp">    Socket.gethostbyname(&#39;www.ruby-lang.org&#39;)[3],</span>
<span class="cp">    0, 0].pack(&quot;snA4NN&quot;)</span>
<span class="cp"># connect</span>
<span class="cp">begin</span>
<span class="cp">    s.connect(sockaddr_server)</span>
<span class="cp">rescue</span>
<span class="cp">    puts &quot;error: #{$!}&quot;</span>
<span class="cp">else</span>
<span class="cp">    # ... do something with the socket</span>
<span class="cp">    s.print &quot;GET / HTTP/1.0\n\n&quot;</span>
<span class="cp">    # and terminate the connection when we&#39;re done</span>
<span class="cp">    s.close</span>
<span class="cp">end</span>

<span class="cp"># TCP connection with management of error (DNS)</span>
<span class="cp">require &#39;socket&#39;</span>
<span class="cp">begin</span>
<span class="cp">    client = TCPSocket.new(&#39;does not exists&#39;, &#39;www&#39;)</span>
<span class="cp">rescue</span>
<span class="cp">    puts &quot;error: #{$!}&quot;</span>
<span class="cp">end</span>

<span class="cp"># TCP connection with a time out</span>
<span class="cp">require &#39;socket&#39;</span>
<span class="cp">require &#39;timeout&#39;</span>
<span class="cp">begin</span>
<span class="cp">    timeout(1) do #the server has one second to answer</span>
<span class="cp">        client = TCPSocket.new(&#39;www.host.com&#39;, &#39;www&#39;)</span>
<span class="cp">    end</span>
<span class="cp">rescue</span>
<span class="cp">    puts &quot;error: #{$!}&quot;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_17.12</span>
<span class="cp">require &#39;socket&#39;</span>

<span class="cp">class Preforker </span>
<span class="cp">    attr_reader (:child_count)</span>
<span class="cp">    </span>
<span class="cp">    def initialize(prefork, max_clients_per_child, port, client_handler)</span>
<span class="cp">        @prefork = prefork</span>
<span class="cp">        @max_clients_per_child = max_clients_per_child</span>
<span class="cp">        @port = port</span>
<span class="cp">        @child_count = 0</span>
<span class="cp">        </span>
<span class="cp">        @reaper = proc {</span>
<span class="cp">            trap(&#39;CHLD&#39;, @reaper)</span>
<span class="cp">            pid = Process.wait</span>
<span class="cp">            @child_count -= 1</span>
<span class="cp">        }</span>
<span class="cp">        </span>
<span class="cp">        @huntsman = proc {</span>
<span class="cp">            trap(&#39;CHLD&#39;, &#39;IGNORE&#39;)</span>
<span class="cp">            trap(&#39;INT&#39;, &#39;IGNORE&#39;)</span>
<span class="cp">            Process.kill(&#39;INT&#39;, 0)</span>
<span class="cp">            exit</span>
<span class="cp">        }</span>
<span class="cp">        </span>
<span class="cp">        @client_handler=client_handler</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def child_handler</span>
<span class="cp">        trap(&#39;INT&#39;, &#39;EXIT&#39;)</span>
<span class="cp">        @client_handler.setUp</span>
<span class="cp">        # wish: sigprocmask UNblock SIGINT</span>
<span class="cp">        @max_clients_per_child.times {</span>
<span class="cp">            client = @server.accept or break</span>
<span class="cp">            @client_handler.handle_request(client)</span>
<span class="cp">            client.close</span>
<span class="cp">        }</span>
<span class="cp">        @client_handler.tearDown</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def make_new_child</span>
<span class="cp">        # wish: sigprocmask block SIGINT</span>
<span class="cp">        @child_count += 1</span>
<span class="cp">        pid = fork do</span>
<span class="cp">            child_handler</span>
<span class="cp">        end</span>
<span class="cp">        # wish: sigprocmask UNblock SIGINT</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def run</span>
<span class="cp">        @server = TCPserver.open(@port)</span>
<span class="cp">        trap(&#39;CHLD&#39;, @reaper)</span>
<span class="cp">        trap(&#39;INT&#39;, @huntsman)</span>
<span class="cp">        loop {</span>
<span class="cp">            (@prefork - @child_count).times { |i|</span>
<span class="cp">                make_new_child</span>
<span class="cp">            }</span>
<span class="cp">            sleep .1</span>
<span class="cp">        }</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/ruby</span>

<span class="cp">require &#39;Preforker&#39;</span>

<span class="cp">class ClientHandler</span>
<span class="cp">    def setUp</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def tearDown</span>
<span class="cp">    end</span>
<span class="cp">    </span>
<span class="cp">    def handle_request(client)</span>
<span class="cp">        # do stuff</span>
<span class="cp">    end</span>
<span class="cp">end</span>

<span class="cp">server = Preforker.new(1, 100, 3102, ClientHandler.new)</span>
<span class="cp">server.run</span>


<span class="cp"># @@PLEAC@@_18.2</span>
<span class="cp">require &#39;net/ftp&#39;</span>

<span class="cp">begin</span>
<span class="cp">    ftp = Net::FTP::new(&quot;ftp.host.com&quot;)</span>
<span class="cp">    ftp.login(username,password)</span>
<span class="cp">    ftp.chdir(directory)</span>
<span class="cp">    ftp.get(filename)</span>
<span class="cp">    ftp.put(filename)</span>
<span class="cp">rescue Net::FTPError</span>
<span class="cp">    $stderr.print &quot;FTP failed: &quot; + $!</span>
<span class="cp">ensure</span>
<span class="cp">    ftp.close() if ftp</span>
<span class="cp">end</span>

<span class="cp"># A better solution for a local use could be :</span>
<span class="cp">Net::FTP::new(&quot;ftp.host.com&quot;) do |ftp|</span>
<span class="cp">    ftp.login(username,password)</span>
<span class="cp">    ftp.chdir(directory)</span>
<span class="cp">    ftp.get(filename)</span>
<span class="cp">    ftp.put(filename)</span>
<span class="cp">end</span>

<span class="cp"># If you have only one file to get, there is a simple solution :</span>
<span class="cp">require &#39;open-uri&#39;</span>
<span class="cp">open(&quot;ftp://www.ruby-lang.org/path/filename&quot;) do |fh|</span>
<span class="cp">    # read from filehandle fh</span>
<span class="cp">end </span>
<span class="cp">#--------------------------------------------</span>
<span class="cp"># to wait a defined time for the connection, </span>
<span class="cp"># use the timeout module</span>
<span class="cp">require &#39;timeout&#39;</span>
<span class="cp">begin </span>
<span class="cp">    timeout(30){</span>
<span class="cp">        ftp = Net::FTP::new(&quot;ftp.host.com&quot;)</span>
<span class="cp">        ftp.debug_mode = true</span>
<span class="cp">    }</span>
<span class="cp">rescue Net::FTPError</span>
<span class="cp">    $stderr.puts &quot;Couldn&#39;t connect.&quot;</span>
<span class="cp">rescue Timeout::Error</span>
<span class="cp">    $stderr.puts &quot;Timeout while connecting to server.&quot;</span>
<span class="cp">end</span>

<span class="cp">begin</span>
<span class="cp">    ftp.login()</span>
<span class="cp">rescue Net::FTPError</span>
<span class="cp">    $stderr.print &quot;Couldn&#39;t authentificate.\n&quot;</span>
<span class="cp">end</span>

<span class="cp">begin</span>
<span class="cp">    ftp.login(username)</span>
<span class="cp">rescue Net::FTPError</span>
<span class="cp">    $stderr.print &quot;Still couldn&#39;t authenticate.\n&quot;</span>
<span class="cp">end</span>

<span class="cp">begin</span>
<span class="cp">    ftp.login(username, password)</span>
<span class="cp">rescue Net::FTPError</span>
<span class="cp">    $stderr.print &quot;Couldn&#39;t authenticate, even with explicit</span>
<span class="cp">    username and password.\n&quot;</span>
<span class="cp">end</span>

<span class="cp">begin</span>
<span class="cp">    ftp.login(username, password, account)</span>
<span class="cp">rescue Net::FTPError</span>
<span class="cp">    $stderr.print &quot;No dice. It hates me.\n&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">ftp.put(localfile, remotefile)</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Sending data from STDIN is not directly supported </span>
<span class="cp"># by the ftp library module. A possible way to do it is to use the </span>
<span class="cp"># storlines method directly to send raw commands to the ftp server.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">ftp.get(remotefile, localfile)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">ftp.get(remotefile) { |data| puts data }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">ftp.chdir(&quot;/pub/ruby&quot;) </span>
<span class="cp">print &quot;I&#39;m in the directory &quot;, ftp.pwd(), &quot;\n&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">ftp.mkdir(&quot;/pub/ruby/new_dir&quot;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">lines = ftp.ls(&quot;/pub/ruby/&quot;)</span>
<span class="cp"># =&gt; [&quot;drwxr-xr-x 2 matz users 4096 July 17 1998 1.0&quot;, ... ]</span>

<span class="cp">latest = ftp.dir(&quot;/pub/ruby/*.tgz&quot;).sort.last</span>

<span class="cp">ftp.nlst(&quot;/pub/ruby&quot;)</span>
<span class="cp"># =&gt; [&quot;/pub/ruby/1.0&quot;, ... ]</span>
<span class="cp">#-----------------------------</span>
<span class="cp">ftp.quit()</span>


<span class="cp"># @@PLEAC@@_18.6</span>
<span class="cp">require &#39;net/telnet&#39;</span>
<span class="cp">t = Net::Telnet::new( &quot;Timeout&quot; =&gt; 10,</span>
<span class="cp">                      &quot;Prompt&quot;  =&gt; /%/,</span>
<span class="cp">                      &quot;Host&quot;    =&gt; host )</span>
<span class="cp">t.login(username, password)</span>
<span class="cp">files = t.cmd(&quot;ls&quot;)</span>
<span class="cp">t.print(&quot;top&quot;)</span>
<span class="cp">process_string = t.waitfor(/\d+ processes/)</span>
<span class="cp">t.close</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/[$%#&gt;] \z/n</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># In case of an error, the telnet module throws an exception.</span>
<span class="cp"># For control of the behavior in case of an error,</span>
<span class="cp"># you just need to catch the exceptions and do your custom</span>
<span class="cp"># error handling.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">begin</span>
<span class="cp">    telnet.login(username, password)</span>
<span class="cp">rescue TimeoutError</span>
<span class="cp">    fail &quot;Login failed !\n&quot;</span>
<span class="cp">end</span>
<span class="cp">#-----------------------------</span>
<span class="cp">telnet.waitfor(&#39;/--more--/&#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">telnet.waitfor(String =&gt; &#39;greasy smoke&#39;, Timeout =&gt; 30)</span>


<span class="cp"># @@PLEAC@@_18.7</span>
<span class="cp">require &#39;ping&#39;</span>

<span class="cp">puts &quot;#{host} is alive.\n&quot; if Ping.pingecho(host);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># the ping module only use TCP ping, not ICMP even if we are root</span>
<span class="cp">if Ping.pingecho(&quot;kingkong.com&quot;)</span>
<span class="cp">    puts &quot;The giant ape lives!\n&quot;;</span>
<span class="cp">else</span>
<span class="cp">    puts &quot;All hail mighty Gamera, friend of children!\n&quot;;</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_19.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># http://www.perl.com/CPAN/</span>
<span class="cp"># http://www.perl.com:8001/bad/mojo.html</span>
<span class="cp"># ftp://gatekeeper.dec.com/pub/misc/netlib.tar.Z</span>
<span class="cp"># ftp://anonymous@myplace:gatekeeper.dec.com/pub/misc/netlib.tar.Z</span>
<span class="cp"># file:///etc/motd</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># http://mox.perl.com/cgi-bin/program?name=Johann&amp;born=1685</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># http://mox.perl.com/cgi-bin/program</span>
<span class="cp">#-----------------------------</span>


<span class="cp"># @@PLEAC@@_19.1</span>
<span class="cp">#!/usr/local/bin/ruby -w</span>
<span class="cp"># hiweb - load CGI class to decode information given by web server</span>

<span class="cp">require &#39;cgi&#39;</span>

<span class="cp">cgi = CGI.new(&#39;html3&#39;)</span>

<span class="cp"># get a parameter from a form</span>
<span class="cp">value = cgi.params[&#39;PARAM_NAME&#39;][0]</span>

<span class="cp"># output a document</span>
<span class="cp">cgi.out {</span>
<span class="cp">    cgi.html {</span>
<span class="cp">        cgi.head { cgi.title { &quot;Howdy there!&quot; } } +</span>
<span class="cp">            cgi.body { cgi.p { &quot;You typed: &quot; + cgi.tt {</span>
<span class="cp">                    CGI.escapeHTML(value) } } }</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">require &#39;cgi&#39;</span>
<span class="cp">cgi = CGI.new</span>
<span class="cp">who   = cgi.param[&quot;Name&quot;][0]     # first param in list</span>
<span class="cp">phone = cgi.param[&quot;Number&quot;][0]</span>
<span class="cp">picks = cgi.param[&quot;Choices&quot;]     # complete list</span>

<span class="cp">print cgi.header( &#39;type&#39; =&gt; &#39;text/plain&#39;,</span>
<span class="cp">                  &#39;expires&#39; =&gt; Time.now + (3 * 24 * 60 * 60) )</span>


<span class="cp"># @@PLEAC@@_19.3</span>
<span class="cp">#!/usr/local/bin/ruby -w</span>
<span class="cp"># webwhoami - show web user&#39;s id</span>
<span class="cp">require &#39;etc&#39;</span>
<span class="cp">print &quot;Content-Type: text/plain\n\n&quot;</span>
<span class="cp">print &quot;Running as &quot; + Etc.getpwuid.name + &quot;\n&quot;</span>

<span class="cp"># % ruby -wc cgi-script     # just check syntax</span>

<span class="cp"># % ruby -w  cgi-script     # params from stdin</span>
<span class="cp"># (offline mode: enter name=value pairs on standard input)</span>
<span class="cp"># name=joe</span>
<span class="cp"># number=10</span>
<span class="cp"># ^D</span>

<span class="cp"># % ruby -w  cgi-script name=joe number=10     # run with mock form input</span>
<span class="cp"># % ruby -d  cgi-script name=joe number=10     # ditto, under the debugger</span>

<span class="cp"># POST method script in csh</span>
<span class="cp"># % (setenv HTTP_METHOD POST; ruby -w cgi-script name=joe number=10)</span>
<span class="cp"># POST method script in sh</span>
<span class="cp"># % HTTP_METHOD=POST perl -w cgi-script name=joe number=10</span>


<span class="cp"># @@PLEAC@@_19.4</span>
<span class="cp"># ruby has several security levels, the level &quot;1&quot; is similar to perls taint mode.</span>
<span class="cp"># It can be switched on by providing the -T command line parameter</span>
<span class="cp"># or by setting $SAFE to 1. Setting $SAFE to 2,3 or 4 restricts possible</span>
<span class="cp"># harmful operations further.</span>

<span class="cp">#!/usr/bin/ruby -T</span>
<span class="cp">$SAFE = 1</span>
<span class="cp">File.open(ARGV[0], &quot;w&quot;)</span>
<span class="cp"># ruby warns with:</span>
<span class="cp"># taint1.rb:2:in `initialize&#39;: Insecure operation - initialize (SecurityError)</span>

<span class="cp">$SAFE = 1</span>
<span class="cp">file = ARGV[0]</span>
<span class="cp">unless /^([\w.-]+)$/.match(file)</span>
<span class="cp">    raise &quot;filename #{file} has invalid characters&quot;</span>
<span class="cp">end</span>
<span class="cp">file = $1</span>
<span class="cp"># In ruby, even the back reference from a regular expression stays tainted.</span>
<span class="cp"># you need to explicitly untaint the variable:</span>
<span class="cp">file.untaint</span>
<span class="cp">File.open(file, &quot;w&quot;)</span>

<span class="cp"># Race condition exists like in perl:</span>
<span class="cp">unless File.exists(filename)        # Wrong because of race condition</span>
<span class="cp">    File.open(filename, &quot;w&quot;)</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_19.8</span>
<span class="cp">url = &quot;http://pleac.sourceforge.net/pleac_ruby/&quot;</span>
<span class="cp">print &quot;Location: #{url}\r\n\r\n&quot;</span>
<span class="cp">exit</span>

<span class="cp">#!/usr/bin/ruby</span>
<span class="cp">require &#39;cgi&#39;</span>

<span class="cp">cgi = CGI.new</span>
<span class="cp">oreo = CGI::Cookie.new(&#39;name&#39; =&gt; &#39;filling&#39;,</span>
<span class="cp">                       &#39;value&#39; =&gt; &#39;vanilla creme&#39;,</span>
<span class="cp">                       &#39;expires&#39; =&gt; Time.now + (3 * 30 * 24 * 60 * 60),</span>
<span class="cp">                       &#39;domain&#39; =&gt; &#39;.pleac.sourceforge.net&#39;)</span>

<span class="cp">whither = &#39;http://pleac.sourceforge.net/pleac_ruby/cgiprogramming.html&#39;</span>

<span class="cp">cgi.out(&#39;cookie&#39; =&gt; oreo,</span>
<span class="cp">        &#39;Location&#39; =&gt; whither){&quot;&quot;}</span>

<span class="cp">#!/usr/bin/ruby</span>
<span class="cp"># os_snipe - redirect to a Jargon File entry about current OS</span>
<span class="cp">dir = &#39;http://www.elsewhere.org/jargon/html/entry&#39;</span>

<span class="cp">agent = ENV[&#39;HTTP_USER_AGENT&#39;]</span>

<span class="cp">page = case</span>
<span class="cp">    when agent =~ /Mac/: &#39;Macintrash.html&#39;</span>
<span class="cp">    when agent =~ /Win(dows )?NT/: &#39;evil_and_rude.html&#39;</span>
<span class="cp">    when agent =~ /Win|MSIE|WebTV/: &#39;Microsloth_Windows.html&#39;</span>
<span class="cp">    when agent =~ /Linux/: &#39;Linux.html&#39;</span>
<span class="cp">    when agent =~ /HP-UX/: &#39;HP-SUX.html&#39;</span>
<span class="cp">    when agent =~ /SunOS/: &#39;ScumOS.html&#39;</span>
<span class="cp">    else &#39;Appendix_B.html&#39;</span>
<span class="cp">end</span>

<span class="cp">print &quot;Location: #{dir}/#{page}\n\n&quot;</span>

<span class="cp">require &#39;cgi&#39;</span>
<span class="cp">cgi = CGI.new</span>
<span class="cp">cgi.out(&#39;status&#39; =&gt; &#39;204 No response&#39;){&quot;&quot;}</span>
<span class="cp"># this produces:</span>
<span class="cp"># Status: 204 No response</span>
<span class="cp"># Content-Type: text/html</span>
<span class="cp"># Content-Length: 0</span>
<span class="cp"># &lt;blank line here&gt;</span>


<span class="cp"># @@PLEAC@@_19.10</span>
<span class="cp">preference_value = cgi.cookies[&quot;preference name&quot;][0]</span>

<span class="cp">packed_cookie = CGI::Cookie.new(&quot;name&quot; =&gt; &quot;preference name&quot;,</span>
<span class="cp">                                &quot;value&quot; =&gt; &quot;whatever you&#39;d like&quot;,</span>
<span class="cp">                                &quot;expires&quot; =&gt; Time.local(Time.now.year + 2,</span>
<span class="cp">    Time.now.mon, Time.now.day, Time.now.hour, Time.now.min, Time.now.sec) )</span>

<span class="cp">cgi.header(&quot;cookie&quot; =&gt; [packed_cookie])</span>

<span class="cp">#!/usr/local/bin/ruby -w</span>
<span class="cp"># ic_cookies - sample CGI script that uses a cookie</span>
<span class="cp">require &#39;cgi&#39;</span>

<span class="cp">cgi = CGI.new(&#39;html3&#39;)</span>

<span class="cp">cookname = &quot;favorite ice cream&quot;</span>
<span class="cp">favorite = cgi.params[&quot;flavor&quot;][0]</span>
<span class="cp">tasty    = cgi.cookies[cookname][0] || &#39;mint&#39;</span>

<span class="cp">unless favorite</span>
<span class="cp">    cgi.out {</span>
<span class="cp">        cgi.html {</span>
<span class="cp">            cgi.head { cgi.title { &quot;Ice Cookies&quot; } } +</span>
<span class="cp">            cgi.body {</span>
<span class="cp">                cgi.h1 { &quot;Hello Ice Cream&quot; } +</span>
<span class="cp">                cgi.hr +</span>
<span class="cp">                cgi.form {</span>
<span class="cp">                    cgi.p { &quot;Please select a flavor: &quot; +</span>
<span class="cp">                            cgi.text_field(&quot;flavor&quot;, tasty ) }</span>
<span class="cp">                } +</span>
<span class="cp">                cgi.hr</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">else</span>
<span class="cp">    cookie = CGI::Cookie.new( &quot;name&quot;    =&gt; cookname,</span>
<span class="cp">                              &quot;value&quot;   =&gt; favorite,</span>
<span class="cp">                              &quot;expires&quot; =&gt; Time.local(Time.now.year + 2,</span>
<span class="cp">Time.now.mon, Time.now.day, Time.now.hour, Time.now.min, Time.now.sec) )</span>
<span class="cp">    cgi.out(&quot;cookie&quot; =&gt; [cookie]) {</span>
<span class="cp">        cgi.html {</span>
<span class="cp">            cgi.head { cgi.title { &quot;Ice Cookies&quot; } } +</span>
<span class="cp">            cgi.body {</span>
<span class="cp">                cgi.h1 { &quot;Hello Ice Cream&quot; } +</span>
<span class="cp">                cgi.p { &quot;You chose as your favorite flavor `#{favorite}&#39;.&quot; }</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">end</span>


<span class="cp"># @@PLEAC@@_20.9</span>
<span class="cp">def templatefile(filename, fillings)</span>
<span class="cp">    aFile = File.new(filename, &quot;r&quot;)</span>
<span class="cp">    text = aFile.read()</span>
<span class="cp">    aFile.close()</span>
<span class="cp">    pattern = Regexp.new(&#39;%%(.*?)%%&#39;)</span>
<span class="cp">    text.gsub!(pattern) {</span>
<span class="cp">        fillings[$1] || &quot;&quot;</span>
<span class="cp">    }</span>
<span class="cp">    text</span>
<span class="cp">end</span>

<span class="cp">fields = {</span>
<span class="cp">    &#39;username&#39; =&gt; whats_his_name,</span>
<span class="cp">    &#39;count&#39; =&gt; login_count,</span>
<span class="cp">    &#39;total&#39; =&gt; minutes_used</span>
<span class="cp">}</span>
<span class="cp">puts templatefile(&#39;simple.template&#39;, fields)</span>

<span class="cp"># @@INCOMPLETE@@</span>
<span class="cp"># An example using databases is missing</span>
</pre></div>
</body>
</html>
