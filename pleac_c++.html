<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=latin1">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span class="c1">// -*- c++ -*-</span>

<span class="c1">// @@PLEAC@@_NAME</span>
<span class="c1">// @@SKIP@@ C++/STL/Boost</span>


<span class="c1">// @@PLEAC@@_WEB</span>
<span class="c1">// @@SKIP@@ http://www.research.att.com/~bs/C++.html</span>
<span class="c1">// @@SKIP@@ http://www.boost.org/</span>


<span class="c1">// @@PLEAC@@_1.0</span>
<span class="c1">// NOTE: Whilst it is perfectly valid to use Standard C Library, or GNU</span>
<span class="c1">// C Library, routines in C++ programs, the code examples here will, as</span>
<span class="c1">// far as possible, avoid doing so, instead using C++-specific functionality</span>
<span class="c1">// and idioms. In general:</span>
<span class="c1">// * I/O will be iostream-based [i.e. no &#39;scanf&#39;, &#39;printf&#39;, &#39;fgets&#39; etc]</span>
<span class="c1">// * Container / iterator idioms based on the Standard Template Library [STL]</span>
<span class="c1">//   will replace the built-in array / raw pointer idioms typically used in C</span>
<span class="c1">// * Boost Library functionality utilised wherever possible [the reason for</span>
<span class="c1">//   this is that much of this functionality is likely to appear in the next</span>
<span class="c1">//   C++ standard]</span>
<span class="c1">// * Error detection/handling will generally be exception-based [this is done</span>
<span class="c1">//   to keep examples simple. Exception use is optional in C++, and is not as</span>
<span class="c1">//   pervasive as it is in other languages like Java or C#]</span>
<span class="c1">// C-based solution(s) to problem(s) will be found in the corresponding section</span>
<span class="c1">// of PLEAC-C/Posix/GNU.</span>
 
<span class="c1">// In C++, one can use the builtin &#39;char *&#39; type or the &#39;string&#39; type</span>
<span class="c1">// to represent strings.  In this section, we will work with the C++</span>
<span class="c1">// library &#39;string&#39; class.</span>

<span class="c1">// Characteristics of &#39;string&#39; types:</span>
<span class="c1">// - may be of any length</span>
<span class="c1">// - are defined within the std namespace</span>
<span class="c1">// - can be converted to a &#39;const char *&#39; using std::string::c_str()</span>
<span class="c1">// - can be subscripted to access individual characters (e.g., str[3]</span>
<span class="c1">//   returns the 4th character of the string</span>
<span class="c1">// - memory associated with strings is reclaimed automatically as strings</span>
<span class="c1">//   go out of scope</span>
<span class="c1">// - strings cannot be used as true/false values (i.e., the following is not</span>
<span class="c1">//   allowed:  string s; if (s) {})</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Before using strings, you must include the &lt;string&gt; header file</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// To create a literal strings, you must use double quotes (&quot;).  You cannot</span>
<span class="c1">// use single quotes. </span>

<span class="c1">//-----------------------------</span>
<span class="c1">// String variables must be declared -- if no value is given it&#39;s</span>
<span class="c1">// value is the empty string (&quot;&quot;). </span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// To insert special characters, quote the character with \</span>
<span class="c1">std::string s1 = &quot;\\n&quot;;                     // Two characters, \ and n</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&quot;Jon </span><span class="se">\&quot;</span><span class="s">Maddog</span><span class="se">\&quot;</span><span class="s"> Orwant&quot;</span><span class="p">;</span>   <span class="c1">// Literal double quotes</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Strings can be declared in one of two ways</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;assignment syntax&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span><span class="p">(</span><span class="s">&quot;constructor syntax&quot;</span><span class="p">);</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Multi-line strings.</span>
<span class="c1">// There is no equivalent to perl&#39;s &quot;here&quot; documents in c++</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;</span>
<span class="n">This</span> <span class="n">is</span> <span class="n">a</span> <span class="n">multiline</span> <span class="n">string</span> <span class="n">started</span> <span class="n">and</span> <span class="n">finished</span> <span class="n">with</span> <span class="kt">double</span> 
<span class="n">quotes</span> <span class="n">that</span> <span class="n">spans</span> <span class="mi">4</span> <span class="n">lines</span> <span class="p">(</span><span class="n">it</span> <span class="n">contains</span> <span class="mi">3</span> <span class="n">newline</span> <span class="n">characters</span><span class="p">).</span>
<span class="s">&quot;;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&quot;This is a multiline string started and finished with double </span>
<span class="n">quotes</span> <span class="n">that</span> <span class="n">spans</span> <span class="mi">2</span> <span class="n">lines</span> <span class="p">(</span><span class="n">it</span> <span class="n">contains</span> <span class="mi">1</span> <span class="n">newline</span> <span class="n">character</span><span class="p">).</span><span class="s">&quot;;</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.1</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;some string&quot;</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value1</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>  
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value2</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>

<span class="c1">// Unlike perl, the substr function returns a copy of the substring</span>
<span class="c1">// rather than a reference to the existing substring, thus using substr</span>
<span class="c1">// on the left hand side of an assignment statement will not modify </span>
<span class="c1">// the original string.  To get this functionality, you can use the</span>
<span class="c1">// std::string::replace function.</span>

<span class="c1">// Using offsets and lengths</span>
<span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">newstring</span><span class="p">);</span>  
<span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="n">newtail</span><span class="p">);</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// The C++ string class doesn&#39;t have anything equivalent to perl&#39;s unpack.</span>
<span class="c1">// Instead, one can use C structures to import/export binary data</span>

<span class="c1">//-----------------------------</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;This is what you have&quot;</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first</span>  <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>          <span class="c1">// &quot;T&quot;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">second</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>          <span class="c1">// &quot;is&quot;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rest</span>   <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>            <span class="c1">// &quot;you have&quot;</span>

<span class="c1">// C++ strings do not support backwards indexing as perl does but </span>
<span class="c1">// you can fake it out by subtracting the negative index from the</span>
<span class="c1">// string length</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">last</span>   <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">// &quot;e&quot;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">end</span>    <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>    <span class="c1">// &quot;have&quot;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">piece</span>  <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// &quot;you&quot;</span>

<span class="c1">//-----------------------------</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>

<span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&quot;This is what you have&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 
<span class="c1">// This is what you have</span>

<span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;wasn&#39;t&quot;</span><span class="p">);</span>                <span class="c1">// change &quot;is to &quot;wasn&#39;t&quot;</span>
<span class="c1">// This wasn&#39;t what you have</span>

<span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="s">&quot;ondrous&quot;</span><span class="p">);</span> <span class="c1">// &quot;This wasn&#39;t wondrous&quot;</span>
<span class="c1">// This wasn&#39;t wonderous</span>

<span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>                    <span class="c1">// delete first character</span>
<span class="c1">// his wasn&#39;t wondrous</span>

<span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>        <span class="c1">// delete last 10 characters</span>
<span class="c1">// his wasn&#39;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// C++ does not have built-in support for the perl s///, m//, and tr/// </span>
<span class="c1">// operators; however, similar results can be achieved in at least </span>
<span class="c1">// two ways:</span>
<span class="c1">// - string operations such as string::find, string::rfind, etc.</span>
<span class="c1">// - the boost regular expression library (regex++) supports perl</span>
<span class="c1">//   regular expression syntax.</span>
<span class="c1">// TODO:  Add examples of each.</span>

<span class="c1">// MISSING: if (substr($string, -10) =~ /pattern/) {</span>
<span class="c1">//            print &quot;Pattern matches in last 10 characters\n&quot;;</span>
<span class="c1">//          }</span>

<span class="c1">// MISSING: substr($string, 0, 5) =~ s/is/at/g;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// exchange the first and last letters in a string using substr and replace</span>
<span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;make a hat&quot;</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="n">a</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
<span class="n">a</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>

<span class="c1">// exchange the first and last letters in a string using indexing and swap</span>
<span class="cp">#include &lt;algorithm&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.2</span>
<span class="c1">//-----------------------------</span>
<span class="c1">// C++ doesn&#39;t have functionality equivalent to the || and ||=.  </span>
<span class="c1">// If statements and trigraphs can be used instead.</span>
<span class="c1">//-----------------------------</span>
<span class="c1">// C++ doesn&#39;t have anything equivalent &quot;defined&quot;.  C++ variables</span>
<span class="c1">// cannot be used at all if they have not previously been defined.</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Use b if b is not empty, else c</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">b</span> <span class="o">:</span> <span class="n">c</span><span class="p">;</span>  

<span class="c1">// Set x to y unless x is not empty</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">bar</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span> <span class="o">?</span> <span class="n">bar</span> <span class="o">:</span> <span class="s">&quot;DEFAULT VALUE&quot;</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// NOTE: argv is declared as char *argv[] in C/C++.  We assume</span>
<span class="c1">// the following code surrounds the following examples that deal</span>
<span class="c1">// with argv.  Also, arguments to a program start at argv[1] -- argv[0]</span>
<span class="c1">// is the name of the executable that&#39;s running.</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">**</span><span class="n">args</span> <span class="o">=</span> <span class="n">argv</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// +1 skips argv[0], the name of the executable</span>
   <span class="c1">// examples</span>
<span class="p">}</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">dir</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">?</span> <span class="o">*</span><span class="n">argv</span><span class="o">++</span> <span class="o">:</span> <span class="s">&quot;/tmp&quot;</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;/tmp&quot;</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">argc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;/tmp&quot;</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="cp">#include &lt;map&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span><span class="p">;</span>

<span class="n">count</span><span class="p">[</span><span class="n">shell</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">shell</span> <span class="o">:</span> <span class="s">&quot;/bin/sh&quot;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> 

<span class="c1">//-----------------------------</span>
<span class="c1">// find the user name on Unix systems</span>
<span class="c1">// TODO:  Simplify.  This is too ugly and complex</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;pwd.h&gt;</span>
<span class="cp">#include &quot;boost/lexical_cast.hpp&quot;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">user</span><span class="p">;</span>
<span class="kt">char</span>       <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">passwd</span>     <span class="o">*</span><span class="n">pwd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&quot;USER&quot;</span><span class="p">))</span>    <span class="o">||</span>
     <span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&quot;LOGNAME&quot;</span><span class="p">))</span> <span class="o">||</span>
     <span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="n">getlogin</span><span class="p">())</span>        <span class="p">)</span>
  <span class="n">user</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pwd</span> <span class="o">=</span> <span class="n">getpwuid</span><span class="p">(</span><span class="n">getuid</span><span class="p">()))</span>
  <span class="n">user</span> <span class="o">=</span> <span class="n">pwd</span><span class="o">-&gt;</span><span class="n">pw_name</span><span class="p">;</span>
<span class="k">else</span>
  <span class="n">user</span> <span class="o">=</span> <span class="s">&quot;Unknown uid number &quot;</span> <span class="o">+</span> <span class="n">boost</span><span class="o">::</span><span class="n">lexical_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">getuid</span><span class="p">());</span>

<span class="c1">//-----------------------------</span>
<span class="k">if</span> <span class="p">(</span><span class="n">starting_point</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span> <span class="n">starting_point</span> <span class="o">=</span> <span class="s">&quot;Greenwich&quot;</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Example using list.  Other C++ STL containers work similarly.</span>
<span class="cp">#include &lt;list&gt;</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>     <span class="c1">// copy only if a is empty</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span> <span class="o">?</span> <span class="n">b</span> <span class="o">:</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// asign b if b nonempty, else c</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.3</span>
<span class="c1">//-----------------------------</span>
<span class="cp">#include &lt;algorithm&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>  

<span class="c1">//-----------------------------</span>
<span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span>    <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span>    <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">a</span><span class="p">(</span><span class="s">&quot;alpha&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">b</span><span class="p">(</span><span class="s">&quot;omega&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// The ability to exchange more than two variables at once is not </span>
<span class="c1">// built into the C++ language or C++ standard libraries.  However, you</span>
<span class="c1">// can use the boost tuple library to accomplish this.</span>
<span class="cp">#include &lt;boost/tuple/tuple.hpp&gt;</span>

<span class="n">boost</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">production</span><span class="p">)</span> 
          <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="s">&quot;January&quot;</span><span class="p">,</span> <span class="s">&quot;March&quot;</span><span class="p">,</span> <span class="s">&quot;August&quot;</span><span class="p">);</span>
<span class="c1">// move beta       to alpha,</span>
<span class="c1">// move production to beta,</span>
<span class="c1">// move alpha      to production</span>
<span class="n">boost</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">production</span><span class="p">)</span> 
          <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">production</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.4</span>
<span class="c1">//-----------------------------</span>
<span class="c1">// There are several ways to convert between characters</span>
<span class="c1">// and integers.  The examples assume the following declarations:</span>
<span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
<span class="kt">int</span>  <span class="n">num</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Using implicit conversion</span>
<span class="n">num</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
<span class="n">ch</span>  <span class="o">=</span> <span class="n">num</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// New-style C++ casts</span>
<span class="n">ch</span>  <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
<span class="n">num</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Old-style C casts</span>
<span class="n">ch</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">num</span><span class="p">;</span>
<span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ch</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Using the C++ stringstream class</span>
<span class="cp">#include &lt;sstream&gt;       </span><span class="c1">// On some older compilers, use &lt;strstream&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">a</span><span class="p">;</span>     <span class="c1">// On some older compilers, use std::strstream</span>

<span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">ch</span><span class="p">;</span>                 <span class="c1">// Append character to a string</span>
<span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>                <span class="c1">// Output character as a number</span>

<span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">;</span>                <span class="c1">// Append number to a string</span>
<span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">;</span>                 <span class="c1">// Output number as a character</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Using sprintf, printf</span>
<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>             <span class="c1">// Has to be length 2 to have room for NULL character</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Number %d is character %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

<span class="c1">//-----------------------------</span>
<span class="kt">int</span>  <span class="n">ascii_value</span> <span class="o">=</span> <span class="sc">&#39;e&#39;</span><span class="p">;</span>   <span class="c1">// now 101</span>
<span class="kt">char</span> <span class="n">character</span>   <span class="o">=</span> <span class="mi">101</span><span class="p">;</span>   <span class="c1">// now &#39;e&#39;</span>

<span class="c1">//-----------------------------</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Number %d is character %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">101</span><span class="p">);</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Convert from HAL to IBM, character by character</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ibm</span><span class="p">,</span> <span class="n">hal</span> <span class="o">=</span> <span class="s">&quot;HAL&quot;</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">hal</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">ibm</span> <span class="o">+=</span> <span class="n">hal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>          <span class="c1">// Add one to each ascii value</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ibm</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>          <span class="c1">// prints &quot;IBM&quot;</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Convert hal from HAL to IBM</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;functional&gt;         </span><span class="c1">// For bind1st and plus&lt;&gt;</span>
<span class="cp">#include &lt;algorithm&gt;          </span><span class="c1">// For transform </span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hal</span> <span class="o">=</span> <span class="s">&quot;HAL&quot;</span><span class="p">;</span>   
<span class="n">transform</span><span class="p">(</span><span class="n">hal</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">hal</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">hal</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
          <span class="n">bind1st</span><span class="p">(</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(),</span><span class="mi">1</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hal</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>          <span class="c1">// prints &quot;IBM&quot;</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.5</span>
<span class="c1">//-----------------------------</span>
<span class="c1">// Since C++ strings can be accessed one character at a time,</span>
<span class="c1">// there&#39;s no need to do any processing on the string to convert</span>
<span class="c1">// it into an array of characters.  </span>
<span class="cp">#include &lt;string&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>

<span class="c1">// Accessing characters using for loop and integer offsets</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something with s[i]</span>
<span class="p">}</span>

<span class="c1">// Accessing characters using iterators</span>
<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span><span class="o">!=</span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something with *i</span>
<span class="p">}</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>        <span class="n">str</span>  <span class="o">=</span> <span class="s">&quot;an apple a day&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span><span class="o">=</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span><span class="o">!=</span><span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
   <span class="n">seen</span><span class="p">[</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;unique chars are: &quot;</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span><span class="o">=</span><span class="n">seen</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span><span class="o">!=</span><span class="n">seen</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// unique chars are:  adelnpy</span>

<span class="c1">//-----------------------------</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span><span class="o">=</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span><span class="o">!=</span><span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;sum is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// prints &quot;sum is 1248&quot; if str was &quot;an appla a day&quot;</span>


<span class="c1">//-----------------------------</span>
<span class="c1">// MISSING: sysv-like checksum program</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// slowcat, emulate a slow line printer</span>
<span class="cp">#include &lt;sys/time.h&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;fstream&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">timeval</span> <span class="n">delay</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50000</span> <span class="p">};</span>   <span class="c1">// Delay in { seconds, nanoseconds }</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">arg</span> <span class="o">=</span> <span class="n">argv</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>   
  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>                  <span class="c1">// For each file</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">file</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="o">++</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
      <span class="n">select</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delay</span><span class="p">);</span> 
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.6</span>
<span class="c1">//-----------------------------</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;algorithm&gt;                  </span><span class="c1">// For reverse</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">//-----------------------------</span>
<span class="cp">#include &lt;vector&gt;                    </span><span class="c1">// For std::vector</span>
<span class="cp">#include &lt;sstream&gt;                   </span><span class="c1">// On older compilers, use &lt;strstream&gt;</span>
<span class="cp">#include &quot;boost/regex.hpp&quot;           </span><span class="c1">// For boost::regex_split</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">;</span>
<span class="n">boost</span><span class="o">::</span><span class="n">regex_split</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">words</span><span class="p">),</span> <span class="n">str</span><span class="p">);</span>
<span class="n">reverse</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// Reverse the order of the words</span>

<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">revwords</span><span class="p">;</span>          <span class="c1">// On older compilers, use strstream</span>
<span class="n">copy</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_inserter</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">revwords</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">revwards</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rts</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
<span class="n">reverse</span><span class="p">(</span><span class="n">rts</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">rts</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>     <span class="c1">// Reverses letters in rts</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">;</span>                  
<span class="n">reverse</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// Reverses words in container</span>

<span class="c1">//-----------------------------</span>
<span class="c1">// Reverse word order</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Yoda said, &#39;can you see this?&#39;&quot;</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">allwords</span><span class="p">;</span>
<span class="n">boost</span><span class="o">::</span><span class="n">regex_split</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">allwords</span><span class="p">),</span> <span class="n">s</span><span class="p">);</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">allwords</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">allwords</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    
<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">revwords</span><span class="p">;</span>          <span class="c1">// On older compilers, use strstream</span>
<span class="n">copy</span><span class="p">(</span><span class="n">allwords</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">allwords</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_inserter</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">revwords</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">revwards</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// this?&#39; see you &#39;can said, Yoda</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">word</span>  <span class="o">=</span> <span class="s">&quot;reviver&quot;</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">is_palindrome</span> <span class="o">=</span> <span class="n">equal</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">word</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">word</span><span class="p">.</span><span class="n">rbegin</span><span class="p">());</span>

<span class="c1">//-----------------------------</span>
<span class="cp">#include &lt;ifstream&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">dict</span><span class="p">(</span><span class="s">&quot;/usr/dict/words&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span>   <span class="n">word</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span><span class="n">word</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">word</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">word</span><span class="p">.</span><span class="n">rbegin</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
        <span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.7</span>
<span class="c1">//-----------------------------</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span><span class="p">;</span>
<span class="k">while</span> <span class="p">((</span><span class="n">pos</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span>
    <span class="n">str</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">,</span><span class="mi">8</span><span class="o">-</span><span class="n">pos</span><span class="o">%</span><span class="mi">8</span><span class="p">));</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.8</span>
<span class="c1">//-----------------------------</span>
<span class="c1">// Not applicable to C++</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.9</span>
<span class="c1">//-----------------------------</span>
<span class="c1">// TODO:  Fix to be more like cookbook</span>
<span class="c1">// TODO:  Modify/add code to do this with locales</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;algorithm&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">phrase</span> <span class="o">=</span> <span class="s">&quot;bo peep&quot;</span><span class="p">;</span>
<span class="n">transform</span><span class="p">(</span><span class="n">phrase</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">phrase</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">phrase</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">toupper</span><span class="p">);</span>
<span class="c1">// &quot;BO PEEP&quot;</span>
<span class="n">transform</span><span class="p">(</span><span class="n">phrase</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">phrase</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">phrase</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">tolower</span><span class="p">);</span>
<span class="c1">// &quot;bo peep&quot;</span>
<span class="c1">//-----------------------------</span>


<span class="c1">// @@PLEAC@@_1.10</span>
<span class="c1">//-----------------------------</span>
<span class="c1">// C++ does not provide support for perl-like in-string interpolation,</span>
<span class="c1">// concatenation must be used instead.</span>

<span class="cp">#include &lt;string&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">var1</span> <span class="o">+</span> <span class="n">func</span><span class="p">()</span> <span class="o">+</span> <span class="n">var2</span><span class="p">;</span>  <span class="c1">// func returns string or char *</span>

<span class="c1">//-----------------------------</span>
<span class="cp">#include &quot;boost/lexical_cast.hpp&quot;</span>

<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">phrase</span> <span class="o">=</span> <span class="s">&quot;I have &quot;</span> <span class="o">+</span> <span class="n">boost</span><span class="o">::</span><span class="n">lexical_cast</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; guanacos.&quot;</span><span class="p">;</span>

<span class="c1">//-----------------------------</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;I have &quot;</span> <span class="o">+</span> <span class="n">boost</span><span class="o">::</span><span class="n">lexical_cast</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; guanacos.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>


<span class="c1">// @@PLEAC@@_1.11</span>
<span class="c1">//-----------------------------</span>
<span class="c1">// C++ does not have &quot;here documents&quot;.</span>
<span class="c1">// TODO: Lots more.</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &quot;boost/regex.hpp&quot;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">var</span> <span class="o">=</span> <span class="s">&quot;</span>
   <span class="n">your</span> <span class="n">text</span>
   <span class="n">goes</span> <span class="n">here</span><span class="p">.</span>
<span class="s">&quot;;</span>

<span class="n">boost</span><span class="o">::</span><span class="n">regex</span> <span class="n">ex</span><span class="p">(</span><span class="s">&quot;^</span><span class="se">\\</span><span class="s">s+&quot;</span><span class="p">);</span>
<span class="n">var</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">regex_merge</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

<span class="c1">// @@PLEAC@@_10.0</span>
<span class="c1">// NOTE: Whilst it is perfectly valid to use Standard C Library, or GNU C Library, routines in</span>
<span class="c1">// C++ programs, the code examples here will, as far as possible, avoid doing so, instead using</span>
<span class="c1">// C++-specific functionality and idioms. In general:</span>
<span class="c1">// * I/O will be iostream-based [i.e. no &#39;scanf&#39;, &#39;printf&#39;, &#39;fgets&#39; etc]</span>
<span class="c1">// * Container / iterator idioms based on the Standard Template Library [STL]</span>
<span class="c1">//   will replace the built-in array / raw pointer idioms typically used in C</span>
<span class="c1">// * Boost Library functionality utilised wherever possible [the reason for</span>
<span class="c1">//   this is that much of this functionality is likely to appear in the next</span>
<span class="c1">//   C++ standard]</span>
<span class="c1">// * Error detection/handling will generally be exception-based [this is done</span>
<span class="c1">//   to keep examples simple. Exception use is optional in C++, and is not as</span>
<span class="c1">//   pervasive as it is in other languages like Java or C#]</span>
<span class="c1">// C-based solution(s) to problem(s) will be found in the corresponding section of PLEAC-C/Posix/GNU.</span>

<span class="cp">#include &lt;iostream&gt;</span>

<span class="c1">// &#39;greeted&#39; defined outside of any namespace, class or function, so is part of the</span>
<span class="c1">// global namespace, and will be visible throughout the entire executable. Should it</span>
<span class="c1">// be necessary to restrict the visibility of this global identifier to the current</span>
<span class="c1">// &#39;compilation unit&#39; [i.e. current source file] then the following may be used:</span>
<span class="c1">//</span>
<span class="c1">//     namespace { int greeted = 0; }</span>
<span class="c1">//</span>
<span class="c1">// The effect is similar to using the &#39;static&#39; keyword, in this same context, in the C</span>
<span class="c1">// language.</span>

<span class="kt">int</span> <span class="n">greeted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">howManyGreetings</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">hello</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">hello</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">greetings</span> <span class="o">=</span> <span class="n">howManyGreetings</span><span class="p">();</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bye there!, there have been &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">greetings</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; greetings so far&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">howManyGreetings</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Access &#39;greeted&#39; identifier in the global namespace using the scope resolution</span>
  <span class="c1">// operator. Use of this operator is only necessary if a similarly-named identifier</span>
  <span class="c1">// exists in a </span>
  <span class="k">return</span> <span class="o">::</span><span class="n">greeted</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hello</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Here &#39;greeted&#39; is accessed without additional qualification. Since a &#39;greeted&#39; identifier</span>
  <span class="c1">// exists only in the global namespace, it is that identifier that is used</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;high there!, this function has been called &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">greeted</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; times&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.1</span>
<span class="c1">// Standard C++ requires that a function be prototyped, hence the name and type of parameters</span>
<span class="c1">// must be specified, and the argumemt list in any calls to that function must match the</span>
<span class="c1">// parameter list, as shown here </span>

<span class="cp">#include &lt;cmath&gt;</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Variable length argument list functions, via the C Language derived &#39;va_...&#39; macros,</span>
<span class="c1">// are also supported. However use of this facility is particularly discouraged in C++</span>
<span class="c1">// because:</span>
<span class="c1">// * It is an inherently type-unsafe facility; type safety is a core C++ concern</span>
<span class="c1">// * Other facilities, such as overloaded functions, and default arguments [neither of which</span>
<span class="c1">//   are available in C] can sometimes obviate the need for variable length argument lists</span>
<span class="c1">// * OOP techniques can also lessen the need for variable length argument lists. The most</span>
<span class="c1">//   obvious example here is the Iostream library where repeated calls of I/O operators replace</span>
<span class="c1">//   the format string / variable arguments of &#39;printf&#39;</span>

<span class="cp">#include &lt;cmath&gt;</span>
<span class="cp">#include &lt;cstdarg&gt;</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="p">...);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="c1">// More details available in the corresponding section of PLEAC-C/Posix/GNU</span>
  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">side1</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">side2</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// An example using default arguments appears below</span>

<span class="cp">#include &lt;cmath&gt;</span>

<span class="c1">// Specify default argument values in declaration</span>
<span class="c1">// Note: This may be done in either of the declaration or the definition [not both], but it</span>
<span class="c1">// makes more sense to do so in the declaration since these are usually placed in header files</span>
<span class="c1">// which may be included in several source files. The default argument values would need to be</span>
<span class="c1">// known in all those locations</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// All arguments specified</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>

  <span class="c1">// Both calls utilise default argument value(s)</span>
  <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">);</span>

  <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// A [very contrived, not very practical] example using function overloading appears below</span>

<span class="cp">#include &lt;cmath&gt;</span>

<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Call version (1)</span>
  <span class="kt">double</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>

  <span class="c1">// Call version (2)</span>
  <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">(</span><span class="mf">3.0</span><span class="p">);</span>

  <span class="c1">// Call version (3)</span>
  <span class="n">diag</span> <span class="o">=</span> <span class="n">hypotenuse</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// (1)</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">side2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// (2)</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">(</span><span class="kt">double</span> <span class="n">side1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// (3)</span>
<span class="kt">double</span> <span class="nf">hypotenuse</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;cstddef&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_all</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">arrsize</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_all</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load vectors from built-in arrays, or use Boost &#39;assign&#39; library</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">};</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// Conversion effected at vector creation time</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span> <span class="o">=</span> <span class="n">int_all</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">arrsize</span><span class="p">);</span>

  <span class="c1">// Vector -&gt; vector copy / conversion </span>
  <span class="n">ints</span> <span class="o">=</span> <span class="n">int_all</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">nums</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_all</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">arrsize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_all</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">r</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>  <span class="c1">// Type safe element copying </span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;algorithm&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="cp">#include &lt;cmath&gt;</span>
<span class="cp">#include &lt;cstddef&gt;</span>

<span class="kt">void</span> <span class="n">trunc_em</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load vectors from built-in arrays, or use Boost &#39;assign&#39; library</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">};</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">numsv</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">nums</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">);</span>

  <span class="n">trunc_em</span><span class="p">(</span><span class="n">numsv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">trunc_em</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Replace each element with the value returned by applying &#39;floor&#39; to that element</span>
  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">floor</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// @@PLEAC@@_2.1</span>

<span class="cp">#include &lt;boost/regex.hpp&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="s">&quot;335635f&quot;</span><span class="p">);</span>
<span class="n">boost</span><span class="o">::</span><span class="n">regex</span> <span class="n">pattern</span><span class="p">(</span><span class="s">&quot;PATTERN&quot;</span><span class="p">);</span>	<span class="c1">// pattern given as a string-literal</span>

<span class="k">if</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">regex_match</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">pattern</span><span class="p">))</span> <span class="p">{</span>
	<span class="c1">// string completely matches pattern</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="c1">// string does not match the pattern</span>
<span class="p">}</span>
<span class="c1">// #---------------------------------</span>
<span class="c1">// Some PATTERNs in strings, escaped</span>
<span class="c1">// has nondigits		if     &quot;\\D*&quot;</span>
<span class="c1">// not a natural number&quot;	unless &quot;^\\d+$&quot;             // rejects -3</span>
<span class="c1">// not an integer		unless &quot;^-?\\d+$&quot;           // rejects +3</span>
<span class="c1">// not an integer       	unless &quot;^[+-]?\\d+$&quot;</span>
<span class="c1">// not a decimal number 	unless &quot;^-?\\d+\\.?\\d*$&quot;     // rejects .2</span>
<span class="c1">// not a decimal number 	unless &quot;^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)$&quot;</span>

<span class="c1">// A search of pattern in string is also possible.</span>


<span class="c1">// @@PLEAC@@_2.2</span>

<span class="cp">#include &lt;sstream&gt;</span>
<span class="cp">#include &lt;iomanip&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * equal(float num1, float num2, int accuracy) : returns true if</span>
<span class="cm"> * num1 and num2 are equal to accuracy number of decimal places</span>
<span class="cm"> */</span>
<span class="kt">bool</span> <span class="n">equal</span><span class="p">(</span><span class="kt">float</span> <span class="n">num1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">num2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">accuracy</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
	<span class="c1">// write num1 to s1, represented with as many digits</span>
	<span class="c1">// in the fraction part (fixed) as specified by the precision</span>
	<span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">fixed</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="n">accuracy</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">num1</span><span class="p">;</span>
	<span class="n">s2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">fixed</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="n">accuracy</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">num2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">==</span> <span class="n">s2</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// The approach of fcomparing formatted strings is not the most efficient.</span>


<span class="c1">// @@PLEAC@@_10.2</span>
<span class="c1">// Variables declared within a function body are local to that function, and those declared</span>
<span class="c1">// outside a function body [and not as part of a class / struct definition, or enclosed within</span>
<span class="c1">// a namespace] are global, that is, are visible throughout the executable unless their</span>
<span class="c1">// visibility has been restricted to the source file in which they are defined via enclosing</span>
<span class="c1">// them within an anonymous namespace [which has the same effect as using the &#39;static&#39; keyword,</span>
<span class="c1">// in this same context, in the C language]</span>

<span class="cp">#include &lt;vector&gt;</span>

<span class="kt">void</span> <span class="n">somefunc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// All these variables are local to this function</span>
  <span class="kt">int</span> <span class="n">variable</span><span class="p">,</span> <span class="n">another</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

  <span class="p">;</span> <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// A couple of generic, type-safe type conversion helpers. The Boost Library sports a conversion</span>
<span class="c1">// library at: http://www.boost.org/libs/conversion/index.html</span>

<span class="cp">#include &lt;sstream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">class</span> <span class="nc">bad_conversion</span> <span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fromString</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">iss</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">T</span> <span class="n">t</span><span class="p">;</span> <span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iss</span><span class="p">)</span> <span class="k">throw</span> <span class="n">bad_conversion</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
  <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ends</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oss</span><span class="p">)</span> <span class="k">throw</span> <span class="n">bad_conversion</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="cp">#include &lt;string&gt;</span>

<span class="c1">// File scope variables</span>
<span class="k">namespace</span> 
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">condition</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">run_check</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">check_x</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="c1">// An alternative, C++-specific approach, to command-line handling and type conversion</span>
<span class="c1">// may be seen at: http://www.boost.org/libs/conversion/lexical_cast.htm</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">name</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">try</span>
  <span class="p">{</span>  
    <span class="n">age</span> <span class="o">=</span> <span class="n">fromString</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">bad_conversion</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ... handle conversion error ...</span>
  <span class="p">}</span>

  <span class="n">check_x</span><span class="p">(</span><span class="n">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">void</span> <span class="nf">run_check</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Full access to file scope variables</span>
  <span class="n">condition</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">check_x</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Full access to file scope variables</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">y</span><span class="p">(</span><span class="s">&quot;whatever&quot;</span><span class="p">);</span>

  <span class="n">run_check</span><span class="p">();</span>

  <span class="c1">// &#39;condition&#39; updated by &#39;run_check&#39;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.3</span>
<span class="c1">// Standard C++, owing to its C heritage, allows the creation of &#39;persistent private variables&#39;,</span>
<span class="c1">// via use of the &#39;static&#39; keyword. For more details about this, and illustrative code examples,</span>
<span class="c1">// refer to this same section in PLEAC-C/Posix/GNU. Standard C++-specific methods of perfoming</span>
<span class="c1">// this task involve use of the &#39;namespace&#39; facility, or creating a class containing &#39;static&#39;</span>
<span class="c1">// members and using access specifiers to restrict access</span>

<span class="c1">// This example replaces the &#39;static&#39; keyword with use of an anonymous namespace to force</span>
<span class="c1">// &#39;variable&#39; to have file scope, and be visible only within the &#39;mysubs.cpp file. It is</span>
<span class="c1">// therefore both persistant [because it is a global variable] and private [because it is</span>
<span class="c1">// visible only to functions defined within the same source file]</span>

<span class="c1">// File: &#39;mysubs.h&#39;</span>
<span class="kt">void</span> <span class="nf">mysub</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;mysubs.cpp&#39;</span>
<span class="k">namespace</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">variable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">mysub</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ... do something with &#39;variable&#39; ...</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">variable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;test.cpp&#39;</span>
<span class="cp">#include &quot;mysubs.h&quot;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// &#39;variable&#39; is not accessable here</span>

  <span class="c1">// Call &#39;mysub&#39;, which can access &#39;variable&#39;</span>
  <span class="n">mysub</span><span class="p">();</span>

  <span class="c1">// Call &#39;reset&#39; which sets &#39;variable&#39; to 1  </span>
  <span class="n">reset</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// This example is similar to the previous one in using an anonymous namespace to restrict</span>
<span class="c1">// variable visibility. It goes further, hoewever, grouping logically related items within</span>
<span class="c1">// a named namespace, thus ensuring access to those items is controlled [i.e. requires</span>
<span class="c1">// qualification, or a &#39;using&#39; declaration or directive]</span>

<span class="c1">// File: &#39;counter.h&#39;</span>
<span class="k">namespace</span> <span class="n">cnt</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">increment</span><span class="p">();</span>
  <span class="kt">int</span> <span class="nf">decrement</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;counter.cpp&#39;</span>
<span class="k">namespace</span> <span class="n">cnt</span>
<span class="p">{</span>
  <span class="c1">// Ensures &#39;counter&#39; is visible only within the current source file</span>
  <span class="k">namespace</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">reset</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">int</span> <span class="n">increment</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">decrement</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">--</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;test.cpp&#39;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &quot;counter.h&quot;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Following line is illegal because &#39;cnt::counter&#39; is private to the &#39;counter.cpp&#39; file</span>
  <span class="c1">// int c = cnt::counter;</span>
  
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">::</span><span class="n">increment</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">::</span><span class="n">decrement</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// This example sees a class containing &#39;static&#39; members and using access specifiers to</span>
<span class="c1">// restrict access to those members. Since all the members are static, this class is not</span>
<span class="c1">// meant to be instantiated [i.e. objects created from it - it can be done, but they would</span>
<span class="c1">// all be the exact same object :)], but merely uses the &#39;class&#39; facility to encapsulate</span>
<span class="c1">// [i.e. group together] and allow selective access [i.e. hide some parts, allow access to</span>
<span class="c1">// others]. For Design Pattern afficiandos, this is a crude example of the Singleton Pattern</span>

<span class="c1">// File: &#39;counter.h&#39;</span>
<span class="k">class</span> <span class="nc">Counter</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">increment</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">decrement</span><span class="p">();</span>
<span class="nl">private:</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;counter.cpp&#39;</span>
<span class="cp">#include &quot;counter.h&quot;</span>

<span class="kt">int</span> <span class="n">Counter</span><span class="o">::</span><span class="n">increment</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">Counter</span><span class="o">::</span><span class="n">decrement</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">--</span><span class="n">counter</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">Counter</span><span class="o">::</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="c1">// File: &#39;test.cpp&#39;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &quot;counter.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Counter</span><span class="o">::</span><span class="n">increment</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">Counter</span><span class="o">::</span><span class="n">decrement</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.4</span>
<span class="c1">// Standard C++ offers no facility for performing adhoc, runtime stack inspection; therefore,</span>
<span class="c1">// information such as the currently-executing function name, cannot be obtained. Now, this</span>
<span class="c1">// isn&#39;t to say that such facilities don&#39;t exist [since, after all, a symbolic debugger works</span>
<span class="c1">// by doing just this - stack inspection, among other things], but that such features are, for</span>
<span class="c1">// native code compiled languages like C++, &#39;extra-language&#39; and development tool-specific</span>

<span class="c1">// @@PLEAC@@_10.5</span>
<span class="c1">// Standard C++ supports both</span>
<span class="c1">// * &#39;pass-by-value&#39;: a copy of an argument is passed when calling a function; in this way</span>
<span class="c1">//   the original is safe from modification, but a copying overhead is incurred which may</span>
<span class="c1">//   adversely affect performance</span>
<span class="c1">// * &#39;pass-by-reference&#39;: the address of an argument is passed when calling a function;</span>
<span class="c1">//   allows the original to be modified, and incurrs no performance penalty from copying</span>
<span class="c1">//</span>
<span class="c1">// The &#39;pass-by-value&#39; mechanism works in the same way as in the Standard C language [see</span>
<span class="c1">// corresponding section in PLEAC-C/Posix/GNU]. The &#39;pass-by-reference&#39; mechanism provides</span>
<span class="c1">// the same functionality as passing a pointer-to-a-pointer-to-an-argument, but without the</span>
<span class="c1">// complications arising from having to correctly dereference. Using a reference to a non-const</span>
<span class="c1">// item allows:</span>
<span class="c1">// * The item&#39;s state to be modified i.e. if an object was passed, it can be mutated [effect</span>
<span class="c1">//   can be mimiced by passing a pointer to the item]</span>
<span class="c1">// * The item, itself, can be replaced with a new item i.e. the memory location to which the</span>
<span class="c1">//   reference refers is updated [effect can be mimiced by passing a pointer-to-a-pointer to</span>
<span class="c1">//   the item]</span>

<span class="cp">#include &lt;cstddef&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="c1">// &#39;pass-by-value&#39;: a copy of each vector is passed as an argument</span>
<span class="c1">// void array_diff(const std::vector&lt;int&gt; arr1, const std::vector&lt;int&gt; arr2);</span>

<span class="c1">// &#39;pass-by-reference&#39;: the address of each vector is passed as an argument. Some variants:</span>
<span class="c1">// * Disallow both vector replacement and alteration of its contents</span>
<span class="c1">//     void array_diff(const std::vector&lt;const int&gt;&amp; arr1, const std::vector&lt;const int&gt;&amp; arr2);</span>
<span class="c1">// * Disallow vector replacement only</span>
<span class="c1">//     void array_diff(const std::vector&lt;int&gt;&amp; arr1, const std::vector&lt;int&gt;&amp; arr2);</span>
<span class="c1">// * Disallow alteration of vector contents only</span>
<span class="c1">//     void array_diff(std::vector&lt;const int&gt;&amp; arr1, std::vector&lt;const int&gt;&amp; arr2);</span>
<span class="c1">// * Allow replacement / alteration</span>
<span class="c1">//     void array_diff(std::vector&lt;int&gt;&amp; arr1, std::vector&lt;int&gt;&amp; arr2);</span>

<span class="kt">void</span> <span class="nf">array_diff</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr2</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load vectors from built-in arrays, or use Boost &#39;assign&#39; library</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="c1">// Function call is the same whether &#39;array_diff&#39; is declared to be &#39;pass-by-value&#39;</span>
  <span class="c1">// or &#39;pass-by-reference&#39;</span>
  <span class="n">array_diff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr1</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr2</span><span class="p">,</span> <span class="n">arr2</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// void array_diff(const std::vector&lt;int&gt; arr1, const std::vector&lt;int&gt; arr2)</span>
<span class="c1">// {</span>
<span class="c1">//  ; // &#39;arr1&#39; and &#39;arr2&#39; are copies of the originals</span>
<span class="c1">// }</span>

<span class="kt">void</span> <span class="nf">array_diff</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// &#39;arr1&#39; and &#39;arr2&#39; are references to the originals</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="cp">#include &lt;cstddef&gt;</span>

<span class="cp">#include &lt;algorithm&gt;</span>
<span class="cp">#include &lt;functional&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">add_vecpair</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr2</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load vectors from built-in arrays, or use Boost &#39;assign&#39; library</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">aa</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="n">ba</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>
  <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">aa</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">ba</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">);</span>  

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">add_vecpair</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">add_vecpair</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">retvec</span><span class="p">;</span> <span class="n">retvec</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">arr1</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">arr1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">arr2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">retvec</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">retvec</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.6</span>
<span class="c1">// Please refer to the corresponding section in PLEAC-C/Posix/GNU since the points raised there</span>
<span class="c1">// apply to C++ also. Examples here don&#39;t so much illustrate C++&#39;s handling of &#39;return context&#39;</span>
<span class="c1">// as much as how disparate types might be handled in a reasonably uniform manner</span>

<span class="c1">// Here, &#39;mysub&#39; is implemented as a function template, and its return type varies with the</span>
<span class="c1">// argument type. In most cases the compiler is able to infer the return type from the </span>
<span class="c1">// argument, however, it is possible to pass the type as a template parameter. Note this</span>
<span class="c1">// code operates at compile-time, as does any template-only code</span>

<span class="cp">#include &lt;cstddef&gt;</span>

<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">mysub</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// 1. Type information inferred by compiler</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">mysub</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">mysub</span><span class="p">(</span><span class="mf">7.6</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">arrsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">mysub</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">arrsize</span><span class="p">));</span>

  <span class="c1">// 2. Type information provided by user</span>
  <span class="c1">// Pass a &#39;const char*&#39; argument and specify type information in the call</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">mysub</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;xyz&quot;</span><span class="p">);</span>

  <span class="c1">// Could avoid specifying type information by passing a &#39;std::string&#39; argument  </span>
  <span class="c1">// std::string s = mysub(std::string(&quot;xyz&quot;));</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// This is a variant on the previous example that uses the Boost Library&#39;s &#39;any&#39; type as a</span>
<span class="c1">// generic &#39;stub&#39; type</span>

<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="cp">#include &lt;boost/any.hpp&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">any</span> <span class="n">mysub</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">any</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">any</span><span class="o">&gt;</span> <span class="n">any</span><span class="p">;</span>

  <span class="c1">// Add various types [encapsulated in &#39;any&#39; objects] to the container</span>
  <span class="n">any</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mysub</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">any</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mysub</span><span class="p">(</span><span class="mf">7.6</span><span class="p">));</span>
  <span class="n">any</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mysub</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)));</span>
  <span class="n">any</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mysub</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;xyz&quot;</span><span class="p">)));</span>

  <span class="c1">// Extract the various types from the container by appropriately casting the relevant</span>
  <span class="c1">// &#39;any&#39; object</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">any</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">any</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">any</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">any</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.7</span>
<span class="c1">// Just like the C language, C++ offers no support for named / keyword parameters. It is of</span>
<span class="c1">// course possible to mimic such functionality the same way it is done in C [see corresponding</span>
<span class="c1">// section in PLEAC-C/Posix/GNU], the most obvious means being by passing a set of key/value</span>
<span class="c1">// pairs in a std::map. This will not be shown here. Instead, two quite C++-specific examples</span>
<span class="c1">// will be provided, based on:</span>
<span class="c1">//</span>
<span class="c1">// * Named Parameter Idiom [see: http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.18]</span>
<span class="c1">// * Boost &#39;parameter&#39; Library [see: http://www.boost.org/libs/parameter/doc/html/index.html]</span>

<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;map&gt;</span>

<span class="k">class</span> <span class="nc">TimeEntry</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">TimeEntry</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">char</span> <span class="n">dim</span> <span class="o">=</span> <span class="sc">&#39;s&#39;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">);</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">value_</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">dim_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="o">&gt;</span> <span class="n">TENTRY</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="o">&gt;</span> <span class="n">TIMETBL</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">RaceTime</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">START_TIME</span><span class="p">,</span> <span class="n">FINISH_TIME</span><span class="p">,</span> <span class="n">INCR_TIME</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="nf">RaceTime</span><span class="p">();</span>

  <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">start_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">);</span>
  <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">finish_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">);</span>
  <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">incr_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">);</span>

  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>

<span class="nl">private:</span>
  <span class="n">TIMETBL</span> <span class="n">timetbl_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">START_TIME</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">FINISH_TIME</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">INCR_TIME</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">the_func</span><span class="p">(</span><span class="k">const</span> <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">the_func</span><span class="p">(</span><span class="n">RaceTime</span><span class="p">().</span><span class="n">start_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)).</span><span class="n">finish_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">)).</span><span class="n">incr_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)));</span>

  <span class="n">the_func</span><span class="p">(</span><span class="n">RaceTime</span><span class="p">().</span><span class="n">start_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">)).</span><span class="n">finish_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">)));</span>

  <span class="n">the_func</span><span class="p">(</span><span class="n">RaceTime</span><span class="p">().</span><span class="n">start_time</span><span class="p">(</span><span class="n">TimeEntry</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">value_</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">dim_</span><span class="p">;</span> <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r_</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">RaceTime</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

  <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;start_time:  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r_</span><span class="p">.</span><span class="n">timetbl_</span><span class="p">[</span><span class="n">RaceTime</span><span class="o">::</span><span class="n">START_TIME</span><span class="p">]</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">finish_time: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r_</span><span class="p">.</span><span class="n">timetbl_</span><span class="p">[</span><span class="n">RaceTime</span><span class="o">::</span><span class="n">FINISH_TIME</span><span class="p">]</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">incr_time:   &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r_</span><span class="p">.</span><span class="n">timetbl_</span><span class="p">[</span><span class="n">RaceTime</span><span class="o">::</span><span class="n">INCR_TIME</span><span class="p">];</span>

  <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TimeEntry</span><span class="o">::</span><span class="n">TimeEntry</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="n">dim</span><span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">dim_</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">bool</span> <span class="n">TimeEntry</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">dim_</span> <span class="o">==</span> <span class="n">right</span><span class="p">.</span><span class="n">dim_</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">value_</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">.</span><span class="n">value_</span><span class="p">)</span> <span class="o">:</span> <span class="o">!</span><span class="p">(</span><span class="n">dim_</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">.</span><span class="n">dim_</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">RaceTime</span><span class="o">::</span><span class="n">RaceTime</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">timetbl_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">TENTRY</span><span class="p">(</span><span class="n">START_TIME</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)));</span>
  <span class="n">timetbl_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">TENTRY</span><span class="p">(</span><span class="n">FINISH_TIME</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)));</span>
  <span class="n">timetbl_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">TENTRY</span><span class="p">(</span><span class="n">INCR_TIME</span><span class="p">,</span> <span class="n">TimeEntry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">)));</span>
<span class="p">}</span>

<span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">start_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">timetbl_</span><span class="p">[</span><span class="n">START_TIME</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">finish_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">timetbl_</span><span class="p">[</span><span class="n">FINISH_TIME</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">RaceTime</span><span class="o">::</span><span class="n">incr_time</span><span class="p">(</span><span class="k">const</span> <span class="n">TimeEntry</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">timetbl_</span><span class="p">[</span><span class="n">INCR_TIME</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">the_func</span><span class="p">(</span><span class="k">const</span> <span class="n">RaceTime</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// The Boost &#39;parameter&#39; library requires a significant amount of setup code to be written,</span>
<span class="c1">// much more than this section warrants. My recommendation is to read carefully through the</span>
<span class="c1">// tutorial to determine whether a problem for which it is being considered justifies all</span>
<span class="c1">// the setup.</span>

<span class="c1">// @@PLEAC@@_10.8</span>
<span class="c1">// The Boost &#39;tuple&#39; Library also allows multiple assignment to variables, including the</span>
<span class="c1">// selective skipping of return values</span>

<span class="cp">#include &lt;iostream&gt;</span>

<span class="cp">#include &lt;boost/tuple/tuple.hpp&gt;</span>

<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">T3</span><span class="p">;</span>

<span class="n">T3</span> <span class="nf">func</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// A tuple of references to the referred variables is created; the values</span>
  <span class="c1">// captured from the returned tuple are thus multiply-assigned to them</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Variables can still be individually referenced</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span> 
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Return values may be ignored; affected variables retain existing values</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">tuples</span><span class="o">::</span><span class="n">ignore</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">T3</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">T3</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.9</span>
<span class="c1">// Like Standard C, C++ allows only the return of a single value. The return of multiple values</span>
<span class="c1">// *can*, however, be simulated by packaging them within an aggregate type [as in C], or a</span>
<span class="c1">// custom class, or one of the STL containers like std::vector. Probably the most robust, and</span>
<span class="c1">// [pseudo]-standardised, approach is to use the Boost &#39;tuple&#39; Library, as will be done in this</span>
<span class="c1">// section. Notes:</span>
<span class="c1">// * Use made of Boost &#39;assign&#39; Library to simplify container loading; this is a *very* handy</span>
<span class="c1">//   library</span>
<span class="c1">// * Use made of Boost &#39;any&#39; Library to make containers heterogenous; &#39;variant&#39; Library is</span>
<span class="c1">//   similar, and is more appropriate where type-safe container traversal is envisaged e.g.</span>
<span class="c1">//   for printing  </span>

<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;map&gt;</span>

<span class="cp">#include &lt;boost/any.hpp&gt;</span>
<span class="cp">#include &lt;boost/tuple/tuple.hpp&gt;</span>

<span class="cp">#include &lt;boost/assign/std/vector.hpp&gt;</span>
<span class="cp">#include &lt;boost/assign/list_inserter.hpp&gt;</span>

<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">any</span><span class="o">&gt;</span> <span class="n">ARRAY</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">any</span><span class="o">&gt;</span> <span class="n">HASH</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">ARRAY</span><span class="p">,</span> <span class="n">HASH</span><span class="o">&gt;</span> <span class="n">ARRAY_HASH</span><span class="p">;</span>

<span class="n">ARRAY_HASH</span> <span class="nf">some_func</span><span class="p">(</span><span class="k">const</span> <span class="n">ARRAY</span><span class="o">&amp;</span> <span class="n">array</span><span class="p">,</span> <span class="k">const</span> <span class="n">HASH</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Load containers using Boost &#39;assign&#39; Library </span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">assign</span><span class="p">;</span>
  <span class="n">ARRAY</span> <span class="n">array</span><span class="p">;</span> <span class="n">array</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">HASH</span> <span class="n">hash</span><span class="p">;</span> <span class="n">insert</span><span class="p">(</span><span class="n">hash</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;k1&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;k2&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;k3&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

  <span class="c1">// Pass arguments to &#39;somefunc&#39; and retrieve them as members of a tuple</span>
  <span class="n">ARRAY_HASH</span> <span class="n">refs</span> <span class="o">=</span> <span class="n">some_func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>

  <span class="c1">// Retrieve copy of &#39;array&#39; from tuple</span>
  <span class="n">ARRAY</span> <span class="n">ret_array</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">refs</span><span class="p">);</span>

  <span class="c1">// Retrieve copy of &#39;hash&#39; from tuple</span>
  <span class="n">HASH</span> <span class="n">ret_hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">refs</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">ARRAY_HASH</span> <span class="nf">some_func</span><span class="p">(</span><span class="k">const</span> <span class="n">ARRAY</span><span class="o">&amp;</span> <span class="n">array</span><span class="p">,</span> <span class="k">const</span> <span class="n">HASH</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">;</span> <span class="c1">// ... do something with &#39;array&#39; and &#39;hash&#39;</span>

  <span class="k">return</span> <span class="n">ARRAY_HASH</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.10</span>
<span class="c1">// Like function calls in Standard C, function calls in C++ need to conform to signature</span>
<span class="c1">// requirements; a function call must match its declaration with the same number, and type,</span>
<span class="c1">// of arguments passed [includes implicitly-passed default arguments], and the same return</span>
<span class="c1">// value type. Thus, unlike Perl, a function declared to return a value *must* do so, thus</span>
<span class="c1">// cannot &#39;return nothing&#39; to indicate failure. </span>
<span class="c1">// Whilst in Standard C certain conventions like returning NULL pointers, or returning -1, to</span>
<span class="c1">// indicate the &#39;failure&#39; of a task [i.e. function return codes are checked, and control</span>
<span class="c1">// proceeds conditionally] are used, Standard C++ sports facilities which lessen the need for</span>
<span class="c1">// dong the same. Specifically, C++ offers:</span>
<span class="c1">// * Built-in exception handling which can be used to detect [and perhaps recover from],</span>
<span class="c1">//   all manner of unusual, or erroneous / problematic situations. One recommended use is</span>
<span class="c1">//   to avoid writing code that performs a lot of return code checking</span>
<span class="c1">// * Native OOP support allows use of the Null Object Design Pattern. Put simply, rather than</span>
<span class="c1">//   than checking return codes then deciding on an action, an object with some predefined</span>
<span class="c1">//   default behaviour is returned / used where an unusual / erroneous / problematic situation</span>
<span class="c1">//   is encountered. This approach could be as simple as having some sort of default base</span>
<span class="c1">//   class member function behaviour, or as complex as having a diagnostic-laden object created</span>
<span class="c1">// * Functions can still return &#39;error-indicating entities&#39;, but rather than primitive types</span>
<span class="c1">//   like &#39;int&#39;s or NULL pointers, complex objects can be returned. For example, the Boost</span>
<span class="c1">//   Library sports a number of such types:</span>
<span class="c1">//   - &#39;tuple&#39;</span>
<span class="c1">//   - &#39;any&#39;, &#39;variant&#39; and &#39;optional&#39;</span>
<span class="c1">//   - &#39;tribool&#39; [true, false, indeterminate]</span>

<span class="c1">// Exception Handling Example</span>

<span class="k">class</span> <span class="nc">XYZ_exception</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="nf">func</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">valid_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">try</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ...</span>

    <span class="n">valid_value</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span>

    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">XYZ_exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">valid_value</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">throw</span> <span class="n">XYZ_exception</span><span class="p">();</span>

  <span class="p">;</span> <span class="c1">// ...</span>
  
  <span class="k">return</span> <span class="n">valid_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// Null Object Design Pattern Example</span>

<span class="cp">#include &lt;iostream&gt;</span>

<span class="k">class</span> <span class="nc">Value</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">do_something</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">NullValue</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Value</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">do_something</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ValidValue</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Value</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">do_something</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">Value</span><span class="o">*</span> <span class="nf">func</span><span class="p">();</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Error checking is performed within &#39;func&#39;. However, regardless of the outcome, an</span>
  <span class="c1">// object of &#39;Value&#39; type is returned which possesses similar behaviour, though appropriate</span>
  <span class="c1">// to whether processing was successful or not. In this way no error checking is needed</span>
  <span class="c1">// outside of &#39;func&#39;</span>
  <span class="n">Value</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span>

  <span class="n">v</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>

  <span class="k">delete</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="n">NullValue</span><span class="o">::</span><span class="n">do_something</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*null*&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ValidValue</span><span class="o">::</span><span class="n">do_something</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;valid&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Value</span><span class="o">*</span> <span class="n">func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">NullValue</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>
  
  <span class="k">return</span> <span class="k">new</span> <span class="n">ValidValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// The Boost &#39;optional&#39; library has many uses, but in the current context, one is of particular</span>
<span class="c1">// use: returning a specified type [thus satisfying language requirements], but whose value</span>
<span class="c1">// may be &#39;set&#39; [if the function succeeded] or &#39;unset&#39; [if it failed], and this condition very</span>
<span class="c1">// easily checked</span>

<span class="cp">#include &lt;iostream&gt;</span>

<span class="cp">#include &lt;cstdlib&gt;</span>

<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;map&gt;</span>

<span class="cp">#include &lt;boost/optional/optional.hpp&gt;</span>

<span class="k">class</span> <span class="nc">func_fail</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">func_fail</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="o">:</span> <span class="n">msg_</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">msg_</span><span class="p">;</span> <span class="p">}</span> 
<span class="nl">private:</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">die</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>

<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sfunc</span><span class="p">();</span>
<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">afunc</span><span class="p">();</span>
<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">hfunc</span><span class="p">();</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">try</span>
  <span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">h</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">sfunc</span><span class="p">()))</span> <span class="k">throw</span> <span class="n">func_fail</span><span class="p">(</span><span class="s">&quot;&#39;sfunc&#39; failed&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">afunc</span><span class="p">()))</span> <span class="k">throw</span> <span class="n">func_fail</span><span class="p">(</span><span class="s">&quot;&#39;afunc&#39; failed&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">hfunc</span><span class="p">()))</span> <span class="k">throw</span> <span class="n">func_fail</span><span class="p">(</span><span class="s">&quot;&#39;hfunc&#39; failed&quot;</span><span class="p">);</span>

    <span class="p">;</span> <span class="c1">// ... do stuff with &#39;s&#39;, &#39;a&#39;, and &#39;h&#39; ...</span>
    <span class="kt">int</span> <span class="n">scalar</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

    <span class="p">;</span> <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">func_fail</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">die</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">msg</span><span class="p">());</span>   
  <span class="p">}</span>

  <span class="p">;</span> <span class="c1">// ... other code executed if no error above ...</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">void</span> <span class="nf">die</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Should only be used if all objects in the originating local scope have been destroyed</span>
  <span class="n">std</span><span class="o">::</span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sfunc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">error_detected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">valid_int_value</span><span class="p">;</span>

  <span class="p">;</span> <span class="c1">// ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">error_detected</span><span class="p">)</span> <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="p">;</span> <span class="c1">// ...</span>
  
  <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">valid_int_value</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">afunc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// ... code not shown ...</span>
 
  <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// ... code not shown</span>
<span class="p">}</span>

<span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">hfunc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// ... code not shown ...</span>

  <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// ... code not shown ...</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.11</span>
<span class="c1">// Whilst in Perl function prototyping is optional, this is not the case in C++, where it is</span>
<span class="c1">// necessary to:</span>
<span class="c1">// * Declare a function before use; this could either be a function declaration separate from</span>
<span class="c1">//   the function definition, or the function definition itself which serves as its own</span>
<span class="c1">//   declaration</span>
<span class="c1">// * Specify both parameter positional and type information; parameter names are optional in</span>
<span class="c1">//   declarations, mandatory in definitions</span>
<span class="c1">// * Specify return type</span>

<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="c1">// Function Declaration</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">);</span> <span class="c1">// Also possible: std::vector&lt;int&gt; myfunc(int, int);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Call function with all required arguments; this is the only calling method</span>
  <span class="c1">// [except for calling via function pointer which still needs all arguments supplied]</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">myfunc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

  <span class="c1">// Let&#39;s look at our return array&#39;s contents</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// Function Definition</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// A version on the above code that is generic, that is, making use of the C++ template</span>
<span class="c1">// mechanism to work with any type</span>

<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="c1">// Function Declaration</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">arg1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">arg2</span><span class="p">);</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">myfunc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="c1">// Function Definition</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">arg1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="c1">// Other Perl examples are omitted since there is no variation in C++ function calling or</span>
<span class="c1">// parameter handling</span>

<span class="c1">// @@PLEAC@@_10.12</span>
<span class="c1">// One of the key, non-object oriented features of Standard C++ is its built-in support for</span>
<span class="c1">// exceptions / exception handling. The feature is well-integrated into the language, including</span>
<span class="c1">// a set of predefined exception classes included in, and used by, the Standard Library, is</span>
<span class="c1">// quite easy to use, and helps the programmer write robust code provided certain conventions</span>
<span class="c1">// are followed. On the downside, the C++ exception handling system is criticised for imposing</span>
<span class="c1">// significant runtime overhead, as well as increasing executable code size [though this</span>
<span class="c1">// varies considerably between CPU&#39;s, OS&#39;s, and compilers]. Please refer to the corresponding</span>
<span class="c1">// section in PLEAC-C/Posix/GNU for pertinent reading references.</span>
<span class="c1">//</span>
<span class="c1">// The example code below matches the PLEAC-C/Posix/GNU example rather than the Perl code. Note:</span>
<span class="c1">// * A very minimal, custom exception class is implemented; a more complex class, one richer in</span>
<span class="c1">//   diagnostic information, could have been implemented, or perhaps one based on a standard</span>
<span class="c1">//   exception class like &#39;std::exception&#39;</span>
<span class="c1">// * Ordinarily error / exception messages are directed to &#39;std::cerr&#39; or &#39;std::clog&#39;</span>
<span class="c1">// * General recommendation is to throw &#39;temporaries&#39; [via invoking a constructor],</span>
<span class="c1">//   and to &#39;catch&#39; as const reference(s)</span>
<span class="c1">// * Proper &#39;cleanup&#39; is very important; consult a suitable book for guidance on writing</span>
<span class="c1">//   &#39;exception safe&#39; code</span>

<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">class</span> <span class="nc">FullmoonException</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">FullmoonException</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="o">:</span> <span class="n">msg_</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">FullmoonException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">msg_</span><span class="p">;</span> <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main - entry&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">try</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;try block - entry&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;... doing stuff ...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// if (... error condition detected ...)</span>
         <span class="k">throw</span> <span class="n">FullmoonException</span><span class="p">(</span><span class="s">&quot;... the problem description ...&quot;</span><span class="p">);</span>

    <span class="c1">// Control never gets here ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;try block - end&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">FullmoonException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Caught a&#39;Fullmoon&#39; exception. Message: &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">catch</span><span class="p">(...)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Caught an unknown exceptione&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Control gets here regardless of whether an exception is thrown or not</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main - end&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.13</span>
<span class="c1">// Standard C++ sports a namespace facility which allows an application to be divided into</span>
<span class="c1">// logical sub-systems, each of which operates within its own scope. Put very simply, the same</span>
<span class="c1">// identifiers [i.e. name of types, objects, and functions] may be each used in a namespace</span>
<span class="c1">// without fear of a nameclash occurring when logical sub-systems are variously combined as</span>
<span class="c1">// an application. The name-clash problem is inherent in single-namespace languages like C; it</span>
<span class="c1">// often occurs when several third-party libraries are used [a common occurrence in C], or</span>
<span class="c1">// when an application scales up. The remedy is to rename identifiers, or, in the case of </span>
<span class="c1">// functions that cannot be renamed, to wrap them up in other functions in a separate source</span>
<span class="c1">// file. Of course the problem may be minimised via strict adherence to naming conventions. </span>
<span class="c1">//</span>
<span class="c1">// The C++ namespace facility is important, too, because it avoids the need to utilise certain</span>
<span class="c1">// C language practices, in particular:</span>
<span class="c1">// * Use of, possibly, &#39;clumsy&#39; naming conventions [as described above]</span>
<span class="c1">// * Partition an application by separating logically-related items into separate source</span>
<span class="c1">//   files. Namespaces cross file boundaries, so items may reside in several source files</span>
<span class="c1">//   and still comprise a single, logical sub-system</span>
<span class="c1">// * Anonymous namespaces avoid use of the &#39;static&#39; keyword in creating file scope globals</span>

<span class="c1">// Global variable</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">print_age</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Global value, &#39;age&#39;, is accessed</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Age is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// A local variable named, &#39;age&#39; will act to &#39;shadow&#39; the globally</span>
  <span class="c1">// defined version, thus any changes to, &#39;age&#39;, will not affect</span>
  <span class="c1">// the global version</span>
  <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// Prints 18, the current value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Local version is altered, *not* global version</span>
  <span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

  <span class="c1">// Prints 18, the current value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Global variable</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">print_age</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Global value, &#39;age&#39;, is accessed</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Age is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Here no local version declared: any changes affect global version</span>
  <span class="n">age</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// Prints 5, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Global version again altered</span>
  <span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

  <span class="c1">// Prints 23, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----------------------------</span>

<span class="c1">// Global variable</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="c1">// ----</span>

<span class="kt">void</span> <span class="nf">print_age</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Global value, &#39;age&#39;, is accessed</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Age is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ------------</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Global version value saved into local version</span>
  <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="o">::</span><span class="n">age</span><span class="p">;</span>

  <span class="c1">// Prints 18, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Global version this time altered</span>
  <span class="o">::</span><span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

  <span class="c1">// Prints 23, the new value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>

  <span class="c1">// Global version value restored from saved local version</span>
  <span class="o">::</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>

  <span class="c1">// Prints 18, the restored value of the global version</span>
  <span class="n">print_age</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.14</span>
<span class="c1">// Please refer to the corresponding section in PLEAC-C/Posix/GNU since the points raised there</span>
<span class="c1">// about functions and function pointers apply equally to Standard C++ [briefly: functions</span>
<span class="c1">// cannot be redefined; several same-signature functions may be called via the same function</span>
<span class="c1">// pointer variable; code cannot be generated &#39;on-the-fly&#39; (well, not without the use of</span>
<span class="c1">// several external tools, making it an extra-language, not integral, feature)].</span>
<span class="c1">// @@INCOMPLETE@@</span>

<span class="c1">// @@PLEAC@@_10.15</span>
<span class="c1">// Please refer to the corresponding section in PLEAC-C/Posix/GNU since all the points raised</span>
<span class="c1">// there apply equally to Standard C++ [briefly: undefined function calls are compiler-detected</span>
<span class="c1">// errors; function-pointer-based calls can&#39;t be checked for integrity].</span>
<span class="c1">// @@INCOMPLETE@@</span>

<span class="c1">// @@PLEAC@@_10.16</span>
<span class="c1">// Standard C++ does not support either simple nested functions or closures, therefore the</span>
<span class="c1">// example cannot be implemented exactly as per the Perl code</span>

<span class="cm">/* ===</span>
<span class="cm">int outer(int arg)</span>
<span class="cm">{</span>
<span class="cm">  int x = arg + 35;</span>

<span class="cm">  // *** wrong - illegal C++ ***</span>
<span class="cm">  int inner() { return x * 19; }</span>

<span class="cm">  return x + inner();</span>
<span class="cm">}</span>
<span class="cm">=== */</span>

<span class="c1">// The problem may, of course, be solved by defining two functions using parameter passing</span>
<span class="c1">// where appropriate, but this is contrary to the intent of the original Perl code</span>
<span class="kt">int</span> <span class="nf">inner</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">outer</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// An arguably better [but far more complicated] approach is to encapsulate all items within</span>
<span class="c1">// a namespace, but again, is an approach that is counter the intent of the original Perl code</span>
<span class="cp">#include &lt;iostream&gt;</span>

<span class="k">namespace</span> <span class="n">nst</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">inner</span><span class="p">();</span>
  <span class="kt">int</span> <span class="nf">outer</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nst</span><span class="o">::</span><span class="n">outer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ----</span>

<span class="kt">int</span> <span class="n">nst</span><span class="o">::</span><span class="n">inner</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">nst</span><span class="o">::</span><span class="n">x</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">nst</span><span class="o">::</span><span class="n">outer</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">nst</span><span class="o">::</span><span class="n">x</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">nst</span><span class="o">::</span><span class="n">x</span> <span class="o">+</span> <span class="n">nst</span><span class="o">::</span><span class="n">inner</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Another way to solve this problem and avoiding the use of an external function, is to</span>
<span class="c1">// create a local type and instantiate an object passing any required environment context</span>
<span class="c1">// to the constructor. Then, what appears as a parameterless nested function call, can be</span>
<span class="c1">// effected using &#39;operator()&#39;. This approach most closely matches the original Perl code</span>

<span class="kt">int</span> <span class="n">outer</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">35</span><span class="p">;</span>

  <span class="c1">// &#39;Inner&#39; is what is known as a Functor or Function Object [or Command Design Pattern]; it</span>
  <span class="c1">// allows objects that capture state / context to be instantiated, and that state / context</span>
  <span class="c1">// used / retained / altered at multiple future times. Both the STL and Boost Libraries</span>
  <span class="c1">// provide extensive support these constructs</span>
  <span class="k">struct</span> <span class="n">Inner</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n_</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="nf">Inner</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">n_</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n_</span> <span class="o">*</span> <span class="mi">19</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span> <span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">inner</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// @@PLEAC@@_10.17</span>
<span class="c1">// @@INCOMPLETE@@</span>
<span class="c1">// @@INCOMPLETE@@</span>
</pre></div>
</body>
</html>
