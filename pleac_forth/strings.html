<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Strings</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Forth"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="PLEAC-Forth"
HREF="index.html"><LINK
REL="NEXT"
TITLE="Numbers"
HREF="numbers.html"></HEAD
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Forth</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="numbers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="STRINGS"
>1. Strings</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN14"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">: string ( -- c- u ) s&quot; \n&quot; ; ( two characters, \ and an n )
: string ( -- c- u ) s&quot; John 'Maddog' Orwant&quot; ; ( literal single quotes
---------------------------- )
: string ( -- ) cr ; ( a &quot;newline&quot; character, or: )
: string ( -- ) newline type ; ( a &quot;newline&quot; character, or: )
: string ( -- c ) 13 ; ( depending, obviously, on your platform's newline )

( double quotes must be entered manually )
: put-quote ( c- u -- )
	+ 34 swap c!
;
: string ( -- c- u )
	s&quot; Jon  Maddog  Orwant&quot;
	over dup 4 put&quot; 11 put&quot; ( literal double quotes )
;
( no q/ / type quoting options
----------------------------
some words to make a here document: )
: newline? ( c -- f )
 dup 10 = swap 13 = or
( or whatever the newline is for your platform )
;
: get-terminator ( -- c- u )
 here dup
 12 chars allot
 12 accept
 ( change 12 if you absolutely must have a larger EOF marker than 12 characters )
 cr
;
: get-char ( -- c )
 key dup emit dup here 1 chars allot c!
;
: line-in ( -- u )
 0 begin 1 + get-char 13 = until 1 -
;
: &lt;&lt;&lt; ( -- c- u )
\ A parsing &lt;&lt;&lt; would be cute but I don't want to deal with writing one
  get-terminator here -rot
  begin
  	line-in
	here over - 1 - swap 2over
  	compare not
  until
  drop drop here over -
;
&lt;&lt;&lt; EOF
This is a multiline here document
terminated by EOF on a line by itself
EOF</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN17"
>Accessing Substrings</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">: substr ( c- u u u -- c- u )
  dup 0=
  if
    drop tuck -
  else
    2dup + 2swap -rot dup -rot &gt;
    if
      rot drop 2dup swap - nip
    else
      drop swap
    then
  then
  -rot + 0 -rot swap here swap 2dup chars allot drop 0
  do
    over i + c@ over i + c! rot 1+ -rot
  loop
  nip swap
;
: value string offset count substr ;
: value string offset 0 substr ;

: reassign ( c- u u u c- u -- c- u )
  { addr1 strlen1 offset count addr2 strlen2 }
  strlen1 count - strlen2 + allocate throw
  addr1 over offset cmove
  addr2 over offset chars + strlen2 cmove
  addr1 offset chars + count chars +
	over offset chars + strlen2 chars + strlen1 count - offset - cmove
  strlen1 count - strlen2 +
;
string offset count newstring reassign
( ----------------------------
get a 5-byte string, skip 3, then grab 2 8-byte strings, then the rest. )
: unpack ( c- u -- c-1 u1 c-2 u2 c-3 u3 c-4 u4 )
  2&gt;r
  5 chars allocate throw 2r@ drop over 5 cmove 5
  8 chars allocate throw 2r@ drop 8 chars + over 8 cmove 8
  8 chars allocate throw 2r@ drop 16 chars + over 8 cmove 8
  2r&gt; 24 - dup chars allocate throw dup 2swap &gt;r r@ swap 24 + -rot cmove
  r&gt;
;

( split at five byte boundaries )
: fivers ( c- u -- c-1 u1 c-2 u2 ... c-n un )
  5 / 0
  do
    5 chars allocate throw 2dup swap i 5 * chars + swap 5 cmove 5 rot
  loop
  drop
;

( chop string into individual characters )
: chop ( c- u -- c1 c2 ... cn )
  0 do dup i chars + c@ swap loop drop ;
( ---------------------------- )
: string s&quot; This is what you have&quot; ;
: first string drop 1 ; ( &quot;T&quot; )
: start string drop 5 chars + 2 ; ( &quot;is&quot; )
: rest string 13 swap over - -rot chars + swap; ( &quot;you have&quot; )
: last string 1 - chars + 1 ; ( &quot;e&quot; )
: end string 4 - chars + 4 ; ( &quot;have&quot; )
: piece string 8 - chars + 3 ; ( &quot;you&quot; )
( ---------------------------- )
: string s&quot; This is what you have&quot; ;
string type
( This is what you have )

string 5 2 s&quot; wasn't&quot; reassign ( change &quot;is&quot; to &quot;wasn't&quot;
This wasn't what you have )

string 13 12 s&quot; ondrous&quot; reassign ( replace last 12 characters
This wasn't wondrous )

string swap 1 chars + swap 1 - ( delete first character
his wasn't wondrous )

string 10 - dup -rot resize throw swap ( delete last 10 characters
his wasn' )
( ----------------------------
 TODO RE's
------------------------------
 exchange first and last letters in a string )
: a s&quot; make a hat&quot; ;
: exchange ( c- u -- )
  1 - 2dup chars + c@ -rot over c@ -rot chars over + rot swap c! c!
;
a exchange type
( take a ham

------------------------------

extract column )
: a &quot;To be or not to be&quot; ;
: b ( c- u u u -- c- u )
  dup
  chars
  allocate throw swap ( c- len off cou c-2 )
  &gt;r &gt;r nip chars + 2r@ cmove r&gt; r&gt;
;

a 6 6 ( skip 6, grab 6 )
b type
( or not )</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN20"
>Establishing a Default Value</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">( use b if b is true, else c )
: default ( x a- -- ) dup @ not if ! else 2drop then ;
c b default a !

( set x to y unless x is already true )
: !? dup if ! else drop then ;
x dup @ 0= y @ and  swap !?</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN23"
>Exchanging Values Without Using Temporary Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">: swap! ( x x -- )
  2dup @ swap @ rot ! swap !
;
var1 var2 swap!
( ---------------------------- )
variable temp
a @ temp !
b @ a !
temp @ b !
( ---------------------------- )</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN26"
>Converting Between ASCII Characters and Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">( not an issue, really; a char is just an integer and stored as a cell on the stack )
: ord ( c -- u ) ;
: chr ( u -- c ) ;
( or, to see the char  )
: chr ( u -- ) emit ;
( but if it's an actual variable rather than a stack element: )
: ord ( c- -- a- ) 1 cells allocate throw swap c@ swap ! ;
: chr ( a- -- c- ) 1 chars allocate throw swap @ swap c! ;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN29"
>Processing a String One Character at a Time</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">( with a literal word )
: process-string ( c- u -- variable stack effect )
  0 do dup i chars + c@ ( your-word ) swap loop drop
;

( or better yet, with an execution token )
: map-xt ( xt c- u -- variable stack effect )
 0 do 2dup i chars + c@ swap execute loop
;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32"
>Reversing a String by Word or Character</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">
: 4dup-nip ( a b c d -- a b c d a b d  )
    2over 2over nip
;

: c[i]@ ( c- i -- c )   chars + c@
;

: c[i]! ( c- i c -- )
    chars + c!
;

: -cmove ( c- x c- -- c- x  )
    over 0
    u+do 	i 4dup-nip
	1+ - c[i]@
	2over nip rot c[i]!
    loop
    rot drop swap
;

: revbytes ( c- x -- c- x )
    dup allocate throw
    -cmove
;

: gnirts s&quot; string&quot; revbytes ;

: space?
    32 =
;

: ^? ( c c- a -- c t )
    c[i]@
    tuck      space? not       swap      space? and     ;

: -^? ( c c- a -- c t )
    c[i]@
    tuck
    space?
    swap
    space? not and
;

: count-words ( c- x -- x )
    0 -rot 32 swap
    0 u+do
	over i ^? if
	    rot 1+ -rot
	then
    loop
    drop drop
;

: last-spaces ( c- x -- x )
    0 -rot
    begin
	1-
	2dup
	c[i]@
	space?
	over 0 &gt;=
	and
    while
	    rot 1+ -rot
    repeat
    drop drop
;

: last-word ( c- x -- x )
    0 -rot
    begin
	1-
	2dup
	c[i]@
	space? not
	over 0 &gt;=
	and
    while
	    rot 1+ -rot
    repeat
    drop drop
;

: back&gt;front ( c- x c- x -- )
    2swap 2dup last-word -rot
    chars + over chars - swap
    rot drop rot swap
    cmove  ;

: sback&gt;front ( c- x c- x -- )
    2swap 2dup last-spaces -rot
    chars + over chars - swap
    rot drop rot swap
    cmove
;

: sdrow ( c- x -- c- x )      2dup last-spaces -
dup &gt;r dup chars allocate throw
    dup &gt;r
    over 2swap 2dup count-words               0 u+do
2dup last-word &gt;r       	2over 2over 2swap back&gt;front r@
	- rot drop dup -rot 2swap
	r&gt;
	rot + swap 2swap
	2dup last-spaces &gt;r
	2over 2over 2swap sback&gt;front r@
	- rot drop dup -rot 2swap
	r&gt;
	rot + swap 2swap
    loop
    2drop 2drop
    r&gt; r&gt;
;

: count-spaces ( c- x -- x )
    0 -rot
    0 u+do
	dup i c[i]@ space? if
	    swap 1+ swap
	then
    loop
    drop
;

: move-if-not-space ( c- c- -- f )
    swap c@ dup space?
    if
	drop drop false
    else
	swap c! true
    then
;

: squash-words ( c- x -- c- x )
    2dup count-spaces
    over swap -
    dup chars allocate throw
    swap &gt;r dup &gt;r
    -rot
    0 u+do
	2dup
	i chars +
	swap
	move-if-not-space if
	    swap 1 chars + swap
	then
    loop
    drop drop r&gt; r&gt;
;

: confused ( c- x -- c- x )
    squash-words
    revbytes
;

80 constant biggest-word
create buff biggest-word 2 + allot

: palindrome? ( c- x -- f )
    2dup revbytes
    compare not
;

: chomp ( c- x -- c- x )
    2dup last-spaces -
;
s&quot; /usr/share/dict/words&quot;  r/o open-file throw value dict

: scan-dictionary ( c- x --  )
    begin
	buff biggest-word dict read-line throw
    while
	    dup buff swap chomp
	    dup 5 &gt; -rot
	    palindrome? and if
		buff swap type cr
	    else
		drop
	    then
    repeat
;
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>
</HTML></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN35"
>Expanding and Compressing Tabs</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN38"
>Expanding Variables in User Input</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41"
>Controlling Case</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44"
>Interpolating Functions and Expressions Within Strings</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN47"
>Indenting Here Documents</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN50"
>Reformatting Paragraphs</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN53"
>Escaping Characters</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56"
>Trimming Blanks from the Ends of a String</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN59"
>Parsing Comma-Separated Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN62"
>Soundex Matching</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN65"
>Program: fixstyle</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN68"
>Program: psgrep</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="numbers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>PLEAC-Forth</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Numbers</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>