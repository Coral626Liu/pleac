<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Strings</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-PicoLisp
"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="PLEAC-PicoLisp
"
HREF="index.html"><LINK
REL="NEXT"
TITLE="Numbers"
HREF="numbers.html"></HEAD
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-PicoLisp
</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="numbers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="STRINGS"
>1. Strings</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN14"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><I><FONT COLOR="#B22222"></FONT></I><I><FONT COLOR="#B22222"># PicoLisp has no special string type. Instead, symbols are used. Syntactically,
</FONT></I><I><FONT COLOR="#B22222"># &quot;transient&quot; symbols resemble strings in other languages. Also, there is no
</FONT></I><I><FONT COLOR="#B22222"># separate character type. Instead, characters are represented by strings of
</FONT></I><I><FONT COLOR="#B22222"># length 1 (using 1 .. 3 bytes (UTF-8)).
</FONT></I><I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>(setq String <B><FONT COLOR="#BC8F8F">&quot;^J&quot;</FONT></B>)             <I><FONT COLOR="#B22222"># a newline character
</FONT></I>(setq String <B><FONT COLOR="#BC8F8F">&quot;\^J&quot;</FONT></B>)            <I><FONT COLOR="#B22222"># two characters, '^' and 'J'
</FONT></I><I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>: <B><FONT COLOR="#BC8F8F">&quot;Jon \&quot;Maddog\&quot; Orwant&quot;</FONT></B>      <I><FONT COLOR="#B22222"># literal double quotes
</FONT></I>-&gt; <B><FONT COLOR="#BC8F8F">&quot;Jon \&quot;Maddog\&quot; Orwant&quot;</FONT></B>

<I><FONT COLOR="#B22222"># Single quotes do not delimit strings, and are not special inside strings
</FONT></I><I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>: <B><FONT COLOR="#BC8F8F">&quot;This is a multiline string
containing a newline&quot;</FONT></B>
-&gt; <B><FONT COLOR="#BC8F8F">&quot;This is a multiline string^Jcontaining a newline&quot;</FONT></B>

: <B><FONT COLOR="#BC8F8F">&quot;This is a multiline string \
without a newline&quot;</FONT></B>
-&gt; <B><FONT COLOR="#BC8F8F">&quot;This is a multiline string without a newline&quot;</FONT></B>
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN17"
>Accessing Substrings</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><I><FONT COLOR="#B22222"></FONT></I><I><FONT COLOR="#B22222"># First 'chop' the string to convert it to a list of characters, and then use
</FONT></I><I><FONT COLOR="#B22222"># the rich set of list processing functions. Optionally, you can 'pack' the
</FONT></I><I><FONT COLOR="#B22222"># result to a string (not necessary in many cases, as many functions that expect
</FONT></I><I><FONT COLOR="#B22222"># a string also accept a list of characters).
</FONT></I><I><FONT COLOR="#B22222">#-----------------------------
</FONT></I><I><FONT COLOR="#B22222"># get a 5-byte string, skip 3, then grab 2 8-byte strings, then the rest
</FONT></I>: (let S (<B><FONT COLOR="#A020F0">chop</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;This is a suitable string&quot;</FONT></B>)
   (prinl (cut 5 <B><FONT COLOR="#BC8F8F">'S))
   (cut 3 '</FONT></B>S)
   (prinl (cut 8 <B><FONT COLOR="#BC8F8F">'S))
   (prinl (cut 8 '</FONT></B>S))
   (prinl S) )
This
a suitab
<B><FONT COLOR="#A020F0">le</FONT></B> strin
g
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I><I><FONT COLOR="#B22222"># split at five byte boundaries
</FONT></I>: (make (<B><FONT COLOR="#A020F0">for</FONT></B> (S (<B><FONT COLOR="#A020F0">chop</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;This is what you have&quot;</FONT></B>)  S)
   (<B><FONT COLOR="#A020F0">link</FONT></B> (<B><FONT COLOR="#A020F0">pack</FONT></B> (cut 5 <B><FONT COLOR="#BC8F8F">'S))) ) )
-&gt; (&quot;This &quot; &quot;is wh&quot; &quot;at yo&quot; &quot;u hav&quot; &quot;e&quot;)
#-----------------------------
(let S (chop &quot;This is what you have&quot;)
   (prinl (car S))
   (prinl (tail 2 (head 4 S)))
   (prinl (tail -13 S))
   (prinl (tail 1 S))
   (prinl (tail 4 S))
   (prinl (head 3 (tail 8 S))) )
T
is
you have
e
have
you
#-----------------------------
# You can test for substrings with '</FONT></B>pre?<B><FONT COLOR="#BC8F8F">' and '</FONT></B><B><FONT COLOR="#A020F0">sub</FONT></B>?<B><FONT COLOR="#BC8F8F">'
: (pre? &quot;a&quot; &quot;abc&quot;)
-&gt; &quot;abc&quot;

: (sub? &quot;bc&quot; &quot;abcdef&quot;)
-&gt; &quot;abcdef&quot;

:  (sub? &quot;x&quot; &quot;abc&quot;)
-&gt; NIL

# or use the '</FONT></B>match<B><FONT COLOR="#BC8F8F">' function
: (match '</FONT></B>(<B><FONT COLOR="#BC8F8F">&quot;a&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;b&quot;</FONT></B> @X <B><FONT COLOR="#BC8F8F">&quot;d&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;e&quot;</FONT></B>) (<B><FONT COLOR="#A020F0">chop</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;abcde&quot;</FONT></B>))
-&gt; T
: @X
-&gt; (<B><FONT COLOR="#BC8F8F">&quot;c&quot;</FONT></B>)
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I><I><FONT COLOR="#B22222"># substitute &quot;at&quot; for &quot;is&quot;, restricted to first five characters
</FONT></I>: (match <B><FONT COLOR="#BC8F8F">'(@A &quot;i&quot; &quot;s&quot; @Z) (head 5 (chop &quot;Me is You&quot;))) (pack @A &quot;at&quot; @Z)
-&gt; &quot;Me at&quot;
#-----------------------------
# exchange the first and last letters in a string
: (let S (chop &quot;make a hat&quot;)
   (xchg S (tail 1 S))
   (pack S) )
-&gt; &quot;take a ham&quot;
#-----------------------------
# extract column
: (pack (tail 6 (head 12 (chop &quot;To be or not to be&quot;))))
-&gt; &quot;or not&quot;
#-----------------------------
# skip every second character
: (pack (filter prog2 (chop &quot;To be or not to be&quot;) '</FONT></B>(T NIL .)))
-&gt; <B><FONT COLOR="#BC8F8F">&quot;T eo o ob&quot;</FONT></B>
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN20"
>Establishing a Default Value</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><I><FONT COLOR="#B22222"></FONT></I><I><FONT COLOR="#B22222">#-----------------------------
</FONT></I><I><FONT COLOR="#B22222"># Use B if B is true, else C
</FONT></I>(setq A (<B><FONT COLOR="#A020F0">or</FONT></B> B C))

<I><FONT COLOR="#B22222"># set X to Y unless X is already true
</FONT></I>(default X Y)
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I><I><FONT COLOR="#B22222"># use B if B is defined, else C
</FONT></I>(setq A (<B><FONT COLOR="#A020F0">or</FONT></B> (fun? B) C))
(def <B><FONT COLOR="#BC8F8F">'A (or (fun? B) C))
#-----------------------------
(setq Dir (or (opt) &quot;/tmp&quot;))
#-----------------------------
(setq Dir (if (argv) (car @) &quot;/tmp&quot;))
#-----------------------------
# find the user name on Unix systems
(setq User
   (or
      (sys &quot;USER&quot;)
      (sys &quot;LOGNAME&quot;)
      (native &quot;@&quot; &quot;getlogin&quot; '</FONT></B>S)  <I><FONT COLOR="#B22222"># 'native' only in 64-bits
</FONT></I>      (car (native <B><FONT COLOR="#BC8F8F">&quot;@&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;getpwuid&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">'(S) UserID))
      (pack &quot;Unknown uid number &quot; UserID) ) )
#-----------------------------
: (default StartingPoint &quot;Greenwich&quot;)
-&gt; &quot;Greenwich&quot;
#-----------------------------
(setq A (if B B C))            # assign B if nonempty, else C
#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN23"
>Exchanging Values Without Using Temporary Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
(xchg '</FONT></B>Var1 <B><FONT COLOR="#BC8F8F">'Var2)
#-----------------------------
(setq Temp A  A B  B Temp)
#-----------------------------
(setq A &quot;alpha&quot;  B &quot;omega&quot;) (xchg '</FONT></B>A <B><FONT COLOR="#BC8F8F">'B)
#-----------------------------
: (setq Alpha '</FONT></B>January Beta <B><FONT COLOR="#BC8F8F">'March Production '</FONT></B>August)
-&gt; August
: (setq Alpha Beta  Beta Production  Production Alpha)
-&gt; March
: Alpha
-&gt; March
: Beta
-&gt; August
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN26"
>Converting Between ASCII Characters and Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><I><FONT COLOR="#B22222"></FONT></I><I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>(char Character) -&gt; Number
(char Number) -&gt; Character
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>: (let Num 101
   (prinl <B><FONT COLOR="#BC8F8F">&quot;Number &quot;</FONT></B> Num <B><FONT COLOR="#BC8F8F">&quot; is character &quot;</FONT></B> (char Num)) )
Number 101 is character e
-&gt; <B><FONT COLOR="#BC8F8F">&quot;e&quot;</FONT></B>
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>: (mapcar char (<B><FONT COLOR="#A020F0">chop</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;sample&quot;</FONT></B>))
-&gt; (115 97 109 112 108 101)

: (<B><FONT COLOR="#A020F0">pack</FONT></B> (mapcar char (115 97 109 112 108 101)))
-&gt; <B><FONT COLOR="#BC8F8F">&quot;sample&quot;</FONT></B>
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>: (<B><FONT COLOR="#A020F0">pack</FONT></B>
   (mapcar
      <B><FONT COLOR="#BC8F8F">'((C) (char (inc (char C))))
      (chop &quot;HAL&quot;) ) )
-&gt; &quot;IBM&quot;
#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN29"
>Processing a String One Character at a Time</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
(for Char (chop String)
   (doSomethingWith Char) )
#-----------------------------
: (prinl &quot;unique chars are: &quot; (sort (uniq (chop &quot;an apple a day&quot;))))
unique chars are:  adelnpy

# Analog to Perl
: (let Seen NIL
   (for C (chop &quot;an apple a day&quot;)
      (accu '</FONT></B>Seen C 1) )
   (<B><FONT COLOR="#A020F0">pack</FONT></B> (<B><FONT COLOR="#A020F0">sort</FONT></B> (mapcar car Seen))) )
-&gt; <B><FONT COLOR="#BC8F8F">&quot; adelnpy&quot;</FONT></B>
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>: (sum char (<B><FONT COLOR="#A020F0">chop</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;an apple a day&quot;</FONT></B>))
-&gt; 1248
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I><I><FONT COLOR="#B22222"># <font size="-1"><a href="http://pleac.sourceforge.net/include/picolisp/ch01/sum">download the following standalone program</a></font>
</FONT></I><I><FONT COLOR="#B22222">#!/usr/bin/picolisp /usr/lib/picolisp/lib.l
</FONT></I><I><FONT COLOR="#B22222"># sum - compute 16-bit checksum of all input files
</FONT></I>
(let Sum 0
   (<B><FONT COLOR="#A020F0">while</FONT></B> (opt)
      (in @
         (<B><FONT COLOR="#A020F0">while</FONT></B> (char) (inc <B><FONT COLOR="#BC8F8F">'Sum (char @))) ) )
   (println (% Sum 65535)) )

(bye)

#-----------------------------
$ ./sum lib.l lib/misc.l
52659
#-----------------------------
# <font size="-1"><a href="http://pleac.sourceforge.net/include/picolisp/ch01/slowcat">download the following standalone program</a></font>
#!/usr/bin/picolisp /usr/lib/picolisp/lib.l
# slowcat - emulate a   s l o w   line printer
# usage: slowcat [-DELAY] [files ...]

(let Delay (ifn (lt0 (format (car (argv)))) 1 (opt) (- @))
   (for F (argv)
      (for C (in F (till))
         (prin C)
         (wait (* 5 Delay)) ) ) )

(bye)

#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32"
>Reversing a String by Word or Character</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
(setq
   RevChars (flip (chop String))
   RevWords (glue &quot; &quot; (flip (split (chop String) &quot; &quot;))) )
#-----------------------------
# reverse word order
: (glue &quot; &quot;
   (flip
      (split (chop &quot;Yoda said, \&quot;can you see this?\&quot;&quot;) &quot; &quot;) ) )
-&gt; &quot;this?\&quot; see you \&quot;can said, Yoda&quot;
#-----------------------------
: (de palindrome? (S)
   (= (setq S (chop S)) (reverse S)) )
: (palindrome? &quot;reviver&quot;)
-&gt; T
#-----------------------------
: (in &quot;/usr/share/dict/words&quot;
   (until (eof)
      (let L (line)
         (and
            (&gt; (length L) 5)
            (= L (reverse L))
            (prinl L) ) ) ) )
deified
redder
#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN35"
>Expanding and Compressing Tabs</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
(let Str (line)
   (use (@A @Z)                        # Expand tabs
      (while (match '</FONT></B>(@A <B><FONT COLOR="#BC8F8F">&quot;^I&quot;</FONT></B> @Z) Str)
         (setq Str
            (conc
               @A
               (need (- 8 (% (<B><FONT COLOR="#A020F0">length</FONT></B> @A) 8)) <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>)
               @Z ) ) ) )
   Str )
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>(let Str (line)
   (make                               <I><FONT COLOR="#B22222"># Compress tabs
</FONT></I>      (<B><FONT COLOR="#A020F0">while</FONT></B> (nth Str 9)
         (let S (trim (cut 8 <B><FONT COLOR="#BC8F8F">'Str))
            (chain S)
            (or (= 8 (length S)) (link &quot;^I&quot;)) ) )
      (and Str (chain @)) ) )
#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN38"
>Expanding Variables in User Input</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
: (let Dept 123
   (prinl &quot;You owe &quot; Dept &quot; to me.&quot;)
   (pack &quot;You owe &quot; Dept &quot; to me.&quot;) )
You owe 123 to me.
-&gt; &quot;You owe 123 to me.&quot;
#-----------------------------
: (text &quot;I am @1 high and @2 long&quot; 24 80)
-&gt; &quot;I am 24 high and 80 long&quot;
#-----------------------------
(let (@Rows 24  @Cols 80)
   (fill '</FONT></B>(I am @Rows high <B><FONT COLOR="#A020F0">and</FONT></B> @Cols long)) )
-&gt; (I am 24 high <B><FONT COLOR="#A020F0">and</FONT></B> 80 long)
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I><I><FONT COLOR="#B22222"># expand variables in 'Lst', but put an error message in
</FONT></I><I><FONT COLOR="#B22222"># if the variable isn't defined
</FONT></I>(let (@Rows 24  Lst <B><FONT COLOR="#BC8F8F">'(I am @Rows high and @Cols long))
   (for Var (fish pat? Lst)
      (unless (val Var)
         (set Var (pack &quot;[NO VARIABLE: &quot; Var &quot;]&quot;)) ) )
   (fill Lst) )
-&gt; (I am 24 high and &quot;[NO VARIABLE: @Cols]&quot; long)
#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN41"
>Controlling Case</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
: (uppc &quot;bo peep&quot;)
-&gt; &quot;BO PEEP&quot;
: (lowc &quot;JOHN&quot;)
-&gt; &quot;john&quot;
: (let S (chop &quot;dromedary&quot;) (pack (uppc (car S)) (cdr S)))
-&gt; &quot;Dromedary&quot;
#-----------------------------
# capitalize each word'</FONT></B><B><FONT COLOR="#A020F0">s</FONT></B> first character, downcase the rest
(let Str <B><FONT COLOR="#BC8F8F">&quot;thIS is a loNG liNE&quot;</FONT></B>
   (glue <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
      (mapcar
         <B><FONT COLOR="#BC8F8F">'((W) (cons (uppc (car W)) (mapcar lowc (cdr W))))
         (split (chop Str) &quot; &quot;) ) ) )
-&gt; &quot;This Is A Long Line&quot;
#-----------------------------
(when (= (uppc A) (uppc B))
   (prinl &quot;A and B are the same&quot;) )
#-----------------------------
# <font size="-1"><a href="http://pleac.sourceforge.net/include/picolisp/ch01/randcap">download the following standalone program</a></font>
#!/usr/bin/picolisp /usr/lib/picolisp/lib.l
# randcap: filter to randomly capitalize 20% of the letters

(in NIL
   (while (char)
      (let C @
         (prin (if (=0 (rand 0 4)) (uppc C) C)) ) ) )

(bye)

#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44"
>Interpolating Functions and Expressions Within Strings</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
: (let N 7
   (prinl &quot;I have &quot; (+ N 2) &quot; guanacos.&quot;)
   (pack &quot;I have &quot; (+ N 2) &quot; guanacos.&quot;) )
I have 9 guanacos.
-&gt; &quot;I have 9 guanacos.&quot;
#-----------------------------
: (let N 7
   (text &quot;I have @1 guanacos.&quot; (+ N 2)) )
#-----------------------------
(mail &quot;localhost&quot; 25 &quot;Your Bank&quot; Naughty &quot;Subject&quot;
   (prinl &quot;Dear &quot; Naughty)
   &quot;&quot;
   (prinl &quot;Today, you bounced check number &quot; (+ 500 (rand 0 99)) &quot; to us.&quot;)
   &quot;Your account is now closed.&quot;
   &quot;&quot;
   &quot;Sincerely,&quot;
   &quot;the management&quot; )
#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN47"
>Indenting Here Documents</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
(de myhere (Target)  # The built-in '</FONT></B>here<B><FONT COLOR="#BC8F8F">' cannot be used
   (char)
   (setq Target (chop Target))
   (make
      (for (L (line)  (and L (&lt;&gt; L Target))  (line))
         (link L) ) ) )
#-----------------------------
(setq Var (mapcar clip (myhere &quot;HERE_TARGET&quot;)))
   your text
   goes here
HERE_TARGET

# or with two steps
(setq Var (myhere &quot;HERE_TARGET&quot;))
   your text
   goes here
HERE_TARGET
(setq Var (mapcar clip Var))
#-----------------------------
(prinl &quot;Here'</FONT></B><B><FONT COLOR="#A020F0">s</FONT></B> your poem:<B><FONT COLOR="#BC8F8F">&quot;)
(prinl)
(let (Str (prog (char) (line))  Cnt 1)
   (for (S Str  (and S (sp? (car S)))  (cdr S))
      (inc 'Cnt) )
   (loop
      (prinl (nth Str Cnt))
      (T (eof))
      (setq Str (line))
      (T (=  '`(chop &quot;</FONT></B>EVER_ON_AND_ON<B><FONT COLOR="#BC8F8F">&quot;) Str)) ) )
   Now far ahead the Road has gone,
      And I must follow, if I can,
   Pursuing it with eager feet,
      Until it joins some larger way
   Where many paths and errands meet.
      And whither then? I cannot say.
            --Bilbo in /usr/src/perl/pp_ctl.c
EVER_ON_AND_ON
#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN50"
>Reformatting Paragraphs</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
# <font size="-1"><a href="http://pleac.sourceforge.net/include/picolisp/ch01/wrapdemo">download the following standalone program</a></font>
#!/usr/bin/picolisp /usr/lib/picolisp/lib.l

(load &quot;</FONT></B>@lib/misc.l<B><FONT COLOR="#BC8F8F">&quot;)

(let Input
   (chop
      (wrap 17
         (conc (need 4 &quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;)
            (chop
               &quot;</FONT></B>Folding <B><FONT COLOR="#A020F0">and</FONT></B> splicing is the work of an editor, \
               <B><FONT COLOR="#A020F0">not</FONT></B> a mere collection of silicon \
               <B><FONT COLOR="#A020F0">and</FONT></B> \
               mobile electrons!<B><FONT COLOR="#BC8F8F">&quot; ) ) ) )
   (prinl (replace Input &quot;</FONT></B>^J<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>^J  <B><FONT COLOR="#BC8F8F">&quot;)) )

(bye)

#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN53"
>Escaping Characters</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
# backslash
: (let (CharList '(a d g)  Str &quot;</FONT></B>abcdefghi<B><FONT COLOR="#BC8F8F">&quot;)
   (pack
      (mapcar
         '((C) (pack (and (member C CharList) &quot;</FONT></B>\\&quot;) C))
         (<B><FONT COLOR="#A020F0">chop</FONT></B> Str) ) ) )
-&gt; <B><FONT COLOR="#BC8F8F">&quot;\\abc\\def\\ghi&quot;</FONT></B>

<I><FONT COLOR="#B22222"># double
</FONT></I>: (let (CharList <B><FONT COLOR="#BC8F8F">'(a d g)  Str &quot;abcdefghi&quot;)
   (pack
      (mapcar
         '</FONT></B>((C) (<B><FONT COLOR="#A020F0">pack</FONT></B> (<B><FONT COLOR="#A020F0">and</FONT></B> (member C CharList) C) C))
         (<B><FONT COLOR="#A020F0">chop</FONT></B> Str) ) ) )
-&gt; <B><FONT COLOR="#BC8F8F">&quot;aabcddefgghi&quot;</FONT></B>
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN56"
>Trimming Blanks from the Ends of a String</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><I><FONT COLOR="#B22222"></FONT></I><I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>(trim (<B><FONT COLOR="#A020F0">chop</FONT></B> String))  <I><FONT COLOR="#B22222"># Remove trailing white space
</FONT></I>(clip (<B><FONT COLOR="#A020F0">chop</FONT></B> String))  <I><FONT COLOR="#B22222"># Remove white space from both ends
</FONT></I><I><FONT COLOR="#B22222">#-----------------------------
</FONT></I><I><FONT COLOR="#B22222"># print what's typed, but surrounded by &gt;&lt; symbols
</FONT></I>(in NIL
   (<B><FONT COLOR="#A020F0">until</FONT></B> (<B><FONT COLOR="#A020F0">eof</FONT></B>)
      (prinl <B><FONT COLOR="#BC8F8F">&quot;&gt;&quot;</FONT></B> (clip (line)) <B><FONT COLOR="#BC8F8F">&quot;&lt;&quot;</FONT></B>) ) )
<I><FONT COLOR="#B22222">#-----------------------------
</FONT></I></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN59"
>Parsing Comma-Separated Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><I><FONT COLOR="#B22222"></FONT></I><I><FONT COLOR="#B22222">#-----------------------------
</FONT></I>(<B><FONT COLOR="#A020F0">for</FONT></B> (I . Line)
   (let *Uni T
      (str
         <B><FONT COLOR="#BC8F8F">&quot;XYZZY,\&quot;\&quot;,\&quot;O'Reilly, Inc\&quot;,\&quot;Wall, Larry\&quot;,\&quot;a \
         \\\&quot;glug\\\&quot; bit,\&quot;,5,  \&quot;Error, Core Dumped\&quot;&quot;</FONT></B> ) )
   (prinl I <B><FONT COLOR="#BC8F8F">&quot; : &quot;</FONT></B> Line) )
1 : XYZZY
2 :
3 : O<B><FONT COLOR="#BC8F8F">'Reilly, Inc
4 : Wall, Larry
5 : a &quot;glug&quot; bit,
6 : 5
7 : Error, Core Dumped
#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN62"
>Soundex Matching</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
# <font size="-1"><a href="http://pleac.sourceforge.net/include/picolisp/ch01/soundex">download the following standalone program</a></font>
#!/usr/bin/picolisp /usr/lib/picolisp/lib.l

(load &quot;@lib/misc.l&quot;)

(de soundex (Str)
   (pack
      (pad -4
         (cons
            (uppc (char (char Str)))
            (head 3
               (let Last NIL
                  (extract
                     '</FONT></B>((C)
                        (<B><FONT COLOR="#A020F0">and</FONT></B>
                           (setq C
                              (case (uppc C)
                                 (<B><FONT COLOR="#BC8F8F">`(chop &quot;BFPV&quot;) &quot;1&quot;)
                                 (`</FONT></B>(<B><FONT COLOR="#A020F0">chop</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;CGJKQSXZ&quot;</FONT></B>) <B><FONT COLOR="#BC8F8F">&quot;2&quot;</FONT></B>)
                                 ((<B><FONT COLOR="#BC8F8F">&quot;D&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;T&quot;</FONT></B>) <B><FONT COLOR="#BC8F8F">&quot;3&quot;</FONT></B>)
                                 (<B><FONT COLOR="#BC8F8F">&quot;L&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;4&quot;</FONT></B>)
                                 ((<B><FONT COLOR="#BC8F8F">&quot;M&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;N&quot;</FONT></B>) <B><FONT COLOR="#BC8F8F">&quot;5&quot;</FONT></B>)
                                 (<B><FONT COLOR="#BC8F8F">&quot;R&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;6&quot;</FONT></B>) ) )
                           (&lt;&gt; Last C)
                           (setq Last C) ) )
                     (cdr (<B><FONT COLOR="#A020F0">chop</FONT></B> Str)) ) ) ) ) ) ) )

(prin <B><FONT COLOR="#BC8F8F">&quot;Lookup user: &quot;</FONT></B>)
(flush)
(let (User (clip (in NIL (line T)))  Code (soundex User))
   (<B><FONT COLOR="#A020F0">while</FONT></B> (native <B><FONT COLOR="#BC8F8F">&quot;@&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;getpwent&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">'(S S I I S S S))  # '</FONT></B>native<B><FONT COLOR="#BC8F8F">' only in 64-bits
      (let Lst @
         (when (or (= Code (soundex (car Lst))) (= Code (soundex (get Lst 5))))
            (println Lst) ) ) ) )

(bye)

#-----------------------------
$ ./soundexUsers
Lookup user: sshd
(&quot;sshd&quot; &quot;x&quot; 71 65 &quot;SSH daemon&quot; &quot;/var/lib/sshd&quot; &quot;/bin/false&quot;)
#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN65"
>Program: fixstyle</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
# <font size="-1"><a href="http://pleac.sourceforge.net/include/picolisp/ch01/fixstyle">download the following standalone program</a></font>
#!/usr/bin/picolisp /usr/lib/picolisp/lib.l
# Use: ./fixstyle [-v] &lt;infile &gt;outfile

(and (= &quot;-v&quot; (opt)) (on *Verbose))

(de Data
   (&quot;analysed&quot; . &quot;analyzed&quot;)
   (&quot;built-in&quot; . &quot;builtin&quot;)
   (&quot;chastized&quot; . &quot;chastised&quot;)
   (&quot;commandline&quot; . &quot;command-line&quot;)
   (&quot;de-allocate&quot; . &quot;deallocate&quot;)
   (&quot;dropin&quot; . &quot;drop-in&quot;)
   (&quot;hardcode&quot; . &quot;hard-code&quot;)
   (&quot;meta-data&quot; . &quot;metadata&quot;)
   (&quot;multicharacter&quot; . &quot;multi-character&quot;)
   (&quot;multiway&quot; . &quot;multi-way&quot;)
   (&quot;non-empty&quot; . &quot;nonempty&quot;)
   (&quot;non-profit&quot; . &quot;nonprofit&quot;)
   (&quot;non-trappable&quot; . &quot;nontrappable&quot;)
   (&quot;pre-define&quot; . &quot;predefine&quot;)
   (&quot;preextend&quot; . &quot;pre-extend&quot;)
   (&quot;re-compiling&quot; . &quot;recompiling&quot;)
   (&quot;reenter&quot; . &quot;re-enter&quot;)
   (&quot;turnkey&quot; . &quot;turn-key&quot;) )

(in NIL
   (while (apply echo '</FONT></B><B><FONT COLOR="#BC8F8F">`(mapcar car Data))
      (let (Key @  Val (get Data Key))
         (when *Verbose
            (out 2 (prinl Key &quot; =&gt; &quot; Val)) )
         (prin Val) ) ) )

(bye)

#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN68"
>Program: psgrep</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">#-----------------------------
# <font size="-1"><a href="http://pleac.sourceforge.net/include/picolisp/ch01/psgrep">download the following standalone program</a></font>
#!/usr/bin/picolisp /usr/lib/picolisp/lib.l

# Use: psgrep 'lisp-expression'
#
# Takes a single optional argument:
# An arbitrary lisp expression without the outermost parentheses
#
# For example:
#    psgrep '= &quot;Ss+&quot; STAT'
#    psgrep 'and (&gt; SIZE 10000) (= TT &quot;tty1&quot;)'
#    psgrep 'member UID (101 102 104 106)'
#
# The variables (case-sensitive!) have the
# same names as the column headers

(load &quot;@lib/misc.l&quot;)

(de PsFields
   (F         1  &quot;flags&quot;   NIL (read))
   (UID       6  &quot;uid&quot;     NIL (read))
   (PID       6  &quot;pid&quot;     NIL (read))
   (PPID      6  &quot;ppid&quot;    NIL (read))
   (PRI       4  &quot;pri&quot;     NIL (read))
   (NI        4  &quot;nice&quot;    NIL (read))
   (NIL       1)
   (SIZE      5  &quot;size&quot;    NIL (read))
   (NIL       1)
   (RSS       5  &quot;rss&quot;     NIL (read))
   (NIL       1)
   (WCHAN    -7  &quot;wchan&quot;   NIL (skip) (till &quot; &quot; T))
   (STAT     -5  &quot;stat&quot;    NIL (skip) (till &quot; &quot; T))
   (TT       -9  &quot;tty&quot;     NIL (skip) (till &quot; &quot; T))
   (TIME      8  &quot;time&quot;    (tim$ TIME T) (skip) ($tim (till &quot; &quot; T)))
   (NIL       1)
   (COMMAND -30  &quot;command&quot; NIL (char) (line T)) )

(let Cond (or (str (opt)) T)
   (in (list 'ps &quot;hax&quot; &quot;-o&quot; (glue &quot;,&quot; (extract caddr PsFields)))
      (let Fmt (mapcar cadr PsFields)
         (apply tab (mapcar car PsFields) Fmt)
         (bind (mapcar car PsFields)
            (until (eof)
               (for Fld PsFields
                  (when (car Fld)
                     (set @ (run (cddddr Fld))) ) )
               (when (eval Cond)
                  (apply tab
                     (mapcar
                        '((Fld) (or (eval (cadddr Fld)) (val (car Fld))))
                        PsFields )
                     Fmt ) ) ) ) ) ) )

(bye)

#-----------------------------</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="numbers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>PLEAC-PicoLisp
</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Numbers</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>