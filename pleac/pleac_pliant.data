# -*- pliant -*-

# @@PLEAC@@_NAME
# @@SKIP@@ Pliant

# @@PLEAC@@_WEB
# @@SKIP@@ http://pliant.cx

# @@PLEAC@@_INTRO
# @@SKIP@@ Written for version 64.
# @@SKIP@@ Code is function code to allow local variables (for readibility).

# @@PLEAC@@_APPENDIX

# multiline strings may be achieved by addition of a new
# parser filter
# We give here a full answer which goes a bit out the scope
# of a basic tutorial, but emphasizes the power of Pliant reflexiveness.
#

module "/pliant/language/parser.pli"
module "/pliant/language/compiler.pli"

#
# parser filter declaration helper function
#     mod is the module in which the filter is declared
#     section_name is the section in which the filter is inserted
#     ad is the address of the filter function
#     adp is the address of the filter parameter
#
function declare_filter2 mod section_name ad adp
  arg_rw Module mod; arg Str section_name; arg Address ad; arg Arrow adp
  var Link:ParserFilter lp :> new ParserFilter
  lp function :> ad map Function
  lp parameter := adp
  mod define section_name addressof:lp

#
# declare_filter meta
#
#    syntax: declare_filter section filter parameter [link|copy]
# inserts the filter 'filter' in section 'section' of the caller's module
# with parameter 'parameter'; By default, parameter is copied.
# parameter may be mapped by using 'link' keyword
#

meta declare_filter e
  if (e:size <> 2) and (e:size<>3) and (e:size<>4)
     return
  var Bool copy:=true
  if e:size=4
     if not e:3:is_pure_ident
        return
     if e:3:ident="copy"
        copy:=true
     eif e:3:ident="link"
        copy:=false
     else
        return
  var Link:Expression ef :> expression immediat (the_function fun ParserContext Str Address) substitute fun e:1 near e
  var Address ad := ef evaluate
  if error_notified
    return
  if ad=null
    error error_id_unexpected "Failed to evaluate expression at "+e:position
    e set_void_result
  var Arrow adp
  if e:size>=3
   e:2 compile ?
   var Pointer:Type ptype :> e:2:result:type
   var Link:Expression type_id :> expression ident ptype:name near e:2
   if copy
      ef :> expression immediat (new ptype pvalue) substitute ptype type_id substitute pvalue e:2 near e
      adp := ef evaluate
   else
      adp := e:2 evaluate
   if error_notified
      return
   if adp=null
      error error_id_unexpected "Failed to evaluate expression at "+e:position
      e set_void_result
  if (addressof e:module:external)=null
     var Link:Argument adr :> argument constant Address addressof:(e:module)
  else
     var Link:Argument adr :> argument constant Address addressof:(e:module:external)
  var Link:Argument ma :> argument indirect Module adr 0
  e add (instruction (the_function declare_filter2 Module Str Address Arrow) ma (argument constant Str e:0:ident) (argument constant Address ad) (argument constant Arrow adp))
  e set_void_result
#
# generic parse_text parser filter
# parameter is assumed to be a string corresponding to the keyword used.
# If parameter is "foo", then
#   foo a b c
#     hello
#    How are you ?
#       this morning...
#
# will be parsed as if written
#
#   foo a b c
#    " hello"
#    "How are you ?"
#    "   this morning..."
#

function parse_text context line parameter
  arg_rw ParserContext context ; arg Str line ; arg Address parameter
  var Pointer:Str kwd :> parameter map Str
  if (line 0 kwd:len)=kwd
    var Int x := 0
    var Pointer:Str l :> context:current_line map Str
    while l:x = " "
       x+=1
    var Pointer:Arrow cur :> context:text next context:current_line
    while cur<>null and { var Pointer:Str l :> cur map Str ; (l 0 x+1)=(repeat x+1 " ") or l=(repeat l:len " ") }
      var Str t := l x+1 l:len
      l := (repeat x+1 " ")+string:t
      cur :> context:text next cur

#
# simple multi-line text meta
#
# syntax:
# inline_text [leftcut|ignorefirst]
#   some text
#    over multiple lines...
#
meta inline_text e
  if e:size<1
     return
  var Link:Expression body :> e e:size-1
  if body:ident<>"{}" or body:size=0
     return
  for (var Int i) 0 body:size-1
     var Address ad := body:i constant Str
     if ad=null
        error error_id_unexpected "text: argument #"+string:i+" is not a constant Str"
        return
  var Bool leftcut := false; var Int leftmargin:=0; var Int start:=0
  var Str s
  if e:size>1 and e:0:is_pure_ident
   if e:0:ident="leftcut"
     leftcut:=true
     leftmargin := -1 # stands for infinity
   eif e:0:ident="ignorefirst"
     start := 1
     var Pointer:Str ss :> (body:0 constant Str) map Str
     ss eparse spaces:s
     leftmargin := s:len
  if leftcut
    for (var Int i) 0 body:size-1
       var Pointer:Str ss :> (body:i constant Str) map Str
       ss eparse spaces:s
       if s:len<leftmargin or leftmargin<0
         leftmargin:=s:len
  s:=""
  for (var Int i) start body:size-1
    var Pointer:Str ss :> (body:i constant Str) map Str
    s += (ss leftmargin ss:len)+"[lf]"
  e set_result (argument constant Str s) access_read

#
# filter declaration for immediat use
#
declare_filter 'pliant parser basic types' parse_text "inline_text" copy


# @@PLEAC@@_1.0
# In Pliant, the standard type to handle character strings is Str.
# String variables must be declared -- if no value is given it's
# value is the empty string ("") if the variable is global.
var Str string

# special characters
string := "[lb]"                   # character '['
string := "[rb]"                   # character ']'
string := "[lf]"                   # line feed
string := "[cr]"                   # carriage return
string := "[tab]"                  # tabulation
string := "[0]"                    # null character
string := "Jon said [dq]hello[dq]" # literal double quotes

#
# multiline text using inline_text meta and parse_text filters defined 
# in the Appendix
#

var Str string := inline_text
 This is a multiline here document
 terminated by indentation rule
 (the first indenting space is ignored).
 In the multiline, "special" characters have not to be
 [quoted].

# remark each lines of string is ended with a [lf]

var Str string := inline_text leftcut
     This is a multiline here document
       terminated by indentation rule
   with left margin given by the leftest string

var Str string := inline_text ignorefirst
       ! left margin is here
           This is a multiline here document
  gna  with all characters left to the margin ignored,
       as long as properly indented.

# @@PLEAC@@_1.1
var Str s:="some string"

# extraction of at most length characters (less if the required
# length is not available in the string) -> new string

var Str s1 
s1 := s offset length
s1 := s offset s:len      # extracts the end of the string

# same, but the string is really a substring (like in Perl)
# to do this, we add new methods to Str:

method p map s from to
  arg_rw Str p; arg Str s; arg Int from length
  check to < s:len
  p set (s:characters translate Char from) to-from false
#

s1 map s offset offset+length
s1 map s offset s:len-1

#
# The equivalent of unpack in Pliant is eparse. However,
# no parsing method is present by default for fixed length
# strings.
# We should create some function FixedStr to create the
# type "string of length xxx" and the from_string method
# on these types. Then, the unpack could be writen as

var FixedStr:5 leading
var FixedStr:3 dummy
var FixedStr:8 s1 s2
var Str trailing data
data eparse leading dummy s1 s2 any:trailing

#
# A string may be accessed as an array of Char, but if we
# way to transfer a Str into an Array of Char, we need a loop
#
var Array:Char chars
for (var Int i) 0 s:len
  chars i := s i

#
#

s := "This is what you have"

# strings do not support backwards indexing as perl does, but we may
# add this functionality
method s 'new substring' i j -> ss
  arg Str s ss; arg Int i j
  strong_definition
  ss:= s (shunt i<0 s:len+i i) j
alias '' '. new substring' 
#
first  := string 0 1              # "T"
start  := string 5 2              # "is"
rest   := string 13 string:len    # "you have"
last   := string -1 string:len    # "e"
end    := string -4 string:len    # "have"
piece  := string -8 3             # "you"
#--------------------
string := "This is what you have"
console string
#This is what you have

# @@PLEAC@@_1.4

# characters have type Char in Pliant
var Char char:="X"
var Int num := char number        # gets the ASCII code of char
char := character num             # ASCII to character
#-----------------------------
# Here, we use a string
var Str string:="Hello"
num := string:0:number            # ASCII code of first character
string := character num           # implicit Char->Str cast
#-----------------------------
var Int ascii_value := "e":number # now 101
var Char char := character 101    # now "e"
#-----------------------------
var Str hal := "HAL"
var Str ibm := hal
for (var Int i) 0 ibm:len-1
  ibm:i := character hal:i:number+1

# @@PLEAC@@_1.5
# Since Pliant++ strings can be accessed one character at a time,
# there's no need to do any processing on the string to convert
# it into an array of characters

var Str s

for (var Int i) 0 s:len-1
  # do something with s:i
#------------------------------------------
# we use an Index to sort implicitely the keys
module "/pliant/language/unsafe.pli"         # at the moment Index is still considered unsafe
module "/pliant/language/type/set/each.pli"  # each.pli has to be linked to explicitely
var (Index Char Bool) seen
var Str string := "an apple a day"
for (var Int i) 0 string:len-1
  if not (seen exists string:i)
    seen insert string:i true
console "unique chars are: "
each c seen                       # warning, c is the value associated with the key
  console (seen key c)
console eol
# unique chars are:  adelnpy
#-------------------------------------------
var Int sum:=0
for (var Int i) 0 string:len-1
  sum += s:i:number
console sum eol
# prints "1248" if string was "an apple a day"
#---------------------------------------------
# @@PLEAC@@_1.13

var Str str := "This is a [dq]string[dq] with [lf] special [lb]characters[rb] in it"
var Str quoted := string str
# "This is a [lb]dq[rb]string[lb]dq[rb] with [lb]lf[rb] special [lb]lb[rb]characters[lb]rb[rb] in it"
#
# back to unquoted string (quoted -> str)
quoted eparse str
#---------------------------------------------

# @@PLEAC@@_1.15

#
# quoted " ([lb][dq][rb]) are implictely dequoted when arising in a parsed string
# 
var Str string := "XYZZY,[dq][dq],[dq]O'Reilly, Inc[dq],[dq]Wall, Larry[dq],[dq]a [lb]dq[rb]glug[lb]dq[rb] bit[dq], another [dq]glub[dq] bit, 5, [dq]Error, Core Dumped[dq]"
var Str a
var Str b:=string+","
var Array:Str fields
while b<>""
  if not (b parse a "," any:b)  # if not a quoted string
    b parse any:a "," any:b     # it is not quoted and ends with the next ","
  fields += a
for (var Int i) 0 fields:size-1
  console "#" i ":" fields:i eol

#0 : XYZZY
#1 :
#2 : O'Reilly, Inc
#3 : Wall, Larry
#4 : a "glug" bit
#5 : another "glub" bit
#6 : 5
#7 : Error, Core Dumped 
#-----------------------------


