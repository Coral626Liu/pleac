; -*- lisp -*-
;
; @@PLEAC@@_NAME
; @@SKIP@@ Common Lisp

; @@PLEAC@@_WEB
; @@SKIP@@ http://www.lisp.org/


; @@PLEAC@@_1.1
; assign a substring to a variable
(setq value (substring string offset (+ offset count)))
(setq value (substring string offset))

; edit a substring
(setq string (concatenate 'string (substring string 0 offset) newstring
(substring string (+ offset count))))
(setq string (concatenate 'string (substring string 0 offset) newtail))


; @@PLEAC@@_1.2
; use b if b is true, else c
(if b (setq a b) (setq a c))

; set x to y unless x is already true
(unless x (setq x y))


;@@PLEAC@@_1.3
;;--------------------------------------------------
(multiple-value-setq (VAR1 VAR2) (values VAR2 VAR1))

;;--------------------------------------------------
(setq temp a)
(setq a b)
(setq b temp)
;;--------------------------------------------------
(setq a "alpha")
(setq b "omega")
(multiple-value-setq (a b) (values b a)) ;; the first shall be last -- and versa vice
;;--------------------------------------------------
(setq alpha 'January beta 'March production 'August)
(multiple-value-setq (alpha beta production) (values beta production alpha))


; @@PLEAC@@_1.4
(setq ord (char-code char))
(setq char (code-char ord))


; @@PLEAC@@_1.5
(coerce (mapcar #'(lambda (x) (whatever-you-want-to-do x)) (coerce string
'list)) 'string)

; @@PLEAC@@_1.6
(setq revbytes (reverse string))

(setq revwords (reverse (do* ((stringstream (make-string-input-stream
string)) (result nil (cons next result))
			       (next (read stringstream nil 'eos)
				     (read stringstream nil 'eos)))
			     ((equal next 'eos) (reverse result)))))

; @@PLEAC@@_1.9
(setq big (string-upcase string))

(setq little (string-downcase string))


; @@PLEAC@@_1.10
; func, obviously, must evaluate to a string

(setq answer (concatenate (concatenate var1 (func args)) var2))


; @@PLEAC@@_2.1
; recursive lambdas are no fun, so define a function

(defun string-is-numberp (x)
  (if (eq 0 (length x)) (digit-char-p (car x)) (and (digit-char-p (car x))
(string-is-numberp (rest x)))))

(string-is-numberp (coerce string 'list))


; @@PLEAC@@_2.4
; decimal to binary
(setq bin (format nil "~2R" dec))

; binary to decimal
(setq dec (formant nil "~10R" bin))


; @@PLEAC@@_2.6
;arabic to roman
(setq roman (format nil "~@R" arabic))

;roman to arabic
(defun romanchar (x) (cond ((or (eq x #\m) (eq x #\M)) 1000)
			   ((or (eq x #\d) (eq x #\D)) 500)
			   ((or (eq x #\c) (eq x #\C)) 100)
			   ((or (eq x #\l) (eq x #\L)) 50)
			   ((or (eq x #\x) (eq x #\X)) 10)
		           ((or (eq x #\v) (eq x #\V)) 5)
			   ((or (eq x #\i) (eq x #\I)) 1)
			   (t 0)))

(defun roman2arabic (x) (let ((y (coerce x 'list))) 
				(if (eq 1 (length y)) 
				    (romanchar (car y)) 
				    (if (< (romanchar (car y)) (romanchar (cadr y)))
				 		(- (roman2arabic (rest y)) (romanchar (car y)))
						(+ (romanchar (car y)) (roman2arabic (rest y)))))))

(setq arabic (roman2arabic roman))


; @@PLEAC@@_2.7
;integer
(+ (random 51) 25)

;float
(+ (random 51.0) 25.0)


; @@PLEAC@@_2.8
; Question: anyone know a way to give a pre-determined seed, rather than seeding from hardware?
(random limit (make-random-state t))


; @@PLEAC@@_2.11
; degrees to radians
(defun deg2rad (degrees) (* (/ degrees 180) pi))

; radians to degrees
(defun rad2deg (radians) (* (/ radians pi) 180))


; @@PLEAC@@_2.12
; tangent
(tan theta)

(setq y (acos 3.7))


; @@PLEAC@@_2.13
; natural log
(setq log_e (log value))

(setq log_base_whatever (log value base))


