;;; -*- scheme -*-

;;; @@PLEAC@@_NAME
;;; @@SKIP@@ Guile 1.5

;;; @@PLEAC@@_WEB
;;; @@SKIP@@ http://www.gnu.org/software/guile/

;;; @@PLEAC@@_INTRO
;;; @@SKIP@@ The code requires a really recent version of Guile (out of CVS, or the beta version which is tested right now).


;;; @@PLEAC@@_1.0
(define string "\\n")                    ; two characters, \ and an n
(define string "\n")                     ; a "newline" character
(define string "Jon \"Maddog\" Orwant")  ; literal double quotes
(define string "Jon 'Maddog' Orwant")    ; literal single quotes

(define a "This is a multiline here document
terminated by a closing double quote")

;;; @@PLEAC@@_1.1
;; Use substring

(substring str start end)
(substring str start)

;; You can fill portions of a string with another string

(substring-move-right! str start end newstring newstart)
(substring-move-left! str start end newstring newstart)

;; Guile has a separate character type, and you can treat strings as a
;; character array.

(string-ref str pos)
(string-set! str pos char)
(string-fill! str char)
(substring-fill! str start end char)

(define s "This is what you have")
(define first (substring s 0 1))                     ; "T"
(define start (substring s 5 7))                     ; "is"
(define rest  (substring s 13))                      ; "you have"
(define last  (substring s (1- (string-length s))))  ; "e"
(define end   (substring s (- (string-length s) 4))) ; "have"
(define piece (let ((len (string-length s)))
                (substring s (- len 8) (- len 5))))  ; "you"


;;; Or use the string library SRFI-13
(use-modules (srfi srfi-13))

(define s "This is what you have")
(define first (string-take s 1))                     ; "T"
(define start (xsubstring s 5 7))                    ; "is"
(define rest  (xsubstring s 13 -1))                  ; "you have"
(define last  (string-take-right s 1))               ; "e"
(define end   (string-take-right s 4))               ; "have"
(define piece (xsubstring s -8 -5))                  ; "you"

;; Mutation of different sized strings is not allowed.  You have to
;; use set! to change the variable.

(set! s (string-replace s "wasn't" 5 7))
;; This wasn't what you have
(set! s (string-replace s "ondrous" 13 25))
;; This wasn't wondrous
(set! s (string-take-right s (1- (string-length s))))
;; his wasn't wondrous
(set! s (string-take s 9))

;;; @@PLEAC@@_1.2
(define a (or b c))
(define a (if (defined? b) b c))
(define a (or (and (defined? b) b) c))

;;; @@PLEAC@@_1.3
;; This doesn't really make sense in Scheme... temporary variables are
;; a natural construct and cheap.  If you want to swap variables in a
;; block without introducing any new variable names, you can use let:

(let ((a b) (b a))
  ;; ...
  )

(let ((alpha beta) (beta production) (production alpha))
  ;; ...
  )

;;; @@PLEAC@@_1.4
(define num (char->integer char))
(define char (integer->char num))

(use-modules (srfi srfi-13))
(let ((str "sample"))
  (display (string-join
            (map number->string
                 (map char->integer (string->list str))) " "))
  (newline))

(let ((lst '(115 97 109 112 108 101)))
  (display (list->string (map integer->char lst)))
  (newline))

(letrec ((next (lambda (c) (integer->char (1+ (char->integer c))))))
  (let* ((hal "HAL")
         (ibm (list->string (map next (string->list hal)))))
    (display ibm)
    (newline)))

;;; @@PLEAC@@_1.5
;; Convert the string to a list of characters
(map proc
     (string->list str))

(use-modules (srfi srfi-1))
(format #t "unique chars are: ~A\n"
        (apply string (sort (delete-duplicates
                             (string->list "an apple a day")) char<?)))

(let* ((str "an apple a day")
       (sum (apply + (map char->integer (string->list str)))))
  (format #t "sum is ~A\n" sum))

;;; or use string-fold/string-map/string-for-each from SRFI-13
(use-modules (srfi srfi-13))

(let* ((str "an apple a day")
       (sum (string-fold (lambda (c acc) (+ acc (char->integer c)))
                         0 str)))
  (format #t "sum is ~A\n" sum))

#!/usr/local/bin/guile -s
!#
;; sum - compute 16-bit checksum of all input files
(use-modules (srfi srfi-13))
(define (checksum p)
  (let loop ((line (read-line p 'concat)) (sum 0))
    (if (eof-object? line)
      (format #t "~A ~A\n" sum (port-filename p))
      (let ((line-sum (string-fold (lambda (c acc)
                                     (+ acc (char->integer c)))
                                   0 line)))
        (loop (read-line p 'concat) (modulo (+ sum line-sum)
                                            (1- (expt 2 16))))))))
(let ((args (cdr (command-line))))
  (if (null? args)
    (checksum (current-input-port))
    (for-each (lambda (f) (call-with-input-file f checksum)) args)))

#!/usr/local/bin/guile -s
!#
;; slowcat - emulate a  s l o w  line printer
(use-modules (ice-9 regex) (srfi srfi-2) (srfi srfi-13))
(define args (cdr (command-line)))
(define delay 1)
(and-let* ((p (pair? args))
           (m (string-match "^-([0-9]+)$" (car args))))
  (set! delay (string->number (match:substring m 1)))
  (set! args (cdr args)))
(define (slowcat p)
  (let loop ((line (read-line p 'concat)))
    (cond ((not (eof-object? line))
           (string-for-each
            (lambda (c) (display c) (usleep (* 5 delay))) line)
           (loop (read-line p 'concat))))))
(if (null? args)
  (slowcat (current-input-port))
  (for-each (lambda (f) (call-with-input-file f slowcat)) args))

;;; @@PLEAC@@_1.6
(define revbytes (list->string (reverse (string->list str))))

;;; Or from SRFI-13
(use-modules (srfi srfi-13))
(define revbytes (string-reverse str))
(string-reverse! str) ; modifies in place

(define revwords (string-join (reverse (string-tokenize str)) " "))

(with-input-from-file "/usr/share/dict/words"
  (lambda ()
    (do ((word (read-line) (read-line)))
        ((eof-object? word))
      (if (and (> (string-length word) 5)
               (string=? word (string-reverse word)))
        (write-line word)))))

;; A little too verbose on the command line
;; guile --use-srfi=13 -c '(with-input-from-file "/usr/share/dict/words" (lambda () (do ((word (read-line) (read-line))) ((eof-object? word)) (if (and (> (string-length word) 5) (string=? word (string-reverse word))) (write-line word)))))'

;;; @@PLEAC@@_1.7
;; Use regexp-substitute/global
(regexp-substitute/global
 #f "([^\t]*)(\t+)" str
 (lambda (m)
   (let* ((pre-string (match:substring m 1))
          (pre-len (string-length pre-string))
          (match-len (- (match:end m 2) (match:start m 2))))
     (string-append
      pre-string
      (make-string
       (- (* match-len 8)
          (modulo pre-len 8))
       #\space))))
 'post)

;;; @@PLEAC@@_1.8
;; just interpolate $abc in strings:
(define (varsubst str)
  (regexp-substitute/global #f "\\$(\\w+)" str
   'pre (lambda (m) (eval (string->symbol (match:substring m 1))
                          (current-module)))
   'post))

;; interpolate $abc with error messages:
(define (safe-varsubst str)
  (regexp-substitute/global #f "\\$(\\w+)" str
   'pre (lambda (m)
          (catch #t
            (lambda () (eval (string->symbol (match:substring m 1))
                             (current-module)))
            (lambda args
              (format #f "[NO VARIABLE: ~A]" (match:substring m 1)))))
   'post))

;; interpolate ${(any (scheme expression))} in strings:
(define (interpolate str)
  (regexp-substitute/global #f "\\${([^{}]+)}" str
   'pre (lambda (m) (eval-string (match:substring m 1))) 'post))

;;; @@PLEAC@@_1.9
(use-modules (srfi srfi-13))

(string-upcase "bo beep")     ; BO PEEP
(string-downcase "JOHN")      ; john
(string-titlecase "bo")       ; Bo
(string-titlecase "JOHN")     ; John

(string-titlecase "thIS is a loNG liNE")  ; This Is A Long Line

#!/usr/local/bin/guile -s
!#
;; randcap: filter to randomly capitalize 20% of the time
(use-modules (srfi srfi-13))
(seed->random-state (current-time))
(define (randcap p)
  (let loop ((line (read-line p 'concat)))
    (cond ((not (eof-object? line))
           (display (string-map (lambda (c)
                                  (if (= (random 5) 0)
                                    (char-upcase c)
                                    (char-downcase c)))
                                line))
           (loop (read-line p 'concat))))))
(let ((args (cdr (command-line))))
  (if (null? args)
    (randcap (current-input-port))
    (for-each (lambda (f) (call-with-input-file f randcap)) args)))

;;; @@PLEAC@@_1.10
;; You can do this with format.  Lisp/Scheme format is a little
;; different from what you may be used to with C/Perl style printf
;; (actually far more powerful) , but if you keep in mind that we use
;; ~ instead of %, and , instead of . for the prefix characters, you
;; won't have trouble getting used to Guile's format.

(format #f "I have ~A guanacos." n)

;;; @@PLEAC@@_1.11
(define var "
        your text
        goes here")

(use-modules (ice-9 regexp))
(set! var (regexp-substitute/global #f "\n +" var 'pre "\n" 'post))

(use-modules (srfi srfi-13))
(set! var (string-join (map string-trim (string-tokenize var #\newline)) "\n"))

(use-modules (ice-9 regexp) (srfi srfi-13) (srfi srfi-14))
(define (dequote str)
  (let* ((str (if (char=? (string-ref str 0) #\newline)
                (substring str 1) str))
         (lines (string-tokenize str #\newline))
         (rx (let loop ((leader (car lines)) (lst (cdr lines)))
               (cond ((string= leader "")
                      (let ((pos (or (string-skip (car lines)
                                                  char-set:whitespace) 0)))
                        (make-regexp (format #f "^[ \\t]{1,~A}" pos)
                                     regexp/newline)))
                     ((null? lst)
                      (make-regexp (string-append "^[ \\t]*"
                                                  (regexp-quote leader))
                                   regexp/newline))
                     (else
                      (let ((pos (or (string-prefix-length leader (car lst)) 0)))
                        (loop (substring leader 0 pos) (cdr lst))))))))
    (regexp-substitute/global #f rx str 'pre 'post)))

;;; @@PLEAC@@_1.12
(use-modules (srfi srfi-13))

(define text "Folding and splicing is the work of an editor,
not a mere collection of silicon
and
mobile electrons!")

(define (wrap str max-col)
  (let* ((words (string-tokenize str))
         (all '())
         (first (car words))
         (col (string-length first))
         (line (list first)))
    (for-each
     (lambda (x)
       (let* ((len (string-length x))
              (new-col (+ col len 1)))
         (cond ((> new-col max-col)
                (set! all (cons (string-join (reverse! line) " ") all))
                (set! line (list x))
                (set! col len))
               (else
                (set! line (cons x line))
                (set! col new-col)))))
     (cdr words))
    (set! all (cons (string-join (reverse! line) " ") all))
    (string-join (reverse! all) "\n")))

(display (wrap text 20))

;;; @@PLEAC@@_1.13
(define str "Mom said, \"Don't do that.\"")
(set! str (regexp-substitute/global #f "['\"]" str 'pre "\\"
                                    match:substring 'post))
(set! str (regexp-substitute/global #f "[^A-Z]" str 'pre "\\"
                                    match:substring 'post))
(set! str (string-append "this " (regexp-substitute/global
                                  #f "\W" "is a test!" 'pre "\\"
                                  match:substring 'post)))

;;; @@PLEAC@@_1.14
(use-modules (srfi srfi-13))

(define str "  space  ")
(string-trim str)          ; "space  "
(string-trim-right str)    ; "  space"
(string-trim-both str)     ; "space"

;;; @@PLEAC@@_1.15
(use-modules (srfi srfi-2) (srfi srfi-13) (ice-9 format))

(define parse-csv
  (let* ((csv-match (string-join '("\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\",?"
                                   "([^,]+),?"
                                   ",")
                                 "|"))
         (csv-rx (make-regexp csv-match)))
    (lambda (text)
      (let ((start 0)
            (result '()))
        (let loop ((start 0))
          (and-let* ((m (regexp-exec csv-rx text start)))
            (set! result (cons (or (match:substring m 1)
                                   (match:substring m 3))
                               result))
            (loop (match:end m))))
        (reverse result)))))

(define line "XYZZY,\"\",\"O'Reilly, Inc\",\"Wall, Larry\",\"a \\\"glug\\\" bit,\",5,\"Error, Core Dumped\"")

(do ((i 0 (1+ i))
     (fields (parse-csv line) (cdr fields)))
    ((null? fields))
  (format #t "~D : ~A\n" i (car fields)))

;;; @@PLEAC@@_1.16
(use-modules (srfi srfi-13) (srfi srfi-14))

;; Knuth's soundex algorithm from The Art of Computer Programming, Vol 3
(define soundex
  (letrec ((chars "AEIOUYBFPVCGJKQSXZDTLMNR")
           (nums "000000111122222222334556")
           (skipchars (string->char-set "HW"))
           (trans (lambda (c)
                    (let ((i (string-index chars c)))
                      (if i (string-ref nums i) c)))))
    (lambda (str)
      (let* ((ustr (string-upcase str))
             (f (string-ref ustr 0))
             (skip (trans f)))
        (let* ((mstr (string-map trans (string-delete ustr skipchars 1)))
               (dstr (string-map (lambda (c)
                                   (cond ((eq? c skip) #\0)
                                         (else (set! skip c) c)))
                                 mstr))
               (zstr (string-delete dstr #\0)))
          (substring (string-append (make-string 1 f) zstr "000") 0 4))))))

(soundex "Knuth")  ; K530
(soundex "Kant")   ; K530
(soundex "Lloyd")  ; L300
(soundex "Ladd")   ; L300

;;; @@PLEAC@@_1.17
#!/usr/local/bin/guile -s
!#

(use-modules (srfi srfi-13)
             (srfi srfi-14)
             (ice-9 rw)
             (ice-9 regex))

(define data "analysed        => analyzed
built-in        => builtin
chastized       => chastised
commandline     => command-line
de-allocate     => deallocate
dropin          => drop-in
hardcode        => hard-code
meta-data       => metadata
multicharacter  => multi-character
multiway        => multi-way
non-empty       => nonempty
non-profit      => nonprofit
non-trappable   => nontrappable
pre-define      => predefine
preextend       => pre-extend
re-compiling    => recompiling
reenter         => re-enter
turnkey         => turn-key")

(define input (if (null? (cdr (command-line)))
                (current-input-port)
                (open-input-file (cadr (command-line)))))

(let* ((newline-char-set (string->char-set "\n"))
       (assoc-char-set (string->char-set " =>"))
       (dict (map
              (lambda (line)
                (string-tokenize line assoc-char-set))
              (string-tokenize data newline-char-set)))
       (dict-match (string-join (map car dict) "|")))
  (let loop ((line (read-line input)))
    (cond ((not (eof-object? line))
           (regexp-substitute/global
            (current-output-port) dict-match line
            'pre
            (lambda (x)
              (cadr (assoc (match:substring x 0) dict)))
            'post)
           (loop (read-line input 'concat))))))

(close-port input)

;; @@PLEAC@@_2.1
;; Strings and numbers are separate data types in Scheme, so this
;; isn't as important as it is in Perl.  More often you would use the
;; type predicates, string? and number?.

(if (string-match "[^\\d]" str) (display "has nondigits"))
(or (string-match "^\\d+$" str) (display "not a natural number"))
(or (string-match "^-?\\d+$" str) (display "not an integer"))
(or (string-match "^[\\-+]?\\d+$" str) (display "not an integer"))
(or (string-match "^-?\\d+\.?\d*$" str) (display "not a decimal number"))
(or (string-match "^-?(\d+(\.\d*)?|\.\d+)$" str)
    (display "not a decimal number"))
(or (string-match "^([+-]?)(\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$" str)
    (display "not a C float"))

(define num1 (string->number str))

(define num2 (read))

;; @@PLEAC@@_2.2
;; (approx-equal? num1 num2 accuracy) : returns #t if num1 and num2 are
;;   equal to accuracy number of decimal places
(define (approx-equal? num1 num2 accuracy)
  (< (abs (- num1 num2)) (expt 10.0 (- accuracy))))

(define wage 536)                     ;; $5.36/hour
(define week (* 40 wage))             ;; $214.40
(format #t "One week's wage is: $~$\n" (/ week 100.0))


;; @@PLEAC@@_2.3
(round num)                           ;; rounds to inexact whole number
(inexact->exact num)                  ;; rounds to exact integer

;; You can also use format to convert numbers to more precisely
;; formatted strings.  Note Guile has a builtin format which is a more
;; limited version of that found in the (ice-9 format) module, to save
;; load time.  Basically, if you are doing anything you couldn't do
;; with a series of (display), (write) and (newline), then you'll need
;; to use the module.
(use-modules (ice-9 format))

(define a 0.255)
(define b (/ (round (* 100.0 a)) 100.0))
(format #t "Unrounded: ~F\nRounded: ~F\n" a b)
(format #t "Unrounded: ~F\nRounded: ~,2F\n" a a)

(define a '(3.3 3.5 3.7 -3.3))
(display "number\tint\tfloor\tceil\n")
(for-each
 (lambda (n)
   (format #t "~,1F\t~,1F\t~,1F\t~,1F\n"
           n (round n) (floor n) (ceiling n)))
 a)

;; @@PLEAC@@_2.4
;; numbers are radix independent internally, so you usually only
;; convert on output, however to convert strings:
(define (dec->bin num)
  (number->string (string->number num 10) 2))

(define (bin->dec num)
  (number->string (string->number num 2) 10))

(define num (bin->dec "0110110"))  ; 54
(define binstr (dec->bin "54"))    ; 110110

;; @@PLEAC@@_2.5
;; do is the most general loop iterator
(do ((i x (1+ i)))   ; var  init-value  step-value
    ((> i y))        ; end when true
  ;; i is set to every integer from x to y, inclusive
  ;; ...
  )

;; Guile also offers a while loop
(let ((i x))
  (while (<= i y)
         ;; i is set to every integer from x to y, inclusive
         ; ...
         (set! i (1+ i))))

;; named let is another common loop
(let loop ((i x))
  (cond ((<= i y)
         ;; i is set to every integer from x to y, step-size 7
         ;; ...
         (loop (+ i 7)))))  ; tail-recursive call

(display "Infancy is: ")
(do ((i 0 (1+ i)))
    ((> i 2))
  (format #t "~A " i))
(newline)

(display "Toddling is: ")
(let ((i 3))
  (while (<= i 4)
         (format #t "~A " i)
         (set! i (1+ i))))
(newline)

(display "Childhood is: ")
(let loop ((i 5))
  (cond ((<= i 12)
         (format #t "~A " i)
         (loop (1+ i)))))
(newline)

;; @@PLEAC@@_2.6
;; format can output roman numerals - use ~:@R

(use-modules (ice-9 format))

(format #t "Roman for ~R is ~:@R\n" 15 15)

;; @@PLEAC@@_2.7
(random 5)        ; an integer from 0 to 4
(random 5.0)      ; an inexact real in the range [0,5)

;; char sets from SRFI-14 and string-unfold from SRFI-13 make a quick
;; way to generate passwords

(use-modules (srfi srfi-13) (srfi srfi-14))

(define chars (char-set->string char-set:graphic))
(define size (char-set-size char-set:graphic))
(define password
  (string-unfold (lambda (x) (= x 8))
                 (lambda (x) (string-ref chars (random size)))
                 1+ 0))

;; @@PLEAC@@_2.8
;; if you're working with random numbers you'll probably want to set
;; the random seed

(seed->random-state (current-time))

;; you can also save random states and pass them to any of the above
;; random functions

(define state (copy-random-state))
(random:uniform)
;; 0.939377327721761
(random:uniform state)
;; 0.939377327721761

;; @@PLEAC@@_2.9
;; @@INCOMPLETE@@
;; very inefficient
(use-modules (ice-9 rw))
(define make-true-random
  (letrec ((bufsize 8)
           (accum (lambda (c acc) (+ (* 256 acc)
                                     (char->integer c))))
           (getbuf (lambda ()
                     (call-with-input-file "/dev/urandom"
                       (lambda (p)
                         (let ((buf (make-string bufsize)))
                           (read-string!/partial buf p)
                           buf))))))
    (lambda (rand-proc)
      (lambda args
        (let ((state (seed->random-state (string-fold accum 0 (getbuf)))))
          (apply rand-proc (append args (list state))))))))

(define urandom (make-true-random random))
(define urandom:exp (make-true-random random:exp))
(define urandom:normal (make-true-random random:normal))
(define urandom:uniform (make-true-random random:uniform))

;; @@PLEAC@@_2.10
;; Guile offers a number of random distributions

(random:exp)      ; an inexact real in an exponential dist with mean 1
(random:normal)   ; an inexact real in a standard normal distribution
(random:uniform)  ; a uniformly distributed inexact real in [0,1)

;; There are also functions to fill vectors with random distributions

;; Fills vector v with inexact real random numbers the sum of whose
;; squares is equal to 1.0.
(random:hollow-sphere! v)

;; Fills vector v with inexact real random numbers that are
;; independent and standard normally distributed (i.e., with mean 0
;; and variance 1).
(random:normal-vector! v)

;; Fills vector v with inexact real random numbers the sum of whose
;; squares is less than 1.0.
(random:solid-sphere! v)

;; @@PLEAC@@_2.11
;; Guile's trigonometric functions use radians.

(define pi 3.14159265358979)

(define (degrees->radians deg)
  (* pi (/ deg 180.0)))

(define (radians->degrees rad)
  (* 180.0 (/ rad pi)))

(define (degree-sine deg)
  (sin (degrees->radians deg)))

;; @@PLEAC@@_2.12

;; Guile provides the following standard trigonometric functions (and
;; their hyperbolic equivalents), defined for all real and complex
;; numbers:

(sin z)
(cos z)
(tan z)
(asin z)
(acos z)
(atan z)

(acos 3.7)  ; 0.0+1.9826969446812i

;; @@PLEAC@@_2.13
;; Guile provides log in base e and 10 natively, defined for any real
;; or complex numbers:

(log z)    ; natural logarithm
(log10 z)  ; base-10 logarithm

;; For other bases, divide by the log of the base:

(define (log-base n z)
  (/ (log z) (log n)))

;; To avoid re-computing (log n) for a base you want to use
;; frequently, you can create a custom log function:

(define (make-log-base n)
  (let ((divisor (log n)))
    (lambda (z) (/ (log z) divisor))))

(define log2 (make-log-base 2))

(log2 1024)

;; @@PLEAC@@_2.14
;; In addition to simple vectors, Guile has builtin support for
;; uniform arrays of an arbitrary dimension.

;; a rows x cols integer matrix
(define a (make-array 0 rows cols))
(array-set! a 3 row col)
(array-ref a row col)

;; a 3D matrix of reals
(define b (make-array 0.0 x y z))

;; a literal boolean truth table for logical and
'#2((#f #f) (#f #t))

;; simple matrix multiplication

(define (matrix-mult m1 m2)
  (let* ((d1 (array-dimensions m1))
         (d2 (array-dimensions m2))
         (m1rows (car d1))
         (m1cols (cadr d1))
         (m2rows (car d2))
         (m2cols (cadr d2)))
    (if (not (= m1cols m2rows))
      (error 'index-error "matrices don't match"))
    (let ((result (make-array 0 m1rows m2cols)))
      (do ((i 0 (1+ i)))
          ((= i m1rows))
        (do ((j 0 (1+ j)))
            ((= j m2cols))
          (do ((k 0 (1+ k)))
              ((= k m1cols))
            (array-set! result (+ (array-ref result i j)
                                  (* (array-ref m1 i k)
                                     (array-ref m2 k j)))
                        i j))))
      result)))

(matrix-mult '#2((3 2 3) (5 9 8)) '#2((4 7) (9 3) (8 1)))

;; @@PLEAC@@_2.15
;; Guile has builtin support for complex numbers:

(define i 0+1i)       ; 0.0+1.0i
(define i (sqrt -1))  ; 0.0+1.0i

(complex? i)          ; #t
(real-part i)         ; 0.0
(imag-part i)         ; 1.0

(* 3+5i 2-2i)         ; 16+4i
(sqrt 3+4i)           ; 2+i

;; Classic identity:  -e^(pi*i) => 1
(inexact->exact (real-part (- (exp (* pi 0+1i))))) ; 1

;; @@PLEAC@@_2.16
;; You can type in literal numbers in alternate radixes:

#b01101101     ; 109 in binary
#o155          ; 109 in octal
#d109          ; 109 in decimal
#x6d           ; 109 in hexadecimal

;; number->string and string->number also take an optional radix:

(define number (string->number hexadecimal 16))
(define number (string->number octal 8))

;; format will also output in different radixes:

(format #t "~B ~O ~D ~X\n" num num num num)

;; converting Unix file permissions read from stdin:

(let loop ((perm (read-line)))
  (cond ((not (eof-object? perm))
         (format #t "The decimal value is ~D\n" (string->number perm 8))
         (loop (read-line)))))


;; @@PLEAC@@_2.17
;; once again, format is our friend :)
(use-modules (ice-9 format))

;; the : prefix to the D directive causes commas to be output every
;; three digits.
(format #t "~:D\n" (random 10000000000000000))
; => 2,301,267,079,619,540

;; the third prefix arg to the D directive is the separator character
;; to use instead of a comma, useful for European style numbers:
(format #t "~,,'.:D\n" (random 10000000000000000))
; => 6.486.470.447.356.534

;; the F directive, however, does not support grouping by commas.  to
;; achieve this, we can format the integer and fractional parts
;; separately:
(define (commify num)
  (let ((int (inexact->exact (truncate num))))
    (if (= num int)
      (format #f "~:D" int)
      (string-append (format #f "~:D" int)
                     (let ((str (format #f "~F" num)))
                       (substring str (or (string-index str #\.)
                                          (string-length str))))))))

;; @@PLEAC@@_2.18
;; format can handle simple 's' plurals with ~p, and 'y/ies' plurals
;; with the @ prefix:

(format #t "It took ~D hour~P\n" hours hours)

(format #t "It took ~D centur~@P\n" centuries centuries)

(define noun-plural
  (let* ((suffixes '(("ss"  . "sses")
                     ("ph"  . "phes")
                     ("sh"  . "shes")
                     ("ch"  . "ches")
                     ("z"   . "zes")
                     ("ff"  . "ffs")
                     ("f"   . "ves")
                     ("ey"  . "eys")
                     ("y"   . "ies")
                     ("ix"  . "ices")
                     ("s"   . "ses")
                     ("x"   . "xes")
                     ("ius" . "ii")))
        (suffix-match
         (string-append "(" (string-join (map car suffixes) "|") ")$"))
        (suffix-rx (make-regexp suffix-match)))
    (lambda (noun)
      (let ((m (regexp-exec suffix-rx noun)))
        (if m
          (string-append (regexp-substitute #f m 'pre)
                         (cdr (assoc (match:substring m) suffixes)))
          (string-append noun "s"))))))

;; @@PLEAC@@_2.19
#!/usr/local/bin/guile -s
!#

;; very naive factoring algorithm
(define (factor n)
  (let ((factors '())
        (limit (inexact->exact (round (sqrt n))))
        (twos 0))
    ;; factor out 2's
    (while (even? n)
           (set! n (ash n -1))
           (set! twos (1+ twos)))
    (if (> twos 0) (set! factors (list (cons 2 twos))))
    ;; factor out odd primes
    (let loop ((i 3))
      (let ((r (remainder n i)))
        (cond ((= r 0)
               (set! n (quotient n i))
               (let* ((old-val (assv i factors))
                      (new-val (if old-val (1+ (cdr old-val)) 1)))
                 (set! factors (assv-set! factors i new-val)))
               (loop i))
              ((< i limit)
               (loop (+ 2 i))))))
    ;; remainder
    (if (> n 1) (set! factors (cons (cons n 1) factors)))
    (reverse! factors)))

;; pretty print a term of a factor
(define (pp-term pair)
  (if (= (cdr pair) 1)
    (number->string (car pair))
    (format #f "~A^~A" (car pair) (cdr pair))))

;; factor each number given on the command line
(for-each
 (lambda (n)
   (let ((factors (factor n)))
     (format #t "~A = ~A" n (pp-term (car factors)))
     (for-each
      (lambda (x) (format #t " * ~A" (pp-term x)))
      (cdr factors))
     (newline)))
 (map string->number (cdr (command-line))))

;; @@PLEAC@@_3.0
;; Use the builtin POSIX time functions

;; get the current time
(current-time)   ; number of seconds since the epoch
(gettimeofday)   ; pair of seconds and microseconds since the epoch

;; create a time object from an integer (e.g. returned by current-time)
(localtime time) ; in localtime
(gmtime time)    ; in UTC

;; get/set broken down components of a time object

(tm:sec time)    (set-tm:sec time secs)    ; seconds (0-59)
(tm:min time)    (set-tm:min time mins)    ; minutes (0-59)
(tm:hour time)   (set-tm:hour time hours)  ; hours (0-23)
(tm:mday time)   (set-tm:mday time mday)   ; day of the month (1-31)
(tm:mon time)    (set-tm:mon time month)   ; month (0-11)
(tm:year time)   (set-tm:year time year)   ; year minus 1900 (70-)
(tm:wday time)   (set-tm:wday time wday)   ; day of the week (0-6)
                                           ; where Sunday is 0
(tm:yday time)   (set-tm:yday time yday)   ; day of year (0-365)
(tm:isdst time)  (set-tm:isdst time isdst) ; daylight saving indicator
                                           ; 0 for "no", > 0 for "yes",
                                           ; < 0 for "unknown"
(tm:gmtoff time) (set-tm:gmtoff time off)  ; time zone offset in seconds
                                           ; west of UTC (-46800 to 43200)
(tm:zone time)   (set-tm:zone time zone)   ; Time zone label (a string),
                                           ; not necessarily unique.

(format #t "Today is day ~A of the current year.\n"
        (tm:yday (localtime (current-time))))

;; Or use SRFI-19 - Time and Date Procedures
(use-modules (srfi srfi-19))

(define now (current-date))  ; immutable once created

(date-nanosecond now)        ; 0-9,999,999
(date-second now)            ; 0-60 (60 represents a leap second)
(date-minute now)            ; 0-59
(date-hour now)              ; 0-23
(date-day now)               ; 0-31
(date-month now)             ; 1-12
(date-year now)              ; integer representing the year
(date-year-day now)          ; day of year (Jan 1 is 1, etc.)
(date-week-day now)          ; day of week (Sunday is 0, etc.)
(date-week-number now start) ; week of year, ignoring a first partial week
                             ; start is the first day of week as above
(date-zone-offset now)       ; integer number of seconds east of GMT

(format #t "Today is day ~A of the current year.\n"
        (date-year-day (current-date)))

;; @@PLEAC@@_3.1
;; using format and POSIX time components
(use-modules (ice-9 format))
(let ((now (localtime (current-time))))
  (format #t "The current date is ~4'0D ~2'0D ~2'0D\n"
          (+ 1900 (tm:year now)) (tm:mon now) (tm:mday now)))

;; using format and SRFI-19 time components
(use-modules (srfi srfi-19) (ice-9 format))
(let ((now (current-date)))
  (format #t "The current date is ~4'0d-~2'0D-~2'0D\n"
          (date-year now) (date-month now) (date-day now)))

;; using POSIX strftime with a libc time format string
(display (strftime "%Y-%m-%d\n" (localtime (current-time))))

;; @@PLEAC@@_3.2
;; set the individual components of a time struct and use mktime
(define time (localtime (current-time)))
(set-tm:mday time mday)
(set-tm:mon time mon)
(set-tm:year time year)
(car (mktime time))  ; mktime returns a (epoch-seconds . time) pair

;; or use SRFI-19's make-date and date->time-monotonic
(use-modules (srfi srfi-19))
(date->time-monotonic
 (make-date nanosecond second minute hour day month year zone-offset))

;; @@PLEAC@@_3.3
;; use localtime or gmtime with the accessors mentioned in the
;; introduction to this chapter
(let ((time (localtime seconds)))  ; or gmtime
  (format #t "Dateline: ~2'0d:~2'0d:~2'0d-~4'0d/~2'0d/~2'0d\n"
          (tm:hour time) (tm:min time) (tm:sec time)
          (+ 1900 (tm:year time)) (1+ (tm:mon time)) (tm:mday time)))

;; or use SRFI-19
(use-modules (srfi srfi-19))
(let* ((time (make-time time-monotonic nanosecond second)))
  (display (date->string (time-monotonic->date time) "~T-~1\n")))

;; @@PLEAC@@_3.4
;; just add or subtract epoch seconds
(define when (+ now difference))
(define then (- now difference))

;; if you have DMYHMS values, you can convert them to times or add
;; them as seconds:
(define birthtime 96176750)
(define interval (+ 5                  ; 5 seconds
                    (* 17 60)          ; 17 minutes
                    (* 2 60 60)        ; 2 hours
                    (* 55 60 60 24)))  ; and 55 days
(define then (+ birthtime interval))
(format #t "Then is ~A\n" (strftime "%a %b %d %T %Y" (localtime then)))

;; @@PLEAC@@_3.5
;; subtract the epoch seconds:
(define bree 361535725)
(define nat 96201950)
(define difference (- bree nat))
(format #t "There were ~A seconds between Nat and Bree\n" difference)

;; or use SRFI-19's time arithmetic procedures:
(use-modules (srfi srfi-19))
(define time1 (make-time time-monotonic nano1 sec1))
(define time2 (make-time time-monotonic nano2 sec2))
(define duration (time-difference time1 time2))
(time=? (subtract-duration time1 duration) time2) ; #t
(time=? (add-duration time2 duration) time1)      ; #t

;; @@PLEAC@@_3.6
;; convert to a SRFI-19 date and use the accessors
(use-modules (srfi srfi-19))
(date-day date)
(date-year-day date)
(date-week-day date)
(date-week-number date start-day-of-week)

;; @@PLEAC@@_3.7
;; use the strptime function:
(define time-pair (strptime "%Y-%m-%d" "1998-06-03"))
(format #t "Time is ~A\n." (strftime "%b %d, %Y" (car time-pair)))

;; or use SRFI-19's string->date:
(use-modules (srfi srfi-19))
(define date (string->date "1998-06-03" "~Y-~m-~d"))
(format #t "Time is ~A.\n" (date->string date))

;; @@PLEAC@@_3.8
;; use the already seen strftime:
(format #t "strftime gives: ~A\n"
        (strftime "%A %D" (localtime (current-time))))

;; or SRFI-19's date->string:
(use-modules (srfi srfi-19))
(format #t "default date->string gives: ~A\n" (date->string (current-date)))
(format #t "date->string gives: ~A\n"
        (date->string (current-date) "~a ~b ~e ~H:~M:~S ~z ~Y"))

;; @@PLEAC@@_3.9
;; gettimeofday will return seconds and microseconds:
(define t0 (gettimeofday))
;; do your work here
(define t1 (gettimeofday))
(format #t "You took ~A seconds and ~A microseconds\n"
        (- (car t1) (car t0)) (- (cdr t1) (cdr t0)))

;; you can also get more detailed info about the real and processor
;; times:
(define runtime (times))
(tms:clock runtime)  ; the current real time
(tms:utime runtime)  ; the CPU time units used by the calling process
(tms:stime runtime)  ; the CPU time units used by the system on behalf
                     ; of the calling process.
(tms:cutime runtime) ; the CPU time units used by terminated child
                     ; processes of the calling process, whose status
                     ; has been collected (e.g., using `waitpid').
(tms:cstime runtime) ; the CPU times units used by the system on
		     ; behalf of terminated child processes

;; you can also use the time module to time execution:
(use-modules (ice-9 time))
(time (sleep 3))
;; clock utime stime cutime cstime gctime
;; 3.01  0.00  0.00   0.00   0.00   0.00
;; 0

;; @@PLEAC@@_3.10
(sleep i)   ; sleep for i seconds
(usleep i)  ; sleep for i microseconds (not available on all platforms)

;; @@PLEAC@@_4.0
(define nested '("this" "that" "the" "other"))
(define nested '("this" "that" ("the" "other")))
(define tune '("The" "Star-Spangled" "Banner"))

;; @@PLEAC@@_4.1
(define a '("quick" "brown" "fox"))
(define a '("Why" "are" "you" "teasing" "me?"))

(use-modules (srfi srfi-13))
(define lines
  (map string-trim
       (string-tokenize "\
    The boy stood on the burning deck,
    It was as hot as glass."
			#\newline)))

(define bigarray
  (with-input-from-file "mydatafile"
    (lambda ()
      (let loop ((lines '())
		 (next-line (read-line)))
	(if (eof-object? next-line)
	    (reverse lines)
	    (loop (cons next-line lines)
		  (read-line)))))))

(define banner "The Mines of Moria")

(define name "Gandalf")
(define banner
  (string-append "Speak, " name ", and enter!"))
(define banner
  (format #f "Speak, ~A, and welcome!" name))

;; Advanced shell-like function is provided by guile-scsh, the Guile
;; port of SCSH, the Scheme shell.  Here we roll our own using the
;; pipe primitives that come with core Guile.
(use-modules (ice-9 popen))

(define (drain-output port)
  (let loop ((chars '())
             (next (read-char port)))
    (if (eof-object? next)
        (list->string (reverse! chars))
        (loop (cons next chars)
              (read-char port)))))

(define (qx pipeline)
  (let* ((pipe (open-input-pipe pipeline))
         (output (drain-output pipe)))
    (close-pipe pipe)
    output))

(define his-host "www.perl.com")
(define host-info (qx (format #f "nslookup ~A" his-host)))

(define perl-info (qx (format #f "ps ~A" (getpid))))
(define shell-info (qx "ps $$"))

(define banner '("Costs" "only" "$4.95"))
(define brax    (map string (string->list "()<>{}[]")))
(define rings   (string-tokenize "Nenya Narya Vilya"))
(define tags    (string-tokenize "LI TABLE TR TD A IMG H1 P"))
(define sample
  (string-tokenize "The vertical bar (|) looks and behaves like a pipe."))
(define ships  '("Niña" "Pinta" "Santa María"))

;; @@PLEAC@@_4.2
(define array '("red" "yellow" "green"))

(begin
  (display "I have ")
  (for-each display array)
  (display " marbles.\n"))
;; I have redyellowgreen marbles.

(begin
  (display "I have ")
  (for-each (lambda (colour)
	      (display colour)
	      (display " "))
	    array)
  (display "marbles.\n"))
;; I have red yellow green marbles.

;; commify - insertion of commas into list output
(define (commify strings)
  (let ((len (length strings)))
    (case len
      ((0) "")
      ((1) (car strings))
      ((2) (string-append (car strings) " and " (cadr strings)))
      ((3) (string-append (car strings) ", "
                          (cadr strings) ", and "
                          (caddr strings)))
      (else
       (string-append (car strings) ", "
                      (commify (cdr strings)))))))

(define lists '(("just one thing")
                ("Mutt" "Jeff")
                ("Peter" "Paul" "Mary")
                ("To our parents" "Mother Theresa" "God")
                ("pastrami" "ham and cheese" "peanut butter and jelly" "tuna")
                ("recycle tired, old phrases" "ponder big, happy thoughts")
                ("recycle tired, old phrases"
                 "ponder big, happy thoughts"
                 "sleep and dream peacefully")))

(for-each (lambda (list)
            (display "The list is: ")
            (display (commify list))
            (display ".\n"))
          lists)

;; The list is: just one thing.
;; The list is: Mutt and Jeff.
;; The list is: Peter, Paul, and Mary.
;; The list is: To our parents, Mother Theresa, and God.
;; The list is: pastrami, ham and cheese, peanut butter and jelly, and tuna.
;; The list is: recycle tired, old phrases and ponder big, happy thoughts.
;; The list is: recycle tired, old phrases, ponder big, happy thoughts, and sleep and dream peacefully.

;; @@PLEAC@@_4.3
;;-----------------------------

;; Scheme does not normally grow and shrink arrays in the way that
;; Perl can.  The more usual operations are adding and removing from
;; the head of a list using the `cons' and `cdr' procedures.
;; However ...
(define (grow/shrink list new-size)
  (let ((size (length list)))
    (cond ((< size new-size)
           (grow/shrink (cons "" list) new-size))
          ((> size new-size)
           (grow/shrink (cdr list) new-size))
          (else list))))

(define (element list i)
  (list-ref list (- (length list) i 1)))

(define (set-element list i value)
  (if (>= i (length list))
      (set! list (grow/shrink list (- i 1))))
  (set-car! (list-cdr-ref list (- (length list) i 1)))
  list)

(define (what-about list)
  (let ((len (length list)))
    (format #t "The array now has ~A elements.\n" len)
    (format #t "The index of the last element is ~A.\n" (- len 1))
    (format #t "Element #3 is `~A'.\n" (if (> len 3)
                                           (element list 3)
                                           ""))))

;; In the emulation of Perl arrays implemented here, the elements are
;; in reverse order when compared to normal Scheme lists.
(define people (reverse '("Crosby" "Stills" "Nash" "Young")))
(what-about people)
;;-----------------------------
;; The array now has 4 elements.
;; The index of the last element is 3.
;; Element #3 is `Young'.
;;-----------------------------
(set! people (grow/shrink people 3))
(what-about people)
;;-----------------------------
;; The array now has 3 elements.
;; The index of the last element is 2.
;; Element #3 is `'.
;;-----------------------------
(set! people (grow/shrink people 10001))
(what-about people)
;;-----------------------------
;; The array now has 10001 elements.
;; The index of the last element is 10000.
;; Element #3 is `'.
;;-----------------------------

;; @@PLEAC@@_7.0
;; use (open-input-file filename) or (open filename O_RDONLY)

(define input (open-input-file "/usr/local/widgets/data"))
(let loop ((line (read-line input 'concat)))
  (cond ((not (eof-object? line))
         (if (string-match "blue" line)
           (display line))
         (loop (read-line input 'concat)))))
(close input)

;; Many I/O functions default to the logical STDIN/OUT

;; You can also explicitly get the standard ports with
;; [set-]current-{input,output,error}-port.

;; format takes a port as the first argument.  If #t is given, format
;; writes to stdout, if #f is given, format returns a string.

(let loop ((line (read-line)))     ; reads from stdin
  (cond ((not (eof-object? line))
         (if (not (string-match "[0-9]" line))
           ;; writes to stderr
           (display "No digit found.\n" (current-error-port))
           ;; writes to stdout
           (format #t "Read: ~A\n" line))
         (loop (read-line)))))

;; use open-output-file

(define logfile (open-output-file "/tmp/log"))

;; increasingly specific ways of closing ports (it's safe to close a
;; closed port)

(close logfile)                ; #t
(close-port logfile)           ; #f (already closed)
(close-output-port logfile)    ; unspecified

;; you can rebind standard ports with set-current-<foo>-port:

(let ((old-out (current-output-port)))
  (set-current-output-port logfile)
  (display "Countdown initiated ...\n")
  (set-current-output-port old-out)
  (display "You have 30 seconds to reach minimum safety distance.\n"))

;; or

(with-output-to-file logfile
  (lambda () (display "Countdown initiated ...\n")))
(display "You have 30 seconds to reach minimum safety distance.\n")


;; @@PLEAC@@_7.1
(define source (open-input-file path))
(define sink (open-output-file path))

(define source (open path O_RDONLY))
(define sink (open path O_WRONLY))

;;-----------------------------
(define port (open-input-file path))
(define port (open-file path "r"))
(define port (open path O_RDONLY))
;;-----------------------------
(define port (open-output-file path))
(define port (open-file path "w"))
(define port (open path (logior O_WRONLY O_TRUNC O_CREAT)))
;;-----------------------------
(define port (open path (logior O_WRONLY O_EXCL O_CREAT)))
;;-----------------------------
(define port (open-file path "a"))
(define port (open path (logior O_WRONLY O_APPEND O_CREAT)))
;;-----------------------------
(define port (open path (logior O_WRONLY O_APPEND)))
;;-----------------------------
(define port (open path O_RDWR))
;;-----------------------------
(define port (open-file path "r+"))
(define port (open path (logior O_RDWR O_CREAT)))
;;-----------------------------
(define port (open path (logior O_RDWR O_EXCL O_CREAT)))
;;-----------------------------

;; @@PLEAC@@_7.2
;; Nothing different needs to be done with Guile

;; @@PLEAC@@_7.3
(define expand-user
  (let ((rx (make-regexp "^\\~([^/]+)?")))
    (lambda (filename)
      (let ((m (regexp-exec rx filename)))
        (if m
          (string-append
           (if (match:substring m 1)
             (passwd:dir (getpwnam (match:substring m 1)))
             (or (getenv "HOME") (getenv "LOGDIR")
                 (passwd:dir (getpwuid (cuserid))) ""))
           (substring filename (match:end m)))
          filename)))))

;; @@PLEAC@@_7.4
(define port (open-file filename mode))  ; raise an exception on error

;; use catch to trap errors
(catch 'system-error ; the type of error thrown
  (lambda () (set! port (open-file filename mode))) ; thunk to try
  (lambda (key . args)  ; exception handler
    (let ((fmt (cadr args))
          (msg&path (caddr args)))
      (format (current-error-port) fmt (car msg&path) (cadr msg&path))
      (newline))))

;; @@PLEAC@@_7.5
;; use the POSIX tmpnam
(let ((name (tmpnam)))
  (call-with-output-file name
    (lambda (port)
      ;; ... output to port
      )))

;; better to test and be sure you have exclusive access to the file
;; (temp file name will be available as (port-filename port))
(define (open-temp-file)
  (let loop ((name (tmpnam)))
    (catch 'system-error
      (lambda () (open name (logior O_RDWR O_CREAT O_EXCL)))
      (lambda (key . args) (loop (tmpnam))))))

;; or let mkstemp! do the work for you:
(define port (mkstemp! template-string-ending-in-XXXXXX))

(let* ((tmpl "/tmp/programXXXXXX")
       (port (mkstemp! tmpl)))
  ;; tmpl now contains the name of the temp file,
  ;; e.g. "/tmp/programhVoEzw"
  (do ((i 0 (1+ i)))
      ((= i 10))
    (format port "~A\n" i))
  (seek port 0 SEEK_SET)
  (display "Tmp file has:\n")
  (do ((line (read-line port 'concat) (read-line port 'concat)))
      ((eof-object? line))
    (display line))
  (close port))

;; @@PLEAC@@_7.6
;; string ports are ideal for this

(define DATA "
your data goes here
")

(call-with-input-string
 DATA
 (lambda (port)
   ;; ... process input from port
   ))

;; or

(with-input-from-string DATA
  (lambda ()
    ;; ... stdin now comes from DATA
    ))

;; @@PLEAC@@_7.7
;; to process lines of current-input-port:
(do ((line (read-line) (read-line)))
    ((eof-object? line))
  ;; ... do something with line
  )

;; a general filter template:

(define (body)
  (do ((line (read-line) (read-line)))
      ((eof-object? line))
    (display line)
    (newline)))

(let ((args (cdr (command-line))))
  ;; ... handle options here
  (if (null? args)
    (body)     ; no args, just call body on stdin
    (for-each  ; otherwise, call body with stdin set to each arg in turn
     (lambda (file)
       (catch 'system-error
         (lambda ()
           (with-input-from-file file
             body))
         (lambda (key . args)
           (format (current-error-port) (cadr args) (caaddr args)
                   (car (cdaddr args)))
           (newline (current-error-port)))))
     args)))

;; example: count-chunks:
(use-modules (srfi srfi-1) (srfi srfi-13) (ice-9 format) (ice-9 regex))

;; also use directory-files from 9.5 and globbing functions from 9.6

;; can use (ice-9 getopt-long) described in chapter 15, or process
;; options by hand
(define opt-append 0)
(define opt-ignore-ints 0)
(define opt-nostdout 0)
(define opt-unbuffer 0)

(define args (cdr (command-line)))

(do ((opts args (cdr opts)))
    ((or (null? opts) (not (eq? (string-ref (car opts) 0) #\-)))
     (set! args opts))
  (let ((opt (car opts)))
    (cond ((string=? opt "-a") (set! opt-append (1+ opt-append)))
          ((string=? opt "-i") (set! opt-ignore-ints (1+ opt-ignore-ints)))
          ((string=? opt "-n") (set! opt-nostdout (1+ opt-nostdout)))
          ((string=? opt "-u") (set! opt-unbuffer (1+ opt-unbuffer)))
          (else (throw 'usage-error "Unexpected argument: ~A" opt)))))

;; default to all C source files
(if (null? args) (set! args (glob "*.[Cch]" ".")))

(define (find-login)
  (do ((line (read-line) (read-line)))
      ((eof-object? line))
    (cond ((string-match "login" line)
           (display line)
           (newline)))))

(define (lowercase)
  (do ((line (read-line) (read-line)))
      ((eof-object? line))
    (display (string-downcase line))
    (newline)))

(define (count-chunks)
  (do ((line (read-line) (read-line))
       (chunks 0))
      ((or (eof-object? line)
           (string=? line "__DATA__") (string=? line "__END__"))
       (format #t "Found ~A chunks\n" chunks))
    (let ((tokens
           (string-tokenize (string-take line (or (string-index line #\#)
                                                  (string-length line))))))
      (set! chunks (+ chunks (length tokens))))))

(if (null? args)
  (count-chunks)     ; or find-login, lowercase, etc.
  (for-each
   (lambda (file)
     (catch 'system-error
       (lambda ()
         (with-input-from-file file
           count-chunks))
       (lambda (key . args)
         (format (current-error-port) (cadr args) (caaddr args)
                 (car (cdaddr args)))
         (newline (current-error-port)))))
   args))

;; @@PLEAC@@_7.8
;; write changes to a temporary file then rename it
(with-input-from-file old
  (lambda ()
    (with-output-to-file new
      (lambda ()
        (do ((line (read-line) (read-line)))
            ((eof-object? line))
          ;; change line, then...
          (write-line line))))))
(rename-file old (string-append old ".orig"))
(rename-file new old)

;; @@PLEAC@@_7.9
;; no -i switch

;; @@PLEAC@@_7.10
;; open the file in read/write mode, slurp up the contents, modify it,
;; then write it back out:
(let ((p (open-file file "r+"))
      (lines '()))
  ;; read in lines
  (do ((line (read-line p) (read-line p)))
      ((eof-object? line))
    (set! lines (cons line lines)))
  ;; modify (reverse lines)
  (seek p 0 SEEK_SET)
  ;; write out lines
  (for-each (lambda (x) (write-line x p)) lines)
  ;; truncate the file
  (truncate-file p)
  (close p))

(let ((p (open-file "foo" "r+"))
      (lines '())
      (date (date->string (current-date))))
  (do ((line (read-line p 'concat) (read-line p 'concat)))
      ((eof-object? line))
    (set! lines (cons line lines)))
  (seek p 0 SEEK_SET)
  (for-each
   (lambda (x)
     (regexp-substitute/global p "DATE" x 'pre date 'post))
   (reverse lines))
  (truncate-file p)
  (close p))

;; @@PLEAC@@_7.11
(define p (open-file path "r+"))
(flock p LOCK_EX)
;; update the file, then...
(close p)

;; to increment a number in a file
(define p (open "numfile" (logior O_RDWR O_CREAT)))
(flock p LOCK_EX)
;; Now we have acquired the lock, it's safe for I/O
(let* ((obj (read p))
       (num (if (eof-object? obj) 0 obj)))
  (seek p 0 SEEK_SET)
  (truncate-file p)
  (write (1+ num) p)
  (newline p))
(close p)

;; @@PLEAC@@_7.12
;; use force-output
(force-output p)

;; flush all open ports
(flush-all-ports)

;; @@PLEAC@@_7.13
;; use select
(select inputs outputs exceptions seconds)
(select (list p1 p2 p3) '() '())

(let* ((nfound (select (list inport) '() '()))
       (inputs (car nfound)))
  (if (not (null? inputs))
      (let ((line (read-line inport)))
        (format #t "I read ~A\n" line))))

;; or use char-ready? if you only need a single character
(if (char-ready? p)
  (format #t "I read ~A\n" (read-char p)))

;; @@PLEAC@@_7.14
;; use the O_NONBLOCK option with open
(define modem (open "/dev/cua0" (logior O_RDWR O_NONBLOCK)))

;; or use fcntl if you already have a port
(let ((flags (fcntl p F_GETFD)))
  (fcntl p F_SETFD (logior flags O_NONBLOCK)))

;; @@PLEAC@@_7.15
;; use stat
(let ((buf (make-string (stat:size (stat p)))))
  (read-string!/partial buf input))

;; @@PLEAC@@_7.16
;; not needed - ports are first class objects

;; @@PLEAC@@_7.18
;; use for-each on the list of ports:
(for-each (lambda (p) (display stuff-to-print p)) port-list)

;; or, if you don't want to keep track of the port list and know you
;; want to print to all open output ports, you can use port-for-each:
(port-for-each (lambda (p) (if (output-port? p) (display stuff p))))

;; @@PLEAC@@_7.19
;; use fdopen:
(define p (fdopen num mode))
(define p (fdopen 3 "r"))

(define p (fdopen (string->number (getenv "MHCONTEXTFD")) "r"))
;; after processing
(close p)

;; @@PLEAC@@_7.20
;; ports are first class objects and can be aliased and passed around
;; like any other non-immediate variables:
(define alias original)
(define old-in (current-input-port))

;; or you can open two separate ports on the same file:
(define p1 (open-input-file path))
(define p2 (open-input-file path))

;; or use fdopen:
(define copy-of-p (fdopen (fileno p) mode))

(define old-out (current-output-port))
(define old-err (current-error-port))

(define new-out (open-output-file "/tmp/program.out"))

(set-current-output-port new-out)
(set-current-error-port new-out)

(system joe-random-program)

(close new-out)

(set-current-output-port old-out)
(set-current-error-port old-out)

;; @@PLEAC@@_8.0
;; open the file and loop through the port with read-line:
(let ((p (open-input-file file)))
  (do ((line (read-line p) (read-line p)))
      ((eof-object? line))
    (format #t "~A\n" (string-length line)))
  (close p))

;; you can use with-input-from-file to temporarily rebind stdin:
(with-input-from-file file
  (lambda ()
    (do ((line (read-line) (read-line)))
        ((eof-object? line))
      (format #t "~A\n" (string-length line)))))

;; or define a utility procedure to do this
(define (for-each-line proc file)
  (with-input-from-file file
    (lambda ()
      (do ((line (read-line) (read-line)))
          ((eof-object? line))
        (proc line)))))
(for-each-line (lambda (x) (format #t "~A\n" (string-length line))) file)

;; read in the file as a list of lines
(define (read-lines file)
  (let ((ls '()))
    (with-input-from-file file
      (lambda ()
        (do ((line (read-line) (read-line)))
            ((eof-object? line))
          (set! ls (cons line ls)))
        (reverse ls)))))

;; read in the file as a single string
(define (file-contents file)
  (call-with-input-file file
    (lambda (p)
      (let* ((size (stat:size (stat p)))
             (buf (make-string size)))
        (read-string!/partial buf p)
        buf))))

;; use display to print human readable output
(display '("One" "two" "three") port)  ; (One two three)
(display "Baa baa black sheep.\n")     ; Sent to default output port

;; use write to print machine readable output
(write '("One" "two" "three") port)    ; ("One" "two" "three")

;; use (ice-9 rw) to read/write fixed-length blocks of data:
(use-modules (ice-9 rw))
(let ((buffer (make-string 4096)))
  (read-string!/partial buffer port 4096))

;; truncate-file
(truncate-file port length)  ; truncate to length
(truncate-file port)         ; truncate to current pos

;; ftell
(define pos (ftell port))
(format #t "I'm ~A bytes from the start of DATAFILE.\n" pos)

;; seek
(seek log-port 0 SEEK_END)      ; seek to end
(seek data-port pos SEEK_SET)   ; seek to pos
(seek out-port -20 SEEK_CUR)    ; seek back 20 bytes

;; block read/write
(use-modules (ice-9 rw))
(write-string/partial mystring data-port (string-length mystring))
(read-string!/partial block 256 5)

;; @@PLEAC@@_8.1
(let ((rx (make-regexp "(.*)\\\\$"))) ; or "(.*)\\\\\\s*$"
  (with-input-from-file file
    (lambda ()
      (let loop ((line (read-line)))
        (if (not (eof-object? line))
          (let ((m (regexp-exec rx line))
                (next (read-line)))
            (cond ((and m (not (eof-object? next)))
                   (loop (string-append (match:substring m 1) next)))
                  (else
                   ;; else process line here, then recurse
                   (loop next)))))))))

;; @@PLEAC@@_8.2
(do ((line (read-line p) (read-line p))
     (i 0 (1+ i)))
    ((eof-object? line) i))

;; fastest way if your terminator is a single newline
(use-modules (ice-9 rw) (srfi srfi-13))
(let ((buf (make-string (expt 2 16)))
      (count 0))
  (do ((len (read-string!/partial buf p) (read-string!/partial buf p)))
      ((not len) count)
    (set! count (+ count (string-count buf #\newline 0 len)))))

;; or use port-line
(let loop ((line (read-line p)))
  (if (eof-object? line) (port-line p) (loop (read-line p))))

;; @@PLEAC@@_8.3
;; default behaviour of string-tokenize is to split on whitespace:
(use-modules (srfi srfi-13))
(let loop ((line (read-line p)))
  (cond ((not eof-object? line)
         (for-each some-function-of-word (string-tokenize line))
         (loop (read-line p)))))

(let ((table (make-hash-table 31)))
  (let loop ((line (read-line p)))
    (cond ((not (eof-object? line))
           (for-each
            (lambda (w) (hash-set! table w (1+ (hash-ref table w 0))))
            (string-tokenize line))
           (loop (read-line p)))))
  (hash-fold (lambda (k v p) (format #t "~5D ~A\n" v k)) #f table))

;; @@PLEAC@@_8.4
;; build up the list the reverse it or fold over it:
(define lines (read-lines file))
(for-each (lambda (word) do-something-with-word) (reverse lines))
(fold (lambda (word acc) do-something-with-word) #f lines)

;; @@PLEAC@@_8.5
;; save the current position and reseek to it
(define (tail file)
  (call-with-input-file file
    (lambda (p)
      (let loop ((line (read-line p)))
        (cond ((eof-object? line)
               (sleep sometime)
               (let ((pos (ftell p)))
                 (seek p 0 SEEK_SET)
                 (seek p pos SEEK_SET)))
              (else
               ;; process line
               ))
        (loop (read-line p))))))

;; @@PLEAC@@_8.6
(let ((rand-line #f))
  (let loop ((line (read-line p)))
    (cond ((not (eof-object? line))
           (if (= 0 (random (port-line p)))
             (set! rand-line line))
           (loop (read-line p)))))
  ;; rand-line is the random line
  )

;; @@PLEAC@@_8.7
(define (shuffle list)
  (let ((v (list->vector list)))
    (do ((i (1- (vector-length v)) (1- i)))
        ((< i 0) (vector->list v))
      (let ((j (random (1+ i))))
        (cond ((not (= i j))
               (let ((temp (vector-ref v i)))
                 (vector-set! v i (vector-ref v j))
                 (vector-set! v j temp))))))))

(define rand-lines (shuffle (read-lines file))

;; @@PLEAC@@_8.8
;; looking for line number desired-line-number
(do ((line (read-line p) (read-line p)))
    ((= ((port-line p) desired-line-number) line)))
;; or read into a list
(define lines (read-lines file))
(list-ref lines desired-line-number)

;; @@INCOMPLETE@@
; (define (build-index data-file index-file)
;   )

; (define (line-with-index data-file index-file line-number)
;   )

;; @@PLEAC@@_8.9
;; use string-tokenize with an appropriate character set
(use-modules (srfi srfi-13) (srfi srfi-14))
(define fields (string-tokenize line (string->charset "+-")))
(define fields (string-tokenize line (string->charset ":")))
(define fields (string-tokenize line))

;; @@PLEAC@@_8.10
(let ((p (open-file file "r+")))
  (let ((pos 0))
    (let loop ((line (read-line p)))
      (cond ((eof-object? (peek-char p))
             (seek p 0 SEEK_SET)
             (truncate-file p pos)
             (close p))
            (else
             (set! pos (ftell p))
             (loop (read-line p)))))))

;; @@PLEAC@@_8.11
;; no equivalent - don't know how Guile under windows handles this

;; @@PLEAC@@_8.12
(let* ((address (* recsize recno))
       (buf (make-string recsize)))
  (seek p address SEEK_SET)
  (read-string!/partial buf p)
  buf)

;; @@PLEAC@@_8.13
(let* ((address (* recsize recno))
       (buf (make-string recsize)))
  (seek p address SEEK_SET)
  (read-string!/partial buf p)
  ;; modify buf, then write back with
  (seek p address SEEK_SET)
  (write-string/partial buf p)
  (close p))

;; @@INCOMPLETE@@
;; weekearly

;; @@PLEAC@@_8.14
(seek p addr SEEK_SET)
(define str (read-delimited (make-string 1 #\nul) p))

#!/usr/local/bin/guile -s
!#
;; bgets -- get a string from an address in a binary file
(use-modules (ice-9 format))

(define args (cdr (command-line)))
(define file (car args))
(define addrs (map string->number (cdr args)))
(define delims (make-string 1 #\nul))

(call-with-input-file file
  (lambda (p)
    (for-each
     (lambda (addr)
       (seek p addr SEEK_SET)
       (format #t "~X ~O ~D ~S\n" addr addr addr
               (read-delimited delims p)))
     addrs)))

;; @@INCOMPLETE@@
;; strings

;; @@PLEAC@@_9.0
(define entry (stat "/usr/bin/vi"))
(define entry (stat "/usr/bin"))
(define entry (stat port))

(use-modules (ice-9 posix))

(define inode (stat "/usr/bin/vi"))
(define ctime (stat:ctime inode))
(define size (stat:size inode))

(define F (open-input-file filename))
;; no equivalent - what defines -T?
; unless (-s F && -T _) {
;     die "$filename doesn't have text in it.\n";
; }

(define dir (opendir "/usr/bin"))
(do ((filename (readdir dir) (readdir dir)))
    ((eof-object? filename))
  (format #t "Inside /usr/bin is something called ~A\n" filename))
(closedir dir)

;; @@PLEAC@@_9.1
(define inode (stat filename))
(define readtime (stat:atime inode))
(define writetime (stat:mtime inode))

(utime newreadtime newwritetime filename)

(define seconds-per-day (* 60 60 24))
(define inode (stat file))
(define atime (stat:atime inode))
(define mtime (stat:mtime inode))
(set! atime (- atime (* 7 seconds-per-day)))
(set! mtime (- mtime (* 7 seconds-per-day)))
(utime file atime mtime)

;; mtime is optional
(utime file (current-time))
(utime file (stat:atime (stat file)) (current-time))

#!/usr/local/bin/guile -s
!#
;; uvi - vi a file without changing its access times

(define file (cadr (command-line)))
(define inode (stat file))
(define atime (stat:atime inode))
(define mtime (stat:mtime inode))
(system (string-append (or (getenv "EDITOR")  "vi") " " file))
(utime file atime mtime)

;; @@PLEAC@@_9.2
(delete-file file)

(let ((count 0))
  (for-each
   (lambda (x)
     (catch #t
       (lambda () (delete-file x) (set! count (1+ count)))
       (lambda (err . args) #f)))
   file-list)
  (if (not (= count (length file-list)))
    (format (current-error-port) "could only delete ~A of ~A files"
            count (length file-list))))

;; @@PLEAC@@_9.3
;; use builtin copy-file
(copy-file oldfile newfile)
(rename-file oldfile newfile)

;; or do it by hand (clumsy, error-prone)
(use-modules (ice-9 rw) (ice-9 posix))
(with-input-from-file oldfile
  (lambda ()
    (call-with-output-file newfile
      (lambda (p)
        (let* ((inode (stat oldfile))
               (blksize (if inode (stat:size inode) 16384))
               (buf (make-string blksize)))
          (let loop ((len (read-string!/partial buf)))
            (cond ((and len (> len 0))
                   (write-string/partial buf p 0 len)
                   (loop (read-string!/partial buf))))))))))

;; or call out to the system (non-portable, insecure)
(system (string-append "cp " oldfile " " newfile))    ; unix
(system (string-append "copy " oldfile " " newfile))  ; dos, vms

;; @@PLEAC@@_9.4
;; use a hash lookup of inodes
(use-modules (ice-9 posix))
(let ((seen (make-hash-table 31)))
  (for-each
   (lambda (file)
     (let* ((stats (stat file))
            (key (cons (stat:dev stats) (stat:ino stats)))
            (val (hash-ref seen key 0)))
       (cond ((= val 0)
              ;; do something with new file
              ))
       (hash-set! seen key (1+ val))))
   file-names))

(let ((seen (make-hash-table 31)))
  (for-each
   (lambda (file)
     (let* ((stats (stat file))
            (key (cons (stat:dev stats) (stat:ino stats)))
            (val (hash-ref seen key '())))
       (hash-set! seen key (cons file val))))
   file-names)
  (hash-fold
   (lambda (key value prior)
     ;; process key == (dev . inode), value == list of filenames
     )
   '() seen))

;; @@PLEAC@@_9.5
;; use opendir, readdir, closedir
(let ((p (opendir dir)))
  (let loop ((file (readdir p)))
    (if (eof-object? file)
      (close p)
      ;; do something with file
      )))

;; or define a utility function for this
(define (directory-files dir)
  (if (not (access? dir R_OK))
    '()
    (let ((p (opendir dir)))
      (do ((file (readdir p) (readdir p))
           (ls '()))
          ((eof-object? file) (closedir p) (reverse! ls))
        (set! ls (cons file ls))))))

;; to skip . and ..
(cddr (directory-files dir))

;; probably better to implement full Emacs style directory-files
(use-modules (ice-9 posix))
(define plain-files
  (let ((rx (make-regexp "^\\.")))
    (lambda (dir)
      (sort (filter (lambda (x) (eq? 'regular (stat:type (stat x))))
                    (map (lambda (x) (string-append dir "/" x))
                         (remove (lambda (x) (regexp-exec rx x))
                                 (cddr (directory-files dir)))))
            string<))))

;; @@PLEAC@@_9.6
(define (glob->regexp pat)
  (let ((len (string-length pat))
        (ls '("^"))
        (in-brace? #f))
    (do ((i 0 (1+ i)))
        ((= i len))
      (let ((char (string-ref pat i)))
        (case char
          ((#\*) (set! ls (cons "[^.]*" ls)))
          ((#\?) (set! ls (cons "[^.]" ls)))
          ((#\[) (set! ls (cons "[" ls)))
          ((#\]) (set! ls (cons "]" ls)))
          ((#\\)
           (set! i (1+ i))
           (set! ls (cons (make-string 1 (string-ref pat i)) ls))
           (set! ls (cons "\\" ls)))
          (else
           (set! ls (cons (regexp-quote (make-string 1 char)) ls))))))
    (string-concatenate (reverse (cons "$" ls)))))

(define (glob pat dir)
  (let ((rx (make-regexp (glob->regexp pat))))
    (filter (lambda (x) (regexp-exec rx x)) (directory-files dir))))

(define files (glob "*.c" "."))
(define files (glob "*.[ch]" "."))

;; Not sure if the Schwartzian Transform would really be more
;; efficient here... perhaps with a much larger directory where very
;; few files matched.
(define dirs (filter
              (lambda (x) (eq? 'directory (stat:type (stat x))))
              (map (lambda (x) (string-append dir "/" x))
                   (sort (filter (lambda (x) (string-match "^[0-9]+$" x))
                                 (directory-files dir))
                         (lambda (a b)
                           (< (string->number a) (string->number b)))))))

;; @@PLEAC@@_9.7
(define (find proc . dirs)
  (cond ((pair? dirs)
         (for-each proc (map (lambda (x) (string-append (car dirs) "/" x))
                             (directory-files (car dirs))))
         (apply find proc (cdr dirs)))))

(find (lambda (x) (format #t "~A~A\n" x
                          (if (equal? (stat:type (stat x)) 'directory)
                            "/" ""))) ".")

(define saved-size -1)
(define saved-name "")
(define (biggest file)
  (let ((stats (stat file)))
    (if (eq? (stat:type stats) 'regular)
      (let ((size (stat:size (stat file))))
        (cond ((> size saved-size)
               (set! saved-size size)
               (set! saved-name file)))))))
(apply find biggest (cdr (command-line)))
(format #t "Biggest file ~A in ~A is ~A bytes long.\n"
        saved-name (cdr (command-line)) saved-size)

#!/usr/local/bin/guile -s
!#
;; fdirs - find all directories
(define (print-dirs f)
  (if (eq? (stat:type (stat f)) 'directory)
    (write-line f)))
(apply find print-dirs (cdr (command-line)))

;; @@PLEAC@@_9.8
#!/usr/local/bin/guile -s
!#
;; rmtree - remove whole directory trees like rm -f
(define (finddepth proc . dirs)
  (cond ((pair? dirs)
         (apply finddepth proc (cdr dirs))
         (for-each proc (map (lambda (x) (string-append (car dirs) "/" x))
                             (directory-files (car dirs)))))))
(define (zap f)
  (let ((rm (if (eq? (stat:type (stat f)) 'directory) rmdir delete-file)))
    (format #t "deleting ~A\n" f)
    (catch #t
      (lambda () (rm f))
      (lambda args (format #t "couldn't delete ~A\n" f)))))
(let ((args (cdr (command-line))))
  (if (null? args)
    (error "usage: rmtree dir ..\n")
    (apply finddepth zap args)))

;; @@PLEAC@@_9.9
(for-each
 (lambda (file)
   (let ((newname (function-of file)))
     (catch #t
       (lambda () (rename-file file newname))
       (lambda args (format (current-error-port)
                            "couldn't rename ~A to ~A\n" file newname)))))
 names)

#!/usr/local/bin/guile -s
!#
;; rename - Guile's filename fixer
(use-modules (ice-9 regex)) ; not needed, but often useful here
(define args (cdr (command-line)))
(if (null? args) (error "usage: rename expr [files]\n"))
(define proc (eval-string (car args)))
(for-each
 (lambda (old)
   (let ((new (proc old)))
     (if (not (string=? old new))
       (catch #t
         (lambda () (rename-file old new))
         (lambda args (format (current-error-port)
                              "couldn't rename ~A to ~A\n" old new))))))
 (cdr args))

;; command-line examples:
;; rename '(lambda (x) (regexp-substitute/global #f "\\.orig\$" x (quote pre)))' *.orig
;; rename string-downcase *
;; rename '(lambda (x) (if (string-match "^Make" x) x (string-downcase x)))' *
;; rename '(lambda (x) (string-append x ".bad"))' *.pl
;; rename '(lambda (x) (format #t "~a: ") (read-line))' *

;; @@PLEAC@@_9.10
(define base (basename path))
(define base (dirname path ext))
(define dir (dirname path))

(define path "/usr/lib/libc.a")
(define file (basename path))
(define dir (dirname path))

(format #t "dir is ~A, file is ~A\n" dir file)

(basename path ".a") ; libc

(use-modules (ice-9 regex))
(define (file-parse path . args)
  (let* ((ext (if (null? args) "\\..*" (car args)))
         (rx1 (string-append "^((.*)/)?(.*)?(" ext ")$"))
         (rx2 (string-append "^((.*)/)?(.*)?()$")))
    (let ((m (or (string-match rx1 path) (string-match rx2 path))))
      (list (match:substring m 2) (match:substring m 3)
            (match:substring m 4)))))

(define (extension path . args)
  (caddr (apply file-parse path args)))

;; @@PLEAC@@_13.0
;; Guile OOP is in the (oop goops) module (based on CLOS).  All
;; following sections assume you have (oop goops loaded).
(use-modules (oop goops))
(define-class <data-encoder> ())
(define obj (make <data-encoder>))

(define obj #(3 5))
(format #t "~A ~A\n" (class-of obj) (array-ref obj 1))
(change-class v <human-cannibal>) ; has to be defined
(format #t "~A ~A\n" (slot-ref obj stomach) (slot-ref obj name))

(slot-ref obj 'stomach)
(slot-set! obj 'stomach "Empty")
(name obj)
(set! (name obj) "Thag")

;; inheritance
(define-class <lawyer> (<human-cannibal>))

(define lector (make <human-cannibal>))
(feed lector "Zak")
(move lector "New York")

;; @@PLEAC@@_13.1
(define-class <my-class> ()
  (start #:init-form (current-time))
  (age #:init-value 0))

;; classes must have predefined slots, but you could use one as a
;; dictionary:
(define-class <my-class> ()
  (start #:init-form (current-time))
  (age #:init-value 0)
  (properties #:init-value '()))
(define (initialize (m <my-class>) initargs)
  (and-let* ((extra (memq #:extra initargs)))
    (slot-set! m 'properties (cdr extra))))

;; @@PLEAC@@_13.2
;; For smobs (external C objects), you can specify a callback to be
;; performed when the object is garbage collected with the C API
;; function `scm_set_smob_free'.  This solves the problem of cleaning up
;; after external objects and connections.  Guile doesn't use reference
;; count garbage collection, so circular data structures aren't a
;; problem.

;; @@PLEAC@@_13.3
;; either use slot-ref/set!
(slot-ref obj 'name)
(slot-set! obj 'name value)

;; or define the class with accessors
(define-class <my-class> ()
  (name #:accessor name))
(name obj)
(set! (name obj) value)

;; or use getters/setters to implement read/write-only slots
(define-class <my-class> ()
  (name #:getter name)
  (age #:setter age))
(name obj)
(set! (age obj) value)

;; or implement getters/setters manually
(define-method ((setter name) (obj <my-class>) value)
  (cond ((string-match "[^-\\w0-9']" value)
         (warn "funny characters in name"))
        ((string-match "[0-9]" value)
         (warn "numbers in name"))
        ((not (string-match "\\w+\\W+\\w+" value))
         (warn "prefer multiword names"))
        ((not (string-match "\\w" value))
         (warn "name is blank")))
  (slot-set! obj 'name (string-downcase value)))

;; @@PLEAC@@_13.4
;; override the initialize method
(define body-count 0)

(define-method (initialize (obj <person>) initargs)
  (set! body-count (1+ body-count))
  (next-method))

(define people '())
(do ((i 1 (1+ i)))
    ((> i 10))
  (set! people (cons (make <person>) people)))

(format #t "There are ~A people alive.\n" body-count)

(define him (make <person>))
(slot-set! him 'gender "male")

(define her (make <person>))
(slot-set! her 'gender "female")

;; use the :class allocation method
(slot-set! (make <fixed-array>) 'max-bounds 100) ; set for whole class
(define alpha (make <fixed-array>))
(format #t "Bound on alpha is ~D\n" (slot-ref alpha 'max-bounds))
;; 100

(define beta (make <fixed-array>))
(slot-set! beta 'max-bounds 50)          ; still sets for whole class
(format #t "Bound on alpha is ~D\n" (slot-ref alpha 'max-bounds))
;; 50

;; defined simply as
(define-class <fixed-array> ()
  (max-bounds #:init-value 7 #:allocation #:class))

;; @@PLEAC@@_13.5
;; Guile classes are basically structs by definition.  If you don't care
;; about OO programming at all, you can use records, which are portable
;; across most Schemes.  This is, however, an OO chapter so I'll stick
;; to classes.
(define-class <person> () name age peers)

(define p (make <person>))
(slot-set! p 'name "Jason Smythe")
(slot-set! p 'age 13)
(slot-set! p 'peers '("Wilbur" "Ralph" "Fred"))
(format #t "At age ~D, ~A's first friend is ~A.\n"
        (slot-ref p 'age) (slot-ref p 'name) (car (slot-ref p 'peers)))

;; For type-checking and field validation, define the setters
;; accordingly.
(define-class <person> ()
  (name #:accessor name)
  (age #:accessor age))

(define-method ((setter age) (p <person>) a)
  (cond ((not (number? a))
         (warn "age" a "isn't numeric"))
        ((> a 150)
         (warn "age" a "is unreasonable")))
  (slot-set! p 'age a))

(define-class <family> ()
  (head #:init-form (make <person>) #:accessor head)
  (address #:init-value "" #:accessor address)
  (members #:init-value '() #:accessor members))

(define folks (make <family>))

(define dad (head folks))
(set! (name dad) "John")
(set! (age dad) 34)

(format #t "~A's age is ~D\n" (name dad) (age dad))

;; Macros are the usual way to add syntactic sugar

;; For all fields of the same type, let's use _ to mean the slot name in
;; the options expansion.
(define-macro (define-uniform-class name supers slots . options)
  `(define-class ,name ,supers
     ,@(map (lambda (s) (cons s (map (lambda (o) (if (eq? o '_) s o)) options)))
            slots)))

(define-uniform-class <card> (name color cost type release text)
  #:accessor _ #:init-value "")

;; If you *really* wanted to enforce slot types you could use something
;; like the above with the custom setter.  To illustrate reversing
;; normal slot definition args, we'll reverse an init-value:
(define-macro (define-default-class name supers . default&slots)
  `(define-class ,name ,supers
     ,@(map (lambda (d&s) (list (cadr d&s)
                                #:init-value (car d&s)
                                #:accessor (cadr d&s)))
            default&slots)))

(define-default-class hostent ()
  ("" name)
  ('() aliases)
  ("" addrtype)
  (0  length)
  ('() addr-list))

;; Nothing special needed for Aliases - all names are equal
(define type addrtype)
(define-method (addr (h <hostent>))
  (car (addr-list h)))

;; @@PLEAC@@_13.6
;; A little more clear than the Perl, but not very useful.
(define obj1 (make <some-class>))
(define obj2 (make (class-of obj1)))

;; Use the shallow-clone or deep-clone methods to initialize from
;; another instance.
(define obj1 (make <widget>))
(define obj2 (deep-clone obj1))

;; @@PLEAC@@_13.7
;; Use eval or a variant to convert from a symbol or string to the
;; actual method.  As shown in 13.5 above, methods are first class and
;; you'd be more likely to store the actual method than the name in a
;; real Scheme program.
(define methname "flicker")
(apply-generic (eval-string methname) obj 10)

(for-each (lambda (m) (apply-generic obj (eval-string m)))
          '("start" "run" "stop"))

;; really, don't do this...
(define methods '("name" "rank" "serno"))
(define his-info
  (map (lambda (m) (cons m (apply-generic (eval-string m) obj)))
       methods))

;; same as this:
(define his-info (list (cons "name" (name obj))
                       (cons "rank" (rank obj))
                       (cons "serno" (serno obj))))

;; a closure works
(define fnref (lambda args (method obj args)))
(fnref 10 "fred")
(method obj 10 fred)

;; @@PLEAC@@_13.8
;; use is-a?
(is-a? obj <http-message>)
(is-a? <http-response> <http-message>)
