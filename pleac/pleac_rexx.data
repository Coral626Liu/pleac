/* -*- REXX -*- */

/* @@PLEAC@@_NAME */
/* @@SKIP@@ REXX @@SKIP@@ */

/* @@PLEAC@@_WEB */
/* @@SKIP@@ http://www.rexxla.org/ @@SKIP@@ */

/* @@PLEAC@@_INTRO */
/* @@SKIP@@  REXX is an interpreted, general purpose programming language that     @@SKIP@@ */
/* @@SKIP@@  is used for both system and applications programming, as well as      @@SKIP@@ */
/* @@SKIP@@  REXX is an interpreted, general purpose programming language that     @@SKIP@@ */
/* @@SKIP@@  is used for both system and applications programming, as well as      @@SKIP@@ */
/* @@SKIP@@  scripting tasks on a number of platforms ranging from mainframes      @@SKIP@@ */
/* @@SKIP@@  to hand-held devices.                                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  ANSI Standard of the REXX language [a.k.a 'Classic' REXX] released    @@SKIP@@ */
/* @@SKIP@@  in 1996. The language has undergone extensive development over time,  @@SKIP@@ */
/* @@SKIP@@  and is now available in two flavours:                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * 'Classic' REXX                                                      @@SKIP@@ */
/* @@SKIP@@  * ObjectREXX or ooREXX                                                @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  The difference between these two flavours can be likened to that      @@SKIP@@ */
/* @@SKIP@@  between the C, and C++ languages: syntactically similar, but the      @@SKIP@@ */
/* @@SKIP@@  latter extended to support object oriented programming.               @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  More information is available at: http://en.wikipedia.org/wiki/REXX   @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  Comments about the examples:                                          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * REXX, unlike Perl, does not support the concept of 'references',    @@SKIP@@ */
/* @@SKIP@@    that is, the notion that an entity possesses an identifier other    @@SKIP@@ */
/* @@SKIP@@    than its own name. This means that many of the examples have not    @@SKIP@@ */
/* @@SKIP@@    been translated because the task in question is neither an issue,   @@SKIP@@ */
/* @@SKIP@@    nor is expressable, in REXX. These have been marked with:           @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@        Translation skipped                                             @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * Unfinished examples have been marked with:                          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@        Unfinished                                                      @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * Most examples contain extensive narrative descriptions as it was    @@SKIP@@ */
/* @@SKIP@@    felt important to convey to the reader the strengths of the         @@SKIP@@ */
/* @@SKIP@@    REXX language, something not always evident in the examples         @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * REXX is a simple, quite minimal language. It relies for its         @@SKIP@@ */
/* @@SKIP@@    expressiveness on its ability to seamlessly make use of             @@SKIP@@ */
/* @@SKIP@@    platform facilities, chiefly via:                                   @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - Interface to platform command processor(s)                        @@SKIP@@ */
/* @@SKIP@@    - Interface to third party libraries                                @@SKIP@@ */
/* @@SKIP@@    - Interface to system services                                      @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    As such, not all examples will work on all platforms. However,      @@SKIP@@ */
/* @@SKIP@@    such platform-specifics are clearly marked                          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * PLEAC examples seem strongly 'UNIX-oriented'. In order to better    @@SKIP@@ */
/* @@SKIP@@    reflect the cross-platform nature of REXX examples have been kept   @@SKIP@@ */
/* @@SKIP@@    as platform-neutral as possible, and examples from several          @@SKIP@@ */
/* @@SKIP@@    platforms provided wherever possible                                @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * Code examples use the 'Classic' REXX language, and use of the       @@SKIP@@ */
/* @@SKIP@@    following interpreter / platform combinations has been made:        @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - Reginald ... [http://www.borg.com/~jglatt/rexx/rexxuser.htm] on:  @@SKIP@@ */
/* @@SKIP@@      + Win32 [W2K SP4]                                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - Regina REXX 3.4 [http://regina-rexx.sourceforge.net/] on:         @@SKIP@@ */
/* @@SKIP@@      + Win32 [W2K SP4]                                                 @@SKIP@@ */
/* @@SKIP@@      + Linux [Fedora Core 2]                                           @@SKIP@@ */
/* @@SKIP@@      + VMS [OpenVMS 7.3]                                               @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - BREXX ... on:                                                     @@SKIP@@ */
/* @@SKIP@@      + MVS/TSO [MVS 3.8J]                                              @@SKIP@@ */
/* @@SKIP@@      + VM/CMS [VM/370]                                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    The choice of interpreters is partly personal and partly based on   @@SKIP@@ */
/* @@SKIP@@    availability. BREXX is the only available REXX on the latter two    @@SKIP@@ */
/* @@SKIP@@    platforms. Reginald, based on an early Regina code base, is a much  @@SKIP@@ */
/* @@SKIP@@    extended, GUI-friendly product heavily optimisd for the Win32       @@SKIP@@ */
/* @@SKIP@@    platform; in short, the VB of the REXX world, that fully caters to  @@SKIP@@ */
/* @@SKIP@@    beginners and professionals alike. Regina has the advantage of      @@SKIP@@ */
/* @@SKIP@@    cross-platform availabilty, a reputation for high performance, and  @@SKIP@@ */
/* @@SKIP@@    is probably the most recognised REXX implementation around          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * All third party code libraries are mentioned as used, and a         @@SKIP@@ */
/* @@SKIP@@    complete list appears in the appendix                               @@SKIP@@ */


/* @@PLEAC@@_APPENDIX */
/*
   Global constants assumed in examples:

     FALSE = 0 ; TRUE = 1 ; NULL = "" ; SPACE = ' '
     NEWLINE = "0A"X [Platform-specific value]

   Libraries used:

   * http://home.interlog.com/~ptjm/software.html
     
     REXXUtil      General Purpose Utilities
                   - System Information
                   - Basic Console Control
                   - File / Directory Manipulation

     REXXMath      Common Mathematical Functions
     RxHash        Associative Array Support
     REXXRe        Regular Expressions 

   * http://rxsock.sourceforge.net/index.html
     RxSock        TCP/IP Sockets

   * http://rexxsql.sourceforge.net/index.html
     REXX/SQL      SQL Library

   * http://rexxtk.sourceforge.net/index.html
     REXX/Tk       TK Toolkit

   * http://rexxcurses.sourceforge.net/index.html
     REXX/Curses   Curses Toolkit
*/


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.0                                                      */
/*                                                                    */
/* ------------------------------------------------------------------ */
                                   
string = '\n'     /* two characters, \ and an n, though not a newline */
string = "\n"     /* two characters, \ and an n, though not a newline */

string = "0A"X                     /* newline character code [hex] */
string = "1010"B                   /* newline character code [binary] */
string = "Newline" "0A"X "here"    /* embedded newline in string */

string = 'Jon ''Maddog'' Orwant'   /* literal single quotes */
string = "Jon ""Maddog"" Orwant"   /* literal double quotes */

string = "Jon 'Maddog' Orwant"     /* embedded literal single quotes */
string = 'Jon "Maddog" Orwant'     /* embedded literal double quotes */

/* ----------------------------- */

/* HERE documents not supported, but multi-line string allowed */
a = "This is a multiline string that is not a HERE document" ,
    "but consists of a series of concatenated strings" ,
    "each on its own line courtesy of the 'comma' which, when" ,
    "it appears as the last, space-separated character on a" ,
    "line, acts as a line continuation character"

/* ----------------------------- */

/* Pseudo implementation of a HERE document */

signal HEREDOC /*
Line 1 ...
Line 2 ...
Line 3
*/

HEREDOC:
  a = NULL
  do i = SIGL + 1
    line = SOURCELINE(i)
    if line = "*/" then leave
    a = a||NEWLINE||line
  end


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.1                                                      */
/*                                                                    */
/* * REXX offers string manipulation built-in functions [BIF's] many  */
/*   being equivalent to Perl offerings. However, all REXX BIF's      */
/*   return copies of the transformed string; original is unaltered.  */
/*   Therefore this type of usage is illegal:                         */
/*                                                                    */
/*     SUBSTR(string, offset, count) = newstring                      */
/*                                                                    */
/*   Instead, variable storing original must be reassigned with the   */
/*   altered copy                                                     */
/*                                                                    */
/* * REXX implements PARSE instruction which provides a faster means  */
/*   of:                                                              */
/*   - tokenising strings [from several sources: string, file, stack] */
/*   - assigning tokens to variables                                  */
/*   - initialisng and swapping variables, multi-line assignments     */
/*                                                                    */
/* Examples of both approaches shown wherever applicable              */
/* ------------------------------------------------------------------ */

string = "a value"

/* ----------------------------- */

offset = 3 ; count = 9 ; padchar = 'X'

parse var string =(offset) v
v = SUBSTR(string, offset)                     /* "value    " */

parse var string =(offset) v +(count)
v = SUBSTR(string, offset, count)              /* "value    " */

v = SUBSTR(string, offset, count, padchar)     /* "valueXXXX" */

/* ----------------------------- */

offset = 2 ; count = 2 ; padchar = '*' ; newstring = "Z"

v = INSERT(newstring, string, offset, count, padchar)  /* "a Z*value" */
v = OVERLAY(newstring, string, offset, count, padchar) /* "aZ*alue" */

/* ----------------------------- */

/* *** Unfinished *** - UNPACK   */

/* ----------------------------- */

/* PARSE VAR instruction equivalent, but more efficient, than SUBSTR */
string = "This is what you have"
slen = LENGTH(string)

parse var string =1 first +1
first = SUBSTR(string, 1, 1)                           /* "T" */

parse var string =6 start +2
start = SUBSTR(string, 6, 2)                           /* "is" */

parse var string =14 rest
rest = SUBSTR(string, 14)                              /* "you have" */

parse var string =(slen) last +1
last = SUBSTR(string, slen, 1)                         /* "e" */

parse var string =(slen) -3 end
end = SUBSTR(string, slen - 3)                         /* "have" */

parse var string =(slen) -7 piece +3
piece = SUBSTR(string, slen - 7, 3)                    /* "you" */

/* Display contents of string */
say string

/* Change "is" to "wasn't" : This wasn't  what you have */
string = CHANGEWORD("is", string, "wasn't")

/* Replace last 12 characters : This wasn't wondrous */
newstring = "ondrous" ; slen = LENGTH(string) ; nlen = LENGTH(newstring)

/* 1 - slow */
string = OVERLAY(newstring, string, slen - 11)
string = DELSTR(string, LASTPOS(newstring, string) + nlen) 

/* 2 - faster */
string = LEFT(string, slen - 12)||newstring

/* 3 - fastest */
sparse = slen - 12
parse var string string +(sparse)
string = string||newstring

/* delete first character : his wasn't wondrous */
parse var string =2 string
string = DELSTR(string, 1, 1)
string = RIGHT(string, slen - 1)

/* Return last 15 characters : wasn't wondrous */
slen = LENGTH(string)
parse var string =(slen) -14 string +15
string = SUBSTR(string, slen - 14, 15)
string = RIGHT(string, 15)

/* Delete last 10 characters : wasn' */
slen = LENGTH(string) ; sparse = slen - 10
parse var string string +(sparse)
string = DELSTR(string, slen - 9, 10)
string = LEFT(string, slen - 10)

/* *** Unfinished ***            */


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.2                                                      */
/*                                                                    */
/* REXX Boolean values are strictly:                                  */
/*   1 - TRUE                                                         */
/*   0 - FALSE                                                        */
/* All other values force an syntax error if used in a Boolean        */
/* context; Boolean expression can be forced via a comparision        */
/* operation [see example below]                                      */
/*                                                                    */
/* REXX does not support conditional structures other than the 'IF'   */
/* and 'SELECT' instructions; there is no ternary operator, nor a     */
/* conditional assignment expression. This can, however, be mimiced   */
/* via function; examples below use an 'iif' function implementation  */
/* that, rather crudely, supports this type of operation              */
/*                                                                    */
/* iif(CONDITION, TRUE_VALUE, FALSE_VALUE)                            */
/*                                                                    */
/* iif : procedure expose (globals)                                   */
/*   if ARG(1, 'E') then cond = ARG(1) ; else cond = ARG(2)           */
/*   if cond == TRUE then return ARG(2) ; else return ARG(3)          */
/*                                                                    */
/* ------------------------------------------------------------------ */

condition = TRUE ; b = 'B' ; c = 'C' ; x = TRUE ; y = 'Y'

/* Use 'b' if 'condition' is TRUE, else return 'c' */
a = iif(condition, b, c)

/* Use 'b' if 'b' is TRUE, else 'c' */
a = iif(, b, c) 

/* Set 'x' to 'y' unless 'x' is already TRUE */
x = iif(, \x, y) 

/* As above; Boolean expression forced in case 'x' non-Boolean */
x = iif(, \(x == TRUE), y) 

/* ----------------------------- */

/* Use 'b' if 'b' is defined, else 'c' */
a = iif(SYMBOL('b') == "VAR", b, c)

bar = "ANOTHER VALUE"
foo = iif(SYMBOL('bar') \= "VAR", bar, "DEFAULT VALUE")


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.3                                                      */
/*                                                                    */
/* No multiple-assignment support, but PARSE VALUE instruction may be */
/* used to perform:                                                   */
/* * Multiple variable initialisation                                 */
/* * Multiple variable assignment [even swap values without temps]    */
/* ------------------------------------------------------------------ */

parse value 1 2 with VAR1 VAR2
parse value VAR1 VAR2 with VAR2 VAR1

/* ----------------------------- */

a = 1 ; b = 2
temp = a ; a = b ; b = temp

/* ----------------------------- */

parse value 57 72 103 with alpha beta production
parse value beta production alpha with alpha beta production


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.0                                                     */
/*                                                                    */ 
/* REXX supports two types of subroutine:                             */
/* * Internal Subroutine [A block of instructions commencing with a   */
/*   label, ending with a RETURN instruction]                         */
/*                                                                    */
/* * External Subroutine [Subroutine residing external to the caller  */
/*   in a separate script file; it's last statement will be an        */
/*   implied RETURN instruction unless an explicit RETURN or EXIT is  */
/*   used]                                                            */
/*                                                                    */
/* A REXX program, can itself, be considered an external subroutine.  */
/* As such, all variables are local to a subroutine which means that  */
/* there is no direct support for 'global' variables, though it is    */
/* possible to achieve a similar effect via:                          */
/*                                                                    */
/* * Adopting the convention whereby a program only uses internal     */
/*   subroutines; any variables declared at the 'program-level' can,  */
/*   in effect, be considered 'global' [though whether these are      */
/*   visible to internal subroutines is determined on an individual   */
/*   basis via the PROCEDURE and EXPOSE intructions]                  */
/*                                                                    */
/* * Using an external 'storage facility'. This is a common approach  */
/*   since common REXX usage sees it interact closely with the        */
/*   external environment                                             */
/*                                                                    */
/* Two types of subroutine calling conventions:                       */
/* * CALL instruction used to invoke subroutine designed as           */
/*   procedures i.e. those which RETURN no value. However, it may     */
/*   also be used to invoke a subroutine which does return a value    */
/*   - in this case it is placed in a variable called RESULT          */
/*                                                                    */
/* * Implict call for subroutines designed as functions; requires     */
/*   arguments enclosed in parentheses and the capture of the return  */
/*   value in a variable or as an argument in another function call.  */
/*   Argument list is, by convention, comma-separated, but may also   */
/*   be space-separated although this requires an adjustment in how   */
/*   arguments are extracted within the procedure                     */
/* ------------------------------------------------------------------ */

greeted = 0

call hello
greetings = howManyGreetings()
say "bye there!, there have been " greetings "greetings so far"

exit 0

/* ----------------------------- */

hello :
  greeted = greeted + 1
  say "hi there!, this procedure has been called" greeted "times"
  return

/* ----------------------------- */

howManyGreetings :
  return greeted


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_1.4                                                      */
/*                                                                    */
/* REXX is a typeless language: all data are strings. This means:     */
/*                                                                    */
/* * REXX has no notion of objects, or aggregate types like arrays    */
/* * It does not support 'primitive' types, those usually mapped to   */
/*   hardware registers                                               */
/*                                                                    */
/* In order to support mathematical operations, however, strings in   */
/* Base 10 format [containing 0-9, leading + or -, a decimal point,   */
/* exponent indicator 'E' and exponent] are recognised as 'numeric'   */
/* strings in such contexts [whilst hex and binary strings are not].  */
/*                                                                    */
/* The benefit of this approach:                                      */
/*                                                                    */
/* * Simplifies interpreter implementation on new platforms           */
/* * Implicit support for arbitrary precision arithmetic              */
/* * Language kept simple - no declarations, casting or conversions   */
/*                                                                    */
/* A set of conversion BIF's is supplied to facilitate the conversion */
/* of strings to / from various numeric representations, though it is */
/* understood that this is not a type conversion, but a 'form'        */
/* conversion, one that may facilitate data printing or storage:      */
/*                                                                    */
/* * C2D / D2C [Character to Decimal / vice versa]                    */
/* * C2X / X2C [Character to Hex / vice versa]                        */
/* * X2B / B2X [Hex to Binary / vice versa]                           */
/* ------------------------------------------------------------------ */

char = 'A'                            /* or: char = '41'X [ASCII] */
num = C2D(char)
char = D2C(num)

/* ----------------------------- */

char = 'e'
say "Number" C2D(char) "is" char      /* Number 101 is e */

/* ----------------------------- */

string = "ABCDE"
ascii = C2X(string)                   /* ascii [hex]: 4142434445 */
string = X2C(ascii)                   /* string: ABCDE */

/* ----------------------------- */

/* Contents: 73616D706C65 */ 
ascii_character_numbers = C2X("sample")

/* Output will now be: 73 61 6D 70 6C 65 */ 
out = "" ; acn = ascii_character_numbers
do while acn <> NULL
  parse var acn token +2 acn
  out = out token
end
say STRIP(out)

/* Output will now be: sample */ 
out = X2C(ascii_character_numbers)
say out

/* ----------------------------- */

hal = "HAL" ; ibm = ""

do while hal <> NULL
  parse var hal token +1 hal
  ibm = ibm||D2C(C2D(token) + 1)
end 

/* Output will now be: IBM */ 
say ibm


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_1.6                                                      */
/*                                                                    */
/* The task of reversing strings is easily and efficiently performed  */
/* via the REVERSE BIF. Implementation of a palindome-checking routine*/
/* is probably best accomplished via its use since it involves a      */
/* single function call, thus incurs minimal calling overhead. Since  */
/* REXX is typically used as an interpreted language, it often becomes*/
/* a significant issue. Performance comparision of the following two  */
/* 'isPalindrome' functions should clearly reveal it's impact.        */
/*                                                                    */
/* isPalindrome : procedure                                           */
/*   i = 1 ; j = LENGTH(ARG(1))                                       */
/*   do until i >= j                                                  */
/*     if SUBSTR(ARG(1),i,1) \= SUBSTR(ARG(1),j,1) ; then return FALSE*/
/*     i = i + 1 ; j = j - 1                                          */ 
/*   end                                                              */
/*   return TRUE                                                      */ 
/*                                                                    */
/* isPalindrome : procedure                                           */
/*   return REVERSE(ARG(1)) == ARG(1)                                 */
/*                                                                    */
/* The task of reversing words within a string can quite easily be    */
/* accomplished in several ways:                                      */
/*                                                                    */
/* * PARSE instruction together with the stack operations PUSH and    */
/*   PARSE PULL [stack and queue structures are native to REXX, and   */
/*   are used for many diverse tasks including interprocess comms]    */
/*                                                                    */
/* * Word-oriented BIF's ['reverseWords' is a recursive function that */
/*   uses two of these: DELWORD and WORD. Anyone familiar with LISP or*/
/*   Scheme will note how they are being used like 'car' and cdr']    */ 
/*                                                                    */
/* reverseWords : procedure                                           */ 
/*   if ARG(1) == "" then ; return ""                                 */
/*   return STRIP(reverseWords(DELWORD(ARG(1), 1, 1)) WORD(ARG(1), 1))*/
/*                                                                    */
/* ------------------------------------------------------------------ */

string = "A horse is a horse, of course, of course !"

/* Reverse string using REXX BIF */
revbytes = REVERSE(string)

/* ----------------------------- */

/* Tokenise 'string', and place each token on stack */
do while string <> NULL
  parse var string token string
  push token
end

/* Build 'revwords' by extracting tokens from stack */
revwords = ""
do while QUEUED() > 0
  parse pull token
  revwords = revwords token 
end

/* ----------------------------- */

string = 'Yoda said, "can you see this?"'

/* Reverse the word order in a string [custom function - see header] */
revwords = reverseWords(string)
say revwords

/* ----------------------------- */

word = "reviver"

/* Check whether string is palindrome [custom function - see header] */
is_palindrome = isPalindrome(word)


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.1                                                     */
/*                                                                    */
/* REXX supports a flexible argument passing / extraction mechanism   */
/* in that arguments passed to a procedure are nothing more than a    */
/* list of strings.                                                   */
/*                                                                    */
/* The convention is to comma-separate arguments so that the          */
/* subroutine simply parses a comma-separated string to extract       */
/* arguments. It is, however, possible to circumvent convention and   */
/* adopt an alternate argument passing approach when required.        */
/*                                                                    */
/* Argument extraction is via the the PARSE ARG instruction, or via   */
/* the ARG() BIF, the latter used where manual parsing of the argument*/
/* list is to be performed.                                           */
/* ------------------------------------------------------------------ */

/* Load math functions from external library */
call rxFuncAdd 'mathLoadFuncs', 'rexxMath', 'mathLoadFuncs'
call mathLoadFuncs

/* In all cases, 'diag', contains the value 5 */ 
diag = hypotenuse(3, 4)
call hypotenuse 3, 4 ; diag = RESULT

diag = hypotenuse2(3, 4)
call hypotenuse2 3, 4 ; diag = RESULT

diag = hypotenuse3(3 4)
call hypotenuse3 3 4 ; diag = RESULT

/* Unload math functions */
call mathDropFuncs

exit 0

/* ----------------------------- */

/* Extract comma-separated arguments via 'parse' instruction */
hypotenuse : procedure

  /* Extracting subroutine arguments - assumed comma-separated */
  parse arg side1, side2

  return SQRT((side1 ** 2) + (side2 ** 2))

/* ----------------------------- */

/* Extract comma-separated arguments via 'ARG()' BIF */
hypotenuse2 : procedure

  /* Check number of [comma-separated] arguments passed */
  if ARG() \= 2 then return -1

  /* Extracting subroutine arguments - assumed comma-separated */
  side1 = ARG(1) ; side2 = ARG(2)

  return SQRT((side1 ** 2) + (side2 ** 2))

/* ----------------------------- */

/* Extract space-separated arguments via 'ARG()' BIF */
hypotenuse3 : procedure

  /* Extracting subroutine arguments - assumed space-separated */
  parse value ARG(1) with side1 side2 .

  return SQRT((side1 ** 2) + (side2 ** 2))


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.2                                                     */
/*                                                                    */
/* In REXX, all variables are local to a subroutine, thus a caller has*/
/* no direct access to the variables of a callee, something which     */
/* applies equally to both internal and external subroutines.         */
/*                                                                    */
/* An internal subroutine, since it is by definition, part of a REXX  */
/* program [therefore part of an external subroutine] is, by default, */
/* granted full access to the caller's variables. However, it is      */
/* possible to prevent such access via the PROCEDURE instruction, or  */
/* more selectively, via a combination of the PROCEDURE and EXPOSE    */
/* instructions.                                                      */
/*                                                                    */
/* Example:                                                           */
/*                                                                    */
/*     v1 = 5 ; v2 = 10                                               */
/*                                                                    */
/*     call f1                                                        */
/*     call f2                                                        */
/*     call f3                                                        */
/*                                                                    */
/*     exit 0                                                         */
/*                                                                    */
/*     f1 :                                                           */
/*       /* Access to caller's 'v1' and 'v2' */                       */
/*       v1 = 10 ; v2 = 15 ; return                                   */
/*                                                                    */
/*     f2 : procedure                                                 */
/*       /* No access to caller's variables - all local to 'f2' */    */
/*       v1 = 10 ; v2 = 15 ; return                                   */
/*                                                                    */
/*     f3 : procedure expose v1                                       */
/*       /* Access to caller's 'v1' only; 'v2' is local to 'f3' */    */
/*       v1 = 10 ; v2 = 15 ; return                                   */
/* ------------------------------------------------------------------ */

/*
   Unless 'variable' is declared in the caller, thus any reference
   to it is to the caller's, it is implicitly invisible outside of
   'somefunc'
*/
somefunc :
    variable = something  

/* ----------------------------- */

/*
   'variable' is implicitly invisible outside of 'somefunc' since
   even if the caller declared its own 'variable', it would not
   be visible here
*/
somefunc : procedure
    variable = something  


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.3                                                     */
/*                                                                    */
/* REXX does not support persistent private variables, commonly known */
/* as 'static' variables in various languages. REXX *does* allow:     */
/* * Visibility of a 'local' variable to be restricted to certain     */
/*   subroutines, but the variable is not persistent - it's destroyed */
/*   once the current subroutine [caller] exits                       */
/* * A 'global' variable to be resticted to certain subroutines; if   */
/*   the variable is first used in the top-level caller then it may be*/
/*   considered persistent. However, it is also visible within the    */
/*   scope it was first used - so is not, strictly-speaking, private  */
/*                                                                    */
/* A common method for mimicing persistent private variables is to    */
/* globally share a 'stem' variable, and have each subroutine that    */
/* needs such items create a leaf [named after itself] on this stem.  */
/* This approach provides persistence whilst avoiding the inadvertent */
/* use of global names.                                               */
/* ------------------------------------------------------------------ */

/* -------------------------------
   REXX doesn't have unnamed scopes that allow declarations:

   {
      my $variable;
      sub mysub {
         # ... accessing $variable
      }
   }

   The following:

   BEGIN {
      my $counter = 42;
      sub next_counter { return ++$counter }
      sub prev_counter { return --$counter }
   }

   may be [roughly] implemented in two ways:
   ----------------------------- */

/* [1] Persistent, but not entirely private */
counter = 42

call next_counter
call next_counter
call prev_counter

exit 0

/* ----------------------------- */

next_counter : procedure expose counter
  counter = counter + 1
  return counter

/* ----------------------------- */

prev_counter : procedure expose counter
  counter = counter - 1
  return counter

/* [2] Private, but not persistent */

BEGIN

exit 0

/* ----------------------------- */

BEGIN : procedure
  counter = 42
  call next_counter
  call next_counter
  call prev_counter

  /* 'counter' destroyed once subroutine returns */
  return

/* ----------------------------- */

next_counter : procedure expose counter
  counter = counter + 1
  return counter

/* ----------------------------- */

prev_counter : procedure expose counter
  counter = counter - 1
  return counter


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.4                                                     */
/* REXX does not offer a standard means of obtaining the current      */
/* procedure name.                                                    */
/*                                                                    */
/* The PARSE instruction with argument SOURCE may be used to obtain:  */
/* * Operating System Name                                            */
/* * Invocation Mode of current script file                           */
/*                                                                    */
/* Various implementations extend the range of available information  */
/* with a third argument commonly being the name of the current script*/
/* file. If only external procedures are ever invoked then this value */
/* corresponds to the procedure name. It is otherwise not possible to */
/* obtain the name of an internal procedure except via some kludge,   */
/* which include:                                                     */ 
/*                                                                    */
/* * Pass the procedure name as a procedure argument                  */
/* * Force an error which then invokes the debugger; trap and parse   */
/*   this output [approach might even allow tracing the call stack    */
/*   but this *is not* a standard approach]                           */
/* ------------------------------------------------------------------ */

me = whoami("whoami")
him = whowasi("whowasi")

exit 0

/* ----------------------------- */

whoami : procedure
  parse arg name
  return name

/* ----------------------------- */

whowasi : procedure
  parse arg name
  return name


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.5                                                     */
/*                                                                    */
/* REXX supports neither pass-by-reference, nor return-by-reference,  */ 
/* thus it is *not* possible [using in-built REXX facilities] to:     */
/*                                                                    */
/* * Pass a variable name / handle to a subroutine                    */
/* * Return a variable name / handle from a subroutine                */
/*                                                                    */
/* and use this item for updating a 'referred' object.                */
/*                                                                    */
/* Other languages possess similar restictions but can circumvent them*/
/* via other built-in facilities. For example, the C language supports*/
/* neither facility, but through its support of pointers mimics these */
/* facilities [i.e. a pointer acts like a handle to a memory block,   */
/* and by passing / returning pointer copies, several subroutines may */
/* all access (and optionally update) the contents of this item].     */
/*                                                                    */
/* In REXX, the following applies:                                    */
/*                                                                    */
/* * Shared access to variable(s) possible via the EXPOSE instruction */
/*   [i.e. controlled access to 'global' data]. This is the idiomatic */
/*   REXX approach though it may be considered by some to not wholly  */
/*   adhere to structured programming principles                      */
/*                                                                    */
/* * Use of a third party library that implements pointer-like or     */
/*   handle-like functionality. The third-party code used is 'RxHash' */ 
/*   library [details on availability in Appendix, and it is also     */
/*   extensively showcased in the PLEAC arrays section <<PLEAC_4.X>>] */
/*                                                                    */
/* The examples illustrate both approaches though emphasis is placed  */
/* on using the 'RxHash' library approach as it is closer in spirit to*/
/* the 'pass-by-reference' approach. Also, all 'RxHash' examples      */
/* assume the following prologue / epilogue:                          */
/*                                                                    */
/*   call rxFuncAdd 'arrLoadFuncs', 'rxHash', 'arrLoadFuncs'          */
/*   call arrLoadFuncs                                                */
/*   ...                                                              */
/*   call arrDropFuncs                                                */
/* ------------------------------------------------------------------ */

/* 'array_diff' Example 1: Data sharing via EXPOSE instruction */
array1.0 = 3 ; array1.1 = 'a' ; array1.2 = 'b' ; array1.3 = 'c'
array2.0 = 3 ; array2.1 = 'a' ; array2.2 = 'z' ; array2.3 = 'c'

/* Arguments need not be passed - done so to enhance code intent */
is_array_different = array_diff(array1, array2)

exit 0 

/* Subroutine has direct access to 'array1.' and 'array2.' variables */
array_diff : procedure expose array1. array2.
  /* Any passed arguments ignored - direct access to 'exposed' items */
  if array1.0 \= array2.0 then ; return TRUE

  /* Convention is that leaf '.0' of a stem variable contain is size */
  do i = 1 for array1.0
    if array1.i \= array2.i then ; return TRUE
  end
  return FALSE

/* ----------------------------- */

/* 'array_diff' Example 2(a): Data sharing via array handle-passing */
array1.0 = 3 ; array1.1 = 'a' ; array1.2 = 'b' ; array1.3 = 'c'
array2.0 = 3 ; array2.1 = 'a' ; array2.2 = 'z' ; array2.3 = 'c'

/* Dynamic 'arrays' created from stem variable contents */
array1Ptr = arrFromStem("array1.") ; array2Ptr = arrFromStem("array2.")

/* Dynamic array handles passed as arguments to subroutine */
is_array_different = array_diff(array1Ptr, array2Ptr)

/* Free dynamic array resources */
call arrDrop array1Ptr, array2Ptr

exit 0 

array_diff : procedure
  /* Extract arguments to obtain array handles */
  array1 = ARG(1) ; array2 = ARG(2)

  /* Compare array sizes - zeroeth element is array size */
  arrSize = arrGet(array1, 0)
  if arrSize \= arrGet(array2, 0) then ; return TRUE

  do i = 1 for arrSize
    if arrGet(array1, i) \= arrGet(array2, i) then ; return TRUE
  end
  return FALSE

/* ----------------------------- */

/* 'array_diff' Example 2(b): Data sharing via array handle-passing */

/* Dynamic 'arrays' created [Always place length in zeroeth element] */
array1Ptr = arrNew() ; call arrSet array1Ptr, 0, 0
array2Ptr = arrNew() ; call arrSet array2Ptr, 0, 0

/* Load arrays with data */
call arrSet array1Ptr, 1, 'a' ; call arrSet array2Ptr, 1, 'a'
call arrSet array1Ptr, 2, 'b' ; call arrSet array2Ptr, 2, 'z'
call arrSet array1Ptr, 3, 'c' ; call arrSet array2Ptr, 3, 'c'

/* Update array length */
call arrSet array1Ptr, 0, 3 ; call arrSet array2Ptr, 0, 3

/* Dynamic array handles passed as arguments to subroutine */
is_array_different = array_diff(array1Ptr, array2Ptr)

/* Free dynamic array resources */
call arrDrop array1Ptr, array2Ptr

exit 0 

/* Subroutine as for 2(a) */

/* ----------------------------- */

/* Create and load arrays */
a = arrNew() ; b = arrNew()
call arrSet a, 1, 1 ; call arrSet a, 2, 2 ; call arrSet a, 0, 2
call arrSet b, 1, 5 ; call arrSet b, 2, 8 ; call arrSet b, 0, 2

/* Compute results, capture return array */
c = add_vecpair(a, b)

/* Build output string */
arrSize = arrGet(c, 0) ; arrString = ""
do i = 1 for arrSize
  arrString = arrString arrGet(c, i)
end

/* Output: 6 10 */
say STRIP(arrString)

/* Release arrays */
call arrDrop a, b, c
 
/* ----------------------------- */

add_vecpair : procedure
  /* Extract arguments to obtain array handles */
  array1 = ARG(1) ; array2 = ARG(2)

  /* Allocate dynamic array, set its size to zero */
  arrayRet = arrNew() ; call arrSet arrayRet, 0, 0

  /* Compare array sizes - zeroeth element is array size */
  arrSize = arrGet(array1, 0)
  if arrSize \= arrGet(array2, 0) then ; return arrayRet

  /* Compute vector sum */
  do i = 1 for arrSize
    call arrSet arrayRet, i, arrGet(array1, i) + arrGet(array2, i)
  end

  /* Update array size */
  call arrSet arrayRet, 0, arrSize

  return arrayRet


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.6                                                     */
/*                                                                    */
/* Since REXX is a typeless language - the only 'type' is 'string', a */
/* sequence of characters - it isn't possible to determine the 'return*/
/* context' of a subroutine as is possible in Perl [i.e. Perl achieves*/
/* this feat by inspecting the stack looking for the type signature of*/
/* the variable 'capturing' the subroutine's return value (IIRC)].    */
/*                                                                    */
/* It is, however, possible to conditionally return values, be it the */
/* number of values, or the 'type' [loosely speaking] of values, based*/
/* on a control flag argument value. This is a rather conventional    */
/* approach capable of being used in many language environments. The  */
/* example shown will utilise this approach.                          */
/* ------------------------------------------------------------------ */

call mysub                                   /* Void Context */

scalar = mysub('S')                          /* Scalar Context */
if mysub('S') \= "" then ; nop

list = mysub('L')                            /* List Context */

exit 0

/* ----------------------------- */

mysub : procedure
  parse upper arg retType

  if retType == 'S' then ; return 4          /* Scalar */
  if retType == 'L' then ; return "1 2 3 4"  /* List */

  return "" /* Void */


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.7                                                     */
/*                                                                    */
/* Argument passing to subroutines is entirely optional: all may be   */
/* legally called with zero or more arguments; whether they are used, */
/* or not, is a subroutine design issue. Looking at this another way, */
/* if arguments are passed to a subroutine then data is available for */
/* extraction [via the ARG BIF or PARSE ARG instruction] and use; if  */
/* no arguments were passed then any extraction results in empty [""] */
/* strings. No runtime argument-passing checks are otherwise made.    */
/*                                                                    */
/* REXX offers no formal support for 'named' parameters, or, for that */
/* matter, default parameters. However, it is easy to mimic both by   */
/* adopting a suitable convention. Examples of these appear below.    */
/* ------------------------------------------------------------------ */

call defaultParmExample             /* a = 'X', b = 'X', c = 'X' */
call defaultParmExample 1           /* a = 1,  b = 'X', c = 'X' */
call defaultParmExample 1, , 3      /* a = 1,  b = 'X', c = 3 */

exit 0

defaultParmExample : procedure
  defaultValue = 'X'

  /* Check whether argument(s) assigned */ 
  a = defaultValue ; if ARG(1) \= "" then ; a = ARG(1)
  b = defaultValue ; if ARG(2) \= "" then ; b = ARG(2)
  c = defaultValue ; if ARG(3) \= "" then ; c = ARG(3)

  /* Display each parameter and its assigned value */
  say "a =" a
  say "b =" b
  say "c =" c

  return

/* ----------------------------- */

call namedParmExample "a=1", "b=2", "c=cat"

exit 0

namedParmExample : procedure
  /* Extract argument count */
  argCount = ARG()

  do i = 1 for argCount
    /* Parse 'named' parameter and value */
    parse value ARG(i) with key '=' val

    /* Create and initialise 'named' parameter */
    call VALUE key, val
  end

  /* Display each 'named' parameter and its assigned value */
  say "a =" a
  say "b =" b
  say "c =" c

  return

/* ----------------------------- */

call thefunc "increment=20s", "start=+5m", "finish=+30m"
call thefunc "start=+5m", "finish=+30m"
call thefunc "finish=+30m"
call thefunc "start=+5m", "increment=15s"

exit 0

thefunc : procedure 
  /* Set default values */
  increment = '10s' ; finish = 0 ; start = 0

  /* Extract argument count */
  argCount = ARG()

  do i = 1 for argCount
    /* Parse 'named' parameter and value */
    parse value ARG(i) with key '=' val

    /* Create and initialise 'named' parameter */
    call VALUE key, val
  end

  /* Default values remain unless 'named' parameters were passed */
  if RIGHT(increment, 1) == "m" then ; nop

  return


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.8                                                     */
/*                                                                    */
/* The PARSE instruction is generally used to tokenise a string. When */
/* used with the VALUE clause it is used to:                          */
/*                                                                    */
/* * Assign literals to a list of variables                           */
/* * Tokenise the return value of a function [shown below] or an      */
/*   expression                                                       */
/*                                                                    */
/* Since a string may be composed of several items, a function        */
/* returning a string allows it to mimic the returning of multiple    */
/* values. It also, almost invariably, requires the use of PARSE VALUE*/
/*                                                                    */
/* Since not all return values may be of significance on every call,  */
/* it is convention to use the '.' as the 'ignore' indicator - any    */
/* matching output is discarded.                                      */
/*                                                                    */
/* Examples use the following custom functions:                       */
/*                                                                    */
/* func : return "1 b cval"                                           */
/* stat : return "DEV INO X Y UID"                                    */
/* ------------------------------------------------------------------ */

parse value func() with a ignore c

/* Displays: 1 'b' 'cval' */
say a ignore c

/* ----------------------------- */

parse value func() with a . c

/* Displays: 1 'cval' */
say a c

/* ----------------------------- */

filename = "myfile.txt"
parse value stat(filename) with dev ino . . uid

/* Displays: 'DEV' 'INO' 'UID'  */
say dev ino uid


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.9                                                     */
/*                                                                    */
/* As already described in <<PLEAC>>_10.8 a function may mimic the    */
/* returning of multiple variables by returning a string which is     */
/* tokenised into multiple values.                                    */
/*                                                                    */
/* As already described in <<PLEAC>>_10.5 REXX supports neither       */
/* pass-by-reference, nor return- by-reference, but can use a 'handle-*/
/* based' approach [with the help of a third-party library] to 'share'*/
/* arrays among several subroutines.                                  */
/*                                                                    */
/* Sadly these two techniques cannot be combined since handles are,   */
/* themselves, strings, and cannot be arbitrarily combined and taken  */
/* apart. It is, however, possible to use the stack to return a fixed,*/
/* or arbitrary number of such items from a subroutine. Its caller is,*/
/* of course, responsible for any stack cleanup.                      */
/*                                                                    */
/* Stack use is quite simple:                                         */
/*                                                                    */
/* * Place items on stack via:                                        */
/*                                                                    */
/*     queue ITEM   [FIFO order retrieval]                            */
/*     push ITEM    [LIFO order retrieval]                            */
/*                                                                    */
/* * Extract items from stack [somewhat like reading a file] via:     */
/*                                                                    */
/*     do while QUEUED() > 0                                          */
/*       parse pull ITEM                                              */
/*       /* Do something with ITEM ... */                             */
/*     end                                                            */
/*                                                                    */
/*   Another technique involves placing [and later retrieving] the    */
/*   number of items in the stack; a counted loop can then be used for*/
/*   item retrieval.                                                  */
/*                                                                    */
/* Only a single example is shown - a modification of the 'somefunc'  */
/* Perl example - that uses a counted loop for stack retrieval. The   */
/* variables used map as follows:                                     */ 
/*                                                                    */
/*   array_ref.0  -->  Number of stack items                          */
/*   array_ref.1  -->  $array_ref                                     */
/*   array_ref.2  -->  $hash_ref                                      */
/* ------------------------------------------------------------------ */

/* Return value is the number of items to be extracted from stack */
array_ref.0 = somefunc()

/* Use counted loop to retrieve 'returned' array handles */
do i = 1 for array_ref.0
  /* Extract item [array handle] from stack */
  parse pull array_ref.i

  /* Display array handle 'length' to prove items are intact */
  say "Length of array_ref."||i "=" arrGet(array_ref.i, 0)

  /* Free array handle */
  call arrDrop array_ref.i
end

exit 0

/* ----------------------------- */

somefunc : procedure
  /* Create two dynamic arrays, set their sizes to arbitrary values */
  arrayRet1 = arrNew() ; call arrSet arrayRet1, 0, 3
  arrayRet2 = arrNew() ; call arrSet arrayRet2, 0, 4

  /* Return array handles on the stack for FIFO retrieval */
  queue arrayRet1 ; queue arrayRet2 

  /* Return number of array handles returned */
  return 2


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.10                                                    */
/*                                                                    */
/* Like so many programming languages, the empty string - "" - may be */
/* used to indicate that a subroutine 'failed'. This is, of course, a */
/* convention only, purely an arbitrary choice.                       */ 
/*                                                                    */
/* In order to improve the readability of examples, the variable NULL */
/* has been assigned the empty string value, so code such as:         */
/*                                                                    */
/*   return ""                                                        */
/*                                                                    */
/* and:                                                               */
/*                                                                    */
/*   return NULL                                                      */
/*                                                                    */
/* is equivalent.                                                     */
/* ------------------------------------------------------------------ */

return ""

/* ----------------------------- */

empty_retval : return ""

/* ----------------------------- */

a = yourfunc()

/* 'nop' means 'No operation' - same as Python's 'pass' */
if a == "" then ; nop 

/* ----------------------------- */

a = sfunc()
if a == "" then do
  ERRTXT = "sfunc failed"
  signal assertionError
end

/* ----------------------------- */

assertionError : 
  say ERRTXT
  exit 1


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.11                                                    */
/*                                                                    */
/* REXX does not require / support the prototyping of subroutines. A  */
/* subroutine is simply assumed to exist as one of a:                 */ 
/*                                                                    */
/* * Label [Internal Subroutine]                                      */ 
/* * File [External Subroutine]                                       */
/*                                                                    */
/* when a subroutine invocation is encountered. If the interpreter    */
/* fails to locate the subroutine then a SYNTAX error is thrown.      */ 
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.13                                                    */
/*                                                                    */
/* REXX does not support true 'global' variables, therefore it does   */
/* not implement the equivalent of Perl's LOCAL whereby a local name  */
/* can be made to override a global name for current block duration.  */
/* The closest facility offered in REXX are the PROCEDURE and EXPOSE  */
/* instructions, but these apply only to the subroutine to which they */
/* are applied, not on a block-basis like Perl's LOCAL.               */
/*                                                                    */
/* See <<PLEAC>>_10.2 for examples of PROCEDURE and EXPOSE            */
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.14                                                    */
/*                                                                    */
/* REXX subroutines are identified via labels. Unlike variables which */
/* may be undefined via the DROP instruction, labels cannot be        */
/* undefined. Any attempt to redefine a subroutine will be ignored -  */
/* ony the first definition in the source file will be recognised.    */
/*                                                                    */
/* Example:                                                           */
/*                                                                    */
/*     call f                                                         */
/*     exit 0                                                         */
/*                                                                    */
/*     /* Multiple subroutines - only the first one is recognised */  */
/*     f : say "First 'f'"; return                                    */
/*     f : say "Second 'f'"; return                                   */
/*     f : say "Third 'f'"; return                                    */
/*                                                                    */
/* Nor is it possible to assign the name of a subroutine to a         */
/* variable, and execute it *indirectly*. This is because REXX does   */
/* not support the notion of object 'address' or 'reference'. In      */
/* short, the whole concept of aliasing is entirely foreign to REXX.  */
/*                                                                    */
/* Aliasing-type behaviour is possible in REXX via:                   */
/*                                                                    */
/* * VALUE BIF                                                        */
/* * INTERPRET instruction                                            */
/*                                                                    */
/* but the approach taken is to build an expression, then dynamically */
/* evaluate it [the INTERPRET instruction is similar to the 'eval'    */
/* facility in Perl and Python].                                      */
/* ------------------------------------------------------------------ */

/* A call to label, 'expand' */
call expand

/* Variable, 'grow', assigned literal, 'expand'
grow = 'expand'

/* A call to label [not variable], 'grow' */
call grow

/* Both equivalent to: 'call expand' */
interpret 'call' grow
interpret 'call' VALUE('grow')

exit 0

/* ----------------------------- */

grow : say 'grow' ; return
expand : say 'expand' ; return

/* ----------------------------- */

two.Table = "X" ; two.small = "Y"

one.var = 'two.Table'
one.big = 'two.small'

interpret 'say' VALUE('one.var')
interpret 'say' VALUE('one.big')

/* ----------------------------- */

fred = 'barney'       
interpret VALUE('fred') '=' 15

say fred      /* fred = 'barney' */
say barney    /* barney = 15 */

/* ----------------------------- */

s = 'red("careful here")'
interpret 'say' VALUE('s')

s = 'green("careful there")'
interpret 'say' VALUE('s')

s = 'blue("careful everywhere")'
interpret 'say' VALUE('s')

/* ----------------------------- */

color_font :
  parse arg color, text
  return "<FONT COLOR='" || color || "'>" || text || "</FONT>"

/* ----------------------------- */

red :
  parse arg text ; return color_font("red", text)
green :
  parse arg text ; return color_font("green", text)
blue :
  parse arg text ; return color_font("blue", text)


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.15                                                    */
/*                                                                    */
/* REXX does not sport an AUTOLOAD facility. However, should a        */
/* non-existent subroutine be invoked the interpreter will signal a   */
/* SYNTAX error, typically Syntax Error Number 43 - "Routine not      */
/* found". It is possible to install a subroutine which checks for    */
/* this condition, and then takes appropriate recovery steps, perhaps */
/* copying an external subroutine from another location, or maybe     */
/* generating one, and then reattempting the subroutine invocation.   */
/*                                                                    */
/* Note, however, this approach is quite limited:                     */
/* * The undefined procedure cannot be identified                     */
/* * SYNTAX class errors are not directly recoverable because control */
/*   is not returned to the line following the error [because the     */
/*   SIGNAL instruction must be used which possesses a GOTO-like      */
/*   behaviour]                                                       */
/*                                                                    */
/* Example:                                                           */
/*                                                                    */
/*     /* Commands are system-specific - examples are Win32 */        */
/*     DELCMD = "del/q notExistFunc.rexx"                             */
/*     GENCMD = "@echo say 'I am notExistFunc' > notExistFunc.rexx"   */
/*                                                                    */
/*     main :                                                         */
/*       /* Install SYNTAX error handler */                           */
/*       signal on SYNTAX name notExistFuncTrap                       */
/*                                                                    */
/*       /* Call an undefined subroutine */                           */
/*       call notExistFunc                                            */
/*                                                                    */
/*       /* If here, subroutine *was* executed */                     */
/*       say "'notExistFunc' called ok"                               */
/*                                                                    */
/*       /* Delete subroutine before exiting */                       */
/*       address system DELCMD                                        */
/*                                                                    */
/*       exit 0                                                       */
/*                                                                    */
/*     /* SYNTAX error handler */                                     */
/*     notExistFuncTrap :                                             */
/*       say "'notExistFunc' not found, so generating it ..."         */
/*                                                                    */
/*       /* Generate missing subroutine */                            */
/*       address system GENCMD                                        */
/*                                                                    */
/*       /* Retry operation by branching back to known label */       */
/*       signal main                                                  */
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.16                                                    */
/*                                                                    */
/* REXX does not support the nesting of subroutines; these must all be*/
/* top-level, and it is not possible to restrict their visibility. If */
/* nesting *is* attempted control returns from the point in the outer */
/* subroutine where the first inner subroutine is defined; this can be*/
/* a difficult problem to diagnose.                                   */
/* ------------------------------------------------------------------ */

/* WRONG ! */
outer : procedure
  parse arg x
  x = x + 35

  inner : return x * 19 /* 'inner' block executed; 'outer' returns */

  return x + inner()    /* this line is never executed !!! */

/* ----------------------------- */

/* OK, don't nest subroutines; alter access with PROCEDURE */
outer : procedure
  parse arg x
  x = x + 35
  return x + inner()    /* this line now executes */

inner : return x * 19   /* 'inner' has direct access to 'x' */
