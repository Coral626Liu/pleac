/* -*- REXX -*- */

/* @@PLEAC@@_NAME */
/* @@SKIP@@ REXX @@SKIP@@ */

/* @@PLEAC@@_WEB */
/* @@SKIP@@ http://www.rexxla.org/ @@SKIP@@ */

/* @@PLEAC@@_INTRO */
/* @@SKIP@@  REXX is an interpreted, general purpose programming language that     @@SKIP@@ */
/* @@SKIP@@  is used for both system and applications programming, as well as      @@SKIP@@ */
/* @@SKIP@@  REXX is an interpreted, general purpose programming language that     @@SKIP@@ */
/* @@SKIP@@  is used for both system and applications programming, as well as      @@SKIP@@ */
/* @@SKIP@@  scripting tasks on a number of platforms ranging from mainframes      @@SKIP@@ */
/* @@SKIP@@  to hand-held devices.                                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  ANSI Standard of the REXX language [a.k.a 'Classic' REXX] released    @@SKIP@@ */
/* @@SKIP@@  in 1996. The language has undergone extensive development over time,  @@SKIP@@ */
/* @@SKIP@@  and is now available in two flavours:                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * 'Classic' REXX                                                      @@SKIP@@ */
/* @@SKIP@@  * ObjectREXX or ooREXX                                                @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  The difference between these two flavours can be likened to that      @@SKIP@@ */
/* @@SKIP@@  between the C, and C++ languages: syntactically similar, but the      @@SKIP@@ */
/* @@SKIP@@  latter extended to support object oriented programming.               @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  More information is available at: http://en.wikipedia.org/wiki/REXX   @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  Comments about the examples:                                          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * REXX, unlike Perl, does not support the concept of 'references',    @@SKIP@@ */
/* @@SKIP@@    that is, the notion that an entity possesses an identifier other    @@SKIP@@ */
/* @@SKIP@@    than its own name. This means that many of the examples have not    @@SKIP@@ */
/* @@SKIP@@    been translated because the task in question is neither an issue,   @@SKIP@@ */
/* @@SKIP@@    nor is expressable, in REXX. These have been marked with:           @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@        Translation skipped                                             @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * Unfinished examples have been marked with:                          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@        Unfinished                                                      @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * Most examples contain extensive narrative descriptions as it was    @@SKIP@@ */
/* @@SKIP@@    felt important to convey to the reader the strengths of the         @@SKIP@@ */
/* @@SKIP@@    REXX language, something not always evident in the examples         @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * REXX is a simple, quite minimal language. It relies for its         @@SKIP@@ */
/* @@SKIP@@    expressiveness on its ability to seamlessly make use of             @@SKIP@@ */
/* @@SKIP@@    platform facilities, chiefly via:                                   @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - Interface to platform command processor(s)                        @@SKIP@@ */
/* @@SKIP@@    - Interface to third party libraries                                @@SKIP@@ */
/* @@SKIP@@    - Interface to system services                                      @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    As such, not all examples will work on all platforms. However,      @@SKIP@@ */
/* @@SKIP@@    such platform-specifics are clearly marked                          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * PLEAC examples seem strongly 'UNIX-oriented'. In order to better    @@SKIP@@ */
/* @@SKIP@@    reflect the cross-platform nature of REXX examples have been kept   @@SKIP@@ */
/* @@SKIP@@    as platform-neutral as possible, and examples from several          @@SKIP@@ */
/* @@SKIP@@    platforms provided wherever possible                                @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * Code examples use the 'Classic' REXX language, and use of the       @@SKIP@@ */
/* @@SKIP@@    following interpreter / platform combinations has been made:        @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - Reginald ... [http://www.borg.com/~jglatt/rexx/rexxuser.htm] on:  @@SKIP@@ */
/* @@SKIP@@      + Win32 [W2K SP4]                                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - Regina REXX 3.4 [http://regina-rexx.sourceforge.net/] on:         @@SKIP@@ */
/* @@SKIP@@      + Win32 [W2K SP4]                                                 @@SKIP@@ */
/* @@SKIP@@      + Linux [Fedora Core 2]                                           @@SKIP@@ */
/* @@SKIP@@      + VMS [OpenVMS 7.3]                                               @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - BREXX ... on:                                                     @@SKIP@@ */
/* @@SKIP@@      + MVS/TSO [MVS 3.8J]                                              @@SKIP@@ */
/* @@SKIP@@      + VM/CMS [VM/370]                                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    The choice of interpreters is partly personal and partly based on   @@SKIP@@ */
/* @@SKIP@@    availability. BREXX is the only available REXX on the latter two    @@SKIP@@ */
/* @@SKIP@@    platforms. Reginald, based on an early Regina code base, is a much  @@SKIP@@ */
/* @@SKIP@@    extended, GUI-friendly product heavily optimisd for the Win32       @@SKIP@@ */
/* @@SKIP@@    platform; in short, the VB of the REXX world, that fully caters to  @@SKIP@@ */
/* @@SKIP@@    beginners and professionals alike. Regina has the advantage of      @@SKIP@@ */
/* @@SKIP@@    cross-platform availabilty, a reputation for high performance, and  @@SKIP@@ */
/* @@SKIP@@    is probably the most recognised REXX implementation around          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * All third party code libraries are mentioned as used, and a         @@SKIP@@ */
/* @@SKIP@@    complete list appears in the appendix                               @@SKIP@@ */


/* @@PLEAC@@_APPENDIX */
/*
   Global constants assumed in examples:

     FALSE = 0 ; TRUE = 1 ; NULL = "" ; SPACE = ' '
     NEWLINE = "0A"X [Platform-specific value]

   Libraries used:

   * http://home.interlog.com/~ptjm/software.html
     
     REXXUtil      General Purpose Utilities
                   - System Information
                   - Basic Console Control
                   - File / Directory Manipulation

     REXXMath      Common Mathematical Functions
     RxHash        Associative Array Support
     REXXRe        Regular Expressions 

   * http://rxsock.sourceforge.net/index.html
     RxSock        TCP/IP Sockets

   * http://rexxsql.sourceforge.net/index.html
     REXX/SQL      SQL Library

   * http://rexxtk.sourceforge.net/index.html
     REXX/Tk       TK Toolkit

   * http://rexxcurses.sourceforge.net/index.html
     REXX/Curses   Curses Toolkit
*/


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.0                                                      */
/*                                                                    */
/* ------------------------------------------------------------------ */
                                   
string = '\n'     /* two characters, \ and an n, though not a newline */
string = "\n"     /* two characters, \ and an n, though not a newline */

string = "0A"X                     /* newline character code [hex] */
string = "1010"B                   /* newline character code [binary] */
string = "Newline" "0A"X "here"    /* embedded newline in string */

string = 'Jon ''Maddog'' Orwant'   /* literal single quotes */
string = "Jon ""Maddog"" Orwant"   /* literal double quotes */

string = "Jon 'Maddog' Orwant"     /* embedded literal single quotes */
string = 'Jon "Maddog" Orwant'     /* embedded literal double quotes */

/* ----------------------------- */

/* HERE documents not supported, but multi-line string allowed */
a = "This is a multiline string that is not a HERE document" ,
    "but consists of a series of concatenated strings" ,
    "each on its own line courtesy of the 'comma' which, when" ,
    "it appears as the last, space-separated character on a" ,
    "line, acts as a line continuation character"

/* ----------------------------- */

/* Pseudo implementation of a HERE document */

signal HEREDOC /*
Line 1 ...
Line 2 ...
Line 3
*/

HEREDOC:
  a = NULL
  do i = SIGL + 1
    line = SOURCELINE(i)
    if line = "*/" then leave
    a = a||NEWLINE||line
  end


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.1                                                      */
/*                                                                    */
/* * REXX offers string manipulation built-in functions [BIF's] many  */
/*   being equivalent to Perl offerings. However, all REXX BIF's      */
/*   return copies of the transformed string; original is unaltered.  */
/*   Therefore this type of usage is illegal:                         */
/*                                                                    */
/*     SUBSTR(string, offset, count) = newstring                      */
/*                                                                    */
/*   Instead, variable storing original must be reassigned with the   */
/*   altered copy                                                     */
/*                                                                    */
/* * REXX implements PARSE instruction which provides a faster means  */
/*   of:                                                              */
/*   - tokenising strings [from several sources: string, file, stack] */
/*   - assigning tokens to variables                                  */
/*   - initialisng and swapping variables, multi-line assignments     */
/*                                                                    */
/* Examples of both approaches shown wherever applicable              */
/* ------------------------------------------------------------------ */

string = "a value"

/* ----------------------------- */

offset = 3 ; count = 9 ; padchar = 'X'

parse var string =(offset) v
v = SUBSTR(string, offset)                     /* "value    " */

parse var string =(offset) v +(count)
v = SUBSTR(string, offset, count)              /* "value    " */

v = SUBSTR(string, offset, count, padchar)     /* "valueXXXX" */

/* ----------------------------- */

offset = 2 ; count = 2 ; padchar = '*' ; newstring = "Z"

v = INSERT(newstring, string, offset, count, padchar)  /* "a Z*value" */
v = OVERLAY(newstring, string, offset, count, padchar) /* "aZ*alue" */

/* ----------------------------- */

/* *** Unfinished *** - UNPACK   */

/* ----------------------------- */

/* PARSE VAR instruction equivalent, but more efficient, than SUBSTR */
string = "This is what you have"
slen = LENGTH(string)

parse var string =1 first +1
first = SUBSTR(string, 1, 1)                           /* "T" */

parse var string =6 start +2
start = SUBSTR(string, 6, 2)                           /* "is" */

parse var string =14 rest
rest = SUBSTR(string, 14)                              /* "you have" */

parse var string =(slen) last +1
last = SUBSTR(string, slen, 1)                         /* "e" */

parse var string =(slen) -3 end
end = SUBSTR(string, slen - 3)                         /* "have" */

parse var string =(slen) -7 piece +3
piece = SUBSTR(string, slen - 7, 3)                    /* "you" */

/* Display contents of string */
say string

/* Change "is" to "wasn't" : This wasn't  what you have */
string = CHANGEWORD("is", string, "wasn't")

/* Replace last 12 characters : This wasn't wondrous */
newstring = "ondrous" ; slen = LENGTH(string) ; nlen = LENGTH(newstring)

/* 1 - slow */
string = OVERLAY(newstring, string, slen - 11)
string = DELSTR(string, LASTPOS(newstring, string) + nlen) 

/* 2 - faster */
string = LEFT(string, slen - 12)||newstring

/* 3 - fastest */
sparse = slen - 12
parse var string string +(sparse)
string = string||newstring

/* delete first character : his wasn't wondrous */
parse var string =2 string
string = DELSTR(string, 1, 1)
string = RIGHT(string, slen - 1)

/* Return last 15 characters : wasn't wondrous */
slen = LENGTH(string)
parse var string =(slen) -14 string +15
string = SUBSTR(string, slen - 14, 15)
string = RIGHT(string, 15)

/* Delete last 10 characters : wasn' */
slen = LENGTH(string) ; sparse = slen - 10
parse var string string +(sparse)
string = DELSTR(string, slen - 9, 10)
string = LEFT(string, slen - 10)

/* *** Unfinished ***            */


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.2                                                      */
/*                                                                    */
/* REXX Boolean values are strictly:                                  */
/*   1 - TRUE                                                         */
/*   0 - FALSE                                                        */
/* All other values force an syntax error if used in a Boolean        */
/* context; Boolean expression can be forced via a comparision        */
/* operation [see example below]                                      */
/*                                                                    */
/* REXX does not support conditional structures other than the 'IF'   */
/* and 'SELECT' instructions; there is no ternary operator, nor a     */
/* conditional assignment expression. This can, however, be mimiced   */
/* via function; examples below use an 'iif' function implementation  */
/* that, rather crudely, supports this type of operation              */
/*                                                                    */
/* iif(CONDITION, TRUE_VALUE, FALSE_VALUE)                            */
/*                                                                    */
/* iif : procedure expose (globals)                                   */
/*   if ARG(1, 'E') then cond = ARG(1) ; else cond = ARG(2)           */
/*   if cond == TRUE then return ARG(2) ; else return ARG(3)          */
/*                                                                    */
/* ------------------------------------------------------------------ */

condition = TRUE ; b = 'B' ; c = 'C' ; x = TRUE ; y = 'Y'

/* Use 'b' if 'condition' is TRUE, else return 'c' */
a = iif(condition, b, c)

/* Use 'b' if 'b' is TRUE, else 'c' */
a = iif(, b, c) 

/* Set 'x' to 'y' unless 'x' is already TRUE */
x = iif(, \x, y) 

/* As above; Boolean expression forced in case 'x' non-Boolean */
x = iif(, \(x == TRUE), y) 

/* ----------------------------- */

/* Use 'b' if 'b' is defined, else 'c' */
a = iif(SYMBOL('b') == "VAR", b, c)

bar = "ANOTHER VALUE"
foo = iif(SYMBOL('bar') \= "VAR", bar, "DEFAULT VALUE")


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.3                                                      */
/*                                                                    */
/* No multiple-assignment support, but PARSE VALUE instruction may be */
/* used to perform:                                                   */
/* * Multiple variable initialisation                                 */
/* * Multiple variable assignment [even swap values without temps]    */
/* ------------------------------------------------------------------ */

parse value 1 2 with VAR1 VAR2
parse value VAR1 VAR2 with VAR2 VAR1

/* ----------------------------- */

a = 1 ; b = 2
temp = a ; a = b ; b = temp

/* ----------------------------- */

parse value 57 72 103 with alpha beta production
parse value beta production alpha with alpha beta production


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.0                                                     */
/*                                                                    */ 
/* REXX supports two types of subroutine:                             */
/* * Internal Subroutine [A block of instructions commencing with a   */
/*   label, ending with a RETURN instruction]                         */
/*                                                                    */
/* * External Subroutine [Subroutine residing external to the caller  */
/*   in a separate script file; it's last statement will be an        */
/*   implied RETURN instruction unless an explicit RETURN or EXIT is  */
/*   used]                                                            */
/*                                                                    */
/* A REXX program, can itself, be considered an external subroutine.  */
/* As such, all variables are local to a subroutine which means that  */
/* there is no direct support for 'global' variables, though it is    */
/* possible to achieve a similar effect via:                          */
/*                                                                    */
/* * Adopting the convention whereby a program only uses internal     */
/*   subroutines; any variables declared at the 'program-level' can,  */
/*   in effect, be considered 'global' [though whether these are      */
/*   visible to internal subroutines is determined on an individual   */
/*   basis via the PROCEDURE and EXPOSE intructions]                  */
/*                                                                    */
/* * Using an external 'storage facility'. This is a common approach  */
/*   since common REXX usage sees it interact closely with the        */
/*   external environment                                             */
/*                                                                    */
/* Two types of subroutine calling conventions:                       */
/* * CALL instruction used to invoke subroutine designed as           */
/*   procedures i.e. those which RETURN no value. However, it may     */
/*   also be used to invoke a subroutine which does return a value    */
/*   - in this case it is placed in a variable called RESULT          */
/*                                                                    */
/* * Implict call for subroutines designed as functions; requires     */
/*   arguments enclosed in parentheses and the capture of the return  */
/*   value in a variable or as an argument in another function call.  */
/*   Argument list is, by convention, comma-separated, but may also   */
/*   be space-separated although this requires an adjustment in how   */
/*   arguments are extracted within the procedure                     */
/* ------------------------------------------------------------------ */

greeted = 0

call hello
greetings = howManyGreetings()
say "bye there!, there have been " greetings "greetings so far"

exit 0

/* ----------------------------- */

hello :
  greeted = greeted + 1
  say "hi there!, this procedure has been called" greeted "times"
  return

/* ----------------------------- */

howManyGreetings :
  return greeted


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.1                                                     */
/*                                                                    */
/* REXX supports a flexible argument passing / extraction mechanism   */
/* in that arguments passed to a procedure are nothing more than a    */
/* list of strings.                                                   */
/*                                                                    */
/* The convention is to comma-separate arguments so that the          */
/* subroutine simply parses a comma-separated string to extract       */
/* arguments. It is, however, possible to circumvent convention and   */
/* adopt an alternate argument passing approach when required.        */
/*                                                                    */
/* Argument extraction is via the the PARSE ARG instruction, or via   */
/* the ARG() BIF, the latter used where manual parsing of the argument*/
/* list is to be performed.                                           */
/* ------------------------------------------------------------------ */

/* Load math functions from external library */
call rxFuncAdd 'mathLoadFuncs', 'rexxMath', 'mathLoadFuncs'
call mathLoadFuncs

/* In all cases, 'diag', contains the value 5 */ 
diag = hypotenuse(3, 4)
call hypotenuse 3, 4 ; diag = RESULT

diag = hypotenuse2(3, 4)
call hypotenuse2 3, 4 ; diag = RESULT

diag = hypotenuse3(3 4)
call hypotenuse3 3 4 ; diag = RESULT

/* Unload math functions */
call mathDropFuncs

exit 0

/* ----------------------------- */

/* Extract comma-separated arguments via 'parse' instruction */
hypotenuse : procedure

  /* Extracting subroutine arguments - assumed comma-separated */
  parse arg side1, side2

  return SQRT((side1 ** 2) + (side2 ** 2))

/* ----------------------------- */

/* Extract comma-separated arguments via 'ARG()' BIF */
hypotenuse2 : procedure

  /* Check number of [comma-separated] arguments passed */
  if ARG() \= 2 then return -1

  /* Extracting subroutine arguments - assumed comma-separated */
  side1 = ARG(1) ; side2 = ARG(2)

  return SQRT((side1 ** 2) + (side2 ** 2))

/* ----------------------------- */

/* Extract space-separated arguments via 'ARG()' BIF */
hypotenuse3 : procedure

  /* Extracting subroutine arguments - assumed space-separated */
  parse value ARG(1) with side1 side2 .

  return SQRT((side1 ** 2) + (side2 ** 2))


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.2                                                     */
/*                                                                    */
/* In REXX, all variables are local to a subroutine, thus a caller has*/
/* no direct access to the variables of a callee, something which     */
/* applies equally to both internal and external subroutines.         */
/*                                                                    */
/* An internal subroutine, since it is by definition, part of a REXX  */
/* program [therefore part of an external subroutine] is, by default, */
/* granted full access to the caller's variables. However, it is      */
/* possible to prevent such access via the PROCEDURE instruction, or  */
/* more selectively, via a combination of the PROCEDURE and EXPOSE    */
/* instructions.                                                      */
/*                                                                    */
/* Example:                                                           */
/*                                                                    */
/*     v1 = 5 ; v2 = 10                                               */
/*                                                                    */
/*     call f1                                                        */
/*     call f2                                                        */
/*     call f3                                                        */
/*                                                                    */
/*     exit 0                                                         */
/*                                                                    */
/*     f1 :                                                           */
/*       /* Access to caller's 'v1' and 'v2' */                       */
/*       v1 = 10 ; v2 = 15 ; return                                   */
/*                                                                    */
/*     f2 : procedure                                                 */
/*       /* No access to caller's variables - all local to 'f2' */    */
/*       v1 = 10 ; v2 = 15 ; return                                   */
/*                                                                    */
/*     f3 : procedure expose v1                                       */
/*       /* Access to caller's 'v1' only; 'v2' is local to 'f3' */    */
/*       v1 = 10 ; v2 = 15 ; return                                   */
/* ------------------------------------------------------------------ */

/*
   Unless 'variable' is declared in the caller, thus any reference
   to it is to the caller's, it is implicitly invisible outside of
   'somefunc'
*/
somefunc :
    variable = something  

/* ----------------------------- */

/*
   'variable' is implicitly invisible outside of 'somefunc' since
   even if the caller declared its own 'variable', it would not
   be visible here
*/
somefunc : procedure
    variable = something  


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.3                                                     */
/*                                                                    */
/* REXX does not support persistent private variables, commonly known */
/* as 'static' variables in various languages. REXX *does* allow:     */
/* * Visibility of a 'local' variable to be restricted to certain     */
/*   subroutines, but the variable is not persistent - it's destroyed */
/*   once the current subroutine [caller] exits                       */
/* * A 'global' variable to be resticted to certain subroutines; if   */
/*   the variable is first used in the top-level caller then it may be*/
/*   considered persistent. However, it is also visible within the    */
/*   scope it was first used - so is not, strictly-speaking, private  */
/*                                                                    */
/* A common method for mimicing persistent private variables is to    */
/* globally share a 'stem' variable, and have each subroutine that    */
/* needs such items create a leaf [named after itself] on this stem.  */
/* This approach provides persistence whilst avoiding the inadvertent */
/* use of global names.                                               */
/* ------------------------------------------------------------------ */

/* -------------------------------
   REXX doesn't have unnamed scopes that allow declarations:

   {
      my $variable;
      sub mysub {
         # ... accessing $variable
      }
   }

   The following:

   BEGIN {
      my $counter = 42;
      sub next_counter { return ++$counter }
      sub prev_counter { return --$counter }
   }

   may be [roughly] implemented in two ways:
   ----------------------------- */

/* [1] Persistent, but not entirely private */
counter = 42

call next_counter
call next_counter
call prev_counter

exit 0

/* ----------------------------- */

next_counter : procedure expose counter
  counter = counter + 1
  return counter

/* ----------------------------- */

prev_counter : procedure expose counter
  counter = counter - 1
  return counter

/* [2] Private, but not persistent */

BEGIN

exit 0

/* ----------------------------- */

BEGIN : procedure
  counter = 42
  call next_counter
  call next_counter
  call prev_counter

  /* 'counter' destroyed once subroutine returns */
  return

/* ----------------------------- */

next_counter : procedure expose counter
  counter = counter + 1
  return counter

/* ----------------------------- */

prev_counter : procedure expose counter
  counter = counter - 1
  return counter


/* ------------------------------------------------------------------ */
/* @@PLEAC@@_10.4                                                     */
/* REXX does not offer a standard means of obtaining the current      */
/* procedure name.                                                    */
/*                                                                    */
/* The PARSE instruction with argument SOURCE may be used to obtain:  */
/* * Operating System Name                                            */
/* * Invocation Mode of current script file                           */
/*                                                                    */
/* Various implementations extend the range of available information  */
/* with a third argument commonly being the name of the current script*/
/* file. If only external procedures are ever invoked then this value */
/* corresponds to the procedure name. It is otherwise not possible to */
/* obtain the name of an internal procedure except via some kludge,   */
/* which include:                                                     */ 
/*                                                                    */
/* * Pass the procedure name as a procedure argument                  */
/* * Force an error which then invokes the debugger; trap and parse   */
/*   this output [approach might even allow tracing the call stack    */
/*   but this *is not* a standard approach]                           */
/* ------------------------------------------------------------------ */

me = whoami("whoami")
him = whowasi("whowasi")

exit 0

/* ----------------------------- */

whoami : procedure
  parse arg name
  return name

/* ----------------------------- */

whowasi : procedure
  parse arg name
  return name
