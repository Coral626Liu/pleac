/* -*- REXX -*- */

/* @@PLEAC@@_NAME */
/* @@SKIP@@ REXX @@SKIP@@ */

/* @@PLEAC@@_WEB */
/* @@SKIP@@ http://www.rexxla.org/ @@SKIP@@ */

/* @@PLEAC@@_INTRO */
/* @@SKIP@@  REXX is an interpreted, general purpose programming language that     @@SKIP@@ */
/* @@SKIP@@  is used for both system and applications programming, as well as      @@SKIP@@ */
/* @@SKIP@@  REXX is an interpreted, general purpose programming language that     @@SKIP@@ */
/* @@SKIP@@  is used for both system and applications programming, as well as      @@SKIP@@ */
/* @@SKIP@@  scripting tasks on a number of platforms ranging from mainframes      @@SKIP@@ */
/* @@SKIP@@  to hand-held devices.                                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  ANSI Standard of the REXX language [a.k.a 'Classic' REXX] released    @@SKIP@@ */
/* @@SKIP@@  in 1996. The language has undergone extensive development over time,  @@SKIP@@ */
/* @@SKIP@@  and is now available in two flavours:                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * 'Classic' REXX                                                      @@SKIP@@ */
/* @@SKIP@@  * ObjectREXX or ooREXX                                                @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  The difference between these two flavours can be likened to that      @@SKIP@@ */
/* @@SKIP@@  between the C, and C++ languages: syntactically similar, but the      @@SKIP@@ */
/* @@SKIP@@  latter extended to support object oriented programming.               @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  More information is available at: http://en.wikipedia.org/wiki/REXX   @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  Comments about the examples:                                          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * REXX, unlike Perl, does not support the concept of 'references',    @@SKIP@@ */
/* @@SKIP@@    that is, the notion that an entity possesses an identifier other    @@SKIP@@ */
/* @@SKIP@@    than its own name. This means that many of the examples have not    @@SKIP@@ */
/* @@SKIP@@    been translated because the task in question is neither an issue,   @@SKIP@@ */
/* @@SKIP@@    nor is expressable, in REXX. These have been marked with:           @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@        Translation skipped                                             @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * Unfinished examples have been marked with:                          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@        Unfinished                                                      @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * Most examples contain extensive narrative descriptions as it was    @@SKIP@@ */
/* @@SKIP@@    felt important to convey to the reader the strengths of the         @@SKIP@@ */
/* @@SKIP@@    REXX language, something not always evident in the examples         @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * REXX is a simple, quite minimal language. It relies for its         @@SKIP@@ */
/* @@SKIP@@    expressiveness on its ability to seamlessly make use of             @@SKIP@@ */
/* @@SKIP@@    platform facilities, chiefly via:                                   @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - Interface to platform command processor(s)                        @@SKIP@@ */
/* @@SKIP@@    - Interface to third party libraries                                @@SKIP@@ */
/* @@SKIP@@    - Interface to system services                                      @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    As such, not all examples will work on all platforms. However,      @@SKIP@@ */
/* @@SKIP@@    such platform-specifics are clearly marked                          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * PLEAC examples seem strongly 'UNIX-oriented'. In order to better    @@SKIP@@ */
/* @@SKIP@@    reflect the cross-platform nature of REXX examples have been kept   @@SKIP@@ */
/* @@SKIP@@    as platform-neutral as possible, and examples from several          @@SKIP@@ */
/* @@SKIP@@    platforms provided wherever possible                                @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * Code examples use the 'Classic' REXX language, and use of the       @@SKIP@@ */
/* @@SKIP@@    following interpreter / platform combinations has been made:        @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - Reginald ... [http://www.borg.com/~jglatt/rexx/rexxuser.htm] on:  @@SKIP@@ */
/* @@SKIP@@      + Win32 [W2K SP4]                                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - Regina REXX 3.4 [http://regina-rexx.sourceforge.net/] on:         @@SKIP@@ */
/* @@SKIP@@      + Win32 [W2K SP4]                                                 @@SKIP@@ */
/* @@SKIP@@      + Linux [Fedora Core 2]                                           @@SKIP@@ */
/* @@SKIP@@      + VMS [OpenVMS 7.3]                                               @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    - BREXX ... on:                                                     @@SKIP@@ */
/* @@SKIP@@      + MVS/TSO [MVS 3.8J]                                              @@SKIP@@ */
/* @@SKIP@@      + VM/CMS [VM/370]                                                 @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@    The choice of interpreters is partly personal and partly based on   @@SKIP@@ */
/* @@SKIP@@    availability. BREXX is the only available REXX on the latter two    @@SKIP@@ */
/* @@SKIP@@    platforms. Reginald, based on an early Regina code base, is a much  @@SKIP@@ */
/* @@SKIP@@    extended, GUI-friendly product heavily optimisd for the Win32       @@SKIP@@ */
/* @@SKIP@@    platform; in short, the VB of the REXX world, that fully caters to  @@SKIP@@ */
/* @@SKIP@@    beginners and professionals alike. Regina has the advantage of      @@SKIP@@ */
/* @@SKIP@@    cross-platform availabilty, a reputation for high performance, and  @@SKIP@@ */
/* @@SKIP@@    is probably the most recognised REXX implementation around          @@SKIP@@ */
/* @@SKIP@@                                                                        @@SKIP@@ */
/* @@SKIP@@  * All third party code libraries are mentioned as used, and a         @@SKIP@@ */
/* @@SKIP@@    complete list appears in the appendix                               @@SKIP@@ */


/* @@PLEAC@@_APPENDIX */
/*
   Global constants assumed in examples:

     FALSE = 0 ; TRUE = 1 ; NULL = "" ; SPACE = ' '
     NEWLINE = "0A"X [Platform-specific value]

   Libraries used:

   * http://home.interlog.com/~ptjm/software.html
     
     REXXUtil      General Purpose Utilities
                   - System Information
                   - Basic Console Control
                   - File / Directory Manipulation

     REXXMath      Common Mathematical Functions
     RxHash        Associative Array Support
     REXXRe        Regular Expressions 

   * http://rxsock.sourceforge.net/index.html
     RxSock        TCP/IP Sockets

   * http://rexxsql.sourceforge.net/index.html
     REXX/SQL      SQL Library

   * http://rexxtk.sourceforge.net/index.html
     REXX/Tk       TK Toolkit

   * http://rexxcurses.sourceforge.net/index.html
     REXX/Curses   Curses Toolkit
*/


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.0                                                      */
/*                                                                    */
/* ------------------------------------------------------------------ */
                                   
string = '\n'     /* two characters, \ and an n, though not a newline */
string = "\n"     /* two characters, \ and an n, though not a newline */

string = "0A"X                     /* newline character code [hex] */
string = "1010"B                   /* newline character code [binary] */
string = "Newline" "0A"X "here"    /* embedded newline in string */

string = 'Jon ''Maddog'' Orwant'   /* literal single quotes */
string = "Jon ""Maddog"" Orwant"   /* literal double quotes */

string = "Jon 'Maddog' Orwant"     /* embedded literal single quotes */
string = 'Jon "Maddog" Orwant'     /* embedded literal double quotes */

/* ----------------------------- */

/* HERE documents not supported, but multi-line string allowed */
a = "This is a multiline string that is not a HERE document" ,
    "but consists of a series of concatenated strings" ,
    "each on its own line courtesy of the 'comma' which, when" ,
    "it appears as the last, space-separated character on a" ,
    "line, acts as a line continuation character"

/* ----------------------------- */

/* Pseudo implementation of a HERE document */

signal HEREDOC /*
Line 1 ...
Line 2 ...
Line 3
*/

HEREDOC:
  a = NULL
  do i = SIGL + 1
    line = SOURCELINE(i)
    if line = "*/" then leave
    a = a||NEWLINE||line
  end


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.1                                                      */
/*                                                                    */
/* * REXX offers string manipulation built-in functions [BIF's] many  */
/*   being equivalent to Perl offerings. However, all REXX BIF's      */
/*   return copies of the transformed string; original is unaltered.  */
/*   Therefore this type of usage is illegal:                         */
/*                                                                    */
/*     SUBSTR(string, offset, count) = newstring                      */
/*                                                                    */
/*   Instead, variable storing original must be reassigned with the   */
/*   altered copy                                                     */
/*                                                                    */
/* * REXX implements PARSE instruction which provides a faster means  */
/*   of:                                                              */
/*   - tokenising strings [from several sources: string, file, stack] */
/*   - assigning tokens to variables                                  */
/*   - initialisng and swapping variables, multi-line assignments     */
/*                                                                    */
/* Examples of both approaches shown wherever applicable              */
/* ------------------------------------------------------------------ */

string = "a value"

/* ----------------------------- */

offset = 3 ; count = 9 ; padchar = 'X'

parse var string =(offset) v
v = SUBSTR(string, offset)                     /* "value    " */

parse var string =(offset) v +(count)
v = SUBSTR(string, offset, count)              /* "value    " */

v = SUBSTR(string, offset, count, padchar)     /* "valueXXXX" */

/* ----------------------------- */

offset = 2 ; count = 2 ; padchar = '*' ; newstring = "Z"

v = INSERT(newstring, string, offset, count, padchar)  /* "a Z*value" */
v = OVERLAY(newstring, string, offset, count, padchar) /* "aZ*alue" */

/* ----------------------------- */

/* *** Unfinished *** - UNPACK   */

/* ----------------------------- */

/* PARSE VAR instruction equivalent, but more efficient, than SUBSTR */
string = "This is what you have"
slen = LENGTH(string)

parse var string =1 first +1
first = SUBSTR(string, 1, 1)                           /* "T" */

parse var string =6 start +2
start = SUBSTR(string, 6, 2)                           /* "is" */

parse var string =14 rest
rest = SUBSTR(string, 14)                              /* "you have" */

parse var string =(slen) last +1
last = SUBSTR(string, slen, 1)                         /* "e" */

parse var string =(slen) -3 end
end = SUBSTR(string, slen - 3)                         /* "have" */

parse var string =(slen) -7 piece +3
piece = SUBSTR(string, slen - 7, 3)                    /* "you" */

/* Display contents of string */
say string

/* Change "is" to "wasn't" : This wasn't  what you have */
string = CHANGEWORD("is", string, "wasn't")

/* Replace last 12 characters : This wasn't wondrous */
newstring = "ondrous" ; slen = LENGTH(string) ; nlen = LENGTH(newstring)

/* 1 - slow */
string = OVERLAY(newstring, string, slen - 11)
string = DELSTR(string, LASTPOS(newstring, string) + nlen) 

/* 2 - faster */
string = LEFT(string, slen - 12)||newstring

/* 3 - fastest */
sparse = slen - 12
parse var string string +(sparse)
string = string||newstring

/* delete first character : his wasn't wondrous */
parse var string =2 string
string = DELSTR(string, 1, 1)
string = RIGHT(string, slen - 1)

/* Return last 15 characters : wasn't wondrous */
slen = LENGTH(string)
parse var string =(slen) -14 string +15
string = SUBSTR(string, slen - 14, 15)
string = RIGHT(string, 15)

/* Delete last 10 characters : wasn' */
slen = LENGTH(string) ; sparse = slen - 10
parse var string string +(sparse)
string = DELSTR(string, slen - 9, 10)
string = LEFT(string, slen - 10)

/* *** Unfinished ***            */


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.2                                                      */
/*                                                                    */
/* REXX Boolean values are strictly:                                  */
/*   1 - TRUE                                                         */
/*   0 - FALSE                                                        */
/* All other values force an syntax error if used in a Boolean        */
/* context; Boolean expression can be forced via a comparision        */
/* operation [see example below]                                      */
/*                                                                    */
/* REXX does not support conditional structures other than the 'IF'   */
/* and 'SELECT' instructions; there is no ternary operator, nor a     */
/* conditional assignment expression. This can, however, be mimiced   */
/* via function; examples below use an 'iif' function implementation  */
/* that, rather crudely, supports this type of operation              */
/*                                                                    */
/* iif(CONDITION, TRUE_VALUE, FALSE_VALUE)                            */
/*                                                                    */
/* iif : procedure expose (globals)                                   */
/*   if ARG(1, 'E') then cond = ARG(1) ; else cond = ARG(2)           */
/*   if cond == TRUE then return ARG(2) ; else return ARG(3)          */
/*                                                                    */
/* ------------------------------------------------------------------ */

condition = TRUE ; b = 'B' ; c = 'C' ; x = TRUE ; y = 'Y'

/* Use 'b' if 'condition' is TRUE, else return 'c' */
a = iif(condition, b, c)

/* Use 'b' if 'b' is TRUE, else 'c' */
a = iif(, b, c) 

/* Set 'x' to 'y' unless 'x' is already TRUE */
x = iif(, \x, y) 

/* As above; Boolean expression forced in case 'x' non-Boolean */
x = iif(, \(x == TRUE), y) 

/* ----------------------------- */

/* Use 'b' if 'b' is defined, else 'c' */
a = iif(SYMBOL('b') == "VAR", b, c)

bar = "ANOTHER VALUE"
foo = iif(SYMBOL('bar') \= "VAR", bar, "DEFAULT VALUE")


/* ------------------------------------------------------------------ */
/*                                                                    */
/* @@PLEAC@@_1.3                                                      */
/*                                                                    */
/* No multiple-assignment support, but PARSE VALUE instruction may be */
/* used to perform:                                                   */
/* * Multiple variable initialisation                                 */
/* * Multiple variable assignment [even swap values without temps]    */
/* ------------------------------------------------------------------ */

parse value 1 2 with VAR1 VAR2
parse value VAR1 VAR2 with VAR2 VAR1

/* ----------------------------- */

a = 1 ; b = 2
temp = a ; a = b ; b = temp

/* ----------------------------- */

parse value 57 72 103 with alpha beta production
parse value beta production alpha with alpha beta production
