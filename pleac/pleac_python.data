 # -*- python -*-

# @@PLEAC@@_NAME
Python

# @@PLEAC@@_WEB
http://www.python.org


# @@PLEAC@@_1.0
string = r'\n'                          # two characters, \ and an n
string = r'Jon \'Maddog\' Orwant'       # literal single quotes

string = "\n"                           # a "newline" character
string = "Jon \"Maddog\" Orwant"        # literal double quotes

string = "Jon 'Maddog' Orwant"          # literal single quotes

string = '''Jon 'Maddog' Orwant'''      # literal single quotes
string = """Jon 'Maddog' Orwant"""      # literal single quotes

a = """
This is a multiline here document
terminated by triple double quote
"""

# @@PLEAC@@_1.1

s = "This is what you have"
first = s[0]                            # "T"
start = s[5:7]                          # "is"
rest  = s[13:]                          # "you have"
last  = s[-1]                           # "e"
end   = s[-4:]                          # "have"
piece = s[-8:-5]                        # "you"

# can't modify string, if really needed use character arrays:
s = array.array("c", "This is what you have")
s[5:7] = array.array("c", "wasn't")
# s now is array('c', "This wasn't what you have")

# @@PLEAC@@_1.2
a = b or c

# @@PLEAC@@_1.3
v1, v2 = v2, v1

alpha, beta, production = "January March August".split()
alpha, beta, production = beta, production, alpha

# @@PLEAC@@_1.4
num = ord(char)
char = chr(num)

char = "%" % num
print "Number %d is character %c\n" % (num, num)

print "Number %(n)d is character %(n)c\n" % {"n": num }

from string import *
hal = "HAL"
ibm = join(map(lambda i: chr(ord(i)+1), hal), "")
print ibm


# @@PLEAC@@_1.5
for b in string:
    # do something with b

string = "an apple a day"
d = {}
for i in string: d[i] = 1
l = d.keys()
l.sort()
print "unique chars are: ", join(l)

sum = 0
for i in ascval: sum += ord(i)
print "sum is ", sum


# @@PLEAC@@_1.6
l = list(string)
l.reverse()
revbytes = "".join(l)

l = split(string)
l.reverse()
revwords = join(l)

def rev_string(s):
    l = list(s)
    l.reverse()
    return "".join(l)

long_palindromes = filter(lambda word: len(word) > 5 and rev_string(word) == word,
             map(rstrip, open("/usr/share/dict/words").readlines()))uu

# @@PLEAC@@_1.7
string.expandtabs()

# @@PLEAC@@_1.8
sub("\d+", lambda i: str(2 * int(i.group(0))), "I am 17 years old")

# @@PLEAC@@_1.9
e = "bo peep".upper()
e = e.lower()
e = e.capitalize()

sub("\w+", lambda i: i.group(0).capitalize(), "thIS is a loNG liNE")

# @@PLEAC@@_1.10
"I have %d guanacos." % (n + 1)
print "I have", n+1, "guanacos."


# @@PLEAC@@_1.12
string = "Folding and splicing is the work of an editor,\n" + \
    "not a mere collection of silicon\n" + \
    "and\n" + \
    "mobile electrons!"

def wrap(str, max_size):
    all = []
    line = ""
    for l in str.split():
        if len(line+l) >= max_size:
            all += [line]
            line = ''
        line += l + ' '
    return "\n".join(all + [line])

print wrap(string, 20)


# @@PLEAC@@_1.13
string = '''Mom said, "Don't do that."'''  #"
sub("['\"]", lambda i: "\\" + i.group(0), string)
sub("[A-Z]", lambda i: "\\" + i.group(0), string)
sub("\W", lambda i: "\\" + i.group(0), "is a test!") # no function like quotemeta?


# @@PLEAC@@_1.14
string = string.strip


# @@PLEAC@@_1.15
from re import *
from string import *

def parse_csv(text):
    l = map(lambda i: join(i, ''), findall('''"([^"\\\]*(?:\\\.[^"\\\]*)*)",?|([^,]+),?|,''', text))
    if text[-1] == ",": l += ['']
    return l

line = '''XYZZY,"","O'Reilly, Inc","Wall, Larry","a \\"glug\\" bit,",5,,"Error,, Core Dumped,",''' #"

fields = parse_csv(line)
for i in range(len(fields)):
    print "%d : %s" % (i, fields[i])

# @@PLEAC@@_1.17
import sys, fileinput, re

data = """\
analysed        => analyzed
built-in        => builtin
chastized       => chastised
commandline     => command-line
de-allocate     => deallocate
dropin          => drop-in
hardcode        => hard-code
meta-data       => metadata
multicharacter  => multi-character
multiway        => multi-way
non-empty       => nonempty
non-profit      => nonprofit
non-trappable   => nontrappable
pre-define      => predefine
preextend       => pre-extend
re-compiling    => recompiling
reenter         => re-enter
turnkey         => turn-key
"""
dict = {}
for line in data.split("\n"):
    if not line.strip():
        continue
    k, v = [word.strip() for word in line.split("=>")]
    dict[k] = v
pattern_text = "(" + "|".join([re.escape(word) for word in dict.keys()]) + ")"
pattern = re.compile(pattern_text)

args = sys.argv[1:]
verbose = 0
if args and args[0] == "-v":
    verbose = 1
    args = args[1:]

if not args:
    sys.stderr.write("%s: Reading from stdin\n" % sys.argv[0])

for line in fileinput.input(args, inplace = 1, backup = ".orig"):
    output = ""
    pos = 0
    while 1:
        match = pattern.search(line, pos)
        if not match:
            output += line[pos:]
            break
        output += line[pos:match.start(0)] + dict[match.group(1)]
        pos = match.end(0)
    sys.stdout.write(output)


# @@PLEAC@@_2.1
if match("[+-]?\d+$", string):
    print 'is an integer'
else:
    print 'is not'


if match("-?(?:\d+(?:\.\d*)?|\.\d+)$", string):
    print 'is a decimal number'
else:
    print 'is not'


# @@PLEAC@@_2.2
# equal(num1, num2, accuracy) : returns true if num1 and num2 are
#   equal to accuracy number of decimal places
def equal(i, j, a):
    i - j < 10. ** -a

wage = 536                        # $5.36/hour
week = 40 * wage                  # $214.40
print "One week's wage is: $%.2f" % (week/100.0)


# @@PLEAC@@_2.3
round(num)                              # rounds to integer

a = 0.255
b = "%.2f" % a
print "Unrounded: %f\nRounded: %s" % (a, b)
print "Unrounded: %f\nRounded: %.2f" % (a, a)

from math import *

print "number\tint\tfloor\tceil"
a = [ 3.3 , 3.5 , 3.7, -3.3 ]
for n in a:
    print "% .1f\t% .1f\t% .1f\t% .1f" % (n, int(n), floor(n), ceil(n))

# @@PLEAC@@_2.5
for i in range(x,y):
    # i is set to every integer from x to y, exclusive

for i in range(x, y, 7):
    # i is set to every integer from x to y, stepsize = 7

print "Infancy is: "
for i in range(0,3):
    print i, " "
print "\n"


# @@PLEAC@@_2.7
from whrandom import *
random = uniform(x, y)


# TODO
#chars = ["A".."Z","a".."z","0".."9"].collect { |r| r.to_a }.join + %q(!@$%^&*)
#password = (1..8).collect { chars[rand(chars.size)] }.pack("C*")


# @@PLEAC@@_2.8
seed        # uses a combination of the time, the process id, and a sequence number
seed(val)   # for repeatable behaviour

# @@PLEAC@@_2.16
print "%(num)d %(num)x %(num)o\n" % { "num": num }

# @@PLEAC@@_7.0
input = open("/usr/local/widgets/data")
for line in input:
    if line.find("blue") != -1:
        print line[:-1]
input.close()
#---------
import sys, re
pattern = re.compile(r"\d")
for line in sys.stdin:
    if not pattern.search(line):
        sys.stderr.write("No digit found.\n")
    sys.stdout.write("Read: " + line)
sys.stdout.close()
#---------
logfile = open("/tmp/log", "w")
#---------
logfile.close()
#---------
# NOTE: this is poor Python style.
import sys
old_output, sys.stdout = sys.stdout, logfile
print "Countdown initiated ..."
sys.stdout = old_output
print "You have 30 seconds to reach minimum safety distance."
# NOTE: It is better to just use
print >> logfile, "Countdown initiated ..."
print >> sys.stdout, "You have 30 seconds to reach minimum safety distance."
#---------

# @@PLEAC@@_7.1
source = open(path)
sink = open(path, "w")
#---------
# NOTE: almost no one uses the low-level os.open and os.fdopen
# commands, so their inclusion here is just silly.  If the
# os.fdopen(os.open(...)) was needed often, it would be turned
# into its own function.  Instead, I'll use 'fd' to hint that
# os.open returns a file descriptor
import os
source_fd = os.open(path, os.O_RDONLY)
source = os.fdopen(fd)
sink_fd = os.open(path, os.O_WRONLY)
sink = os.fdopen(sink_fd)
#---------
file = open(filename, "w")
fd = os.open(filename, os.O_WRONLY | os.O_CREAT)
file = open(filename, "r+")
#---------
fd = os.open(name, flags)
fd = os.open(name, flags, mode)
#---------
file = open(path)
fd = os.open(path, os.O_RDONLY)
#-----------------------------
file = open(path, "w")
fd = os.open(path, os.O_WRONLY|os.O_TRUNC|os.O_CREAT)
fd = os.open(path, os.O_WRONLY|os.O_TRUNC|os.O_CREAT, 0600)
#-----------------------------
fd = os.open(path, os.O_WRONLY|os.O_EXCL|os.O_CREAT)
fd = os.open(path, os.O_WRONLY|os.O_EXCL|os.O_CREAT, 0600)
#-----------------------------
file = open(path, "a")
fd = os.open(path, os.O_WRONLY|os.O_APPEND|os.O_CREAT)
fd = os.open(path, os.O_WRONLY|os.O_APPEND|s.O_CREAT, 0600)
#-----------------------------
fd = os.open(path, os.O_WRONLY|os.O_APPEND)
#-----------------------------
file = open(path, "rw")
fd = os.open(path, os.O_RDWR)
#-----------------------------
fd = os.open(path, os.O_RDWR|os.O_CREAT)
fd = os.open(path, os.O_RDWR|os.O_CREAT, 0600)
#-----------------------------
fd = os.open(path, os.O_RDWR|os.O_EXCL|os.O_CREAT)
fd = os.open(path, os.O_RDWR|os.O_EXCL|os.O_CREAT, 0600)
#-----------------------------

# @@PLEAC@@_7.2
# Nothing different needs to be done with Python

# @@PLEAC@@_7.3
import os
filename = os.path.expanduser(filename)

# @@PLEAC@@_7.4
file = open(filename)   # raise an exception on error

try:
  file = open(filename)
except IOError, err:
  raise AssertionError("Couldn't open %s for reading : %s" %
                       (filename, err.strerror))

# @@PLEAC@@_7.5
import tempfile

file = tempfile.TemporaryFile()

#-----------------------------
# NOTE: The TemporaryFile() call is much more appropriate
# I would not suggest using this code for real work.
import os, tempfile

while 1:
  name = os.tmpnam()
  try:
    fd = os.open(name, os.O_RDWR|os.O_CREAT|os.O_EXCL)
    break
  except os.error:
    pass
file = tempfile.TemporaryFileWrapper(os.fdopen(fd), name)

# now go on to use the file ...
#-----------------------------
import os
while 1:
  tmpname = os.tmpnam()
  fd = os.open(tmpnam, os.O_RDWR | os.O_CREAT | os.O_EXCL)
  if fd:
    tmpfile = os.fdopen(fd)
    break

os.unlink(tmpnam)

#-----------------------------
import tempfile

file = tempfile.TemporaryFile(bufsize = 0)
for i in range(10):
  print >>file, i
file.seek(0)
print "Tmp file has:", file.read()
#-----------------------------

# @@PLEAC@@_7.6
DATA = """\
your data goes here
"""
for line in DATA.split("\n"):
    # process the line

# @@PLEAC@@_7.7
for line in sys.stdin:
    # do something with the line

#-----------------------------
import sys

def do_with(file):
  for line in file:
      print line[:-1]

filenames = sys.argv[1:]
if filenames:
    for filename in filenames:
        try:
            do_with(open(filename))
        except IOError, err:
            sys.stderr.write("Can't open %s: %s\n" % (filename, err.strerror))
            continue
else:
    do_with(sys.stdin)

#-----------------------------
import sys, glob
ARGV = sys.argv[1:] or glob.glob("*.[Cch]")
#-----------------------------
# NOTE: the getopt module is the prefered mechanism for reading
# command line arguments
import sys
args = sys.argv[1:]
chop_first = 0

if args and args[0] == "-c":
   chop_first += 1
   args = args[1:]

# arg demo 2: Process optional -NUMBER flag

# NOTE: You just wouldn't process things this way for Python,
# but I'm trying to preserve the same semantics.

import sys, re
digit_pattern = re.compile(r"-(\d+)$")

args = sys.argv[1:]
if args:
  match = digit_pattern.match(args[0])
  if match:
    columns = int(match.group(1))
    args = args[1:]

# NOTE: here's the more idiomatic way, which also checks
# for the "--" or a non "-" argument to stop processing

args = sys.argv[1:]
for i in range(len(args)):
  arg = args[i]
  if arg == "--" or not arg.startwith("-"):
    break
  if arg[1:].isdigit():
    columns = int(arg[1:])
    continue



# arg demo 3: Process clustering -a, -i, -n, or -u flags
import sys, getopt
try:
  args, filenames = getopt.getopt(sys.argv[1:], "ainu")
except getopt.error:
  raise SystemExit("usage: %s [-ainu] [filenames] ..." % sys.argv[0])

append = ignore_ints = nostdout = unbuffer = 0
for k, v in args:
  if   k == "-a": append += 1
  elif k == "-i": ignore_ints += 1
  elif k == "-n": nostdout += 1
  elif k == "-u": unbuffer += 1
  else:
    raise AssertionError("Unexpected argument: %s" % k)

#-----------------------------
# Note: Idiomatic Perl get translated to idiomatic Python
import fileinput
for line in fileinput.input():
  sys.stdout.write("%s:%s:%s" %
                   (fileinput.filename(), fileinput.filelineno(), line))
#-----------------------------
#!/usr/bin/env python
# findlogin1 - print all lines containing the string "login"
for line in fileinput.input(): # loop over files on command line
  if line.find("login") != -1:
    sys.stdout.write(line)

#-----------------------------
#!/usr/bin/env python
# lowercase - turn all lines into lowercase
### NOTE: I don't know how to do locales in Python
for line in fileinput.input(): # loop over files on command line
  sys.stdout.write(line.lower())

#-----------------------------
#!/usr/bin/env python
# NOTE: The Perl code appears buggy, in that "Q__END__W" is considered
#       to be a __END__ and words after the __END__ on the same line
#       are included in the count!!!
# countchunks - count how many words are used.
# skip comments, and bail on file if __END__
# or __DATA__ seen.
chunks = 0
for line in fileinput.input():
  for word in line.split():
    if word.startswith("#"):
      continue
    if word in ("__DATA__", "__END__"):
      fileinput.close()
      break
    chunks += 1
print "Found", chunks, "chunks"


# @@PLEAC@@_7.13
import select
while 1:
  rlist, wlist, xlist = select.select([file1, file2, file3], [], [], 0)
  for r in rlist:
    # Do something with the file handle

# @@PLEAC@@_7.16
# NOTE: this is all much easier in Python
def subroutine(file):
  print >>file, "Hello, file"

variable = file
subroutine(variable)

# @@PLEAC@@_7.18
for file in files:
  print >> file, stuff_to_print

# NOTE: This is unix specific
import os
file = os.popen("tee file1 file2 file3 >/dev/null", "w")
print >> file, "whatever"

# NOTE: the "make STDOUT go to three files" is bad programming style
import os, sys
sys.stdout.file = os.popen("tee file1 file2 file3", "w")
print "whatever"
sys.stdout.close()

# @@PLEAC@@_7.19
import os
file = os.fdopen(fdnum) # open the descriptor itself
file = os.fdopen(os.dup(fdnum)) # open to a copy of the descriptor

###
outcopy = os.fdopen(os.dup(sys.stdin.fileno()), "w")
incopy = os.fdopen(os.dup(sys.stdin.fileno()), "r")

