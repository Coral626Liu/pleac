# -*- python -*-
# vim:set ft=python:

# @@PLEAC@@_NAME
# @@SKIP@@ Python

# @@PLEAC@@_WEB
# @@SKIP@@ http://www.python.org


# @@PLEAC@@_1.0
string = "\n"   # a newline character
string = r"\n"  # two characters, \ and n

string = "Jon 'Maddog' Orwant"  # literal single quote inside double quotes
string = 'Jon "Maddog" Orwant'  # literal double quote inside single quotes

string = 'Jon \'Maddog\' Orwant'  # escaped single quote
string = "Jon \"Maddog\" Orwant"  # escaped double quote

string = """
This is a multiline string literal
enclosed in triple double quotes.
It may be enclosed in triple single quotes, too.
"""

# @@PLEAC@@_1.1

s = "This is what you have"
first = s[0]                            # "T"
start = s[5:7]                          # "is"
rest = s[13:]                           # "you have"
last = s[-1]                            # "e"
end = s[-4:]                            # "have"
piece = s[-8:-5]                        # "you"

# can't modify string, if really needed use character arrays:
import array
s = array.array("c", "This is what you have")
s[5:7] = array.array("c", "wasn't")
# s now is array('c', "This wasn't what you have")

# there is also MutableString.
# but don't do this in Python, this is for educational purpose only
from UserString import MutableString
s = MutableString("This is what you have")
s[-12:] = "ondrous"
# s is now "This is wondrous"

# @@PLEAC@@_1.2
a = b or c

# set x to y unless x is already true
if not x:
    x=y

# find the user name on Unix systems
import os
user=os.environ.get("USER")
if user==None:
    user=os.environ.get("LOGNAME")

# @@PLEAC@@_1.3
v1, v2 = v2, v1

temp=a
a=b
b=temp

alpha, beta, production = "January March August".split()
alpha, beta, production = beta, production, alpha

# @@PLEAC@@_1.4
num = ord(char)
char = chr(num)

char = "%c" % num
print "Number %d is character %c\n" % (num, num)
# Number 101 is character e

print "Number %(n)d is character %(n)c\n" % {"n": num }

ascii_character_numbers = map(ord,"sample")
print ascii_character_numbers
# [115, 97, 109, 112, 108, 101]

word = "".join(map(chr,ascii_character_numbers))
word = "".join(map(chr,[115, 97, 109, 112, 108, 101]))
print word
# sample

from string import *
hal = "HAL"
ibm = join(map(lambda i: chr(ord(i)+1), hal), "")
print ibm


# @@PLEAC@@_1.5
string="Hello world!"
for character in string:
    pass # do something with character

string = "an apple a day"
d = {}
for i in string: d[i] = 1
l = d.keys()
l.sort()
print "unique chars are: ", join(l)

sum = 0
for i in ascval: sum += ord(i)
print "sum is ", sum


# sysv checksum
import fileinput
checksum = 0
for ln in fileinput.input():
    for c in ln:
        checksum += ord(c)
checksum %= (2 ** 16) -1
print checksum

#!/usr/bin/python
# slowcat - emulate a   s l o w  line printer
# usage: slowcat [- DELAY] [files ...]

import sys, select
import re
DELAY = 1
if re.match("^-\d+$",sys.argv[1]):
    DELAY=-int(sys.argv[1])
    del sys.argv[1]
for ln in fileinput.input():
    for c in ln:
        sys.stdout.write(c)
        sys.stdout.flush()
        select.select([],[],[], 0.005 * DELAY)


# @@PLEAC@@_1.6

# python >= 2.3
revbytes = string[::-1] # extended slice

# python < 2.3
l = list(string)
l.reverse()
revbytes = "".join(l)

l = string.split()
l.reverse()
revwords = ' '.join(l)

def rev_string(s):
    l = list(s)
    l.reverse()
    return "".join(l)

long_palindromes = filter(lambda word: len(word) > 5 and rev_string(word) == word,
             map(rstrip, open("/usr/share/dict/words").readlines()))


# Same more novice friendly:
fd=open("/usr/share/dict/words")
long_palindromes=[]
for line in fd.xreadlines():
    word=line.rstrip()
    if len(word)>5:
        if rev_string(word)==word:
            long_palindromes.append(word)
fd.close()
print long_palindromes

# @@PLEAC@@_1.7
string.expandtabs()

# @@PLEAC@@_1.8
sub("\d+", lambda i: str(2 * int(i.group(0))), "I am 17 years old")

# @@PLEAC@@_1.9
e = "bo peep".upper()
e = e.lower()
e = e.capitalize()

sub("\w+", lambda i: i.group(0).capitalize(), "thIS is a loNG liNE")

# @@PLEAC@@_1.10
"I have %d guanacos." % (n + 1)
print "I have", n+1, "guanacos."


# @@PLEAC@@_1.12
#-----------------------------
# textwrap is a standard library, new in version 2.3.
# Replace a home-made solution with the standard.
#-----------------------------
from textwrap import wrap 
output = wrap(para,
              initial_indent=leadtab
              subsequent_indent=nexttab)
#-----------------------------
#!/usr/bin/env python
# wrapdemo - show how textwrap works

input = """\
Folding and splicing is the work of an editor,
not a mere collection of silicon
and
mobile electrons!
"""

from textwrap import TextWrapper

wrapper = TextWrapper(width=20,
                      initial_indent=" "*4,
                      subsequent_indent=" "*2)

print "0123456789" * 2
print wrapper.fill(input)

#-----------------------------
"""Expected result:

01234567890123456789
    Folding and
  splicing is the
  work of an editor,
  not a mere
  collection of
  silicon and mobile
  electrons!
"""

#-----------------------------
# Here is a simple implementation of wrap() for Python < 2.3
def wrap(str, max_size):
    all = []
    line = ""
    for l in str.split():
        if len(line+l) >= max_size:
            all += [line]
            line = ''
        line += (line and ' ') + l
    return "\n".join(all + [line])

print wrap(string, 20)

#-----------------------------
# merge multiple lines into one, then wrap one long line

from textwrap import fill
import fileinput

print fill(str.join("", fileinput.input()))

#-----------------------------
# Term::ReadKey::GetTermianlSize() is not from PERL standard
# library. Neither in Python standard library its equivalent
# exists. Therefore:

# I will use Michael Hudson's recipie,
# from python-list #530228.
# http://aspn.activestate.com/ASPN/Mail/Message/python-list/530228

from termwrap import wrap

def getheightwidth():
    height, width = struct.unpack(
        "hhhh", ioctl(0, TERMIOS.TIOCGWINSZ ,"\000"*8))[0:2]
    return height, width

# PERL <>, $/, $\ emulation
import fileinput
import re

_, width = getheightwidth()
for para in re.split(r"\n{2,}", str.join("", fileinput.input())):
    print fill(para, width)


# @@PLEAC@@_1.13
string = '''Mom said, "Don't do that."'''  #"
sub("['\"]", lambda i: "\\" + i.group(0), string)
sub("[A-Z]", lambda i: "\\" + i.group(0), string)
sub("\W", lambda i: "\\" + i.group(0), "is a test!") # no function like quotemeta?


# @@PLEAC@@_1.14
string = string.strip


# @@PLEAC@@_1.15

# python >= 2.3
import csv
def parse_csv(line):
    reader = csv.reader([line], escapechar='\\')
    return reader.next()

line = '''XYZZY,"","O'Reilly, Inc","Wall, Larry","a \\"glug\\" bit,",5,"Error, Core Dumped,",''' #"

fields = parse_csv(line)

for i, field in enumerate(fields):
    print "%d : %s" % (i, field)

# cvs.reader is meant to work for many lines, something like:
# (NB: in Python default, quotechar is *not* escaped by backslash,
#      but doubled instead. That's what Excel does.)
for fields in csv.reader(lines, dialect="some"):
    for num, field in enumerate(fields):
        print num, ":", field


# python < 2.3
from re import *
from string import *

def parse_csv(text):
    l = map(lambda i: join(i, ''), findall('''"([^"\\\]*(?:\\\.[^"\\\]*)*)",?|([^,]+),?|,''', text))
    if text[-1] == ",": l += ['']
    return l

line = '''XYZZY,"","O'Reilly, Inc","Wall, Larry","a \\"glug\\" bit,",5,"Error, Core Dumped,",''' #"

fields = parse_csv(line)

for i in range(len(fields)):
    print "%d : %s" % (i, fields[i])


# @@PLEAC@@_1.17
import sys, fileinput, re

data = """\
analysed        => analyzed
built-in        => builtin
chastized       => chastised
commandline     => command-line
de-allocate     => deallocate
dropin          => drop-in
hardcode        => hard-code
meta-data       => metadata
multicharacter  => multi-character
multiway        => multi-way
non-empty       => nonempty
non-profit      => nonprofit
non-trappable   => nontrappable
pre-define      => predefine
preextend       => pre-extend
re-compiling    => recompiling
reenter         => re-enter
turnkey         => turn-key
"""
dict = {}
for line in data.split("\n"):
    if not line.strip():
        continue
    k, v = [word.strip() for word in line.split("=>")]
    dict[k] = v
pattern_text = "(" + "|".join([re.escape(word) for word in dict.keys()]) + ")"
pattern = re.compile(pattern_text)

args = sys.argv[1:]
verbose = 0
if args and args[0] == "-v":
    verbose = 1
    args = args[1:]

if not args:
    sys.stderr.write("%s: Reading from stdin\n" % sys.argv[0])

for line in fileinput.input(args, inplace = 1, backup = ".orig"):
    output = ""
    pos = 0
    while 1:
        match = pattern.search(line, pos)
        if not match:
            output += line[pos:]
            break
        output += line[pos:match.start(0)] + dict[match.group(1)]
        pos = match.end(0)
    sys.stdout.write(output)


# @@PLEAC@@_2.1
if string.isdigit():
    print 'is a positive integer'
else:
    print 'is not'

if re.match("[+-]?\d+$", string):
    print 'is an integer'
else:
    print 'is not'


if re.match("-?(?:\d+(?:\.\d*)?|\.\d+)$", string):
    print 'is a decimal number'
else:
    print 'is not'


# @@PLEAC@@_2.2
# equal(num1, num2, accuracy) : returns true if num1 and num2 are
#   equal to accuracy number of decimal places
def equal(i, j, a):
    i - j < 10. ** -a

wage = 536                        # $5.36/hour
week = 40 * wage                  # $214.40
print "One week's wage is: $%.2f" % (week/100.0)


# @@PLEAC@@_2.3
round(num)                              # rounds to integer

a = 0.255
b = "%.2f" % a
print "Unrounded: %f\nRounded: %s" % (a, b)
print "Unrounded: %f\nRounded: %.2f" % (a, a)

from math import *

print "number\tint\tfloor\tceil"
a = [ 3.3 , 3.5 , 3.7, -3.3 ]
for n in a:
    print "% .1f\t% .1f\t% .1f\t% .1f" % (n, int(n), floor(n), ceil(n))

# @@PLEAC@@_2.4
# Using module http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/111286
# which allow to convert between various bases
import baseconvert

def bin2dec(i):
    return baseconvert.baseconvert(i, baseconvert.BASE2, baseconvert.BASE10)

def dec2bin(i):
    return baseconvert.baseconvert(i, baseconvert.BASE10, baseconvert.BASE2)

num = bin2dec('0110110')  # num is 54
binstr = dec2bin(54)      # binstr is 110110

# @@PLEAC@@_2.5
for i in range(x,y):
    pass # i is set to every integer from x to y, excluding y

for i in range(x, y, 7):
    pass # i is set to every integer from x to y, stepsize = 7

print "Infancy is: "
for i in range(0,3):
    print i,
print "\n"

print "Childhood is: ",
i = 5
while i <= 12:
    print i
    i += 1

# @@PLEAC@@_2.6
# See http://www.faqts.com/knowledge_base/view.phtml/aid/4442
# for a module that does this


# @@PLEAC@@_2.7

import random
rand = random.random()
rand = random.randrange(x, y)
rand = random.randrange(25, 76)
rand = random.choice(list)

import string
chars = string.letters + string.digits + "!@$%^&*"
password = "".join([random.choice(chars) for i in range(8)])

# @@PLEAC@@_2.8
# Changes the default RNG
random.seed()

# Or you can create independent RNGs  (Note: New with Python 2.1)
gen1 = random.Random(6)
gen2 = random.Random(6)
gen3 = random.Random(10)
a1, b1 = gen1.random(), gen1.random()
a2, b2 = gen2.random(), gen2.random()
a3, b3 = gen3.random(), gen3.random()
# a1 == a2 and b1 == b2

# @@PLEAC@@_2.9
# see http://www.sbc.su.se/~per/crng/ or http://www.frohne.westhost.com/rv11reference.htm

# @@PLEAC@@_2.10
import random
mean = 25
sdev = 2
salary = random.gauss(mean, sdev)
print "You have been hired at %.2f" % salary

# @@PLEAC@@_2.11
#-----------------------------
import math
def deg2rad(degrees):
    return (degrees / 180.) * math.pi
def rad2deg(radians):
    return (radians / math.pi) * 180.

#-----------------------------
# math.radians and math.degrees is new in 2.3.
import math
radians = math.radians(degrees)
degrees = math.degrees(radians)

#-----------------------------
# You can use deg2rad and rad2deg defined above instead
# if you have pre-2.3 version.
import math
def degree_sine(degrees):
    radians = math.degrees(degrees)
    return math.sin(radians)

# @@PLEAC@@_2.12
import math
def tan(theta):
    return math.sin(theta) / math.cos(theta)
#----------------
# NOTE: this sets y to 16331239353195370.0
try:
  y = math.tan(math.pi/2)
except ValueError:
  y = None

# @@PLEAC@@_2.13
import math
log_e = math.log(VALUE)
#-----------------------------
log_10 = math.log10(VALUE)
#-----------------------------
def log_base(base, value):
    return math.log(value) / math.log(base)
#-----------------------------
# log_base defined as above
answer = log_base(10, 10000)
print "log10(10,000) =", answer
#> log10(10,000) = 4.0

# @@PLEAC@@_2.14
# NOTE: must have NumPy installed.  See
#   http://www.pfdubois.com/numpy/

import Numeric
a = Numeric.array( ((3, 2, 3),
                    (5, 9, 8) ), "d")
b = Numeric.array( ((4, 7),
                    (9, 3),
                    (8, 1) ), "d")
c = Numeric.matrixmultiply(a, b)

print c
#> [[  54.   30.]
#>  [ 165.   70.]]
print a.shape, b.shape, c.shape
#> (2, 3) (3, 2) (2, 2)

# @@PLEAC@@_2.15
a = 3+5j
b = 2-2j
c = a*b
print "c =", c
#> c = (16+4j)
print c.real, c.imag, c.conjugate()
#> 16.0 4.0 (16-4j)

import cmath
print cmath.sqrt(3+4j)
#> (2+1j)


# @@PLEAC@@_2.16
number = int(hexadecimal, 16)
number = int(octal, 8)
s = hex(number)
s = oct(number)

print "Gimme a number in decimal, octal, or hex: ",
num = sys.stdin.readline().rstrip()
if num[0:2] == "0x":
    num = int(num[2:], 16)
elif num[0] == "0":
    num = int(num[1:], 8)
else:
    num = int(num)
print "%(num)d %(num)x %(num)o\n" % { "num": num }


# @@PLEAC@@_2.17
import re

def commify(amount):
    orig = amount
    new = re.sub("^(-?\d+)(\d{3})", '\g<1>,\g<2>', amount)
    if orig == new:
        return new
    else:
        return comma_me(new)

commified = commify("12345678") # => 12,345,678

# @@PLEAC@@_2.18
# Printing Correct Plurals

def pluralise(root, iflone, ifplural, value):
    if value == 1 or value == -1:
        return root + iflone
    else:
        return root + ifplural

print "It took", time, pluralise('hour', '', 's', time)

print "%d %s %s enough." % (time, pluralise('hour', '', 's', time), pluralise('', 'is', 'are', time))

# @@PLEAC@@_2.19
# Program: Calculating Prime Factors
#-----------------------------
#% bigfact 8 9 96 2178
#8          2**3
#
#9          3**2
#
#96         2**5 3
#
#2178       2 3**2 11**2
#-----------------------------
#% bigfact 239322000000000000000000
#239322000000000000000000 2**19 3 5**18 39887 
#
#
#% bigfact 25000000000000000000000000
#25000000000000000000000000 2**24 5**26
#-----------------------------
import sys

def factorise(num):
    factors = {}
    orig = num
    print num, '\t',

    # we take advantage of the fact that (i +1)**2 = i**2 + 2*i +1
    i, sqi = 2, 4
    while sqi <= num:
        while (num % i == 0):
            num /= i
            factors[i] = factors.get(i, 0) + 1

        sqi += 2 * i + 1
        i += 1

    #--------
    if num != 1 and num != orig:
        factors[num] = factors.get(num, 0) + 1

    #--------
    if not factors:
        print "PRIME"

    #--------
    results = factors.keys()
    results.sort()
    for factor in results:
        if factor > 0:
            tmp = str(factor)
            if factors[factor]>1: tmp += "**" + str(factors[factor])
            print tmp,
    print
    
#--------
if __name__ == '__main__':
    if len(sys.argv) == 1:
        print "Usage:", sys.argv[0], " number [number, ]"
    else:
        for strnum in sys.argv[1:]:
            try:
                num = int(strnum)
                factorise(num)
            except ValueError:
                print strnum, "is not an integer"
#-----------------------------

# @@PLEAC@@_3.0
#----------------------------- 
#introduction
# There are three common ways of manipulating dates in Python
# mxDateTime - a popular third-party module (not discussed here) 
# time - a fairly low-level standard library module 
# datetime - a new library module for Python 2.3 and used for most of these samples 
# (I will use full names to show which module they are in, but you can also use
# from datetime import datetime, timedelta and so on for convenience) 

import time
import datetime

print "Today is day", time.localtime()[7], "of the current year" 
# Today is day 218 of the current year

aDate = datetime.date.today()
print "Today is day", aDate.timetuple()[7], "of ", aDate.year
# Today is day 218 of 2003

print "Today is day", aDate.strftime("%j"), "of the current year" 
# Today is day 218 of the current year
 

# @@PLEAC@@_3.1
#----------------------------- 
# Finding todays date

t = datetime.date.today()
print "The date is", t
# The date is 2003-08-06

# the function strftime() (string-format time) produces nice formatting
# All codes are detailed at http://www.python.org/doc/current/lib/module-time.html
print t.strftime("four-digit year: %Y, two-digit year: %y, month: %m, day: %d") 
# four-digit year: 2003, two-digit year: 03, month: 08, day: 06


# @@PLEAC@@_3.2
#----------------------------- 
# Converting DMYHMS to Epoch Seconds
# To work with Epoch Seconds, you need to use the time module

# For the local timezone

t = datetime.datetime.now()
print "Epoch Seconds:", time.mktime(t.timetuple())
# Epoch Seconds: 1060199000.0

# For UTC

t = datetime.datetime.utcnow()
print "Epoch Seconds:", time.mktime(t.timetuple())
# Epoch Seconds: 1060195503.0


# @@PLEAC@@_3.3
#----------------------------- 
# Converting Epoch Seconds to DMYHMS

now = datetime.datetime.fromtimestamp(EpochSeconds)
#or use datetime.datetime.utcfromtimestamp()
print now
# datetime.datetime(2003, 8, 6, 20, 43, 20)
print now.ctime()
# Wed Aug  6 20:43:20 2003

# or with the time module
oldtimetuple = time.localtime(EpochSeconds)
# oldtimetuple contains (year, month, day, hour, minute, second, weekday, yearday, daylightSavingAdjustment) 
print oldtimetuple 
# (2003, 8, 6, 20, 43, 20, 2, 218, 1)


# @@PLEAC@@_3.4
#----------------------------- 
# Adding to or Subtracting from a Date
# Use the rather nice datetime.timedelta objects

now = datetime.date(2003, 8, 6)
difference1 = datetime.timedelta(days=1)
difference2 = datetime.timedelta(weeks=-2)

print "One day in the future is:", now + difference1
# One day in the future is: 2003-08-07

print "Two weeks in the past is:", now + difference2
# Two weeks in the past is: 2003-07-23

print datetime.date(2003, 8, 6) - datetime.date(2000, 8, 6)
# 1095 days, 0:00:00

#----------------------------- 
birthtime = datetime.datetime(1973, 01, 18, 3, 45, 50)   
# 18/jan/1973, 3:45:50am
interval = datetime.timedelta(seconds=5, minutes=17, hours=2, days=55) 
then = birthtime + interval

print "Then is", then.ctime()
# Then is Wed Mar 14 06:02:55 1973

print "Then is", then.strftime("%A %B %d %I:%M:%S %p %Y")
# Then is Wednesday March 14 06:02:55 AM 1973

#-----------------------------
when = datetime.datetime(1973, 1, 18) + datetime.timedelta(days=55) 
print "Nat was 55 days old on: ", when.month, "/", when.day, "/", when.year 
# Nat was 55 days old on:  3 / 14 / 1973


# @@PLEAC@@_3.5
#----------------------------- 
# Difference of Two Dates
# Also use the rather nice datetime.timedelta objects

diff = date2 - date1
diff = datetime.date(year1, month1, day1) - datetime.date(year2, month2, day2)
#----------------------------- 

bree = datetime.datetime(1981, 6, 16, 4, 35, 25)
nat  = datetime.datetime(1973, 1, 18, 3, 45, 50)

difference = bree - nat
print "There were", difference, "minutes between Nat and Bree"
# There were 3071 days, 0:49:35  minutes between Nat and Bree

weeks = difference.days / 7
days = difference.days % 7
hours = difference.seconds / 60
minutes = (difference.seconds % 60) / 60
seconds = (difference.seconds % 60) % 60

print "%d weeks, %d days, %d:%d:%d" % (weeks, days, hours, minutes, seconds)
# 438 weeks, 5 days, 49:0:35
# NB: This differs from the value in the Perl sample, it looks to me like 
#     the seconds given for bree and nat don't seem to correspond with the text dates given

#----------------------------- 
print "There were", difference.days, "days between bree and nat" 
# There were 3071 days between bree and nat


# @@PLEAC@@_3.6
#----------------------------- 
# Day in a Week/Month/Year or Week Number

when = datetime.date(1981, 6, 16)

print "16/6/1981 was:"
print when.strftime("Day %w of the week (a %A). Day %d of the month
(%B).")
print when.strftime("Day %j of the year (%Y), in week %W of the year.")

# 16/6/1981 was:
# Day 2 of the week (a Tuesday). Day 16 of the month (June).
# Day 167 of the year (1981), in week 24 of the year.


# @@PLEAC@@_3.7
#----------------------------- 
# Parsing Dates and Times from Strings

time.strptime("Tue Jun 16 20:18:03 1981")
# (1981, 6, 16, 20, 18, 3, 1, 167, -1)

time.strptime("16/6/1981", "%d/%m/%Y")
# (1981, 6, 16, 0, 0, 0, 1, 167, -1)
# strptime() can use any of the formatting codes from time.strftime()

# The easiest way to convert this to a datetime seems to be; 
EpochSeconds = time.mktime(time.strptime("16/6/1981", "%d/%m/%Y")) 
now = datetime.datetime.fromtimestamp(EpochSeconds)


# @@PLEAC@@_3.8
#----------------------------- 
# Printing a Date
# Use datetime.strftime()

print datetime.datetime.now().strftime("The date is %A (%a) %d/%m/%Y") 
# The date is Friday (Fri) 08/08/2003

# Other allowed codes are in the documentation at python.org


# @@PLEAC@@_3.9
#----------------------------- 
# High Resolution Timers

t1 = time.clock()
# Do Stuff Here
t2 = time.clock()
print t2 - t1

# 2.27236813618
# Accuracy will depend on platform and OS,
# but time.clock() uses the most accurate timer it can

time.clock(); time.clock()
# 174485.51365466841
# 174485.55702610247

#----------------------------- 
# Also useful;
import timeit
code = '[x for x in range(10) if x % 2 == 0]'
eval(code)
# [0, 2, 4, 6, 8]

t = timeit.Timer(code)
print "10,000 repeats of that code takes:", t.timeit(10000), "seconds" 
print "1,000,000 repeats of that code takes:", t.timeit(), "seconds"

# 10,000 repeats of that code takes: 0.128238644856 seconds
# 1,000,000 repeats of that code takes:  12.5396490336 seconds

#----------------------------- 
import timeit
code = 'import random; l = random.sample(xrange(10000000), 1000); l.sort()' 
t = timeit.Timer(code)

print "Create a list of a thousand random numbers. Sort the list. Repeated a thousand times." 
print "Average Time:", t.timeit(1000) / 1000
# Time taken: 5.24391507859


# @@PLEAC@@_3.10
#----------------------------- 
# Short Sleeps

seconds = 3.1
time.sleep(seconds)
print "boo"

# @@PLEAC@@_3.11
#----------------------------- 
# Program HopDelta
# Save a raw email to disk and run "python hopdelta.py FILE"
# and it will process the headers and show the time taken
# for each server hop (nb: if server times are wrong, negative dates
# might appear in the output).

import datetime, email, email.Utils
import os, sys, time

def extract_date(hop):
    # According to RFC822, the date will be prefixed with
    # a semi-colon, and is the last part of a received
    # header.
    date_string = hop[hop.find(';')+2:]
    date_string = date_string.strip()
    time_tuple = email.Utils.parsedate(date_string)

    # convert time_tuple to datetime
    EpochSeconds = time.mktime(time_tuple) 
    dt = datetime.datetime.fromtimestamp(EpochSeconds)
    return dt

def process(filename):
    # Main email file processing
    # read the headers and process them
    f = file(filename, 'rb')
    msg = email.message_from_file(f)

    hops = msg.get_all('received')
    
    # in reverse order, get the server(s) and date/time involved
    hops.reverse()
    results = []
    for hop in hops:
        hop = hop.lower()
        
        if hop.startswith('by'):  # 'Received: by' line
            sender = "start"
            receiver = hop[3:hop.find(' ',3)]
            date = extract_date(hop)

        else:  # 'Received: from' line
            sender = hop[5:hop.find(' ',5)]
            by = hop.find('by ')+3
            receiver = hop[by:hop.find(' ', by)]
            date = extract_date(hop)

        results.append((sender, receiver, date))
    output(results)

def output(results):
    print "Sender, Recipient, Time, Delta"
    print
    previous_dt = delta = 0
    for (sender, receiver, date) in results:
        if previous_dt:
            delta = date - previous_dt
        
        print "%s, %s, %s, %s" % (sender,
                               receiver,
                               date.strftime("%Y/%d/%m %H:%M:%S"),
                               delta)
        print
        previous_dt = date   
            
def main():
    # Perform some basic argument checking
    if len(sys.argv) != 2:
        print "Usage: mailhop.py FILENAME"

    else:
        filename = sys.argv[1]
        if os.path.isfile(filename):
            process(filename)
        else:
            print filename, "doesn't seem to be a valid file."

if __name__ == '__main__':
    main()


# @@PLEAC@@_4.0
#-----------------------------
nested = ["this", "that", "the", "other"]
#-----------------------------
tune = ["The", "Star-Spangled", "Banner"]
#-----------------------------

# @@PLEAC@@_4.1
a = ["quick", "brown", "fox"]
a = " ".split("Why are you teasing me?")

text = """
    The boy stood on the burning deck,
    It was as hot as glass.
"""
lines = [line.lstrip() for line in text.strip().split("\n")]
#-----------------------------
bigarray = [line.rstrip() for line in open("mydatafile")] # Python 2.2
bigarray = [line.rstrip() for line in open("mydatafile").readlines()]
#-----------------------------
banner = "The Mines of Moria"
banner = 'The Mines of Moria'
#-----------------------------
name = "Gandalf"
banner = "Speak, " + name + ", and enter!"
banner = "Speak, %s, and welcome!" % name
#-----------------------------
his_host = "www.python.org"
import os
host_info = os.popen("nslookup " + his_host).read()

# NOTE: not really relevant to Python (no magic '$$' variable)
python_info = os.popen("ps %d" % os.getpid()).read()
shell_info = os.popen("ps $$").read()
#-----------------------------
# NOTE: not really relevant to Python (no automatic interpolation)
banner = ["Costs", "only", "$4.95"]
banner = "Costs only $4.95".split()
#-----------------------------
brax = """ ' " ( ) < > { } [ ] """.split()            #"""
rings = '''They're  "Nenya Narya Vilya"'''.split()    #'''
tags   = 'LI TABLE TR TD A IMG H1 P'.split()
sample = r'The backslash (\) is often used in regular expressions.'.split()

#-----------------------------
banner = "The backslash (\\) is often used in regular expressions.".split()
#-----------------------------
ships = u"Niña Pinta Santa María".split()          # WRONG (only three ships)
ships = [u"Niña", u"Pinta", u"Santa María"]        # right
#-----------------------------

# @@PLEAC@@_4.2
def commify_series(args):
    if len(args) == 0: return ""
    if len(args) == 1: return args[0]
    if len(args) == 2: return args[0] + " and " + args[1]
    return ", ".join(args[:-1]) + " and " + args[-1]

commify_series([])
commify_series(["red"])
commify_series(["red", "yellow"])
commify_series(["red", "yellow", "green"])
#-----------------------------
array = ["red", "yellow", "green"]
print "I have", array, "marbles."
print "I have", " ".join(array), "marbles."
#>I have ['red', 'yellow', 'green'] marbles.
#>I have red yellow green marbles.

#-----------------------------
#!/usr/bin/env python
# commify_series - show proper comma insertion in list output

data = (
    ( 'just one thing', ),
    ( 'Mutt Jeff'.split() ),
    ( 'Peter Paul Mary'.split() ),
    ( 'To our parents', 'Mother Theresa', 'God' ),
    ( 'pastrami', 'ham and cheese', 'peanut butter and jelly', 'tuna' ),
    ( 'recycle tired, old phrases', 'ponder big, happy thoughts' ),
    ( 'recycle tired, old phrases',
      'ponder big, happy thoughts',
      'sleep and dream peacefully' ),
    )
def commify_series(terms):
    sepchar = ","
    for term in terms:
        if "," in term:
            sepchar = ";"
            break
    if len(terms) == 0: return ""
    if len(terms) == 1: return terms[0]
    if len(terms) == 2: return " and ".join(terms)
    return (sepchar + " ").join(terms[:-1]) + " and " + terms[-1]

for item in data:
    print "The list is: %s." % commify_series(item)

# The list is: just one thing.
# The list is: Mutt and Jeff.
# The list is: Peter, Paul, and Mary.
# The list is: To our parents, Mother Theresa, and God.
# The list is: pastrami, ham and cheese, peanut butter and jelly, and tuna.
# The list is: recycle tired, old phrases and ponder big, happy thoughts.
# The list is: recycle tired, old phrases; ponder big, happy thoughts; and
#    sleep and dream peacefully.

#-----------------------------

# @@PLEAC@@_4.3
ARRAY = ARRAY[:SIZE] # shrink ARRAY
ARRAY += [None] * SIZE # grow ARRAY by appending 'SIZE' None elements
#-----------------------------
def what_about_that_array(terms):
    print "The list now has", len(terms), "elements."
    print "The index of the last element is", len(terms)-1, "(or -1)."
    print "Element #3 is %s." % terms[3]

people = "Crosby Stills Nash Young".split()
what_about_that_array(people)
#-----------------------------
#>The list now has 4 elements.
#>The index of the last element is 3 (or -1).
#>Element #3 is Young.
#-----------------------------
people.pop()
what_about_that_array(people)
#-----------------------------
# NOTE: Python raises an exception when trying to access an
# out of range value.
#>>> people.pop()
#'Young'
#>>> what_about_that_array(people)
#The list now has 3 elements.
#The index of the last element is 2 (or -1).
#Traceback (most recent call last):
#  File "<stdin>", line 1, in ?
#  File "<stdin>", line 4, in what_about_that_array
#IndexError: list index out of range
#>>>
#-----------------------------
people += [None] * (10000 - len(people))
#-----------------------------
#>>> people += [None] * (10000 - len(people))
#>>> what_about_that_array(people)
#The list now has 10000 elements.
#The index of the last element is 9999 (or -1).
#Element #3 is None.
#-----------------------------

# @@PLEAC@@_4.4
for item in LIST:
    pass # do something with item
#-----------------------------
for user in bad_users:
    complain(user)
#-----------------------------
import os
keys = os.environ.keys()
keys.sort()
for key in keys:
    print "%s=%s" % (key, os.environ[key])
#-----------------------------
for user in all_users:
    disk_space = get_usage(user)    # find out how much disk space in use
    if disk_space > MAX_QUOTA:      # if it's more than we want ...
        complain(user)              # ... then object vociferously
#-----------------------------
import os
for line in os.popen("who").readlines():
    if line.find("dalke") != -1:
        print line, # or print line[:-1]

# NOTE: alternate form, and using Python 2.2 code
import os
print "".join([line for line in os.popen("who")
                   if line.find("dalke") != -1]),

#-----------------------------
while 1:
    line = file.readline()
    if not line:
        break
    for word in line.split(): # Split on whitespace
        chars = list(word)    # Turn the string into a list of characters
        chars.reverse()
        print "".join(chars),
    print
#-----------------------------
for item in array:
    print "i =", item
#-----------------------------
# NOTE: you can't modify in place the way Perl does
data = [1, 2, 3]
data = [i-1 for i in data]
print data
#>[0, 1, 2]

# or
for i in range(len(data)):
    data[i] = data[i] - 1

#-----------------------------
# NOTE: strings are immutable in Python so this doesn't translate well.
s = s.strip()
data = [s.strip() for s in data]
for k, v in dict.items():
    dict[k] = v.strip()
#-----------------------------

# @@PLEAC@@_4.5
fruits = ["Apple", "Blackberry"]
for fruit in fruits:
    print fruit, "tastes good in a pie."
#>Apple tastes good in a pie.
#>Blackberry tastes good in a pie.
#-----------------------------
for i in range(len(fruits)):
    print fruits[i], "tastes good in a pie."
#-----------------------------
rogue_cats = ["Morris", "Felix"]
namelist = { "felines": rogue_cats }
for cat in namelist["felines"]:
    print cat, "purrs hypnotically.."

print "--More--\nYou are controlled."

#-----------------------------
for i in range(len(namelist["felines"])):
    print namelist["felines"][i], "purrs hypnotically."

#-----------------------------

# @@PLEAC@@_4.6
seen = {}
uniq = []
for item in LIST:
    if not seen.has_key(item):
        seen[item] = 1
        uniq.append(item)

for item in LIST:
    # in Python 2.2
    if item not in seen:    
        seen[item] = 1
        uniq.append(item)

#-----------------------------
seen = {}
uniq = []
for item in LIST:
    count = seen.get(item, 0)
    if count == 0:
        uniq.append(item)
    seen[item] = count + 1
#-----------------------------
seen = {}
for item in LIST:
    seen[item] = seen.get(item, 0) + 1

uniq = seen.keys()
#-----------------------------
# NOTE: It's a bad idea to use this in real code, since the previous
# example is easier to understand and common.
seen = {}
uniqu = [item for item in list
    if not seen.setdefault(item, []) and seen[item].append(1) is None]

#-----------------------------
# generate a list of users logged in, removing duplicates
import os
ucnt = {}
for line in os.popen("who").readlines():
    username = line.split()[0]  # Get the first word
    ucnt[username] = ucnt.get(username, 0) + 1 # record the users' presence

# extract and print unique keys
users = ucnt.keys()
users.sort()
print "users logged in:", " ".join(users)
#-----------------------------


# @@PLEAC@@_4.7
# assume A and B are already loaded
seen = {}                 # lookup table to test membership of B
aonly = []                # answer

# build lookup table
for item in B:
    seen[item] = 1

# find only elements in A and not in B
for item in A:
    if not seen.has_key(item):
        # it's not in 'seen', so add to 'aonly'
        aonly.append(item)
#-----------------------------
seen = {}   # lookup table
aonly = []  # answer

# build lookup table - NOTE: this is poor Python style
[seen.update({x: 1}) for x in B]

aonly = [item for item in A if not seen.has_key(item)]

#-----------------------------
seen = {}
aonly = []
for item in A:
    if not seen.has_key(item):
        aonly.append(item)
    seen[item] = 1                    # mark as seen
#-----------------------------
dict["key1"] = 1
dict["key2"] = 2
#-----------------------------
dict[("key1", "key2")] = (1,2)
#-----------------------------
seen = {}
for term in B:
    seen[term] = None
#-----------------------------
seen = {}
for k, v in B:
    seen[k] = 1
#-----------------------------

# @@PLEAC@@_4.8
# NOTE: using a tuple instead of a list.  There isn't much
# difference between them for all of these examples.
a = (1, 3, 5, 6, 7, 8)
b = (2, 3, 5, 7, 9)

union_list = []; isect_list = []; diff = []
union_dict = {}; isect_dict = {}
count = {}
#-----------------------------
for e in a:
    union_dict[e] = 1

for e in b:
    if union_dict.has_key(e):
        isect_dict[e] = 1
    union_dict[e] = 1

union_list = union_dict.keys()
isect_list = isect_dict.keys()
#-----------------------------
for e in a + b:
    if union.get(e, 0) == 0:
        isect[e] = 1
    union[e] = 1

union = union.keys()
isect = isect.keys()
#-----------------------------
count = {}
for e in a + b:
    count[e] = count.get(e, 0) + 1

union = []; isect = []; diff = []

for e in count.keys():
    union.append(e)
    if count[e] == 2:
        isect.append(e)
    else:
        diff.append(e)
#-----------------------------
isect = []; diff = []; union = []
count = {}
for e in a + b:
    count[e] = count.get(e, 0) + 1

for e, num in count.items():
    union.append(e)
    [None, diff, isect][num].append(e)

#-----------------------------

# @@PLEAC@@_4.9
# "append" for a single term and
# "extend" for many terms
ARRAY1.extend(ARRAY2)
#-----------------------------
ARRAY1 = ARRAY1 + ARRAY2
#-----------------------------
members = ["Time", "Flies"]
initiates = ["An", "Arrow"]
members.extend(initiates)
# members is now ["Time", "Flies", "An", "Arrow"]
#-----------------------------
members[2:] = ["Like"] + initiates
print " ".join(members)
members[:1] = ["Fruit"]
members[-2:] = ["A", "Banana"]
print " ".join(members)
#-----------------------------
#>Time Flies Like An Arrow
#>
#>Fruit Flies Like A Banana
#-----------------------------

# @@PLEAC@@_4.10
# reverse ARRAY into REVERSED
REVERSED = ARRAY[:]    # one level deep copy
REVERSED.reverse()
#-----------------------------
for i in range(len(ARRAY)-1, -1, -1):
    pass # do something with ARRAY[i]

#-----------------------------
descending = users[:]
descending.sort()
descending.reverse()
#-----------------------------
# sort with reverse comparison
descending = users[:]
descending.sort(lambda x, y: cmp(y, x))
#-----------------------------

# @@PLEAC@@_4.11
# remove N elements from front of ARRAY
ARRAY[:N] = []

# remove N elements from front of ARRAY, saving them into FRONT
FRONT, ARRAY[:N] = ARRAY[:N], []

# remove N elements from the end of the array
ARRAY[-N:] = []

# remove $N elements from the end of the array, saving them in END
END, ARRAY[-N:] = ARRAY[-N:], []

#-----------------------------
def shift2(terms):
    front = terms[:2]
    terms[:2] = []
    return front

def pop2(terms):
    back = terms[-2:]
    terms[-2:] = []
    return back

#-----------------------------
friends = "Peter Paul Mary Jim Tim".split()
this, that = shift2(friends)
# 'this' contains Peter, 'that' has Paul, and
# 'friends' has Mary, Jim, and Tim

beverages = "Dew Jolt Cola Sprite Fresca".split()
pair = pop2(beverages)
# pair[0] contains Sprite, pair[1] has Fresca,
# and 'beverages' has (Dew, Jolt, Cola)
#-----------------------------

# @@PLEAC@@_4.12
match = found = item = None
for item in array:
    if criterion:
        match = item  # must save
        found = 1
        break
if found:
    pass ## do something with 'match'
else:
    pass ## unfound

#-----------------------------
match_idx = None
for i in range(len(array)):
    if criterion:
        match_idx = i    # save the index
        break

if match_idx is not None:
    pass ## found in array[match_idx]
else:
    pass ## unfound
#-----------------------------
# NOTE: I can't see why this is useful either - why's this the highest paid?
for employee in employees:
    if employee.category == 'engineer':
        highest_engineer = employee
        break

print "Highest paid engineer is:", highest_engineer.name
#-----------------------------
for i in range(len(ARRAY)):
    if criterion:
        break

if i < len(ARRAY):
    pass ## found and 'i' is the index
else:
    pass ## not found

#-----------------------------


# @@PLEAC@@_4.13
MATCHING = [term for term in LIST if TEST(term)]
#-----------------------------
MATCHING = filter(TEST, LIST)
#-----------------------------
matching = []
for term in list:
    if TEST(term):
        matching.append(term)
#-----------------------------
bigs = [num for num in nums if num > 1000000]
pigs = [user for user in users.keys() if users[user] > 1e7]
#-----------------------------
import os
matching = filter(lambda s: s.startswith("gnat "),
                  os.popen("who").readlines())
#-----------------------------
engineers = [employee for employee in employees
                            if employee.position == "Engineer"]
#-----------------------------
secondary_assistance = [applicant for applicant in applicants
                             if 26000 <= applicant.income < 30000]
#-----------------------------



# @@PLEAC@@_4.14
LIST.sort()
#-----------------------------
# pids is an unsorted array of process IDs
import os, signal, time
pids.sort()
for pid in pids:
    print pid

pid = raw_input("Select a process ID to kill: ")
try:
    pid = int(pid)
except ValueError:
    raise SystemExit("Exiting ... ")
os.kill(pid, signal.SIGTERM)
time.sleep(2)
try:
    os.kill(pid, signal.SIGKILL)
except OSError, err:
    if err.errno != 3:  # was it already killed?
        raise
#-----------------------------
descending = unsorted[:]
descending.sort(lambda x, y: cmp(y, x))
#-----------------------------
def revnum(a, b):
    return cmp(b, a)

all = [4, 19, 8, 3]
all.sort(revnum)

#-----------------------------
all = [4, 19, 8, 3]
all.sort(lambda x, y: -cmp(x, y))
#-----------------------------


# @@PLEAC@@_4.15
ordered = unordered[:]
ordered.sort(compare())
#-----------------------------
precomputed = [(compute(x), x) for x in unordered]
precomputed.sort(lambda a, b: cmp(a[0], b[0]))
ordered = [v for k,v in precomputed.items()]
#-----------------------------
def functional_sort(l, function):
    l.sort(function)
    return l

ordered = [v for k,v in functional_sort([(compute(x), x) for x in unordered],
                                        lambda a, b: cmp(a[0], b[0]))]

#-----------------------------
ordered = employees[:]
ordered.sort(lambda a, b: cmp(a.name, b.name))
#-----------------------------
terms = employees[:]
terms.sort(lambda a, b: cmp(a.name, b.name))
for employee in terms:
    print employee.name, "earns", "$%s" % employee.salary
#-----------------------------
sorted_employees = employees[:]
sorted_employees.sort(lambda a, b: cmp(a.name, b.name))
for employee in sorted_employees:
    print employee.name, "earns", "$%s" % employee.salary

# load bonus
for employee in sorted_employees:
    if bonus(employee.ssn):
        print employee.name, "got a bonus!"
#-----------------------------
sorted = employees[:]
sorted.sort(lambda a, b: cmp(a.name, b.name) or cmp(b.age, a.age))
#-----------------------------
# NOTE: Python should allow access to the pwd fields by name
# as well as by position.
import pwd
# fetch all users
users = pwd.getpwall()
users.sort(lambda a, b: cmp(a[0], b[0]))
for user in users:
    print user[0]

#-----------------------------
sorted = names[:]
sorted.sort(lambda a, b: cmp(a[:1], b[:1]))
#-----------------------------
sorted = strings[:]
sorted.sort(lambda a, b: cmp(len(a), len(b)))
#-----------------------------
temp = [(len(s), s) for s in strings]
temp.sort(lambda a, b: cmp(a[0], b[0]))
sorted = [x[1] for x in temp]
#-----------------------------
def functional_sort(l, function):
    l.sort(function)
    return l

sorted_fields = [v for k,v in functional_sort(
              [(int(re.search(r"(\d+)", x).group(1)), x) for x in fields],
                                   lambda a, b: cmp(a[0], b[0]))]
#-----------------------------
entries = []
for line in open("/etc/passwd").readlines():
    line = line[:-1]
    terms = line.split(":")
    entries.append( (int(terms[3]), int(terms[2]), terms[0], line) )

entries.sort()

for entry in entries:
    print entry[-1]
#-----------------------------


# @@PLEAC@@_4.16
import time
class Circular:
    def __init__(self, data):
        assert len(data) >= 1, "Cannot use an empty list"
        self.data = data
    def next(self):
        head = self.data[0]
        self.data[:1] = []
        self.data.append(head)
        return head

circular = Circular([1, 2, 3, 4, 5])
while 1:
    process = circular.next()
    print "Handling process", process
    time.sleep(1)

# @@PLEAC@@_4.17
# generate a random permutation of ARRAY in place
import random
random.shuffle(ARRAY)

# @@PLEAC@@_4.18
import sys

# subroutine to check whether at last item on line
def EOL(item):
    return (item+1) % cols == 0

# Might not be portable to non-linux systems
def getwinsize():
    # Use the curses module if installed
    try:
        import curses
        stdscr = curses.initscr()
        rows, cols = stdscr.getmaxyx()
        return cols
    except ImportError:
        pass

    # Nope, so deal with ioctl directly.  What value for TIOCGWINSZ?
    try:
        import termios
        TIOCGWINSZ = termios.TIOCGWINSZ
    except ImportError:
        TIOCGWINSZ = 0x40087468  # This is Linux specific

    import struct, fcntl
    s = struct.pack("HHHH", 0, 0, 0, 0)
    try:
        x = fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ, s)
    except IOError:
        return 80
    rows, cols = struct.unpack("HHHH", x)[:2]
    return cols

cols = getwinsize()

data = [s.rstrip() for s in sys.stdin.readlines()]
if not data:
    maxlen = 1
else:
    maxlen = max(map(len, data))

maxlen += 1       # to make extra space

# determine boundaries of screen
cols = (cols / maxlen) or 1
rows = (len(data)+cols) / cols


# pre-create mask for faster computation
mask = "%%-%ds " % (maxlen-1)

# now process each item, picking out proper piece for this position
for item in range(rows * cols):
    target = (item % cols) * rows + (item/cols)
    if target < len(data):
        piece = mask % data[target]
    else:
        piece = mask % ""
    if EOL(item):
        piece = piece.rstrip()  # don't blank-pad to EOL
    sys.stdout.write(piece)
    if EOL(item):
        sys.stdout.write("\n")

if EOL(item):
  sys.stdout.write("\n")




# @@PLEAC@@_4.19
import fileinput

# Slightly modified from
#   http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66463

def printList(alist, blist=[]):
    if not len(alist):
        print ' '.join(blist)
    for i in range(len(alist)):
        blist.append(alist.pop(i))
        printList(alist, blist)
        alist.insert(i, blist.pop())

for line in fileinput.input():
    words = line.split()
    printList(words)

# @@PLEAC@@_5.0
# dictionaries
age = {"Nat": 24,
       "Jules": 24,
       "Josh": 17}
#-----------------------------
age = {}
age["Nat"] = 24
age["Jules"] = 25
age["Josh"] = 17
#-----------------------------
food_color = {"Apple":  "red",
              "Banana": "yellow",
              "Lemon":  "yellow",
              "Carrot": "orange"
             }
#-----------------------------
# NOTE: keys must be quoted in Python


# @@PLEAC@@_5.1
dict[KEY] = VALUE
#-----------------------------
# food_color defined per the introduction
food_color["Raspberry"] = "pink"
print "Known foods:"
for food in food_color.keys():
    print food

# In Python 2.2
for food in food_color:
    print food
#-----------------------------



# @@PLEAC@@_5.2
# does dict have a value for KEY ?
if dict.has_key(key):
    pass # it exists
else:
    pass # it doesn't

#-----------------------------
# food_color per the introduction
for name in ("Banana", "Martini"):
    if food_color.has_key(name):
        print name, "is a food."
    else:
        print name, "is a drink."
#-----------------------------
age = {}
age["Toddler"] = 3
age["Unborn"] = 0
age["Phantasm"] = None

for thing in ("Toddler", "Unborn", "Phantasm", "Relic"):
    print "%s:" % (thing,),
    if age.has_key(thing):
        print "Exists",
        if age[thing] is not None: print "Defined",
        if age[thing]: print "True",
    print
#-----------------------------
# Get file sizes for the requested filenames
import fileinput, os
size = {}
for line in fileinput.input():
    filename = line.rstrip()
    if size.has_key[filename]:
        continue
    size[filename] = os.path.getsize(filename)


# @@PLEAC@@_5.3
# remove KEY and its value from dict
del dict[KEY]
#-----------------------------
# food_color as per Introduction
def print_foods():
    foods = food_color.keys()

    print "Keys:", " ".join(foods)
    print "Values:",

    for food in foods:
        color = food_color[food]
        if color is not None:
            print color,
        else:
            print "(undef)",
    print "\n"

print "Initially:"
print_foods()

print "\nWith Banana set to None"
food_color["Banana"] = None
print_foods()

print "\nWith Banana deleted"
del food_color["Banana"]
print_foods()

#-----------------------------
del food_color["Banana"], food_color["Apple"], food_color["Cabbage"]
#-----------------------------


# @@PLEAC@@_5.4
#-----------------------------
for key, value in dict.items():
    pass # do something with key and value
#-----------------------------
for key in dict.keys():
    value = dict[key]
    # do something with key and value
#-----------------------------
# food_color per the introduction
for food, color in food_color.iteritems():  # iteritems added in Python 2.2
    print "%s is %s." % (food, color)

for food in food_color.iterkeys():  # iterkeys added in Python 2.2
    color = food_color[food]
    print "%s is %s." % (food, color)

#-----------------------------
print """%(food)s

is

%(color)s.
""" % vars()
#-----------------------------
foods = food_color.keys()
foods.sort()
for food in foods:
    print "%s is %s.\n" % (food, food_color)

#-----------------------------
#!/usr/bin/env python
# countfrom - count number of messages from each sender

import sys
if len(sys.argv) > 1:
    infile = open(sys.argv[1])
else:
    infile = sys.stdin

counts = {}
for line in infile.xreadlines():  # xreadlines added in Python 2.1
    if line.startswith("From: "):
        name = line[6:-1]
        counts[name] = counts.get(name, 0) + 1

names = counts.keys()
names.sort()
for name in names:
    print "%s: %s" % (name, counts[name])

#-----------------------------


# @@PLEAC@@_5.5
for k, v in dict.items():
    print k, "=>", v

#-----------------------------
print "\n".join(map(lambda item: "%s => %s" % item, dict.items()))
print "\n".join(["%s => %s" % item for item in dict.items()])

print "\n".join(map(lambda k: "%s => %s" % (k, dict[k]), dict.keys()))
# for old python (<= 2.0) that don't have closure (nested scopes)
print map(lambda k, dict = dict: "%s => %s" % (k, dict[k]), dict.keys())

#-----------------------------
print dict
#> {'firstname': 'Andrew', 'login': 'dalke', 'state': 'New Mexico', 'lastname': 'Dalke'}
#-----------------------------
import pprint
pprint.pprint(dict)
#> {'firstname': 'Andrew',
#>  'lastname': 'Dalke',
#>  'login': 'dalke',
#>  'state': 'New Mexico'}
#-----------------------------


# @@PLEAC@@_5.6
# No simple, native support in Python.  Would need to derive your
# own version from UserDict (pre-2.2) or from the dictionary type (2.2).

# @@PLEAC@@_5.7
import os
ttys = {}

who = os.popen("who")

# or 'xreadlines()' in 2.1, or 'for line in who' in 2.2
for line in who.readlines():
    user, tty = line.split()[:2]
    ttys.setdefault(user, []).append(tty)

users = ttys.keys()
users.sort()
for user in users:
    print user + ": " + " ".join(ttys[user])

#-----------------------------
import pwd
for user in users:
    tty_list = ttys[user]
    tty_list.sort()
    print user + ":", len(tty_list), "ttys."
    for tty in tty_list:
        try:
            uid = os.stat("/dev/" + tty)[4]
            user = pwd.getpwuid(uid)[0]
        except os.error:
            user = "(not available)"
        print "\t%s (owned by %s)" % (tty, user)

# @@PLEAC@@_5.8
# LOOKUP maps keys to values
reverse = {}
for k, v in LOOKUP.items():
  reverse[v] = k
#-----------------------------
surname = {"Mickey": "Mantle", "Babe": "Ruth"}
first_name = {}
for k, v in surname.items():
    first_name[v] = k

print first_name["Mantle"]
#> Mickey

#-----------------------------
#!/usr/bin/perl -w
# foodfind - find match for food or color

import sys
if not sys.argv[1:]:
    raise SystemExit("usage: foodfind food_or_color")
given = sys.argv[1]

color = {"Apple":  "red",
         "Banana": "yellow",
         "Lemon":  "yellow",
         "Carrot": "orange",
        }
food = {}
for k, v in color.items():
  food[v] = k

if color.has_key(given):
    print given, "is a food with color", color[given]

if food.has_key(given):
    print food[given], "is a food with color", given

#-----------------------------
# food_color as per the introduction
foods_with_color = {}
for food, color in food_color.items():
    foods_with_color.setdefault(color, []).append(food)

print " ".join(foods_with_color["yellow"]), "were yellow foods."

#-----------------------------



# @@PLEAC@@_5.9
# dict is the hash to sort
keys = dict.keys()
keys.sort(criterion)
for key in keys:
    value = dict[key]
    # do something with key, value
#-----------------------------
foods = food_color.keys()
foods.sort()
for food in foods:
    print "%s is %s." % (food, food_color[food])
#-----------------------------
# NOTE: alternate version
items = food_color.items()
items.sort()
for item in items:
    print "%s is %s." % item

#-----------------------------
# NOTE: alternate version showing a user-defined function
def food_cmp(x, y):
    return cmp(x, y)

foods = food_color.keys()
foods.sort(food_cmp)

for food in foods:
    print "%s is %s." % (food, food_color[food])
#-----------------------------
def food_len_cmp(x, y):
    return cmp(len(x), len(y))

foods = food_color.keys()
foods.sort(food_len_cmp)

for food in foods:
    print "%s is %s." % (food, food_color[food])

#-----------------------------


# @@PLEAC@@_5.10
merged = {}
merged.update(A)
merged.update(B)

#-----------------------------
# NOTE: alernate version
merged = A.copy()
merged.update(B)

#-----------------------------
merged = {}
for k, v in A.items():
    merged[k] = v
for k, v in B.items():
    merged[k] = v

#-----------------------------
# food_color as per the introduction
drink_color = {"Galliano": "yellow",
               "Mai Tai": "blue"}

ingested_color = drink_color.copy()
ingested_color.update(food_color)
#-----------------------------
# food_color per the introduction, then
drink_color = {"Galliano": "yellow",
               "Mai Tai": "blue"}

substance_color = {}
for k, v in food_color.items():
    substance_color[k] = v
for k, v in drink_color.items():
    substance_color[k] = v

#-----------------------------
substance_color = {}
for dict in (food_color, drink_color):
    for k, v in dict:
        substance_color[k] = v
#-----------------------------
# NOTE: alternate version
substance_color = {}
for item in food_color.items() + drink_color.items():
    for k, v in dict:
        substance_color[k] = v

#-----------------------------
substance_color = {}
for dict in (food_color, drink_color):
    for k, v in dict.items():
        if substance_color.has_key(k):
            print "Warning:", k, "seen twice.  Using the first definition."
            continue
        substance_color[k] = v

# I think it's a copy, in which case
all_colors = new_colors.copy()


# @@PLEAC@@_5.11
common = []
for k in dict1.keys():
    if dict2.has_key(k):  # In Python 2.2 this is "if k in dict2:"
        common.append(k)
#-----------------------------
this_not_that = []
for k in dict1.keys():
    if not dict2.has_key(k):  # In Python 2.2 this is "if k not in dict2:"
        this_not_that.append(k)
#-----------------------------
# citrus_color is a dict mapping citrus food name to its color.
citrus_color = {"Lemon":  "yellow",
                "Orange": "orange",
                "Lime":   "green"}

# build up a list of non-citrus foods
non_citrus = []

for k in food_color.keys():          # In 2.2: "for k in food_color:"
    if not citrus_color.has_key(k):  # In 2.2: "  if k not in citrus_color:"
        non_citrus.append(k)

# @@PLEAC@@_5.12
# references as keys of dictionaries is no pb in python

name = {}
for filename in ("/etc/termcap", "/vmunix", "/bin/cat"):
    try:
        file = open(filename)
    except IOError:
        pass
    else:
        name[file] = filename

print "open files:", ", ".join(name.values())
for file in name.keys():
    file.seek(0, 2)       # seek to the end
    print "%s is %d bytes long." % (name[file], file.tell())
#-----------------------------

# @@PLEAC@@_5.13
# not available in Python

# @@PLEAC@@_5.14
count = {}
for element in list:
    count[element] = count.get(element, 0) + 1

# @@PLEAC@@_5.15
#-----------------------------
import fileinput

father = {'Cain': 'Adam',
          'Abel': 'Adam',
          'Seth': 'Adam',
          'Enoch': 'Cain',
          'Irad': 'Enoch',
          'Mehujael': 'Irad',
          'Methusael': 'Mehujael',
          'Lamech': 'Methusael',
          'Jabal': 'Lamech',
          'Jubal': 'Lamech',
          'Tubalcain': 'Lamech',
          'Enos': 'Seth',
         }

for line in fileinput.input():
    person = line.rstrip()
    while person is not None:        # as long as we have people,
        print person,                # print the current name
        person = father.get(person)  # set the person to the person's father
    print

#-----------------------------
import fileinput

children = {}
for k, v in father.items():
    children.setdefault(v, []).append(k)

for line in fileinput.input():
    person = line.rstrip()
    kids = children.get(person, ["nobody"])
    print person, "begat", ", ".join(kids)

#-----------------------------
import sys, re
pattern = re.compile(r'^\s*#\s*include\s*<([^>]+)')
includes = {}
for filename in filenames:
    try:
        infile = open(filename)
    except IOError, err:
        print >> sys.stderr, err
        continue
    while 1:    # There are nicer ways starting with Python 2.1
        line = infile.readline()
        if not line:
            break
        match = pattern.match(line)
        if match:
            includes.setdefault(match.group(1), []).append(filename)
    infile.close()

#-----------------------------
# list of files that don't include others
dict = {}
for e in reduce(lambda a,b: a + b, includes.values()):
    if not includes.has_key(e):
        dict[e] = 1
include_free = dict.keys()
include_free.sort()

# @@PLEAC@@_5.16
#-----------------------------
#!/usr/bin/env python -w
# dutree - print sorted indented rendition of du output
import os, sys

def input(args):
    # NOTE: This is insecure - use only from trusted code!
    cmd = "du " + " ".join(args)
    infile = os.popen(cmd)

    dirsize = {}
    kids = {}
    for line in infile.readlines():
        size, name = line[:-1].split("\t", 1)
        dirsize[name] = int(size)
        parent = os.path.dirname(name)
        kids.setdefault(parent, []).append(name)
    # Remove the last field added, which is the root
    kids[parent].pop()
    if kids[parent] == []: del kids[parent]

    return name, dirsize, kids

def getdots(root, dirsize, kids):
    size = cursize = dirsize[root]
    if kids.has_key(root):
        for kid in kids[root]:
            cursize -= dirsize[kid]     # -= added in 1.5.2
            getdots(kid, dirsize, kids)
    if size != cursize:
        dot = root + "/."
        dirsize[dot] = cursize
        kids[root].append(dot)

def output(root, dirsize, kids, prefix = "", width = 0):
    path = os.path.basename(root)
    size = dirsize[root]
    fmt = "%" + str(width) + "d %s"
    line = fmt % (size, path)
    print prefix + line

    prefix += (" " * (width-1)) + "| "  + (" " * len(path))

    if kids.has_key(root):
        kid_list = kids[root]
        kid_list.sort(lambda x, y, dirsize = dirsize:
                          cmp(dirsize[x], dirsize[y]))
        width = len(str(dirsize[kid_list[-1]]))
        for kid in kid_list:
            output(kid, dirsize, kids, prefix, width)
def main():
    root, dirsize, kids = input(sys.argv[1:])
    getdots(root, dirsize, kids)
    output(root, dirsize, kids)

if __name__ == "__main__":
    main()

# @@PLEAC@@_7.0
input = open("/usr/local/widgets/data")
for line in input:
    if line.find("blue") != -1:
        print line[:-1]
input.close()
#---------
import sys, re
pattern = re.compile(r"\d")
for line in sys.stdin:
    if not pattern.search(line):
        sys.stderr.write("No digit found.\n")
    sys.stdout.write("Read: " + line)
sys.stdout.close()
#---------
logfile = open("/tmp/log", "w")
#---------
logfile.close()
#---------
# NOTE: this is poor Python style.
import sys
old_output, sys.stdout = sys.stdout, logfile
print "Countdown initiated ..."
sys.stdout = old_output
print "You have 30 seconds to reach minimum safety distance."
# NOTE: It is better to just use
print >> logfile, "Countdown initiated ..."
print >> sys.stdout, "You have 30 seconds to reach minimum safety distance."
#---------

# @@PLEAC@@_7.1
source = open(path)
sink = open(path, "w")
#---------
# NOTE: almost no one uses the low-level os.open and os.fdopen
# commands, so their inclusion here is just silly.  If the
# os.fdopen(os.open(...)) was needed often, it would be turned
# into its own function.  Instead, I'll use 'fd' to hint that
# os.open returns a file descriptor
import os
source_fd = os.open(path, os.O_RDONLY)
source = os.fdopen(fd)
sink_fd = os.open(path, os.O_WRONLY)
sink = os.fdopen(sink_fd)
#---------
file = open(filename, "w")
fd = os.open(filename, os.O_WRONLY | os.O_CREAT)
file = open(filename, "r+")
#---------
fd = os.open(name, flags)
fd = os.open(name, flags, mode)
#---------
file = open(path)
fd = os.open(path, os.O_RDONLY)
#-----------------------------
file = open(path, "w")
fd = os.open(path, os.O_WRONLY|os.O_TRUNC|os.O_CREAT)
fd = os.open(path, os.O_WRONLY|os.O_TRUNC|os.O_CREAT, 0600)
#-----------------------------
fd = os.open(path, os.O_WRONLY|os.O_EXCL|os.O_CREAT)
fd = os.open(path, os.O_WRONLY|os.O_EXCL|os.O_CREAT, 0600)
#-----------------------------
file = open(path, "a")
fd = os.open(path, os.O_WRONLY|os.O_APPEND|os.O_CREAT)
fd = os.open(path, os.O_WRONLY|os.O_APPEND|s.O_CREAT, 0600)
#-----------------------------
fd = os.open(path, os.O_WRONLY|os.O_APPEND)
#-----------------------------
file = open(path, "rw")
fd = os.open(path, os.O_RDWR)
#-----------------------------
fd = os.open(path, os.O_RDWR|os.O_CREAT)
fd = os.open(path, os.O_RDWR|os.O_CREAT, 0600)
#-----------------------------
fd = os.open(path, os.O_RDWR|os.O_EXCL|os.O_CREAT)
fd = os.open(path, os.O_RDWR|os.O_EXCL|os.O_CREAT, 0600)
#-----------------------------

# @@PLEAC@@_7.2
# Nothing different needs to be done with Python

# @@PLEAC@@_7.3
import os
filename = os.path.expanduser(filename)

# @@PLEAC@@_7.4
file = open(filename)   # raise an exception on error

try:
    file = open(filename)
except IOError, err:
    raise AssertionError("Couldn't open %s for reading : %s" %
                         (filename, err.strerror))

# @@PLEAC@@_7.5
import tempfile

file = tempfile.TemporaryFile()

#-----------------------------
# NOTE: The TemporaryFile() call is much more appropriate
# I would not suggest using this code for real work.
import os, tempfile

while 1:
    name = os.tmpnam()
    try:
        fd = os.open(name, os.O_RDWR|os.O_CREAT|os.O_EXCL)
        break
    except os.error:
        pass
file = tempfile.TemporaryFileWrapper(os.fdopen(fd), name)

# now go on to use the file ...
#-----------------------------
import os
while 1:
    tmpname = os.tmpnam()
    fd = os.open(tmpnam, os.O_RDWR | os.O_CREAT | os.O_EXCL)
    if fd:
        tmpfile = os.fdopen(fd)
        break

os.unlink(tmpnam)

#-----------------------------
import tempfile

file = tempfile.TemporaryFile(bufsize = 0)
for i in range(10):
    print >>file, i
file.seek(0)
print "Tmp file has:", file.read()
#-----------------------------

# @@PLEAC@@_7.6
DATA = """\
your data goes here
"""
for line in DATA.split("\n"):
    pass # process the line

# @@PLEAC@@_7.7
for line in sys.stdin:
    pass # do something with the line

#-----------------------------
import sys

def do_with(file):
    for line in file:
        print line[:-1]

filenames = sys.argv[1:]
if filenames:
    for filename in filenames:
        try:
            do_with(open(filename))
        except IOError, err:
            sys.stderr.write("Can't open %s: %s\n" % (filename, err.strerror))
            continue
else:
    do_with(sys.stdin)

#-----------------------------
import sys, glob
ARGV = sys.argv[1:] or glob.glob("*.[Cch]")
#-----------------------------
# NOTE: the getopt module is the prefered mechanism for reading
# command line arguments
import sys
args = sys.argv[1:]
chop_first = 0

if args and args[0] == "-c":
    chop_first += 1
    args = args[1:]

# arg demo 2: Process optional -NUMBER flag

# NOTE: You just wouldn't process things this way for Python,
# but I'm trying to preserve the same semantics.

import sys, re
digit_pattern = re.compile(r"-(\d+)$")

args = sys.argv[1:]
if args:
    match = digit_pattern.match(args[0])
    if match:
        columns = int(match.group(1))
        args = args[1:]

# NOTE: here's the more idiomatic way, which also checks
# for the "--" or a non "-" argument to stop processing

args = sys.argv[1:]
for i in range(len(args)):
    arg = args[i]
    if arg == "--" or not arg.startwith("-"):
        break
    if arg[1:].isdigit():
        columns = int(arg[1:])
        continue



# arg demo 3: Process clustering -a, -i, -n, or -u flags
import sys, getopt
try:
    args, filenames = getopt.getopt(sys.argv[1:], "ainu")
except getopt.error:
    raise SystemExit("usage: %s [-ainu] [filenames] ..." % sys.argv[0])

append = ignore_ints = nostdout = unbuffer = 0
for k, v in args:
    if k == "-a": append += 1
    elif k == "-i": ignore_ints += 1
    elif k == "-n": nostdout += 1
    elif k == "-u": unbuffer += 1
    else:
        raise AssertionError("Unexpected argument: %s" % k)

#-----------------------------
# Note: Idiomatic Perl get translated to idiomatic Python
import fileinput
for line in fileinput.input():
    sys.stdout.write("%s:%s:%s" %
                     (fileinput.filename(), fileinput.filelineno(), line))
#-----------------------------
#!/usr/bin/env python
# findlogin1 - print all lines containing the string "login"
for line in fileinput.input(): # loop over files on command line
    if line.find("login") != -1:
        sys.stdout.write(line)

#-----------------------------
#!/usr/bin/env python
# lowercase - turn all lines into lowercase
### NOTE: I don't know how to do locales in Python
for line in fileinput.input(): # loop over files on command line
    sys.stdout.write(line.lower())

#-----------------------------
#!/usr/bin/env python
# NOTE: The Perl code appears buggy, in that "Q__END__W" is considered
#       to be a __END__ and words after the __END__ on the same line
#       are included in the count!!!
# countchunks - count how many words are used.
# skip comments, and bail on file if __END__
# or __DATA__ seen.
chunks = 0
for line in fileinput.input():
    for word in line.split():
        if word.startswith("#"):
            continue
        if word in ("__DATA__", "__END__"):
            fileinput.close()
            break
        chunks += 1
print "Found", chunks, "chunks"


# @@PLEAC@@_7.13
import select
while 1:
    rlist, wlist, xlist = select.select([file1, file2, file3], [], [], 0)
    for r in rlist:
        pass # Do something with the file handle

# @@PLEAC@@_7.16
# NOTE: this is all much easier in Python
def subroutine(file):
    print >>file, "Hello, file"

variable = file
subroutine(variable)

# @@PLEAC@@_7.18
for file in files:
    print >> file, stuff_to_print

# NOTE: This is unix specific
import os
file = os.popen("tee file1 file2 file3 >/dev/null", "w")
print >> file, "whatever"

# NOTE: the "make STDOUT go to three files" is bad programming style
import os, sys
sys.stdout.file = os.popen("tee file1 file2 file3", "w")
print "whatever"
sys.stdout.close()

# @@PLEAC@@_7.19
import os
file = os.fdopen(fdnum) # open the descriptor itself
file = os.fdopen(os.dup(fdnum)) # open to a copy of the descriptor

###
outcopy = os.fdopen(os.dup(sys.stdin.fileno()), "w")
incopy = os.fdopen(os.dup(sys.stdin.fileno()), "r")

# ^^PLEAC^^_8.0
#-----------------------------
# for line in DATAFILE: # For Python 2.2
for line in DATAFILE.xreadlines(): # Python 2.1
    line = line.rstrip()
    size = len(line)
    print size        # output size of line

#-----------------------------
for line in datafile:
    print length(line.rstrip())     # output size of line
#-----------------------------
lines = datafile.readlines()
#-----------------------------
whole_file = file.read()
#-----------------------------
## No direct equivalent in Python
#% perl -040 -e '$word = <>; print "First word is $word\n";'
#-----------------------------
## No direct equivalent in Python
#% perl -ne 'BEGIN { $/="%%\n" } chomp; print if /Unix/i' fortune.dat
#-----------------------------
print >>file, "One", "two", "three"  # "One two three"
print "Baa baa black sheep."         # Sent to default output file
#-----------------------------
buffer = file.read(4096)
rv = len(buffer)
#-----------------------------
file.truncate(length)
open("/tmp/%d.pid" % os.getpid(), "a").truncate(length)
#-----------------------------
pos = file.tell()
print "I'm", pos, "bytes from the start of DATAFILE."
#-----------------------------
logfile.seek(0, 2)   # Seek to the end
datafile.seek(pos)   # Seek to a given byte
outfile.seek(-20, 1) # Seek back 20 bytes
#-----------------------------
written = os.write(datafile.fileno(), mystring)
if written != len(mystring):
    warnings.warn("only read %s bytes, not %s" % (written, len(mystring)))
#-----------------------------
pos = os.lseek(file.fileno(), 0, 1)       # don't change position
#-----------------------------

 
# ^^PLEAC^^_8.1
# This uses the 'yield' keyword from Python 2.2
from __future__ import generators
def ContReader(infile):
    lines = []
    for line in infile:
        line = line.rstrip()
        if line.endswith("\\"):
            lines.append(line[:-1])
            continue
        lines.append(line)
        yield "".join(lines)
        lines = []
    if lines:
        yield "".join(lines)

for line in ContReader(datafile):
    pass # process full record in 'line' here

# ^^PLEAC^^_8.2
import os
count = int(os.popen("wc -l < " + filename).read())
#-----------------------------
file = open(filename)
count = 0
for line in file:
    count += 1
# 'count' now holds the number of lines read
#-----------------------------
file = open(filename)
count = 0
while 1:
    line = file.readline()
    if not line:
        break
    count += 1
#-----------------------------
count = 0
while 1:
    s = file.read(2**16)
    count += s.count("\n")
#-----------------------------
for line, count in zip(open(filename), xrange(1, sys.maxint)):
    pass
# 'count' now holds the number of lines read
#-----------------------------
import fileinput
fi = fileinput.FileInput(filename)
while fi.readline(): pass

count = fi.lineno()
#-----------------------------
from __future__ import generators

def SepReader(infile, sep = "\n\n"):
    text = infile.read(10000)
    if not text:
        return
    while 1:
        fields = text.split(sep)
        for field in fields[:-1]:
            yield field
        text = fields[-1]
        new_text = infile.read(10000)
        if not new_text:
            yield text
            break
        text += new_text

para_count = 0
for para in SepReader(open(filename)):
    para_count += 1
# FIXME: For my test case (Python-pre2.2 README from CVS) this
# returns 175 paragraphs while Perl returns 174.
#-----------------------------

 
# ^^PLEAC^^_8.3
for line in sys.stdin:
    for word in line.split():
        pass # do something with 'chunk'
#-----------------------------
pat = re.compile(r"(\w[\w'-]*)")
for line in sys.stdin:
    pos = 0
    while 1:
        match = pat.search(line, pos)
        if not match:
            break
        pos = match.end(1)
        # do something with match.group(1)

# EXPERIMENTAL in the sre implementation but
# likely to be included in future (post-2.2) releases.
pat = re.compile(r"(\w[\w'-]*)")
for line in sys.stdin:
    scanner = pat.scanner(line)
    while 1:
        match = scanner.search()
        if not match:
            break
        # do something with match.group(1)


#-----------------------------
# Make a word frequency count
import fileinput, re
pat = re.compile(r"(\w[\w'-]*)")
seen = {}
for line in fileinput.input():
    pos = 0
    while 1:
        match = pat.search(line, pos)
        if not match:
            break
        pos = match.end(1)
        text = match.group(1).lower()
        seen[text] = seen.get(text, 0) + 1

# output dict in a descending numeric sort of its values
items = seen.items()
items.sort(lambda a, b: cmp(b[1], a[1]))
for text, count in items:
    print "%5d %s" % (count, text)

#-----------------------------
# Line frequency count
import fileinput, sys
seen = {}
for line in fileinput.input():
    text = line.lower()
    seen[text] = seen.get(text, 0) + 1
items = seen.items()
items.sort(lambda a, b: cmp(b[1], a[1]))
for text, count in items:
    sys.stdout.write("%5d %s" % (count, text))

#-----------------------------

 
# ^^PLEAC^^_8.4
lines = file.readlines()
while lines:
    line = lines.pop()
    # do something with 'line'

#-----------------------------
lines = file.readlines()
lines.reverse()
for line in lines:
    pass # do something with 'line'
#-----------------------------
for i in range(len(lines)):
    line = lines[-i]
#-----------------------------
paragraphs = [para for para in SepReader(infile)]
paragraphs.sort()
for paragraph in paragraphs:
    pass # do something

#-----------------------------

 

# ^^PLEAC^^_8.5
import time
while 1:
    for line in infile:
        pass # do something with the line
    time.sleep(SOMETIME)
    infile.seek(0, 1)
#-----------------------------
import time
naptime = 1

logfile = open("/tmp/logfile")
while 1:
    for line in logfile:
        print line.rstrip()
    time.sleep(naptime)
    infile.seek(0, 1)
#-----------------------------
while 1:
    curpos = logfile.tell()
    while 1:
        line = logfile.readline()
        if not line:
            break
        curpos = logfile.tell()
    sleep(naptime)
    logfile.seek(curpos, 0)  # seek to where we had been
#-----------------------------
import os, sys, stat
if os.stat(LOGFILENAME)[stat.ST_NLINK] == 0:
    sys.exit()
#-----------------------------

 
# ^^PLEAC^^_8.6
import random, fileinput
text = None
for line in fileinput.input():
    if random.randrange(fileinput.lineno()) == 0:
        text = line
# 'text' is the random line
#-----------------------------
# XXX is the perl code correct?  Where is the fortunes file opened?
import sys
adage = None
i = 1
for rec in SepReader(open("/usr/share/games/fortunes"), "%\n"):
    if random.randrange(i) == 0:
        adage = rec
    i += 1

print adage
#-----------------------------

 
# ^^PLEAC^^_8.7
import random
lines = input.readlines()
random.shuffle(lines)
for line in lines:
    print line.rstrip()
#-----------------------------

 

# ^^PLEAC^^_8.8
# using efficient caching system
import linecache
linecache.getline(filename, DESIRED_LINE_NUMBER)

# or doing it more oldskool
lineno = 0
while 1:
    line = infile.readline()
    if not line or lineno == DESIRED_LINE_NUMBER:
        break
    lineno = lineno + 1
#-----------------------------
lines = infile.readlines()
line = lines[DESIRED_LINE_NUMBER]
#-----------------------------
for i in range(DESIRED_LINE_NUMBER):
    line = infile.readline()
    if not line:
        break
#-----------------------------

## Not sure what this thing is doing.  Allow fast access to a given
## line number?

# usage: build_index(*DATA_HANDLE, *INDEX_HANDLE)

# ^^PLEAC^^_8.9
# given $RECORD with field separated by PATTERN,
# extract @FIELDS.
fields = re.split(pattern_string, text)
#-----------------------------
pat = re.compile(pattern_string)
fields = pat.split(text)
#-----------------------------
re.split(r"([+-])", "3+5-2")
#-----------------------------
[3, '+', 5, '-', 2]
#-----------------------------
fields = record.split(":")
#-----------------------------
fields = re.split(r":", record)
#-----------------------------
fields = re.split(r"\s+", record)
#-----------------------------
fields = record.split(" ")
#-----------------------------

 
# ^^PLEAC^^_8.10
file = open(filename, "r")
prev_pos = pos = 0
while 1:
    line = file.readline()
    if not line:
        break
    prev_pos = pos
    pos = file.tell()
file = open(filename, "a")
file.truncate(prev_pos)
#-----------------------------

 

# ^^PLEAC^^_8.11
open(filename, "rb")
open(filename, "wb")
#-----------------------------
gifname = "picture.gif"
gif_file = open(gifname, "rb")

# Don't think there's an equivalent for these in Python
#binmode(GIF);               # now DOS won't mangle binary input from GIF
#binmode(STDOUT);            # now DOS won't mangle binary output to STDOUT

#-----------------------------
while 1:
    buff = gif.read(8 * 2**10)
    if not buff:
        break
    sys.stdout.write(buff)
#-----------------------------

 

# ^^PLEAC^^_8.12
address = recsize * recno
file.seek(address, 0)
buffer = file.read(recsize)
#-----------------------------
address = recsize * (recno-1)
#-----------------------------

 

# ^^PLEAC^^_8.13
import posixfile
address = recsize * recno
file.seek(address)
buffer = file.read(recsize)
# ... work with the buffer, then turn it back into a string and ...
file.seek(-recsize, posixfile.SEEK_CUR)
file.write(buffer)
file.close()
#-----------------------------
## Not yet implemented
# weekearly -- set someone's login date back a week

# ^^PLEAC^^_8.14
## Note: this isn't optimal -- the 's+=c' goes O(N**2) so don't
## use for large strings.
file.seek(addr)
s = ""
while 1:
    c = file.read(1)
    if not c or c == "\0":
        break
    s += c
#-----------------------------
file.seek(addr)
offset = 0
while 1:
    s = file.read(1000)
    x = s.find("\0")
    if x != -1:
        offset += x
        break
    offset += len(s)
    if len(s) != 1000:  # EOF
        break
file.seek(addr)
s = file.read(offset - 1)
file.read(1)

#-----------------------------
## Not Implemented
# bgets - get a string from an address in a binary file
#-----------------------------
#!/usr/bin/perl
# strings - pull strings out of a binary file
import re, sys

## Assumes SepReader from above

pat = re.compile(r"([\040-\176\s]{4,})")
for block in SepReader(sys.stdin, "\0"):
    pos = 0
    while 1:
        match = pat.search(block, pos)
        if not match:
            break
        print match.group(1)
        pos = match.end(1)
#-----------------------------

 

# ^^PLEAC^^_8.15
# Not Implemented

# ^^PLEAC^^_8.16
# NOTE: to parse INI file, see the stanard ConfigParser module.
import re
pat = re.compile(r"\s*=\s*")
for line in config_file:
    if "#" in line:         # no comments
        line = line[:line.index("#")]
    line = line.strip()     # no leading or trailing white
    if not line:            # anything left?
        continue
    m = pat.search(line)
    var = line[:m.start()]
    value = line[m.end():]
    User_Preferences[var] = value


# ^^PLEAC^^_8.17
import os

mode, ino, dev, nlink, uid, gid, size, \
atime, mtime, ctime = os.stat(filename)

mode &= 07777               # discard file type info

#-----------------------------
import stat
info = stat(filename)
if info[stat.ST_UID] == 0:
    print "Superuser owns", filename
if info[stat.ST_ATIME] > info[stat.ST_MTIME]:
    print filename, "has been read since it was written."
#-----------------------------
import os, stat
def is_safe(path):
    info = os.stat(path)

    # owner neither superuser nor me 
    # the real uid is in stored in the $< variable
    if info[stat.ST_UID] not in (0, os.getuid()):
        return 0

    # check whether group or other can write file.
    # use 066 to detect either reading or writing
    if info[stat.ST_MODE] & 022:  # someone else can write this
        if not os.path.isdir(path):  # non-directories aren't safe
            return 0
        # but directories with the sticky bit (01000) are
        if not (info[stat.ST_MODE] & 01000):
            return 0
    return 1
#-----------------------------
## XXX What is '_PC_CHOWN_RESTRICTED'?

def is_verysafe(path):
    terms = []
    while 1:
        path, ending = os.path.split(path)
        if not ending:
            break
        terms.insert(0, ending)
    for term in terms:
        path = os.path.join(path, term)
        if not is_safe(path):
            return 0
    return 1
#-----------------------------

# Program: tailwtmp
# Not Implemented (don't know enough about Python's pack module)

# Program: tctee
# Not Implemented (requires reimplementing Perl's builtin '>>', '|',
# etc. semantics)

# Program: laston
# Not Implemented (don't know enough about Python's pack module)


# ^^PLEAC^^_9.0
#-----------------------------
entry = os.stat("/usr/bin/vi")
#-----------------------------
entry = os.stat("/usr/bin")
#-----------------------------
entry = os.stat(INFILE.name)
#-----------------------------
import stat

entry = os.stat("/usr/bin/vi")
ctime = entry[stat.ST_INO]
size = entry[stat.ST_SIZE]
#-----------------------------
F = open(filename)

## No equivalent in Python
# unless (-s F && -T _) {
#    die "$filename doesn't have text in it.\n";
# }

#-----------------------------

for filename in os.listdir("/usr/bin"):
    print "Inside /usr/bin is something called", filename
#-----------------------------

# ^^PLEAC^^_9.1
#-----------------------------
READTIME, WRITETIME = os.stat(filename)[8:10]

os.utime(filename, (NEWREADTIME, NEWWRITETIME))
#-----------------------------
SECONDS_PER_DAY = 60 * 60 * 24
atime, mtime = os.stat(file)[8:10]
atime -= 7 * SECONDS_PER_DAY
mtime -= 7 * SECONDS_PER_DAY

os.utime(file, (atime, mtime))
#-----------------------------
mtime = os.stat(file)[9]
utime(file, (time.time(), mtime))
#-----------------------------
#!/usr/bin/perl -w
# uvi - vi a file without changing its access times

import sys, os
if len(sys.argv) != 2:
    raise SystemExit("usage: uvi filename")
filename = argv[1]
atime, mtime = os.stat(filename)[8:10]
# WARNING: potential security risk
os.system( (os.environ.get("EDITOR") or "vi") + " " + filename)
os.utime(filename, (atime, mtime))
#-----------------------------

# ^^PLEAC^^_9.2
#-----------------------------
os.unlink(FILENAME)

err_flg = 0
for filename in filenames:
    try:
        os.unlink(filename)
    except OSError, err:
        err_flg = 1
if err_flg:
    raise OSError("Couldn't unlink all of %s: %s" % (filenames, err))
#-----------------------------
unlink(filename)
#-----------------------------
success = 0
for filename in filenames:
    try:
        os.unlink(filename)
        success += 1
    except OSError, err:
        pass
if success != len(filenames):
    sys.stderr.write("could only delete %d of %d files" % \
                     (success, len(filenames)))

#-----------------------------

# ^^PLEAC^^_9.3
#-----------------------------
import shutil
shutil.copy(oldfile, newfile)
#-----------------------------
## NOTE: this doesn't do the same thing as the Perl code,
## eg, handling of partial writes.
infile = open(oldfile)
outfile = open(newfile, "w")

blksize = 16384          # preferred block size?

while 1:
    buf = infile.read(blksize)
    if not buf:
        break
    outfile.write(buf)

infile.close()
outfile.close()
#-----------------------------
# WARNING: these are insecure - do not use in hostile environments
os.system("cp %s %s" % (oldfile, newfile))       # unix
os.system("copy %s %s" % (oldfile, newfile))     # dos, vms
#-----------------------------
import shutil

shutil.copy("datafile.dat", "datafile.bak")

shutil.copy("datafile.new", "datafile.dat")
os.unlink("datafile.new")

#-----------------------------

# ^^PLEAC^^_9.4
#-----------------------------
import os
seen = {}

def do_my_thing(filename):
    ino, dev = os.stat(filename)[1:3]
    if not seen.get( (ino, dev) ):
        # do something with filename because we haven't
        # seen it before
        pass
    seen[ (ino, dev) ] = seen.get( (ino, dev), 0 ) + 1

#-----------------------------
for filename in files:
    ino, dev = os.stat(filename)[1:3]
    seen.setdefault( (ino, dev), []).append(filename)

keys = seen.keys()
keys.sort()
for inodev in keys:
    ino, dev = inodev
    filenames = seen[inodev]
    if len(filenames) > 1:
        # 'filenames' is a list of filenames for the same file
        pass
#-----------------------------

# ^^PLEAC^^_9.5
#-----------------------------
for file in os.listdir(dirname):
    # do something with "$dirname/$file"
    pass
#-----------------------------
# XXX No -T equivalent in Python
#-----------------------------
# 'readir' always skipes '.' and '..' on OSes where those are
# standard directory names
for filename in os.listdir(dirname):
    pass
#-----------------------------
# XX Not Implemented -- need to know what DirHandle does
# use DirHandle;

#-----------------------------

# ^^PLEAC^^_9.6
#-----------------------------
import glob
filenames = glob.glob("*.c")
#-----------------------------
files = [filename.endswith(".c") for file in os.listdir(path)]
#-----------------------------
import re
allowed_name = re.compile(r"\.[ch]$", re.I).search
files = filter(allowed_name, os.listdir(path))
#-----------------------------
import re, os
allowed_name = re.compile(r"\.[ch]$", re.I).search

files = []
for filename in os.listdir(dirname):
    if not allowed_name(filename):
        continue

    files.append(os.path.join(dirname, filename))
#-----------------------------
filinfo = filter(lambda s: s.isdigit, listdir(path))  # just numeric files
fileinfo = [(name, "%s/%s" % (path, name)) for name in fileinfo] # (name, path)
fileinfo = filter(lambda name, fullpath: os.path.isdir(fullpath),
                 fileinfo)         # path is a dir
fileinfo.sort(lambda x, y: cmp(int(x[0]), int(y[0])))  # sort names numeric
dirs = [x[1] for x in fileinfo]    # extract pathnames
#-----------------------------

# @@PLEAC@@_9.7
# Processing All Files in a Directory Recursively

# os.walk is new in 2.3.

# For pre-2.3 code, there is os.path.walk, which is
# little harder to use.

#-----------------------------
import os
for root, dirs, files in os.walk(top):
    pass # do whatever

#-----------------------------
import os, os.path
for root, dirs, files in os.walk(top):
    for name in dirs:
        print os.path.join(root, name) + '/'
    for name in files:
        print os.path.join(root, name)

#-----------------------------
import os, os.path
sum = 0
for root, dirs, files in os.walk(top):
    for name in files:
        path = os.path.join(root, name)
        sum += os.path.getsize(path)
print "%s contains %s bytes" % (top, sum)

#-----------------------------
import os, os.path
saved_size, saved_name = -1, ''
for root, dirs, files in os.walk(top):
    for name in files:
        path = os.path.join(root, name)
        size = os.path.getsize(path)
        if size > saved_size:
            saved_size = size
            saved_name = path
print "Biggest file %s in %s is %s bytes long" % (
    saved_name, top, saved_size)

#-----------------------------
import os, os.path, time
saved_age, saved_name = None, ''
for root, dirs, files in os.walk(top):
    for name in files:
        path = os.path.join(root, name)
        age = os.path.getmtime(path)
        if saved_age is None or age > saved_age:
            saved_age = age
            saved_name = path
print "%s %s" % (saved_name, time.ctime(saved_age))

#-----------------------------
#!/usr/bin/env python
# fdirs - find all directories
import sys, os, os.path
argv = sys.argv[1:] or ['.']
for top in argv:
    for root, dirs, files in os.walk(top):
        for name in dirs:
            path = os.path.join(root, name)
            print path


# ^^PLEAC^^_9.8
#-----------------------------
# DeleteDir - remove whole directory trees like rm -r
import os, sys
def DeleteDir(dir):
    for name in os.listdir(dir):
        file = os.path.join(dir, name)
        if not os.path.islink(file) and os.path.isdir(file):
            DeleteDir(file)
        else:
            os.unlink(file)
    os.rmdir(dir)

# Or use shutil.rmtree(path)

#-----------------------------

# ^^PLEAC^^_9.10
#-----------------------------
import os

base = os.path.basename(path)
dirname = os.path.dirname(path)
dirname, filename = os.path.split(path)
base, ext = os.path.splitext(filename)

#-----------------------------
path = '/usr/lib/libc.a'
file = os.path.basename(path)
dirname = os.path.dirname(path)

print "dir is %s, file is %s" % (dirname, file)
# dir is /usr/lib, file is libc.a
#-----------------------------
path = '/usr/lib/libc.a'
dirname, filename = os.path.split(path)
name, ext = os.path.splitext(filename)

print "dir is %s, name is %s, extension is %s" % (dirname, name, ext)
#   NOTE: The Python code prints
# dir is /usr/lib, name is libc, extension is .a
#   while the Perl code prints a '/' after the directory name
# dir is /usr/lib/, name is libc, extension is .a
#-----------------------------
import macpath
path = "Hard%20Drive:System%20Folder:README.txt"
dirname, base = macpath.split(path)
name, ext = macpath.splitext(base)

print "dir is %s, name is %s, extension is %s" % (dirname, name, ext)
# dir is Hard%20Drive:System%20Folder, name is README, extension is .txt
#-----------------------------
# Note: this, like the original perl code, is unix specific
def extension(path):
    pos = path.find(".")
    if pos == -1:
        return ""
    ext = path[pos+1:]
    if "/" in ext:
        # wasn't passed a basename -- this is of the form 'x.y/z'
        return ""
    return ext
#-----------------------------


# @@PLEAC@@_9.11

#!/usr/bin/python
# sysmirror - build spectral forest of symlinks
import sys, os, os.path

pgmname = sys.argv[0]
if len(sys.argv)!=3:
    print "usage: %s realdir mirrordir" % pgmname
    sys.exit()

(srcdir, dstdir) = sys.argv[1:3]
if not os.path.isdir(srcdir):
    print "%s: %s is not a directory" % (pgmname,srcdir)
    sys.exit()
if not os.path.isdir(dstdir):
    try:
        os.mkdir(dstdir)
    except:
        print "%s: can't make directory %s" % (pgmname,dstdir)
        sys.exit()

# fix relative paths
srcdir = os.path.abspath(srcdir)
dstdir = os.path.abspath(dstdir)

def wanted(arg, dirname, names):
    for direntry in names:
        relname = "%s/%s" % (dirname, direntry)
        if os.path.isdir(relname):
            try:
                os.mkdir("%s/%s" % (dstdir,relname))
            except:
                print "can't mkdir %s/%s" % (dstdir,relname)
                sys.exit()
        else:
            if relname[:2] == "./":
                relname = relname[2:]
            os.symlink("%s/%s" % (srcdir, relname), "%s/%s" % (dstdir,relname))

os.chdir(srcdir)
os.path.walk(".",wanted,None)


# ^^PLEAC^^_10.0
#-----------------------------
greeted = 0
def hello():
    global greeted
    greeted += 1
    print "hi there"
#-----------------------------
hello()                 # call subroutine hello with no arguments/parameters
#-----------------------------

# ^^PLEAC^^_10.1
#-----------------------------
import math
def hypotenuse(side1, side2):
    return math.sqrt(side1**2 + side2**2)

diag = hypotenuse(3, 4)  # diag is 5.0
#-----------------------------
print hypotenuse(3, 4)               # prints 5.0

a = (3, 4)
print hypotenuse(*a)                 # prints 5.0
#-----------------------------
both = men + women
#-----------------------------
nums = [1.4, 3.5, 6.7]
ints = int_all(nums)        # nums unchanged
def int_all(nums):
    retlist = []            # make new list for return
    for n in nums:
        retlist.append(int(n))
    return retlist
#-----------------------------
nums = [1.4, 3.5, 6.7]
trunc_em(nums)               # nums now [1,3,6]
def trunc_em(nums):
    for i in range(len(nums)):
        nums[i] = int(nums[i])
#-----------------------------
## Python doesn't have an equivalent for this
##$line = chomp(<>);                  # WRONG
#-----------------------------

# ^^PLEAC^^_10.2
#-----------------------------
def somefunc():
    variable = something  # variable is invisible outside of somefunc
#-----------------------------
import sys
name, age = sys.args[1:]  # assumes two and only two command line parameters
start = fetch_time()
#-----------------------------
a, b = pair
c = fetch_time()

def check_x(x):
    y = "whatever"
    run_check()
    if condition:
        print "got", x
#-----------------------------
def save_array(*args):
    # args is a tuple, Global_Array is a list, so I
    # need to convert the tuple a list before extending
    Global_Array.extend(list(args))
#-----------------------------

# ^^PLEAC^^_10.3
#-----------------------------
### Python doesn't have unnamed scopes that allow declarations
##{
##    my $variable;
##    sub mysub {
##        # ... accessing $variable
##    }
##}
#-----------------------------
# Python executes code when a module is imported - there is
# no equivalent to a BEGIN or END block.
variable = 1                       # initial value
def othersub():
    pass # ... accessing variable
#-----------------------------
## Python 2.2 allows static nesting of scopes for reading
## but not writing, perfering to use objects.  The closest
## equivalent for
#{
#    my $counter;
#    sub next_counter { return ++$counter }
#}
## is something like
class Counter:
    def __init__(self):
        self.counter = 0
    def __call__(self):
        self.counter += 1
        return self.counter
next_counter = Counter()

#-----------------------------
## A close equivalent of
#BEGIN {
#    my $counter = 42;
#    sub next_counter { return ++$counter }
#    sub prev_counter { return --$counter }
#}
## in Python is
counter = 42
def next_counter():
    global counter
    counter += 1
    return counter
def prev_counter():
    global counter
    counter -= 1
    return counter
# but in this case the 'counter' is not private.

## A more Pythonic way uses classes, as this:

class Counter:
    def __init__(self, start = 0):
        self.value = start
    def next(self):
        self.value += 1
        return self.value
    def prev(self):
        self.value -= 1
        return self.value
    def __int__(self):
        return self.value

counter = Counter(42)
next_counter = counter.next
prev_counter = counter.prev

#-----------------------------

# ^^PLEAC^^_10.4
## This sort of code inspection is liable to change as
## Python evolves.  There may be cleaner ways to do this.
## This also may not work for code called from functions
## written in C.
#-----------------------------
import sys
this_function = sys._getframe(0).f_code.co_name
#-----------------------------
i = 0 # how far up the call stack to look
module = sys._getframe(i).f_globals["__name__"]
filename = sys._getframe(i).f_code.co_filename
line = sys._getframe(i).f_lineno
subr = sys._getframe(i).f_code.co_name
# 'has_args' is Perl specific
# 'wantarray' is Perl specific

#-----------------------------
me = whoami()
him = whowasi()

def whoami():
    sys._getframe(1).f_code.co_name
def whowasi():
    sys._getframe(2).f_code.co_name
#-----------------------------

# ^^PLEAC^^_10.5
#-----------------------------
array_diff(array1, array2)
#-----------------------------
a = [1, 2]
b = [5, 8]
c = add_vecpair(a, b)
print " ".join(map(str, c))
#> 6 10

def add_vecpair(x, y):
    result = []
    for x1, y1 in zip(x, y): # assumes both vectors the same length
        result.append(x1 + y1)
    return result

# Can also be done as a list comprehension
def add_vecpair(x, y):
    return [x1+y1 for x1, y1 in zip(x, y)]

# or in a more functional form
import operator
def add_vecpair(x, y):
    return map(operator.add, x, y)

#-----------------------------
## Doing this in Python is considered bad form
assert isinstance(x, type([])) and isinstance(y, type([])), \
    "usage: add_vecpair(list1, list2)"
#-----------------------------

# ^^PLEAC^^_10.6
#-----------------------------
# perl return context is not something standard in python...
# but still you can achieve something alike if you really need it
# (but you must really need it badly since you should never use this!!)
#
# see http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/284742 for more
#
# NB: it has been tested under Python 2.3.x and no guarantees can be given
#     that it works under any future Python version.
import inspect,dis

def expecting():
    """Return how many values the caller is expecting"""
    f = inspect.currentframe().f_back.f_back
    bytecode = f.f_code.co_code
    i = f.f_lasti
    instruction = ord(bytecode[i+3])
    if instruction == dis.opmap['UNPACK_SEQUENCE']:
        howmany = ord(bytecode[i+4])
        return howmany
    elif instruction == dis.opmap['POP_TOP']:
        return 0
    return 1

def cleverfunc():
    howmany = expecting()
    if howmany == 0:
        print "return value discarded"
    if howmany == 2:
        return 1,2
    elif howmany == 3:
        return 1,2,3
    return 1

cleverfunc()
x = cleverfunc()
print x
x,y = cleverfunc()
print x,y
x,y,z = cleverfunc()
print x,y,z

# ^^PLEAC^^_10.7
#-----------------------------
thefunc(INCREMENT = "20s", START = "+5m", FINISH = "+30m")
thefunc(START = "+5m", FINISH = "+30m")
thefunc(FINISH = "+30m")
thefunc(START = "+5m", INCREMENT = "15s")
#-----------------------------
# (Note: in Python it's poor style to use uppercase
# in parameter names)
def thefunc(INCREMENT = '10s',
            FINISH = '0',
            START = '0'):
    if INCREMENT.endswith("m"):
        pass

#-----------------------------

# ^^PLEAC^^_10.8
#-----------------------------
a, ignore, c = func()  # assign to an otherwise unused variable
a, None, c = func() # WRONG: this reassigns the value of None
a, _, c = func()  # Occasionally used
#-----------------------------

# ^^PLEAC^^_10.9
#-----------------------------
arr, dict = somefunc()

def somefunc():
    arr = []
    dict = {}

    # ...

    return arr, dict

#-----------------------------
def fn():
    return a, b, c

#-----------------------------
h0, h1, h2 = fn()
list_of_dicts = fn()    # eg: list_of_dicts[2]["keystring"]
r0, r1, r2 = fn()       # eg: r2["keystring"]

#-----------------------------

# ^^PLEAC^^_10.10
#-----------------------------
return
#-----------------------------
def empty_retval():
    return      # OR, identical to
    return None
#-----------------------------
a = yourfunc()
if a:
    pass
#-----------------------------
a = sfunc()
if not a:
    raise AssertionError("sfunc failed")

assert sfunc(), "sfunc failed"
#-----------------------------

# ^^PLEAC^^_10.11
# Python doesn't really have the same prototyping needs as Perl.
# Plus, I don't understand Perl's prototyping so can't give
# good examples for this section.
# @@INCOMPLETE@@
# @@INCOMPLETE@@
#-----------------------------

# ^^PLEAC^^_10.12
#-----------------------------
# Python has class exceptions but also supports an older
# (now deprecated) form of string exceptions.
raise "some message"        # raise exception (deprecated)
raise AssertionError("some message") # using a class instance
#-----------------------------
import warnings, sys
try:
    func()
except:
    warnings.warn("func raise an exception: " + str(sys.exc_info()[1]))
#-----------------------------
try:
    func()
except:
    warnings.warn("func blew up: " + str(sys.exc_info()[1]))
#-----------------------------
class MoonPhaseError(Exception):
    def __init__(self, phase):
        self.phase = phase
class FullMoonError(MoonPhaseError):
    def __init__(self):
        MoonPhaseError.__init__("full moon")

def func():
    raise FullMoonError()

# Ignore only FullMoonError exceptions
try:
    func()
except FullMoonError:
    pass
#-----------------------------
# Ignore only MoonPhaseError for a full moon
try:
    func()
except MoonPhaseError, err:
    if err.phase != "full moon":
        raise
#-----------------------------

# ^^PLEAC^^_10.13
# There is no direct equivalent to 'local' in Python, and
# it's impossible to write your own.  But then again, even in
# Perl it's considered poor style.
#-----------------------------

# ^^PLEAC^^_10.14
#-----------------------------
grow = expand
grow()                     # calls expand()

#-----------------------------
one.var = two.Table   # make one.var the same as two.Table
one.big = two.small   # make one.big the same as two.small
#-----------------------------
fred = barney     # alias fred to barney
#-----------------------------
s = red("careful here")
print s
#> <FONT COLOR='red'>careful here</FONT>
#-----------------------------
# Note: the 'text' should be HTML escaped if it can contain
# any of the characters '<', '>' or '&'
def red(text):
    return "<FONT COLOR='red'>" + text + "</FONT>"
#-----------------------------
def color_font(color, text):
    return "<FONT COLOR='%s'>%s</FONT>" % (color, text)

def red(text): return color_font("red", text)
def green(text): return color_font("green", text)
def blue(text): return color_font("blue", text)
def purple(text): return color_font("purple", text)
# etc
#-----------------------------
# This is done in Python by making an object, instead of
# saving state in a local anonymous context.
class ColorFont:
    def __init__(self, color):
        self.color = color
    def __call__(self, text):
        return "<FONT COLOR='%s'>%s</FONT>" % (self.color, text)

colors = "red blue green yellow orange purple violet".split(" ")
for name in colors:
    globals()[name] = ColorFont(name)
#-----------------------------
# If you really don't want to make a new class, you can
# fake it somewhat by passing in default args.
colors = "red blue green yellow orange purple violet".split(" ")
for name in colors:
    def temp(text, color = name):
        return "<FONT COLOR='%s'>%s</FONT>" % (color, text)
    globals()[name] = temp

#-----------------------------

# ^^PLEAC^^_10.15

# Python 2.2 has the ability to derive from ModuleType and add
# new __getattr__ and __setattr__ methods.  I don't know the
# expected way to use them to emulate Perl's AUTOLOAD.  Instead,
# here's how something similar would be done in Python.  This
# uses the ColorFont defined above.

#-----------------------------
class AnyColor:
    def __getattr__(self, name):
        return ColorFont(name)

colors = AnyColor()

print colors.chartreuse("stuff")

#-----------------------------
## Skipping this translation because 'local' is too Perl
## specific, and there isn't enough context to figure out
## what this is supposed to do.
#{
#    local *yellow = \&violet;
#    local (*red, *green) = (\&green, \&red);
#    print_stuff();
#}
#-----------------------------

# ^^PLEAC^^_10.16
#-----------------------------
def outer(arg1):
    x = arg1 + 35
    def inner():
        return x * 19
    return x + inner()
#-----------------------------

# ^^PLEAC^^_10.17
#-----------------------------
import mailbox, sys
mbox = mailbox.PortableUnixMailbox(sys.stdin)
messages = []
# In 2.2 you'll be able to replace the next 4 lines with
#   for msg in mbox:
while 1:
    msg = mbox.next()
    if msg is None:
        break
    subject = msg.getheader("Subject", "").strip()
    if subject[:3].lower() == "re:":
        subject = subject[3:].lstrip()
    text = msg.fp.read()
    messages.append( (subject, len(messages), msg, text) )

# Sorts by subject then by original position in the list
messages.sort()

for subject, pos, msg, text in messages:
    print str(msg) + "\n" + text

#-----------------------------
# Sorts by subject then date then original position
def subject_date_position_cmp(x, y):
    return cmp(x[0], y[0]) or \
           cmp(x[2].getdate("Date"), y[2].getdate("Date")) or \
           cmp(x[1], y[1])

messages.sort(subject_date_position_cmp)
#-----------------------------


# ^^PLEAC^^_12.0
#-----------------------------
## Python's "module" is the closest equivalent to Perl's "package"


#=== In the file "Alpha.py"
name = "first"

#=== End of file

#=== In the file "Omega.py"

name = "last"
#=== End of file

import Alpha, Omega
print "Alpha is %s, Omega is %s." % (Alpha.name, Omega.name)
#> Alpha is first, Omega is last.
#-----------------------------
# Python does not have an equivalent to "compile-time load"
import sys

# Depending on the implementation, this could use a builtin
# module or load a file with the extension .py, .pyc, pyo, .pyd,
# .so, .dll, or (with imputils) load from other files.
import Cards.Poker

#-----------------------------
#=== In the file Cards/Poker.py
__all__ = ["card_deck", "shuffle"]  # not usually bneeded
card_deck = []
def shuffle():
    pass

#-----------------------------

# ^^PLEAC^^_12.1
#-----------------------------
#== In the file "YourModule.py"

__version__ = (1, 0)          # Or higher
__all__ = ["...", "..."]      # Override names included in "... import *"
                              #   Note: 'import *' is consider poor style
                              #   and it is rare to use this variable.
########################
# your code goes here
########################

#-----------------------------
import YourModule             # Import the module into my package
                              #  (does not import any of its symbols)

import YourModule as Module   # Use a different name for the module

from YourModule import *      # Import all module symbols not starting
                              #  with an underscore (default); if __all__
                              #  is defined, only imports those symbols.

from YourModule import name1, name2, xxx
                              # Import the named symbols from the module

from YourModule import name1 as name2
                              # Import the named object, but use a
                              #  different name to access it locally.

#-----------------------------
__all__ = ["F1", "F2", "List"]
#-----------------------------
__all__ = ["Op_Func", "Table"]
#-----------------------------
from YourModule import Op_Func, Table, F1
#-----------------------------
from YourModule import Functions, Table
#-----------------------------

# ^^PLEAC^^_12.2
#-----------------------------
# no import
mod = "module"
try:
    __import__(mod)
except ImportError, err:
    raise ImportError("couldn't load %s: %s" % (mod, err))

# imports into current package
try:
    import module
except ImportError, err:
    raise ImportError("couldn't load 'module': %s" % (err, ))

# imports into current package, if the name is known
try:
    import module
except ImportError, err:
    raise ImportError("couldn't load 'module': %s" % (err, ))

# Use a fixed local name for a named module
mod = "module"
try:
    local_name = __import__(mod)
except ImportError, err:
    raise ImportError("couldn't load %s: %s" % (mod, err))

# Use the given name for the named module.
# (You probably don't need to do this.)
mod = "module"
try:
    globals()[mod] = __import__(mod)
except ImportError, err:
    raise ImportError("couldn't load %s: %s" % (mod, err))

#-----------------------------
DBs = "Giant.Eenie Giant.Meanie Mouse.Mynie Moe".split()
for mod in DBs.split():
    try:
        loaded_module = __import__(mod)
    except ImportError:
        continue
    # __import__ returns a reference to the top-most module
    # Need to get the actual submodule requested.
    for term in mod.split(".")[:-1]:
        loaded_module = getattr(loaded_module, term)
    break
else:
    raise ImportError("None of %s loaded" % DBs)
#-----------------------------

# ^^PLEAC^^_12.3
#-----------------------------
import sys
if __name__ == "__main__":
    if len(sys.argv) != 3 or not sys.argv[1].isdigit() \
                          or not sys.argv[2].isdigit():
        raise SystemExit("usage: %s num1 num2" % sys.argv[0])

import Some.Module
import More.Modules
#-----------------------------
if opt_b:
    import math
#-----------------------------
from os import O_EXCL, O_CREAT, O_RDWR

#-----------------------------
import os
O_EXCL = os.O_EXCL
O_CREAT = os.O_CREAT
O_RDWR = os.O_RDWR
#-----------------------------
import os
O_EXCL, O_CREAT, O_RDWR = os.O_EXCL, os.O_CREAT, os.O_RDWR
#-----------------------------
load_module('os', "O_EXCL O_CREAT O_RDWR".split())

def load_module(module_name, symbols):
    module = __import__(module_name)
    for symbol in symbols:
        globals()[symbol] = getattr(module, symbol)
#-----------------------------

# ^^PLEAC^^_12.4
#-----------------------------
# @@INCOMPLETE@@
# Don't know how to translate the 'Alpha' 'Beta' example
#-----------------------------
# Flipper.py
__version__ = (1, 0)

__all__ = ["flip_boundary", "flip_words"]

Separatrix = ' '  # default to blank

def flip_boundary(sep = None):
    prev_sep = Separatrix
    if sep is not None:
        global Separatrix
        Separatrix = sep
    return prev_sep

def flip_words(line):
    words = line.split(Separatrix)
    words.reverse()
    return Separatrix.join(words)
#-----------------------------

# ^^PLEAC^^_12.5
#-----------------------------
this_pack = __name__
#-----------------------------
that_pack = sys._getframe(1).f_globals.get("__name__", "<string>")
#-----------------------------
print "I am in package", __name__
#-----------------------------
# @@INCOMPLETE@@
# I don't know what the Alpha/Beta examples are trying to do.
#-----------------------------
## Do not use this in real Python code
import sys

def nreadline(count, handle_name):
    assert count > 0, "count must be > 0"
    locals = sys._getframe(1).f_locals
    if not locals.has_key(handle_name):
        raise AssertionError("need open filehandle")
    infile = locals[handle_name]
    retlist = []
    for line in infile:
        retlist.append(line)
        count -= 1
        if count == 0:
            break
    return retlist

def main():
    FH = open("/etc/termcap")
    a, b, c = nreadline(3, "FH")

if __name__ == "__main__":
    main()
#-----------------------------

# ^^PLEAC^^_12.6
#-----------------------------
## There is no direct equivalent in Python to an END block
import time, os, sys

# Tricks to ensure the needed functions exist during module cleanup
def _getgmtime(asctime = time.asctime, gmtime = time.gmtime,
               t = time.time):
    return asctime(gmtime(t()))

class Logfile:
    def __init__(self, file):
        self.file = file

    def _logmsg(self, msg, argv0 = sys.argv[0], pid = os.getpid(),
                _getgmtime = _getgmtime):
        # more tricks to keep all needed references
        now = _getgmtime()
        print >>self.file, argv0, pid, now + ":", msg

    def logmsg(self, msg):
        self._logmsg(self.file, msg)

    def __del__(self):
        self._logmsg("shutdown")
        self.file.close()

    def __getattr__(self, attr):
        # forward everything else to the file handle
        return getattr(self.file, attr)

# 0 means unbuffered
LF = Logfile(open("/tmp/mylog", "a+", 0))
logmsg = LF.logmsg

#-----------------------------
## It is more appropriate to use try/finally around the
## main code, so the order of initialization and finalization
## can be specified.
if __name__ == "__main__":
    import logger
    logger.init("/tmp/mylog")
    try:
        main()
    finally:
        logger.close()

#-----------------------------

# ^^PLEAC^^_12.7
#-----------------------------
#% python -c 'import sys\
for i, name in zip(xrange(sys.maxint), sys.path):\
    print i, repr(name)
#> 0 ''
#> 1 '/usr/lib/python2.2'
#> 2 '/usr/lib/python2.2/plat-linux2'
#> 3 '/usr/lib/python2.2/lib-tk'
#-----------------------------
# syntax for sh, bash, ksh, or zsh
#$ export PYTHONPATH=$HOME/pythonlib

# syntax for csh or tcsh
#% setenv PYTHONPATH ~/pythonlib
#-----------------------------
import sys
sys.path.insert(0, "/projects/spectre/lib")
#-----------------------------
import FindBin
sys.path.insert(0, FindBin.Bin)
#-----------------------------
import FindBin
Bin = "Name"
bin = getattr(FindBin, Bin)
sys.path.insert(0, bin + "/../lib")
#-----------------------------

# ^^PLEAC^^_12.8
#-----------------------------
#% h2xs -XA -n Planets
#% h2xs -XA -n Astronomy::Orbits
#-----------------------------
# @@INCOMPLETE@@
# @@INCOMPLETE@@
# Need a distutils example
#-----------------------------

# ^^PLEAC^^_12.11
#-----------------------------
## Any definition in a Python module overrides the builtin
## for that module

#=== In MyModule
def open():
    pass # TBA
#-----------------------------
from MyModule import open
file = open()
#-----------------------------

# ^^PLEAC^^_12.12
#-----------------------------
def even_only(n):
    if n & 1:     # one way to test
        raise AssertionError("%s is not even" % (n,))
    #....

#-----------------------------
def even_only(n):
    if n % 2:    # here's another
        # choice of exception depends on the problem
        raise TypeError("%s is not even" % (n,))
    #....

#-----------------------------
import warnings
def even_only(n):
    if n & 1:           # test whether odd number
        warnings.warn("%s is not even, continuing" % (n))
        n += 1
    #....
#-----------------------------
warnings.filterwarnings("ignore")
#-----------------------------

# ^^PLEAC^^_12.13
#-----------------------------
val = getattr(__import__(packname), varname)
vals =  getattr(__import__(packname), aryname)
getattr(__import__(packname), funcname)("args")
#-----------------------------

# @@INCOMPLETE@@
#-----------------------------

# ^^PLEAC^^_12.14
#-----------------------------
# @@INCOMPLETE@@
# @@INCOMPLETE@@
# No Python equivalent - see Inline for a possible replacement
#-----------------------------

# ^^PLEAC^^_12.15
#-----------------------------
# @@INCOMPLETE@@
# @@INCOMPLETE@@
# Need a distutils equivalent

#-----------------------------

# ^^PLEAC^^_12.16
#-----------------------------
# @@INCOMPLETE@@
# @@INCOMPLETE@@
# No Python equivalent.  (A couple of proposals, but nothing definitive.)
# 
# Python docstrings are one line, which is the short description of the
# function, class, module, etc.  Optionally this is followed by a blank
# line then the full description of the object.

#-----------------------------

# ^^PLEAC^^_12.17
#-----------------------------
# Recent Python distributions are built and installed with disutils.
# 
# To build and install under unix
# 
# % python setup.py install
# 
# If you want to build under one login and install under another
# 
# % python setup.py build
# $ python setup.py install
# 
# A package may also be available prebuilt, eg, as an RPM or Windows
# installer.  Details will be specific to the operating system.

#-----------------------------
# % python setup.py --prefix ~/python-lib
#-----------------------------


# ^^PLEAC^^_12.18
#-----------------------------
#== File Some/Module.py

# There are so many differences between Python and Perl that
# it isn't worthwhile trying to come up with an equivalent to
# this Perl code.  The Python code is much smaller, and there's
# no need to have a template.

#-----------------------------

# ^^PLEAC^^_12.19
#-----------------------------
#% pmdesc
#-----------------------------
import sys, pydoc

def print_module_info(path, modname, desc):
   # Skip files starting with "test_"
   if modname.split(".")[-1].startswith("test_"):
       return
   try:
       # This assumes the modules are safe for importing,
       # in that they don't have side effects.  Could also
       # grep the file for the __version__ line.
       mod = pydoc.safeimport(modname)
   except pydoc.ErrorDuringImport:
       return
   version = getattr(mod, "__version__", "unknown")
   if isinstance(version, type("")):
       # Use the string if it's given
       pass
   else:
       # Assume it's a list of version numbers, from major to minor
       ".".join(map(str, version))
   synopsis, text = pydoc.splitdoc(desc)
   print "%s (%s) - %s" % (modname, version, synopsis)

scanner = pydoc.ModuleScanner()
scanner.run(print_module_info)

#-----------------------------


# ^^PLEAC^^_13.0
#-----------------------------
# Inside a module named 'Data' / file named 'Data.py'
class Encoder:
    pass
#-----------------------------
obj = [3, 5]
print type(obj), id(obj), ob[1]

## Changing the class of builtin types is not supported
## in Python.

#-----------------------------
obj.Stomach = "Empty"    # directly accessing an object's contents
obj.NAME = "Thag"        # uppercase field name to make it stand out
(optional)
#-----------------------------
encoded = object.encode("data")
#-----------------------------
encoded = Data.Encoder.encode("data")
#-----------------------------
class Class:
    def __init__(self):
        pass
#-----------------------------
object = Class()
#-----------------------------
class Class:
    def class_only_method():
        pass # more code here
    class_only_method = staticmethod(class_only_method)

#-----------------------------
class Class:
    def instance_only_method(self):
        pass # more code here
#-----------------------------
lector = Human.Cannival()
lector.feed("Zak")
lector.move("New York")
#-----------------------------
# NOTE: it is rare to use these forms except inside of
# methods to call specific methods from a parent class
lector = Human.Cannival()
Human.Cannival.feed(lector, "Zak")
Human.Cannival.move(lector, "New York")
#-----------------------------
print >> sys.stderr, "stuff here\n"

# ^^PLEAC^^_13.1
#-----------------------------
class Class:
    pass
#-----------------------------
import time
class Class:
    def __init__(self):
        self.START = time.time()  # init data fields
        self.AGE = 0
#-----------------------------
import time
class Class:
    def __init__(self, **kwargs):
        # Sets START to the current time, and AGE to 0.  If called
        # with arguments, interpret them as key+value pairs to
        # initialize the object with
        self.AGE = 0
        self.__dict__.update(kwargs)
#-----------------------------

# ^^PLEAC^^_13.2
#-----------------------------
import time
class Class:
    def __del__(self):
        print self, "dying at", time.ctime()
#-----------------------------
## Why is the perl code introducing a cycle?  I guess it's an
## example of how to keep from calling the finalizer
self.WHATEVER = self
#-----------------------------

# ^^PLEAC^^_13.3
#-----------------------------
## In Python it's also common to access attributes directly
## as self.NAME because __getattr__/__setattr__ can be used
## for encapsulation.  Also, the C++/Java style naming convention
## of getName and setName is becoming more common.
class Class:
    def get_name(self):
        return self.NAME
    def set_name(self, name):
        self.NAME = name
#-----------------------------
## This is a very uncommon style in Python.  You are advised
## not to use it.
class Class:
    def __init__(self):
        self.AGE = 0
    def name(self, *args):
        if len(args) == 0:
            return self.NAME
        elif len(args) == 1:
            self.NAME = args[0]
        else:
            raise TypeError("name only takes 0 or 1 arguments")
    def age(self, *args):
        prev = self.AGE
        if args:
            self.AGE = args[0]
        return prev

# sample call of get and set: happy birthday!
obj.age(1 + obj.age())

#-----------------------------
# Here is a more common way to express the previous example,
# that is, it shows how to make attribute lookups of 'age'
# really use 'AGE' and 'name' use 'NAME'
class Class:
    def __init__(self):
        self.AGE = 0
    def __getattr__(self, name):
        if name in ("name", "age"):
            return getattr(self, name.upper())
        raise AttributeError(name)
    def __setattr__(self, name, value):
        if name in ("name", "age"):
            name = name.upper()
        self.__dict__[name] = value

# sample call of get and set: happy birthday!
obj.age = 1 + obj.age

#-----------------------------
him = Person()
him.NAME = "Sylvester"
him.AGE = 23
#-----------------------------
# Here's another way to implement the 'obj.method()' is a getter
# and 'obj.method(value)' is a settor.  Again, this is not a
# common Python idiom and should not be used.  See below for a
# more common way to do parameter checking of attribute assignment.

import re, sys

def carp(s):
    sys.stderr.write("WARNING: " + s + "\n")

class Class:
    no_name = []

    def name(self, value = no_name):
        if value is Class.no_name:
            return self.NAME
        value = self._enforce_name_value(value)
        self.NAME = value

    def _enforce_name_value(self, value):
        if re.search(r"[^\s\w'-]", value):
            carp("funny characters in name")
        if re.search(r"\d", value):
            carp("numbers in name")
        if not re.search(r"\S+(\s+\S+)+", value):
            carp("prefer multiword name")
        if not re.search(r"\S", value):
            carp("name is blank")
        return value.upper()   # enforce capitalization
#-----------------------------
# A more typical way to enforce restrictions on a value
# to set
class Class:
    def __setattr__(self, name, value):
        if name == "name":
            value = self._enforce_name_value(value)  # Do any conversions
        self.__dict__[name] = value  # Do the default __setattr__ action

    def _enforce_name_value(self, value):
        if re.search(r"[^\s\w'-]", value):
            carp("funny characters in name")
        if re.search(r"\d", value):
            carp("numbers in name")
        if not re.search(r"\S+(\s+\S+)+", value):
            carp("prefer multiword name")
        if not re.search(r"\S", value):
            carp("name is blank")
        return value.upper()   # enforce capitalization

#-----------------------------
class Person:
    def __init__(self, name = None, age = None, peers = None):
        if peers is None: peers = []  # See Python FAQ 6.25
        self.name = name
        self.age = age
        self.peers = peers

    def exclaim(self):
        return "Hi, I'm %s, age %d, working with %s" % \
            (self.name, self.age, ", ".join(self.peers))

    def happy_birthday(self):
        self.age += 1
        return self.age
#-----------------------------

# ^^PLEAC^^_13.4
#-----------------------------
## In the module named 'Person' ...
Body_Count = 0

def population():
    return Body_Count

class Person:
    def __init__(self):
        global Body_Count
        Body_Count += 1
    def __del__(self):
        global Body_Count
        Body_Count -= 1

# later, the user can say this:
import Person
people = []
for i in range(10):
    people.append(Person.Person())
print "There are", Person.population(), "people alive."

#>> There are 10 people alive.
#-----------------------------
him = Person()
him.gender = "male"

her = Person()
her.gender = "female"

#-----------------------------
FixedArray.max_bounds = 100                # set for whole class
alpha = FixedArray.FixedArray()
print "Bound on alpha is", alpha.max_bounds
100

beta = FixedArray.FixedArray()
beta.max_bounds = 50                      # still sets for whole class
print "Bound on alpha is", alpha.max_bounds
50
#-----------------------------
# In the module named 'FixedArray'

max_bounds = 7  # default

class FixedArray:
    def __getattr__(self, name):
        if name == "max_bounds":
            return max_bounds
        raise AttributeError(name)
    def __setattr__(self, name, value):
        if name == "max_bounds":
            global max_bounds
            max_bounds = value
            return
        self.__dict__[name] = value
#-----------------------------

# ^^PLEAC^^_13.5
#-----------------------------
# There isn't the severe separation between scalar, arrays and hashs
# in Python, so there isn't a direct equivalent to the Perl code.
class Person:
    def __init__(self, name = None, age = None, peers = None):
        if peers is None: peers = []
        self.name = name
        self.age = age
        self.peers = peers

p = Person("Jason Smythe", 13, ["Wilbur", "Ralph", "Fred"])

# or this way.  (This is not the prefered style as objects should
# be constructed with all the appropriate data, if possible.)

p = Person()  # allocate an empty Person
p.name = "Jason Smythe"                         # set its name field
p.age = 13                                      # set its age field
p.peers.extend( ["Wilbur", "Ralph", "Fred" ] )  # set its peers field

p.peers = ["Wilbur", "Ralph", "Fred"]

p.peers[:]= ["Wilbur", "Ralph", "Fred"]

# fetch various values, including the zeroth friend
print "At age %d, %s's first friend is %s." % \
    (p.age, p.name, p.peers[0])
#-----------------------------
# This isn't very Pythonic - should create objects with the
# needed data, and not depend on defaults and modifing the object.
import sys
def carp(s):
    sys.stderr.write("WARNING: " + s + "\n")

class Person:
    def __init__(self, name = "", age = 0):
        self.name = name
        self.age = age
    def __setattr__(self, name, value):
        if name == "age":
            # This is very unpythonic
            if not isinstance(value, type(0)):
                carp("age '%s' isn't numeric" % (value,))
            if value > 150: carp("age '%s' is unreasonable" % (value,))
        self.__dict__[name] = value

class Family:
    def __init__(self, head = None, address = "", members = None):
        if members is None: members = []
        self.head = head or Person()
        self.address = address
        self.members = members

folks = Family()

dad = folks.head
dad.name = "John"
dad.age = 34

print "%s's age is %d" % (folks.head.name, folks.head.age)
#-----------------------------
class Card:
    def __init__(self, name = None, color = None, cost = None,
                 type = None, release = None, text = None):
        self.name = name
        self.color = color
        self.cost = cost
        self.type = type
        self.release = release
        self.type = type
#-----------------------------
# For positional args
class Card:
    _names = ("name", "color", "cost", "type", "release", "type")
    def __init__(self, *args):
        assert len(args) <= len(self._names)
        for k, v in zipe(self._names, args):
            setattr(self, k, None)
#-----------------------------
# For keyword args
class Card:
    _names = ("name", "color", "cost", "type", "release", "type")
    def __init__(self, **kwargs):
        for k in self._names:  # Set the defaults
            setattr(self, k, None)
        for k, v in kwargs.items():  # add in the kwargs
            assert k in self._names, "Unexpected kwarg: " + k
            setattr(self, k, v)
#-----------------------------
class hostent:
    def __init__(self, addr_list = None, length = None,
                 addrtype = None, aliases = None, name = None):
        self.addr_list = addr_list or []
        self.length = length or 0
        self.addrtype = addrtype or ""
        self.aliases = aliases or []
        self.name = name or ""
#-----------------------------
## XXX What do I do with these?
#define h_type h_addrtype
#define h_addr h_addr_list[0]
#-----------------------------
# make (hostent object)->type() same as (hostent object)->addrtype()
#
# *hostent::type = \&hostent::addrtype;
#
# # make (hostenv object)->
# addr()
#  same as (hostenv object)->addr_list(0)
#sub hostent::addr { shift->addr_list(0,@_) }
#-----------------------------
# No equivalent to Net::hostent (Python uses an unnamed tuple)
#package Extra::hostent;
#use Net::hostent;
#@ISA = qw(hostent);
#sub addr { shift->addr_list(0,@_) }
#1;
#-----------------------------

# ^^PLEAC^^_13.6
#-----------------------------
class Class(Parent):
    pass
#-----------------------------
## Note: this is unusual in Python code
ob1 = SomeClass()
# later on
ob2 = ob1.__class__()
#-----------------------------
## Note: this is unusual in Python code
ob1 = Widget()
ob2 = ob1.__class__()
#-----------------------------
# XXX I do not know the intent of the original Perl code
# Do not use this style of programming in Python.
import time
class Person(possible,base,classes):
    def __init__(self, *args, **kwargs):
        # Call the parents' constructors, if there are any
        for baseclass in self.__class__.__bases__:
            init = getattr(baseclass, "__init__")
            if init is not None:
                init(self, *args, **kwargs)
        self.PARENT = parent      # init data fields
        self.START = time.time()
        self.AGE = 0
#-----------------------------

# ^^PLEAC^^_13.7
#-----------------------------
methname = "flicker"
getattr(obj, methname)(10)    # calls obj->flicker(10);

# call three methods on the object, by name
for m in ("start", "run", "stop"):
    getattr(obj, m)()
#-----------------------------
methods = ("name", "rank", "serno")
his_info = {}
for m in methods:
   his_info[m] = getattr(ob, m)()

# same as this:

his_info = {
    'name': ob.name(),
    'rank': ob.rank(),
    'serno': ob.serno(),
}
#-----------------------------
fnref = ob.method
#-----------------------------
fnref(10, "fred")
#-----------------------------
obj.method(10, "fred")
#-----------------------------
# XXX Not sure if this is the correct translation.
# XXX Is 'can' special?
if isinstance(obj_target, obj.__class__):
    obj.can('method_name')(obj_target, *arguments)
#-----------------------------

# ^^PLEAC^^_13.8
#-----------------------------
isinstance(obj, mimetools.Message)
issubclass(obj.__class__, mimetools.Message)

if hasattr(obj, "method_name"):  # check method validity
    pass
#-----------------------------
## Explicit type checking is needed fewer times than you think.
his_print_method = getattr(obj, "as_string", None)
#-----------------------------
__version__ = (3, 0)
Some_Module.__version__

# Almost never used, and doesn't work for builtin types, which don't
# have a __module__.

his_vers = obj.__module__.__version__
#-----------------------------
if Some_Module.__version__ < (3, 0):
  raise ImportError("Some_Module version %s is too old, expected (3, 0)" %
                    (Some_Module.__version__,))
# or more simply
assert Some_Module.__version__ >= (3, 0), "version too old"

#-----------------------------
__VERSION__ = '1.01'
#-----------------------------

# ^^PLEAC^^_13.9
#-----------------------------
# Note: This uses the standard Python idiom of accessing the
# attributes directly rather than going through a method call.
# See earlier in this chapter for examples of how this does
# not break encapsulation.
class Person:
    def __init__(self, name = "", age = 0):
        self.name = name
        self.age = age
#-----------------------------
# Prefered: dude = Person("Jason", 23)
dude = Person()
dude.name = "Jason"
dude.age = 23
print "%s is age %d." % (dude.name, dude.age)
#-----------------------------
class Employee(Person):
    pass
#-----------------------------
# Prefered: empl = Employee("Jason", 23)
emp = Employee()
empl.name = "Jason"
empl.age = 23
print "%s is age %d." % (empl.name, empl.age)
#-----------------------------

# ^^PLEAC^^_13.10
#-----------------------------
# This doesn't need to be done since if 'method' doesn't
# exist in the Class it will be looked for in its BaseClass(es)
class Class(BaseClass):
    def method(self, *args, **kwargs):
        BaseClass.method(self, *args, **kwargs)

# This lets you pick the specific method in one of the base classes
class Class(BaseClass1, BaseClass2):
    def method(self, *args, **kwargs):
        BaseClass2.method(self, *args, **kwargs)

# This looks for the first method in the base class(es) without
# specifically knowing which base class.  This reimplements
# the default action so isn't really needed.
class Class(BaseClass1, BaseClass2, BaseClass3):
    def method(self, *args, **kwargs):
        for baseclass in self.__class__.__bases__:
            f = getattr(baseclass, "method")
            if f is not None:
                return f(*args, **kwargs)
        raise NotImplementedError("method")

#-----------------------------
self.meth()   # Call wherever first meth is found

Where.meth(self)  # Call in the base class "Where"

# XXX Does Perl only have single inheritence?  Or does
# it check all base classes?  No directly equivalent way
# to do this in Python, but see above.
#-----------------------------
import time

# The Perl code calls a private '_init' function, but in
# Python there's need for the complexity of 'new' mechanism
# so it's best just to put the '_init' code in '__init__'.
class Class:
    def __init__(self, *args):
        # init data fields
        self.START = time.time()
        self.AGE = 0
        self.EXTRA = args          # anything extra
#-----------------------------
obj = Widget(haircolor = "red", freckles = 121)
#-----------------------------
class Class(Base1, Base2, Base3):
    def __init__(self, *args, **kwargs):
        for base in self.__class__.__bases__:
            f = getattr(base, "__init__")
            if f is not None:
                f(self, *args, **kwargs)
#-----------------------------

# ^^PLEAC^^_13.11
#-----------------------------
# NOTE: Python prefers direct attribute lookup rather than
# method calls.  Python 2.2 will introduce a 'get_set' which
# *may* be equivalent, but I don't know enough about it.  So
# instead I'll describe a class that lets you restrict access
# to only specific attributes.

class Private:
    def __init__(self, names):
        self.__names = names
        self.__data = {}
    def __getattr__(self, name):
        if name in self.__names:
            return self.__data[name]
        raise AttributeError(name)
    def __setattr__(self, name, value):
        if name.startswith("_Private"):
            self.__dict__[name] = value
            return
        if name in self.__names:
            self.__data[name] = value
            return
        raise TypeError("cannot set the attribute %r" % (name,))

class Person(Private):
    def __init__(self, parent = None):
        Private.__init__(self, ["name", "age", "peers", "parent"])
        self.parent = parent
    def new_child(self):
        return Person(self)
#-----------------------------
dad = Person()
dad.name = "Jason"
dad.age = 23
kid = dad.new_child()
kid.name = "Rachel"
kid.age = 2
print "Kid's parent is", kid.parent.name
#Kid's parent is Jason

# ^^PLEAC^^_13.12
#-----------------------------
## XXX No clue on what this does.  For that matter, what's
## "The Data Inheritance Problem"?

# ^^PLEAC^^_13.13
#-----------------------------
node.NEXT = node
#-----------------------------
# This is not a faithful copy of the Perl code, but it does
# show how to have the container's __del__ remove cycles in
# its contents.  Note that Python 2.0 includes a garbage
# collector that is able to remove these sorts of cycles, but
# it's still best to prevent cycles in your code.
class Node:
    def __init__(self, value = None):
        self.next = self
        self.prev = self
        self.value = value

class Ring:
    def __init__(self):
        self.ring = None
        self.count = 0

    def __str__(self):
        # Helpful when debugging, to print the contents of the ring
        s = "#%d: " % self.count
        x = self.ring
        if x is None:
            return s
        values = []
        while 1:
            values.append(x.value)
            x = x.next
            if x is self.ring:
                break
        return s + " -> ".join(map(str, values)) + " ->"

    def search(self, value):
        node = self.ring
        while 1:
            if node.value == value:
                return node
            node = node.next
            if node is self.ring:
                break

    def insert_value(self, value):
        node = Node(value)
        if self.ring is not None:
            node.prev, node.next = self.ring.prev, self.ring
            self.ring.prev.next = self.ring.prev = node
        self.ring = node
        self.count += 1

    def delete_value(self, value):
        node = self.search(value)
        if node is not None:
            self.delete_node(node)

    def delete_node(self, node):
        if node is node.next:
            node.next = node.prev = None
            self.ring = None
        else:
            node.prev.next, node.next.prev = node.next, node.prev
            if node is self.ring:
                self.ring = node.next
        self.count -= 1

    def __del__(self):
        while self.ring is not None:
            self.delete_node(self.ring)

COUNT = 1000
for rep in range(20):
    r = Ring()
    for i in range(COUNT):
        r.insert_value(i)
#-----------------------------

# ^^PLEAC^^_13.14
#-----------------------------
import UserString
class MyString(UserString.UserString):
    def __cmp__(self, other):
        return cmp(self.data.upper(), other.upper())

class Person:
    def __init__(self, name, idnum):
        self.name = name
        self.idnum = idnum
    def __str__(self):
        return "%s (%05d)" % (self.name.lower().capitalize(), self.idnum)

#-----------------------------
class TimeNumber:
    def __init__(self, hours, minutes, seconds):
        assert minutes < 60 and seconds < 60
        self.hours = hours
        self.minutes = minutes
        self.seconds = seconds
    def __str__(self):
        return "%d:%02d:%02d" % (self.hours, self.minutes, self.seconds)
    def __add__(self, other):
        seconds = self.seconds + other.seconds
        minutes = self.minutes + other.minutes
        hours = self.hours + other.hours
        if seconds >= 60:
            seconds %= 60
            minutes += 1
        if minutes >= 60:
            minutes %= 60
            hours += 1
        return TimeNumber(hours, minutes, seconds)

    def __sub__(self, other):
        raise NotImplementedError

    def __mul__(self, other):
        raise NotImplementedError

    def __div__(self, other):
        raise NotImplementedError

t1 = TimeNumber(0, 58, 59)
sec = TimeNumber(0, 0, 1)
min = TimeNumber(0, 1, 0)
print t1 + sec + min + min
# 1:01:00

#-----------------------------
#!/usr/bin/env python

import operator
class StrNum:
    def __init__(self, value):
        self.value = value

    def __cmp__(self, other):  # both <=> and cmp
        # providing <=> gives us <, ==, etc. for free.
        # (In Python 2.2 and newer <, > and == can be individually specified
        return cmp(self.value, other.value)

    def __str__(self, other):  # ""
        return self.value

    def __nonzero__(self, other):   # bool
        return operator.truth(self.value)

    def __int__(self, other):   # 0+
        return int(self.value)

    def __add__(self, other):   # +
        return StrNum(self.value + other.value)

    def __radd__(self, other):   # +, inverted
        return StrNum(other.value + self.value)

    def __mul__(self, other):   # *
        return StrNum(self.value * other)

    def __rmul__(self, other):   # *, inverted
        return StrNum(self.value * other)


def demo():
    # show_strnum - demo operator overloading
    x = StrNum("Red")
    y = StrNum("Black")
    z = x + y
    r = z * 3
    print "values are %s, %s, %s, and %s" % (x, y, z, r)
    if x < y:
        s = "LT"
    else:
        s = "GE"
    print x, "is", s, y

if __name__ == "__main__":
    demo()
# values are Red, Black, RedBlack, and RedBlackRedBlackRedBlack
# Red is GE Black

#-----------------------------
#!/usr/bin/env python
# demo_fixnum - show operator overloading

# sum of STRFixNum: 40 and STRFixNum: 12 is STRFixNum: 52
# product of STRFixNum: 40 and STRFixNum: 12 is STRFixNum: 480
# STRFixNum: 3 has 0 places
# div of STRFixNum: 40 by STRFixNum: 12 is STRFixNum: 3.33
# square of that is  STRFixNum: 11.11

# This isn't excatly the same as the original Perl code since
# I couldn't figure out why the PLACES variable was used.
#-----------------------------
import re
_places_re = re.compile(r"\.(\d+)")

default_places = 0

class FixNum:
    def __init__(self, value, places = None):
        self.value = value
        if places is None:
            # get from the value
            m = _places_re.search(str(value))
            if m:
                places = int(m.group(1))
            else:
                places = default_places
        self.places = places

    def __add__(self, other):
        return FixNum(self.value + other.value,
                      max(self.places, other.places))

    def __mul__(self, other):
        return FixNum(self.value * other.value,
                      max(self.places, other.places))

    def __div__(self, other):
        # Force to use floating point, since 2/3 in Python is 0
        # Don't use float() since that will convert strings
        return FixNum((self.value+0.0) / other.value,
                      max(self.places, other.places))

    def __str__(self):
        return "STR%s: %.*f" % (self.__class__.__name__,
                                self.places, self.value)
    def __int__(self):
        return int(self.value)

    def __float__(self):
        return self.value

def demo():
    x = FixNum(40)
    y = FixNum(12, 0)

    print "sum of", x, "and", y, "is", x+y
    print "product of", x, "and", y, "is", x*y

    z = x/y
    print "%s has %d places" % (z, z.places)
    if not z.places:
        z.places = 2

    print "div of", x, "by", y, "is", z
    print "square of that is ", z*z

if __name__ == "__main__":
    demo()


# ^^PLEAC^^_13.15
# I'm not sure what 'Tie's do in Perl.  Some of it looks like
# the ability to write dictionary-like data structures, but
# I'm not going to worry about it for now.
# @@INCOMPLETE@@
# @@INCOMPLETE@@


# @@PLEAC@@_14.8
# shelve uses anydbm to access and chooses between DBMs.
# anydbm detect file formats automatically.
import shelve
db = shelve.open("celebrities.db")

name1 = "Greg Stein"
name2 = "Greg Ward"

# shelve uses pickle to convert objects into strings and back.
# This is automatic.
db[name1] = ["of ViewCVS fame", "gstein@lyra.org"]
db[name2] = ["of Distutils fame", "gward@python.net"]

greg1 = db[name1]
greg2 = db[name2]

print "Two Gregs: %x %x" % (id(greg1), id(greg2))

if greg1 == greg2:
    print "You're having runtime fun with one Greg made two."
else:
    print "No two Gregs are ever alike."

# Changes to mutable entries are not written back by default.
# You can get the copy, change it, and put it back.
entry = db[name1]
entry[0] = "of Subversion fame"
db[name1] = entry

# Or you can open shelve with writeback option. Then you can
# change mutable entries directly. (New in 2.3)
db = shelve.open("celebrities.db", writeback=True)
db[name2][0] = "of Optik fame"

# However, writeback option can consume vast amounts of memory
# to do its magic. You can clear cache with sync().
db.sync()


# @@PLEAC@@_15.1
#-----------------------------
# Parsing program arguments
# -- getopt way (All Python versions)

#-----------------------------
# Preamble

import sys
import getopt

# getopt() explicitly receives arguments for it to process.
# No magic. Explicit is better than implicit.

# PERL: @ARGV
argv = sys.argv[1:]

# Note that sys.argv[0] is the script name, and need to be
# stripped.

#-----------------------------
# Short options

# PERL: getopt("vDo");
# Polluting the caller's namespace is evil. Don't do that.

# PERL: getopt("vDo:", \%opts);
opts, rest = getopt.getopt(argv, "vDo:")

# If you want switches to take arguments, you must say so.
# Unlike PERL, which silently performs its magic, switches
# specified without trailing colons are considered boolean
# flags by default.

# PERL: getopt("vDo", \%opts);
opts, rest = getopt.getopt(argv, "v:D:o:")

# PERL: getopts("vDo:", \%opts);
# getopt/getopts distinction is not present in Python 'getopt'
# module.

#-----------------------------
# getopt() return values, compared to PERL

# getopt() returns two values. The first is a list of
# (option, value) pair. (Not a dictionary, i.e. Python hash.)
# The second is the list of arguments left unprocessed.

# Example
# >>> argv = "-v ARG1 -D ARG2 -o ARG3".split()
# >>> opts, rest = getopt.getopt(argv, "v:D:o:")
# >>> print opts
# [('-v', 'ARG1'), ('-D', 'ARG2'), ('-o', 'ARG3')]

#-----------------------------
# Long options

# getopt() handles long options too. Pass a list of option
# names as the third argument. If an option takes an argument,
# append an equal sign.

opts, rest = getopt.getopt(argv, "", [
    "verbose", "Debug", "output="])

#-----------------------------
# Switch clustering

# getopt() does switch clustering just fine.

# Example
# >>> argv1 = '-r -f /tmp/testdir'.split()
# >>> argv2 = '-rf /tmp/testdir'.split()
# >>> print getopt.getopt(argv1, 'rf')
# ([('-r', ''), ('-f', '')], ['/tmp/testdir'])
# >>> print getopt.getopt(argv2, 'rf')
# ([('-r', ''), ('-f', '')], ['/tmp/testdir'])

#-----------------------------
# @@INCOMPLETE@@

# TODO: Complete this section using 'getopt'. Show how to
# use the parsed result.

# http://www.python.org/doc/current/lib/module-getopt.html
# Python library reference has a "typical usage" demo.

# TODO: Introduce 'optparse', a very powerful command line
# option parsing module. New in 2.3.

# @@PLEAC@@_15.6

# Show ASCII values for keypresses

# _Getch is from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/134892
class _Getch:
    """Gets a single character from standard input.  Does not echo to the
screen."""
    def __init__(self):
        try:
            self.impl = _GetchWindows()
        except ImportError:
            self.impl = _GetchUnix()

    def __call__(self):
        return self.impl()


class _GetchUnix:
    def __init__(self):
        import tty, sys

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch


class _GetchWindows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()


getch = _Getch()

print "Press keys to see their ASCII values.  Use Ctrl-C to quit.\n"
while (1):
    char = getch()
    char = ord(char)
    if char == 3:
        break
    print " Decimal: %3d   Octal: %3o   Hex: x%02x" % (char, char, char)

# @@PLEAC@@_15.13

#----------------------------------------
# This entry uses pexpect, a pure Python Expect-like module.
# http://pexpect.sourceforge.net/

# for more information, check pexpect's documentation and example.

import pexpect

#----------------------------------------
# spawn program
try:
    command = pexpect.spawn("program to run")
except pexpect.ExceptionPexpect:
    # couldn't spawn program
    pass

#----------------------------------------
# you can pass any filelike object to setlog
# passing None will stop logging

# stop logging
command.setlog(None)

# log to stdout
import sys
command.setlog(sys.stdout)

# log to specific file
fp = file("pexpect.log", "w")
command.setlog(fp)

#----------------------------------------
# expecting simple string
command.expect("ftp>")

# expecting regular expression
# actually, string is always treated as regular expression

# so it's the same thing
command.expect("Name.*:")

# you can do it this way, too
import re
regex = re.compile("Name.*:")
command.expect(regex)

#----------------------------------------
# expecting with timeout
try:
    command.expect("Password:", 10)
except pexpect.TIMEOUT:
    # timed out
    pass

# setting default timeout
command.timeout = 10

# since we set default timeout, following does same as above
try:
    command.expect("Password:")
except pexpect.TIMEOUT:
    # timed out
    pass

#----------------------------------------
# what? do you *really* want to wait forever?

#----------------------------------------
# sending line: normal way
command.sendline("get spam_and_ham")

# you can also treat it as file
print >>command, "get spam_and_ham"

#----------------------------------------
# finalization

# close connection with child process
# (that is, freeing file descriptor)
command.close()

# kill child process
import signal
command.kill(signal.SIGKILL)

#----------------------------------------
# expecting multiple choices
which = command.expect(["invalid", "success", "error", "boom"])

# return value is index of matched choice
# 0: invalid
# 1: success
# 2: error
# 3: boom

#----------------------------------------
# avoiding exception handling
choices = ["invalid", "success", "error", "boom"]
choices.append(pexpect.TIMEOUT)
choices.append(pexpect.EOF)

which = command.expect(choices)

# if TIMEOUT or EOF occurs, appropriate index is returned
# (instead of raising exception)
# 4: TIMEOUT
# 5: EOF

# @@PLEAC@@_15.17
# Start Python scripts without the annoying DOS window on win32
# Use extension ".pys":
# "foo.pyw" instead of "foo.py"


# @@PLEAC@@_16.1
import popen2

# other popen methods than popen4 can lead to deadlocks
# if there is much data on stdout and stderr

(err_out, stdin) = popen2.popen4("program args")
lines = err_out.read() # collect output into one multiline string

(err_out, stdin) = popen2.popen4("program args")
lines = err_out.readlines() # collect output into array, one line per element

#-----------------------------

(err_out, stdin) = popen2.popen4("program args")
output = []
while 1:
    line = err_out.readline()
    if not line:
        break
    output.appen(line)
output = ''.join(output)

# @@PLEAC@@_16.2
import os
myfile = "foo.txt"
status = os.system("vi %s" % myfile)

#-----------------------------
import os
import sys

os.system("cmd1 args | cmd2 | cmd3 >outfile")
os.system("cmd args <infile >outfile 2>errfile")

status = os.system("%s %s %s" % (program, arg1, arg2))
if status != 0:
    print "%s exited funny: %s" % (program, status)
    sys.exit()
    

# @@PLEAC@@_16.3
# -----------------------------
import os
import sys
import glob

args = glob.glob("*.data")
try:
    os.execvp("archive", args)
except OSError, e:
    print "Couldn't replace myself with archive: %s" % str(e)
    sys.exit()

# The error message does not contain the line number like the "die" in
# perl. But if you want to show more information for debuging, you can
# delete the try...except and you get a nice traceback which shows all
# line numbers and filenames.

# -----------------------------
os.execvp("archive", ["accounting.data"])

# @@PLEAC@@_16.4
# -------------------------
# Read from a child process

import sys
import popen2
pipe = popen2.Popen4("program arguments")
pid = pipe.pid
for line in pipe.fromchild.readlines():
    sys.stdout.write(line)

# Popen4 provides stdout and stderr.
# This avoids deadlocks if you get data
# from both streams.
#
# If you don't need the pid, you
# can use popen2.popen4(...)

# -----------------------------
# Write to a child process

import popen2

pipe = popen2.Popen4("gzip > foo.gz")
pid = pipe.pid
pipe.tochild.write("Hello zipped world!\n")
pipe.tochild.close() # programm will get EOF on STDIN

# @@PLEAC@@_16.6
# This script accepts several filenames
# as argument. If the file is zipped, unzip
# it first. Then read each line if the file
import os
import sys
import popen2

for file in sys.argv[1:]:
    if file.endswith(".gz") or file.endswith(".Z"):
        (stdout, stdin) = popen2.popen2("gzip -dc '%s'" % file)
        fd = stdout
    else:
        fd = open(file)
    for line in fd:
        # ....
        sys.stdout.write(line)
    fd.close()
#-----------------------------

#-----------------------------
# Ask for filename and open it
import sys
print "File, please?"
line = sys.stdin.readline()
file = line.strip() # chomp
open(file)

# @@PLEAC@@_16.7
# Execute foo_command and read the output

import popen2
(stdout_err, stdin) = popen2.popen4("foo_command")
for line in stdout_err.readlines():
    # ....

# @@PLEAC@@_16.8
# Open command in a pipe
# which reads from stdin and writes to stdout

import popen2
pipe = popen2.Popen4("wc -l") # Unix command
pipe.tochild.write("line 1\nline 2\nline 3\n")
pipe.tochild.close()
output = pipe.fromchild.read()

# @@PLEAC@@_16.9

# popen3: get stdout and stderr of new process
# Attetion: This can lead to deadlock,
# since the buffer of stderr or stdout might get filled.
# You need to use select if you want to avoid this.

import popen2
(child_stdout, child_stdin, child_stderr) = popen2.popen3(...)

# @@PLEAC@@_16.13
#
# Print avaibable signals an their value
# See "man signal" "man kill" on unix.

import signal
for name in dir(signal):
    if name.startswith("SIG"):
        value = getattr(signal, name)
        print "%s=%s" % (name, value)

# @@PLEAC@@_16.14
# You can send signals to processes
# with os.kill(pid, signal)


# @@PLEAC@@_16.15
import signal

def get_sig_quit(signum, frame):
    ....

signal.signal(signal.SIGQUIT, get_sig_quit)   # Install handler

signal.signal(signal.SIGINT, signal.SIG_IGN)  # Ignore this signal
signal.signal(signal.SIGSTOP, signal.SIG_DFL) # Restore to default handling

# @@PLEAC@@_16.16
# Example of handler: User must Enter Name ctrl-c does not help

import sys
import signal

def ding(signum, frame):
    print "\aEnter your name!"
    return

signal.signal(signal.SIGINT, ding)
print "Please enter your name:"

name = ""
while not name:
    try:
        name = sys.stdin.readline().strip()
    except:
        pass

print "Hello: %s" % name

# @@PLEAC@@_16.18
import signal

# ignore signal INT
signal.signal(signal.SIGINT, signal.SIG_IGN)

# Install signal handler
def tsktsk(signum, frame):
    print "..."

signal.signal(signal.SIGINT, tsktsk)

# @@PLEAC@@_16.21
import signal

def handler(signum, frame):
    raise "timeout"

signal.signal(signal.SIGALRM, handler)

try:
    signal.alarm(5) # signal.alarm(3600)

    # long-time operation
    while 1:
        print "foo"

    signal.alarm(0)
except:
    signal.alarm(0)
    print "timed out"
else:
    print "no time out"

# @@PLEAC@@_17.0
# Socket Programming (tcp/ip and udp/ip)

import socket

# Convert human readable form to 32 bit value
packed_ip = socket.inet_aton("208.146.240.1")
packed_ip = socket.inet_aton("www.oreilly.com")

# Convert 32 bit value to ip adress
ip_adress = socket.inet_ntoa(packed_ip)

# Create socket object
socketobj = socket(family, type) # Example socket.AF_INT, socket.SOCK_STREAM
       
# Get socketname
socketobj.getsockname() # Example, get port adress of client

# @@PLEAC@@_17.1

# Example: Connect to a server (tcp)
# Connect to a smtp server at localhost and send an email.
# For real applications you should use smtplib.

import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("localhost", 25)) # SMTP
print s.recv(1024)
s.send("mail from: <pleac@localhost>\n")
print s.recv(1024)
s.send("rcpt to: <guettli@localhost>\n")
print s.recv(1024)
s.send("data\n")
print s.recv(1024)
s.send("From: Python Lover\nSubject: Python is better then perl\n\nYES!\n.\n")
print s.recv(1024)
s.close()

# @@PLEAC@@_17.2

# Create a Server, calling handler for every client
# You can test it with "telnet localhost 1029"

from SocketServer import TCPServer
from SocketServer import BaseRequestHandler

class MyHandler(BaseRequestHandler):
    def handle(self):
        print "I got an request"
        
server = TCPServer(("127.0.0.1", 1029), MyHandler)
server.serve_forever()

# @@PLEAC@@_17.3
# This is the continuation of 17.2

import time
from SocketServer import TCPServer
from SocketServer import BaseRequestHandler

class MyHandler(BaseRequestHandler):
    def handle(self):
        # self.request is the socket object
        print "%s I got an request from ip=%s port=%s" % (
            time.strftime("%Y-%m-%d %H:%M:%S"),
            self.client_address[0],
            self.client_address[1]
            )
        self.request.send("What is your name?\n")
        bufsize=1024
        response=self.request.recv(bufsize).strip() # or recv(bufsize, flags)
        data_to_send="Welcome %s!\n" % response
        self.request.send(data_to_send) # or send(data, flags)
        print "%s connection finnished" % self.client_address[0]
        
server = TCPServer(("127.0.0.1", 1028), MyHandler)
server.serve_forever()

# -----------------
# Using select

import select
import socket

in_list = []
in_list.append(mysocket)
in_list.append(myfile)
# ...

out_list = []
out_list.append(...)

except_list = []
except_list.append(...)

(in_, out_, exc_) = select.select(in_list, out_list, except_list, timeout)

for fd in in_:
    print "Can read", fd
for fd in out_:
    print "Can write", fd
for fd in exc_:
    print "Exception on", fd

# Missing: setting TCP_NODELAY

# @@PLEAC@@_17.17

# chroot

import os
import sys

try:
    os.chroot("/var/daemon")
except:
    print "Could not chroot"
    sys.exit(1)

#-----------------------------
# fork (Unix): Create a new process
# if pid == 0 --> parent process
# else child process

import os
import sys

pid = os.fork()
if pid:
    print "I am the new child %s" % pid
    sys.exit()
else:
    print "I am still the parent"
    

# ----------------------------
# setsid (Unix): Create a new session
import os
id=os.setsid()

# ----------------------------
# Work until INT TERM or HUP signal is received
import time
import signal

time_to_die = 0

def sighandler(signum, frame):
    print "time to die"
    global time_to_die
    time_to_die = 1

signal.signal(signal.SIGINT, sighandler)
signal.signal(signal.SIGTERM, sighandler)
signal.signal(signal.SIGHUP, sighandler)

while not time_to_die:
    print "work"
    time.sleep(1)

# @@PLEAC@@_17.16
#------------------------------
# Restart programm on signal SIGHUP
# Script must be executable: chmod a+x foo.py

#!/usr/bin/env python
import os
import sys
import time
import signal

def phoenix(signum, frame):
    print "Restarting myself: %s %s" % (self, args)
    os.execv(self, args)

self = os.path.abspath(sys.argv[0])
args = sys.argv[:]
signal.signal(signal.SIGHUP, phoenix)

while 1:
    print "work"
    time.sleep(1)

#--------------------
# Read config file on SIGHUP
import signal

config_file = "/usr/local/etc/myprog/server_conf.py"

def read_config():
    execfile(config_file)

signal.signal(signal.SIGHUP, read_config)

# @@PLEAC@@_18.2
import ftplib
ftp = ftplib.FTP("ftp.host.com")
ftp.login(username, password)
ftp.cwd(directory)

# get file
outfile = open(filename, "wb")
ftp.retrbinary("RETR %s" % filename, outfile.write)
outfile.close()

# upload file
upfile = open(upfilename, "rb")
ftp.storbinary("STOR %s" % upfilename, upfile)
upfile.close()

ftp.quit()


# @@PLEAC@@_18.3
import smtplib
from email.MIMEText import MIMEText

msg = MIMEText(body)
msg['From'] = from_address
msg['To'] = to_address
msg['Subject'] = subject

mailer = smtplib.SMTP()
mailer.connect()
mailer.sendmail(from_address, [to_address], msg.as_string())

# @@PLEAC@@_18.4
import nntplib

# You can except nntplib.NNTPError to process errors
# instead of displaying traceback.

server = nntplib.NNTP("news.example.com")
response, count, first, last, name = server.group("misc.test")
headers = server.head(first)
bodytext = server.body(first)
article = server.article(first)

f = file("article.txt")
server.post(f)

response, grouplist = server.list()
for group in grouplist:
    name, last, first, flag = group
    if flag == 'y':
        pass  # I can post to group

# @@PLEAC@@_18.5
import poplib

pop = poplib.POP3("mail.example.com")
pop.user(username)
pop.pass_(password)
count, size = pop.stat()
for i in range(1, count+1):
    reponse, message, octets = pop.retr(i)
    # message is a list of lines
    pop.dele(i)

# You must quit, otherwise mailbox remains locked.
pop.quit()


# @@PLEAC@@_19.1
# Partial implementation of PLEAC Python section 19.1
# Written by Seo Sanghyeon

# Standard CGI module is where PERL shines. Python
# module, cgi, is nothing but a form parser. So it is
# not really fair to compare these two. But I hesitate
# to introduce any non-standard module. After all,
# which one should I choose?

# I would stick to simple print statements. I believe
# the following is close to how these tasks are usually
# done in Python.

#-----------------------------
#!/usr/bin/env python
# hiweb - using FieldStorage class to get at form data

import cgi
form = cgi.FieldStorage()

# get a value from the form
value = form.getvalue("PARAM_NAME")

# print a standard header
print "Content-Type: text/html"
print

# print a document
print "<P>You typed: <TT>%s</TT></P>" % (
    cgi.escape(value),
    )

#-----------------------------
import cgi
form = cgi.FieldStorage()

who = form.getvalue("Name")
phone = form.getvalue("Number")
picks = form.getvalue("Choices")

# if you want to assure `picks' to be a list
picks = form.getlist("Choices")

#-----------------------------
# Not Implemented

# To implement -EXPIRES => '+3d', I need to study about
# Python date/time handling. `datetime' is a standard
# module, new in 2.3. Before that, there was de-facto
# standard module, `mxDateTime', which is very specialized
# and still richer than `datetime'. There's also low-level
# `time' module, which is kinda wrapper around C API.
# I think I need to mention all of these.

# Anyway, by the time I can implement this, I would be
# able to fill entire PLEAC section 3, "Dates and Times".
# *grin*

#-----------------------------
# NOTES

# CGI::param() is a multi-purpose function. Here I want to
# note which Python functions correspond to it.

# PERL version 5.6.1, CGI.pm version 2.80.
# Python version 2.2.3. cgi.py CVS revision 1.68.

# Assume that `form' is the FieldStorage instance.

# param() with zero argument returns parameter names as
# a list. It is `form.keys()' in Python, following Python's
# usual mapping interface.

# param() with one argument returns the value of the named
# parameter. It is `form.getvalue()', but there are some
# twists:

# 1) A single value is passed.
# No problem.

# 2) Multiple values are passed.
# PERL: in LIST context, you get a list. in SCALAR context,
#       you get the first value from the list.
# Python: `form.getvalue()' returns a list if multiple
#         values are passed, a raw value if a single value
#         is passed. With `form.getlist()', you always
#         get a list. (When a single value is passed, you
#         get a list with one element.) With `form.getfirst()',
#         you always get a value. (When multiple values are
#         passed, you get the first one.)

# 3) Parameter name is given, but no value is passed.
# PERL: returns an empty string, not undef. POD says this
#       feature is new in 2.63, and was introduced to avoid
#       "undefined value" warnings when running with the
#       -w switch.
# Python: tricky. If you want black values to be retained,
#         you should pass a nonzero `keep_blank_values' keyword
#         argument. Default is not to retain blanks. In case
#         values are not retained, see below.

# 4) Even parameter name is never mentioned.
# PERL: returns undef.
# Python: returns None, or whatever you passed as the second
#         argument, or `default` keyword argument. This is
#         consistent with `get()' method of the Python mapping
#         interface.

# param() with more than one argument modifies the already
# set form data. This functionality is not available in Python
# cgi module.


# @@PLEAC@@_19.2
# enable() from 'cgitb' module, by default, redirects traceback
# to the browser. It is defined as 'enable(display=True, logdir=None,
# context=5)'.

# equivalent to importing CGI::Carp::fatalsToBrowser.
import cgitb
cgitb.enable()

# to suppress browser output, you should explicitly say so.
import cgitb
cgitb.enable(display=False)

# equivalent to call CGI::Carp::carpout with temporary files.
import cgitb
cgitb.enable(logdir="/var/local/cgi-logs/")

# Python exception, traceback facilities are much richer than PERL's
# die and its friends. You can use your custom exception formatter
# by replacing sys.excepthook. (equivalent to CGI::Carp::set_message.)
# Default formatter is available as traceback.print_exc() in pure
# Python. In fact, what cgitb.enable() does is replacing excepthook
# to cgitb.handler(), which knows how to format exceptions to HTML.

# If this is not enough, (usually this is enough!) Python 2.3 comes
# with a new standard module called 'logging', which is complex, but
# very flexible and entirely customizable.


# @@PLEAC@@_20.1
import urllib
content = urllib.urlopen(url).read()

try:
    import urllib
    content = urllib.urlopen(url).read()
except IOError:
    print "could not get %s" % url
# @@INCOMPLETE@@

# @@PLEAC@@_20.2
import urllib
params = urllib.urlencode({'module': 'DB_File', 'readme': 1})
content = urllib.urlopen(url, params).read()

urllib.urlopen(url, proxies={'http': 'http://proxy.example.com:8080'})
# @@INCOMPLETE@@


# @@PLEAC@@_20.5
# Converting HTML to ASCII

#-----------------------------
import os
ascii = os.popen("lynx -dump " + filename).read()

#-----------------------------
import formatter
import htmllib

w = formatter.DumbWriter()
f = formatter.AbstractFormatter(w)
p = htmllib.HTMLParser(f)
p.feed(html)
p.close()

# Above is a bare minimum to use writer/formatter/parser
# framework of Python.

# Search Python Cookbook for more details, like writing
# your own writers or formatters.

# Recipe #52297 has TtyFormatter, formatting underline
# and bold in Terminal. Recipe #135005 has a writer
# accumulating text instead of printing.
