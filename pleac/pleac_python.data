 # -*- python -*-

# @@PLEAC@@_NAME
Python

# @@PLEAC@@_WEB
http://www.python.org


# @@PLEAC@@_1.0
string = r'\n'                          # two characters, \ and an n
string = r'Jon \'Maddog\' Orwant'       # literal single quotes

string = "\n"                           # a "newline" character
string = "Jon \"Maddog\" Orwant"        # literal double quotes

string = "Jon 'Maddog' Orwant"          # literal single quotes

string = '''Jon 'Maddog' Orwant'''      # literal single quotes
string = """Jon 'Maddog' Orwant"""      # literal single quotes

a = """
This is a multiline here document
terminated by triple double quote
"""

# @@PLEAC@@_1.1

s = "This is what you have"
first = s[0]                            # "T"
start = s[5:7]                          # "is"
rest  = s[13:]                          # "you have"
last  = s[-1]                           # "e"
end   = s[-4:]                          # "have"
piece = s[-8:-5]                        # "you"

# can't modify string, if really needed use character arrays:
import array
s = array.array("c", "This is what you have")
s[5:7] = array.array("c", "wasn't")
# s now is array('c', "This wasn't what you have")

# @@PLEAC@@_1.2
a = b or c

# @@PLEAC@@_1.3
v1, v2 = v2, v1

alpha, beta, production = "January March August".split()
alpha, beta, production = beta, production, alpha

# @@PLEAC@@_1.4
num = ord(char)
char = chr(num)

char = "%" % num
print "Number %d is character %c\n" % (num, num)

print "Number %(n)d is character %(n)c\n" % {"n": num }

from string import *
hal = "HAL"
ibm = join(map(lambda i: chr(ord(i)+1), hal), "")
print ibm


# @@PLEAC@@_1.5
for b in string:
    pass # do something with b

string = "an apple a day"
d = {}
for i in string: d[i] = 1
l = d.keys()
l.sort()
print "unique chars are: ", join(l)

sum = 0
for i in ascval: sum += ord(i)
print "sum is ", sum


# @@PLEAC@@_1.6
l = list(string)
l.reverse()
revbytes = "".join(l)

l = split(string)
l.reverse()
revwords = join(l)

def rev_string(s):
    l = list(s)
    l.reverse()
    return "".join(l)

long_palindromes = filter(lambda word: len(word) > 5 and rev_string(word) == word,
             map(rstrip, open("/usr/share/dict/words").readlines()))

# @@PLEAC@@_1.7
string.expandtabs()

# @@PLEAC@@_1.8
sub("\d+", lambda i: str(2 * int(i.group(0))), "I am 17 years old")

# @@PLEAC@@_1.9
e = "bo peep".upper()
e = e.lower()
e = e.capitalize()

sub("\w+", lambda i: i.group(0).capitalize(), "thIS is a loNG liNE")

# @@PLEAC@@_1.10
"I have %d guanacos." % (n + 1)
print "I have", n+1, "guanacos."


# @@PLEAC@@_1.12
string = "Folding and splicing is the work of an editor,\n" + \
    "not a mere collection of silicon\n" + \
    "and\n" + \
    "mobile electrons!"

def wrap(str, max_size):
    all = []
    line = ""
    for l in str.split():
        if len(line+l) >= max_size:
            all += [line]
            line = ''
        line += l + ' '
    return "\n".join(all + [line])

print wrap(string, 20)


# @@PLEAC@@_1.13
string = '''Mom said, "Don't do that."'''  #"
sub("['\"]", lambda i: "\\" + i.group(0), string)
sub("[A-Z]", lambda i: "\\" + i.group(0), string)
sub("\W", lambda i: "\\" + i.group(0), "is a test!") # no function like quotemeta?


# @@PLEAC@@_1.14
string = string.strip


# @@PLEAC@@_1.15
from re import *
from string import *

def parse_csv(text):
    l = map(lambda i: join(i, ''), findall('''"([^"\\\]*(?:\\\.[^"\\\]*)*)",?|([^,]+),?|,''', text))
    if text[-1] == ",": l += ['']
    return l

line = '''XYZZY,"","O'Reilly, Inc","Wall, Larry","a \\"glug\\" bit,",5,,"Error,, Core Dumped,",''' #"

fields = parse_csv(line)
for i in range(len(fields)):
    print "%d : %s" % (i, fields[i])

# @@PLEAC@@_1.17
import sys, fileinput, re

data = """\
analysed        => analyzed
built-in        => builtin
chastized       => chastised
commandline     => command-line
de-allocate     => deallocate
dropin          => drop-in
hardcode        => hard-code
meta-data       => metadata
multicharacter  => multi-character
multiway        => multi-way
non-empty       => nonempty
non-profit      => nonprofit
non-trappable   => nontrappable
pre-define      => predefine
preextend       => pre-extend
re-compiling    => recompiling
reenter         => re-enter
turnkey         => turn-key
"""
dict = {}
for line in data.split("\n"):
    if not line.strip():
        continue
    k, v = [word.strip() for word in line.split("=>")]
    dict[k] = v
pattern_text = "(" + "|".join([re.escape(word) for word in dict.keys()]) + ")"
pattern = re.compile(pattern_text)

args = sys.argv[1:]
verbose = 0
if args and args[0] == "-v":
    verbose = 1
    args = args[1:]

if not args:
    sys.stderr.write("%s: Reading from stdin\n" % sys.argv[0])

for line in fileinput.input(args, inplace = 1, backup = ".orig"):
    output = ""
    pos = 0
    while 1:
        match = pattern.search(line, pos)
        if not match:
            output += line[pos:]
            break
        output += line[pos:match.start(0)] + dict[match.group(1)]
        pos = match.end(0)
    sys.stdout.write(output)


# @@PLEAC@@_2.1
if match("[+-]?\d+$", string):
    print 'is an integer'
else:
    print 'is not'


if match("-?(?:\d+(?:\.\d*)?|\.\d+)$", string):
    print 'is a decimal number'
else:
    print 'is not'


# @@PLEAC@@_2.2
# equal(num1, num2, accuracy) : returns true if num1 and num2 are
#   equal to accuracy number of decimal places
def equal(i, j, a):
    i - j < 10. ** -a

wage = 536                        # $5.36/hour
week = 40 * wage                  # $214.40
print "One week's wage is: $%.2f" % (week/100.0)


# @@PLEAC@@_2.3
round(num)                              # rounds to integer

a = 0.255
b = "%.2f" % a
print "Unrounded: %f\nRounded: %s" % (a, b)
print "Unrounded: %f\nRounded: %.2f" % (a, a)

from math import *

print "number\tint\tfloor\tceil"
a = [ 3.3 , 3.5 , 3.7, -3.3 ]
for n in a:
    print "% .1f\t% .1f\t% .1f\t% .1f" % (n, int(n), floor(n), ceil(n))

# @@PLEAC@@_2.5
for i in range(x,y):
    pass # i is set to every integer from x to y, exclusive

for i in range(x, y, 7):
    pass # i is set to every integer from x to y, stepsize = 7

print "Infancy is: "
for i in range(0,3):
    print i, " "
print "\n"


# @@PLEAC@@_2.7
from whrandom import *
random = uniform(x, y)


# TODO
#chars = ["A".."Z","a".."z","0".."9"].collect { |r| r.to_a }.join + %q(!@$%^&*)
#password = (1..8).collect { chars[rand(chars.size)] }.pack("C*")


# @@PLEAC@@_2.8
seed        # uses a combination of the time, the process id, and a sequence number
seed(val)   # for repeatable behaviour

# @@PLEAC@@_2.16
print "%(num)d %(num)x %(num)o\n" % { "num": num }

# @@PLEAC@@_4.0
#-----------------------------
nested = ["this", "that", "the", "other"]
#-----------------------------
tune = ["The", "Star-Spangled", "Banner"]
#-----------------------------

# @@PLEAC@@_4.1
a = ["quick", "brown", "fox"]
a = " ".split("Why are you teasing me?")

text = """
    The boy stood on the burning deck,
    It was as hot as glass.
"""
lines = [line.lstrip() for line in text.strip().split("\n")]
#-----------------------------
bigarray = [line.rstrip() for line in open("mydatafile")] # Python 2.2
bigarray = [line.rstrip() for line in open("mydatafile").readlines()]
#-----------------------------
banner = "The Mines of Moria"
banner = 'The Mines of Moria'
#-----------------------------
name = "Gandalf"
banner = "Speak, " + name + ", and enter!"
banner = "Speak, %s, and welcome!" % name
#-----------------------------
his_host = "www.python.org"
import os
host_info = os.popen("nslookup " + his_host).read()

# NOTE: not really relevant to Python (no magic '$$' variable)
python_info = os.popen("ps %d" % os.getpid()).read()
shell_info = os.popen("ps $$").read()
#-----------------------------
# NOTE: not really relevant to Python (no automatic interpolation)
banner = ["Costs", "only", "$4.95"]
banner = "Costs only $4.95".split()
#-----------------------------
brax   = """ ' " ( ) < > { } [ ] """.split()
rings  = '''They're  "Nenya Narya Vilya"'''.split()    #"
tags   = 'LI TABLE TR TD A IMG H1 P'.split()
sample = r'The backslash (\) is often used in regular expressions.'.split()

#-----------------------------
banner = "The backslash (\\) is often used in regular expressions.".split()
#-----------------------------
ships  = u"Niña Pinta Santa María".split()          # WRONG (only three ships)
ships  = [u"Niña", u"Pinta", u"Santa María"]        # right
#-----------------------------

# @@PLEAC@@_4.2
def commify_series(args):
    if len(args) == 0: return ""
    if len(args) == 1: return args[0]
    if len(args) == 2: return args[0] + " and " + args[1]
    return ", ".join(args[:-1]) + " and " + args[-1]

commify_series([])
commify_series(["red"])
commify_series(["red", "yellow"])
commify_series(["red", "yellow", "green"])
#-----------------------------
array = ["red", "yellow", "green"]
print "I have", array, "marbles."
print "I have", " ".join(array), "marbles."
#>I have ['red', 'yellow', 'green'] marbles.
#>I have red yellow green marbles.

#-----------------------------
#!/usr/bin/env python
# commify_series - show proper comma insertion in list output

data = (
    ( 'just one thing', ),
    ( 'Mutt Jeff'.split() ),
    ( 'Peter Paul Mary'.split() ),
    ( 'To our parents', 'Mother Theresa', 'God' ),
    ( 'pastrami', 'ham and cheese', 'peanut butter and jelly', 'tuna' ),
    ( 'recycle tired, old phrases', 'ponder big, happy thoughts' ),
    ( 'recycle tired, old phrases',
      'ponder big, happy thoughts',
      'sleep and dream peacefully' ),
    )
def commify_series(terms):
    sepchar = ","
    for term in terms:
        if "," in term:
            sepchar = ";"
            break
    if len(terms) == 0: return ""
    if len(terms) == 1: return terms[0]
    if len(terms) == 2: return " and ".join(terms)
    return (sepchar + " ").join(terms[:-1]) + " and " + terms[-1]

for item in data:
    print "The list is: %s." % commify_series(item)

# The list is: just one thing.
# The list is: Mutt and Jeff.
# The list is: Peter, Paul, and Mary.
# The list is: To our parents, Mother Theresa, and God.
# The list is: pastrami, ham and cheese, peanut butter and jelly, and tuna.
# The list is: recycle tired, old phrases and ponder big, happy thoughts.
# The list is: recycle tired, old phrases; ponder big, happy thoughts; and
#    sleep and dream peacefully.

#-----------------------------

# @@PLEAC@@_4.3
ARRAY = ARRAY[:SIZE] # shrink ARRAY
ARRAY += [None] * SIZE # grow ARRAY by appending 'SIZE' None elements
#-----------------------------
def what_about_that_array(terms):
    print "The list now has", len(terms), "elements."
    print "The index of the last element is", len(terms)-1, "(or -1)."
    print "Element #3 is %s." % terms[3]

people = "Crosby Stills Nash Young".split()
what_about_that_array(people)
#-----------------------------
#>The list now has 4 elements.
#>The index of the last element is 3 (or -1).
#>Element #3 is Young.
#-----------------------------
people.pop()
what_about_that_array(people)
#-----------------------------
# NOTE: Python raises an exception when trying to access an
# out of range value.
#>>> people.pop()
#'Young'
#>>> what_about_that_array(people)
#The list now has 3 elements.
#The index of the last element is 2 (or -1).
#Traceback (most recent call last):
#  File "<stdin>", line 1, in ?
#  File "<stdin>", line 4, in what_about_that_array
#IndexError: list index out of range
#>>>
#-----------------------------
people += [None] * (10000 - len(people))
#-----------------------------
#>>> people += [None] * (10000 - len(people))
#>>> what_about_that_array(people)
#The list now has 10000 elements.
#The index of the last element is 9999 (or -1).
#Element #3 is None.
#-----------------------------

# @@PLEAC@@_4.4
for item in LIST:
    pass # do something with item
#-----------------------------
for user in bad_users:
    complain(user)
#-----------------------------
import os
keys = os.environ.keys()
keys.sort()
for key in keys:
    print "%s=%s" % (key, os.environ[key])
#-----------------------------
for user in all_users:
    disk_space = get_usage(user);   # find out how much disk space in use
    if disk_space > MAX_QUOTA:      # if it's more than we want ...
        complain(user)              # ... then object vociferously
#-----------------------------
import os
for line in os.popen("who").readlines():
    if line.find("dalke") != -1:
        print line, # or print line[:-1]

# NOTE: alternate form, and using Python 2.2 code
import os
print "".join([line for line in os.popen("who")
                   if line.find("dalke") != -1]),

#-----------------------------
while 1:
    line = file.readline()
    if not line:
        break
    for word in line.split(): # Split on whitespace
        chars = list(word)    # Turn the string into a list of characters
        chars.reverse()
        print "".join(chars),
    print
#-----------------------------
for item in array:
    print "i =", item
#-----------------------------
# NOTE: you can't modify in place the way Perl does
data = [1, 2, 3]
data = [i-1 for i in data]
print data
#>[0, 1, 2]

# or
for i in range(len(data)):
    data[i] = data[i] - 1

#-----------------------------
# NOTE: strings are immutable in Python so this doesn't translate well.
s = s.strip()
data = [s.strip() for s in data]
for k, v in dict.items():
    dict[k] = v.strip()
#-----------------------------

# @@PLEAC@@_4.5
fruits = ["Apple", "Blackberry"]
for fruit in fruits:
    print fruit, "tastes good in a pie."
#>Apple tastes good in a pie.
#>Blackberry tastes good in a pie.
#-----------------------------
for i in range(len(fruits)):
    print fruits[i], "tastes good in a pie."
#-----------------------------
rogue_cats = ["Morris", "Felix"]
namelist = { "felines": rogue_cats }
for cat in namelist["felines"]:
    print cat, "purrs hypnotically.."

print "--More--\nYou are controlled."

#-----------------------------
for i in range(len(namelist["felines"])):
    print namelist["felines"][i], "purrs hypnotically."

#-----------------------------

# @@PLEAC@@_4.6
seen = {}
uniq = []
for item in LIST:
    if not seen.has_key(item):
        seen[item] = 1
        uniq.append(item)

for item in LIST:
    # in Python 2.2
    if item not in seen:    
        seen[item] = 1
        uniq.append(item)

#-----------------------------
seen = {}
uniq = []
for item in LIST:
    count = seen.get(item, 0)
    if count == 0:
        uniq.append(item)
    seen[item] = count + 1
#-----------------------------
seen = {}
for item in LIST:
    seen[item] = seen.get(item, 0) + 1

uniq = seen.keys()
#-----------------------------
# NOTE: It's a bad idea to use this in real code, since the previous
# example is easier to understand and common.
seen = {}
uniqu = [item for item in list
    if not seen.setdefault(item, []) and seen[item].append(1) is None]

#-----------------------------
# generate a list of users logged in, removing duplicates
import os
ucnt = {}
for line in os.popen("who").readlines():
    username = line.split()[0]  # Get the first word
    ucnt[username] = ucnt.get(username, 0) + 1 # record the users' presence

# extract and print unique keys
users = ucnt.keys()
users.sort()
print "users logged in:", " ".join(users)
#-----------------------------


# @@PLEAC@@_4.7
# assume A and B are already loaded
seen = {}                 # lookup table to test membership of B
aonly = []                # answer

# build lookup table
for item in B:
    seen[item] = 1

# find only elements in A and not in B
for item in A:
    if not seen.has_key(item):
        # it's not in 'seen', so add to 'aonly'
        aonly.append(item)
#-----------------------------
seen = {}   # lookup table
aonly = []  # answer

# build lookup table - NOTE: this is poor Python style
[seen.update({x: 1}) for x in B]

aonly = [item for item in A if not seen.has_key(item)]

#-----------------------------
seen = {}
aonly = []
for item in A:
    if not seen.has_key(item):
        aonly.append(item)
    seen[item] = 1                    # mark as seen
#-----------------------------
dict["key1"] = 1
dict["key2"] = 2
#-----------------------------
dict[("key1", "key2")] = (1,2)
#-----------------------------
seen = {}
for term in B:
    seen[term] = None
#-----------------------------
seen = {}
for k, v in B:
    seen[k] = 1
#-----------------------------

# @@PLEAC@@_4.8
# NOTE: using a tuple instead of a list.  There isn't much
# difference between them for all of these examples.
a = (1, 3, 5, 6, 7, 8)
b = (2, 3, 5, 7, 9)

union_list = []; isect_list = []; diff = []
union_dict = {}; isect_dict = {}
count = {}
#-----------------------------
for e in a:
    union_dict[e] = 1

for e in b:
    if union_dict.has_key(e):
        isect_dict[e] = 1
    union_dict[e] = 1

union_list = union_dict.keys()
isect_list = isect_dict.keys()
#-----------------------------
for e in a + b:
    if union.get(e, 0) == 0:
        isect[e] = 1
    union[e] = 1

union = union.keys()
isect = isect.keys()
#-----------------------------
count = {}
for e in a + b:
    count[e] = count.get(e, 0) + 1

union = []; isect = []; diff = []

for e in count.keys():
    union.append(e)
    if count[e] == 2:
        isect.append(e)
    else:
        diff.append(e)
#-----------------------------
isect = []; diff = []; union = []
count = {}
for e in a + b:
    count[e] = count.get(e, 0) + 1

for e, num in count.items():
    union.append(e)
    [None, diff, isect][num].append(e)

#-----------------------------

# @@PLEAC@@_4.9
# "append" for a single term and
# "extend" for many terms
ARRAY1.extend(ARRAY2)
#-----------------------------
ARRAY1 = ARRAY1 + ARRAY2
#-----------------------------
members = ["Time", "Flies"]
initiates = ["An", "Arrow"]
members.extend(initiates)
# members is now ["Time", "Flies", "An", "Arrow"]
#-----------------------------
members[2:] = ["Like"] + initiates
print " ".join(members)
members[:1] = ["Fruit"]
members[-2:] = ["A", "Banana"]
print " ".join(members)
#-----------------------------
#>Time Flies Like An Arrow
#>
#>Fruit Flies Like A Banana
#-----------------------------

# @@PLEAC@@_4.10
# reverse ARRAY into REVERSED
REVERSED = ARRAY[:]    # one level deep copy
REVERSED.reverse()
#-----------------------------
for i in range(len(ARRAY)-1, -1, -1):
    pass # do something with ARRAY[i]

#-----------------------------
descending = users[:]
descending.sort()
descending.reverse()
#-----------------------------
# sort with reverse comparison
descending = users[:]
descending.sort(lambda x, y: cmp(y, x))
#-----------------------------

# @@PLEAC@@_4.11
# remove N elements from front of ARRAY
ARRAY[:N] = []

# remove N elements from front of ARRAY, saving them into FRONT
FRONT, ARRAY[:N] = ARRAY[:N], []

# remove N elements from the end of the array
ARRAY[-N:] = []

# remove $N elements from the end of the array, saving them in END
END, ARRAY[-N:] = ARRAY[-N:], []

#-----------------------------
def shift2(terms):
    front = terms[:2]
    terms[:2] = []
    return front

def pop2(terms):
    back = terms[-2:]
    terms[-2:] = []
    return back

#-----------------------------
friends = "Peter Paul Mary Jim Tim".split()
this, that = shift2(friends)
# 'this' contains Peter, 'that' has Paul, and
# 'friends' has Mary, Jim, and Tim

beverages = "Dew Jolt Cola Sprite Fresca".split()
pair = pop2(beverages)
# pair[0] contains Sprite, pair[1] has Fresca,
# and 'beverages' has (Dew, Jolt, Cola)
#-----------------------------

# @@PLEAC@@_4.12
match = found = item = None
for item in array:
    if criterion:
        match = item  # must save
        found = 1
        break
if found:
    pass ## do something with 'match'
else:
    pass ## unfound

#-----------------------------
match_idx = None
for i in range(len(array)):
    if criterion:
        match_idx = i    # save the index
        break

if match_idx is not None:
    pass ## found in array[match_idx]
else:
    pass ## unfound
#-----------------------------
# NOTE: I can't see why this is useful either - why's this the highest paid?
for employee in employees:
    if employee.category == 'engineer':
        highest_engineer = employee
        break

print "Highest paid engineer is:", highest_engineer.name
#-----------------------------
for i in range(len(ARRAY)):
    if criterion:
        break

if i < len(ARRAY):
    pass ## found and 'i' is the index
else:
    pass ## not found

#-----------------------------


# @@PLEAC@@_4.13
MATCHING = [term for term in LIST if TEST(term)]
#-----------------------------
MATCHING = filter(TEST, LIST)
#-----------------------------
matching = []
for term in list:
    if TEST(term):
        matching.append(term)
#-----------------------------
bigs = [num for num in nums if num > 1000000]
pigs = [user for user in users.keys() if users[user] > 1e7]
#-----------------------------
import os
matching = filter(lambda s: s.startswith("gnat "),
                  os.popen("who").readlines())
#-----------------------------
engineers = [employee for employee in employees
                            if employee.position == "Engineer"]
#-----------------------------
secondary_assistance = [applicant for applicant in applicants
                             if 26000 <= applicant.income < 30000]
#-----------------------------



# @@PLEAC@@_4.14
LIST.sort()
#-----------------------------
# pids is an unsorted array of process IDs
import os, signal, time
pids.sort()
for pid in pids:
    print pid

pid = raw_input("Select a process ID to kill: ")
try:
    pid = int(pid)
except ValueError:
    raise SystemExit("Exiting ... ")
os.kill(pid, signal.SIGTERM)
time.sleep(2)
try:
  os.kill(pid, signal.SIGKILL)
except OSError, err:
  if err.errno != 3:  # was it already killed?
      raise
#-----------------------------
descending = unsorted[:]
descending.sort(lambda x, y: cmp(y, x))
#-----------------------------
def revnum(a, b):
    return cmp(b, a)

all = [4, 19, 8, 3]
all.sort(revnum)

#-----------------------------
all = [4, 19, 8, 3]
all.sort(lambda x, y: -cmp(x, y))
#-----------------------------


# @@PLEAC@@_4.15
ordered = unordered[:]
ordered.sort(compare())
#-----------------------------
precomputed = [(compute(x), x) for x in unordered]
precomputed.sort(lambda a, b: cmp(a[0], b[0]))
ordered = [v for k,v in precomputed.items()]
#-----------------------------
def functional_sort(l, function):
    l.sort(function)
    return l

ordered = [v for k,v in functional_sort([(compute(x), x) for x in unordered],
                                        lambda a, b: cmp(a[0], b[0]))]

#-----------------------------
ordered = employees[:]
ordered.sort(lambda a, b: cmp(a.name, b.name))
#-----------------------------
terms = employees[:]
terms.sort(lambda a, b: cmp(a.name, b.name))
for employee in terms:
    print employee.name, "earns", "$%s" % employee.salary
#-----------------------------
sorted_employees = employees[:]
sorted_employees.sort(lambda a, b: cmp(a.name, b.name))
for employee in sorted_employees:
    print employee.name, "earns", "$%s" % employee.salary

# load bonus
for employee in sorted_employees:
    if bonus(employee.ssn):
        print employee.name, "got a bonus!"
#-----------------------------
sorted = employees[:]
sorted.sort(lambda a, b: cmp(a.name, b.name) or cmp(b.age, a.age))
#-----------------------------
# NOTE: Python should allow access to the pwd fields by name
# as well as by position.
import pwd
# fetch all users
users = pwd.getpwall()
users.sort(lambda a, b: cmp(a[0], b[0]))
for user in users:
    print user[0]

#-----------------------------
sorted = names[:]
sorted.sort(lambda a, b: cmp(a[:1], b[:1]))
#-----------------------------
sorted = strings[:]
sorted.sort(lambda a, b: cmp(len(a), len(b)))
#-----------------------------
temp = [(len(s), s) for s in strings]
temp.sort(lambda a, b: cmp(a[0], b[0]))
sorted = [x[1] for x in temp]
#-----------------------------
def functional_sort(l, function):
    l.sort(function)
    return l

sorted_fields = [v for k,v in functional_sort(
              [(int(re.search(r"(\d+)", x).group(1)), x) for x in fields],
                                   lambda a, b: cmp(a[0], b[0]))]
#-----------------------------
entries = []
for line in open("/etc/passwd").readlines():
    line = line[:-1]
    terms = line.split(":")
    entries.append( (int(terms[3]), int(terms[2]), terms[0], line) )

entries.sort()

for entry in entries:
    print entry[-1]
#-----------------------------


# @@PLEAC@@_4.16
import time
class Circular:
    def __init__(self, data):
        assert len(data) >= 1, "Cannot use an empty list"
        self.data = data
    def next(self):
        head = self.data[0]
        self.data[:1] = []
        self.data.append(head)
        return head

circular = Circular([1, 2, 3, 4, 5])
while 1:
    process = circular.next()
    print "Handling process", process
    time.sleep(1)

# @@PLEAC@@_4.17
# generate a random permutation of ARRAY in place
import random
random.shuffle(ARRAY)

# @@PLEAC@@_4.18
import sys

# subroutine to check whether at last item on line
def EOL(item):
    return (item+1) % cols == 0

# Might not be portable to non-linux systems
def getwinsize():
    # Use the curses module if installed
    try:
        import curses
        stdscr = curses.initscr()
        rows, cols = stdscr.getmaxyx()
        return cols
    except ImportError:
        pass

    # Nope, so deal with ioctl directly.  What value for TIOCGWINSZ?
    try:
        import termios
        TIOCGWINSZ = termios.TIOCGWINSZ
    except ImportError:
        TIOCGWINSZ = 0x40087468  # This is Linux specific

    import struct, fcntl
    s = struct.pack("HHHH", 0, 0, 0, 0)
    try:
        x = fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ, s)
    except IOError:
        return 80
    rows, cols = struct.unpack("HHHH", x)[:2]
    return cols

cols = getwinsize()

data = [s.rstrip() for s in sys.stdin.readlines()]
if not data:
    maxlen = 1
else:
    maxlen = max(map(len, data))

maxlen += 1       # to make extra space

# determine boundaries of screen
cols = (cols / maxlen) or 1
rows = (len(data)+cols) / cols


# pre-create mask for faster computation
mask = "%%-%ds " % (maxlen-1)

# now process each item, picking out proper piece for this position
for item in range(rows * cols):
    target = (item % cols) * rows + (item/cols)
    if target < len(data):
        piece = mask % data[target]
    else:
        piece = mask % ""
    if EOL(item):
        piece = piece.rstrip()  # don't blank-pad to EOL
    sys.stdout.write(piece)
    if EOL(item):
        sys.stdout.write("\n")

if EOL(item):
  sys.stdout.write("\n")




# @@PLEAC@@_4.19
import fileinput

# Slightly modified from
#   http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66463

def printList(alist, blist=[]):
    if not len(alist):
        print ' '.join(blist)
    for i in range(len(alist)):
        blist.append(alist.pop(i))
        printList(alist, blist)
        alist.insert(i, blist.pop())

for line in fileinput.input():
    words = line.split()
    printList(words)

# @@PLEAC@@_5.0
# dictionaries
age = {"Nat": 24,
       "Jules": 24,
       "Josh": 17}
#-----------------------------
age = {}
age["Nat"]   = 24
age["Jules"] = 25
age["Josh"]  = 17
#-----------------------------
food_color = {"Apple":  "red",
              "Banana": "yellow",
              "Lemon":  "yellow",
              "Carrot": "orange"
             }
#-----------------------------
# NOTE: keys must be quoted in Python


# @@PLEAC@@_5.1
dict[KEY] = VALUE
#-----------------------------
# food_color defined per the introduction
food_color["Raspberry"] = "pink"
print "Known foods:"
for food in food_color.keys():
    print food

# In Python 2.2
for food in food_color:
    print food
#-----------------------------



# @@PLEAC@@_5.2
# does dict have a value for KEY ?
if dict.has_key(key):
    pass # it exists
else:
    pass # it doesn't

#-----------------------------
# food_color per the introduction
for name in ("Banana", "Martini"):
    if food_color.has_key(name):
        print name, "is a food."
    else:
        print name, "is a drink."
#-----------------------------
age = {}
age["Toddler"] = 3
age["Unborn"] = 0
age["Phantasm"] = None

for thing in ("Toddler", "Unborn", "Phantasm", "Relic"):
    print "%s:" % (thing,),
    if age.has_key(thing):
        print "Exists",
        if age[thing] is not None: print "Defined",
        if age[thing]: print "True",
    print
#-----------------------------
# Get file sizes for the requested filenames
import fileinput, os
size = {}
for line in fileinput.input():
    filename = line.rstrip()
    if size.has_key[filename]:
        continue
    size[filename] = os.path.getsize(filename)


# @@PLEAC@@_5.3
# remove KEY and its value from dict
del dict[KEY]
#-----------------------------
# food_color as per Introduction
def print_foods():
    foods = food_color.keys()

    print "Keys:", " ".join(foods)
    print "Values:",

    for food in foods:
        color = food_color[food]
        if color is not None:
            print color,
        else:
            print "(undef)",
    print "\n"

print "Initially:"
print_foods()

print "\nWith Banana set to None"
food_color["Banana"] = None
print_foods()

print "\nWith Banana deleted"
del food_color["Banana"]
print_foods()

#-----------------------------
del food_color["Banana"], food_color["Apple"], food_color["Cabbage"]
#-----------------------------


# @@PLEAC@@_5.4
#-----------------------------
for key, value in dict.items():
    pass # do something with key and value
#-----------------------------
for key in dict.keys():
    value = dict[key]
    # do something with key and value
#-----------------------------
# food_color per the introduction
for food, color in food_color.iteritems():  # iteritems added in Python 2.2
    print "%s is %s." % (food, color)

for food in food_color.iterkeys():  # iterkeys added in Python 2.2
    color = food_color[food]
    print "%s is %s." % (food, color)

#-----------------------------
print """%(food)s

is

%(color)s.
""" % vars()
#-----------------------------
foods = food_color.keys()
foods.sort()
for food in foods:
    print "%s is %s.\n" % (food, food_color)

#-----------------------------
#!/usr/bin/env python
# countfrom - count number of messages from each sender

import sys
if len(sys.argv) > 1:
    infile = open(sys.argv[1])
else:
    infile = sys.stdin

counts = {}
for line in infile.xreadlines():  # xreadlines added in Python 2.1
    if line.startswith("From: "):
        name = line[6:-1]
        counts[name] = counts.get(name, 0) + 1

names = counts.keys()
names.sort()
for name in names:
    print "%s: %s" % (name, counts[name])

#-----------------------------


# @@PLEAC@@_5.5
for k, v in dict.items():
    print k, "=>", v

#-----------------------------
print "\n".join(map(lambda item: "%s => %s" % item, dict.items()))
print "\n".join(["%s => %s" % item for item in dict.items()])

print "\n".join(map(lambda k: "%s => %s" % (k, dict[k]), dict.keys()))
# for old python (<= 2.0) that don't have closure (nested scopes)
print map(lambda k, dict = dict: "%s => %s" % (k, dict[k]), dict.keys())

#-----------------------------
print dict
#> {'Phantasm': None, 'Toddler': 3, 'Unborn': 0}
#-----------------------------
import pprint
pprint.pprint(dict)
#> {'Phantasm': None, 'Toddler': 3, 'Unborn': 0}
#-----------------------------


# @@PLEAC@@_5.6
# No simple, native support in Python.  Would need to derive your
# own version from UserDict (pre-2.2) or from the dictionary type (2.2).

# @@PLEAC@@_5.7
import os
ttys = {}

who = os.popen("who")

# or 'xreadlines()' in 2.1, or 'for line in who' in 2.2
for line in who.readlines():
    user, tty = line.split()[:2]
    ttys.setdefault(user, []).append(tty)

users = ttys.keys()
users.sort()
for user in users:
    print user + ": " + " ".join(ttys[user])

#-----------------------------
import pwd
for user in users:
    tty_list = ttys[user]
    tty_list.sort()
    print user + ":", len(tty_list), "ttys."
    for tty in tty_list:
        try:
            uid = os.stat("/dev/" + tty)[4]
            user = pwd.getpwuid(uid)[0]
        except os.error:
            user = "(not available)"
        print "\t%s (owned by %s)" % (tty, user)

# @@PLEAC@@_5.8
# LOOKUP maps keys to values
reverse = {}
for k, v in LOOKUP.items():
  reverse[v] = k
#-----------------------------
surname = {"Mickey": "Mantle", "Babe": "Ruth"}
first_name = {}
for k, v in surname.items():
    first_name[v] = k

print first_name["Mantle"]
#> Mickey

#-----------------------------
#!/usr/bin/perl -w
# foodfind - find match for food or color

import sys
if not sys.argv[1:]:
    raise SystemExit("usage: foodfind food_or_color")
given = sys.argv[1]

color = {"Apple":  "red",
         "Banana": "yellow",
         "Lemon":  "yellow",
         "Carrot": "orange",
        }
food = {}
for k, v in color.items():
  food[v] = k

if color.has_key(given):
    print given, "is a food with color", color[given]

if food.has_key(given):
    print food[given], "is a food with color", given

#-----------------------------
# food_color as per the introduction
foods_with_color = {}
for food, color in food_color.items():
    foods_with_color.setdefault(color, []).append(food)

print " ".join(foods_with_color["yellow"]), "were yellow foods."

#-----------------------------



# @@PLEAC@@_5.9
# dict is the hash to sort
keys = dict.keys()
keys.sort(criterion)
for key in keys:
    value = dict[key]
    # do something with key, value
#-----------------------------
foods = food_color.keys()
foods.sort()
for food in foods:
    print "%s is %s." % (food, food_color[food])
#-----------------------------
# NOTE: alternate version
items = food_color.items()
items.sort()
for item in items:
    print "%s is %s." % item

#-----------------------------
# NOTE: alternate version showing a user-defined function
def food_cmp(x, y):
    return cmp(x, y)

foods = food_color.keys()
foods.sort(food_cmp)

for food in foods:
    print "%s is %s." % (food, food_color[food])
#-----------------------------
def food_len_cmp(x, y):
    return cmp(len(x), len(y))

foods = food_color.keys()
foods.sort(food_len_cmp)

for food in foods:
    print "%s is %s." % (food, food_color[food])

#-----------------------------


# @@PLEAC@@_5.10
merged = {}
merged.update(A)
merged.update(B)

#-----------------------------
# NOTE: alernate version
merged = A.copy()
merged.update(B)

#-----------------------------
merged = {}
for k, v in A.items():
    merged[k] = v
for k, v in B.items():
    merged[k] = v

#-----------------------------
# food_color as per the introduction
drink_color = {"Galliano": "yellow",
               "Mai Tai": "blue"}

ingested_color = drink_color.copy()
ingested_color.update(food_color)
#-----------------------------
# food_color per the introduction, then
drink_color = {"Galliano": "yellow",
               "Mai Tai": "blue"}

substance_color = {}
for k, v in food_color.items():
    substance_color[k] = v
for k, v in drink_color.items():
    substance_color[k] = v

#-----------------------------
substance_color = {}
for dict in (food_color, drink_color):
    for k, v in dict:
        substance_color[k] = v
#-----------------------------
# NOTE: alternate version
substance_color = {}
for item in food_color.items() + drink_color.items():
    for k, v in dict:
        substance_color[k] = v

#-----------------------------
substance_color = {}
for dict in (food_color, drink_color):
    for k, v in dict.items():
        if substance_color.has_key(k):
            print "Warning:", k, "seen twice.  Using the first definition."
            continue
        substance_color[k] = v

# I think it's a copy, in which case
all_colors = new_colors.copy()


# @@PLEAC@@_5.11
common = []
for k in dict1.keys():
    if dict2.has_key(k):  # In Python 2.2 this is "if k in dict2:"
        common.append(k)
#-----------------------------
this_not_that = []
for k in dict1.keys():
    if not dict2.has_key(k):  # In Python 2.2 this is "if k not in dict2:"
        this_not_that.append(k)
#-----------------------------
# citrus_color is a dict mapping citrus food name to its color.
citrus_color = {"Lemon":  "yellow",
                "Orange": "orange",
                "Lime":   "green"}

# build up a list of non-citrus foods
non_citrus = []

for k in food_color.keys():          # In 2.2: "for k in food_color:"
    if not citrus_color.has_key(k):  # In 2.2: "  if k not in citrus_color:"
        non_citrus.append(k)

# @@PLEAC@@_5.12
# references as keys of dictionaries is no pb in python

name = {}
for filename in ("/etc/termcap", "/vmunix", "/bin/cat"):
    try:
        file = open(filename)
    except IOError:
        pass
    else:
        name[file] = filename

print "open files:", ", ".join(name.values())
for file in name.keys():
    file.seek(0, 2)       # seek to the end
    print "%s is %d bytes long." % (name[file], file.tell())
#-----------------------------

# @@PLEAC@@_5.13
# not available in Python

# @@PLEAC@@_5.14
count = {}
for element in list:
    count[element] = count.get(element, 0) + 1

# @@PLEAC@@_5.15
#-----------------------------
import fileinput

father = {'Cain': 'Adam',
          'Abel': 'Adam',
          'Seth': 'Adam',
          'Enoch': 'Cain',
          'Irad': 'Enoch',
          'Mehujael': 'Irad',
          'Methusael': 'Mehujael',
          'Lamech': 'Methusael',
          'Jabal': 'Lamech',
          'Jubal': 'Lamech',
          'Tubalcain': 'Lamech',
          'Enos': 'Seth',
         }

for line in fileinput.input():
    person = line.rstrip()
    while person is not None:        # as long as we have people,
        print person,                # print the current name
        person = father.get(person)  # set the person to the person's father
    print

#-----------------------------
import fileinput

children = {}
for k, v in father.items():
    children.setdefault(v, []).append(k)

for line in fileinput.input():
    person = line.rstrip()
    kids = children.get(person, ["nobody"])
    print person, "begat", ", ".join(kids)

#-----------------------------
import sys, re
pattern = re.compile(r'^\s*#\s*include\s*<([^>]+)')
includes = {}
for filename in filenames:
    try:
        infile = open(filename)
    except IOError, err:
        print >> sys.stderr, err
        continue
    while 1:    # There are nicer ways starting with Python 2.1
        line = infile.readline()
        if not line:
            break
        match = pattern.match(line)
        if match:
            includes.setdefault(match.group(1), []).append(filename)
    infile.close()

#-----------------------------
# list of files that don't include others
dict = {}
for e in reduce(lambda a,b: a + b, includes.values()):
    if not includes.has_key(e):
        dict[e] = 1
include_free = dict.keys()
include_free.sort()

#-----------------------------
#!/usr/bin/env python -w
# dutree - print sorted indented rendition of du output
import os, sys

def input(args):
    # NOTE: This is insecure - use only from trusted code!
    cmd = "du " + " ".join(args)
    infile = os.popen(cmd)

    dirsize = {}
    kids = {}
    for line in infile.readlines():
        size, name = line[:-1].split("\t", 1)
        dirsize[name] = int(size)
        parent = os.path.dirname(name)
        kids.setdefault(parent, []).append(name)
    # Remove the last field added, which is the root
    kids[parent].pop()
    if kids[parent] == []: del kids[parent]

    return name, dirsize, kids

def getdots(root, dirsize, kids):
    size = cursize = dirsize[root]
    if kids.has_key(root):
        for kid in kids[root]:
            cursize -= dirsize[kid]     # -= added in 1.5.2
            getdots(kid, dirsize, kids)
    if size != cursize:
        dot = root + "/."
        dirsize[dot] = cursize
        kids[root].append(dot)

def output(root, dirsize, kids, prefix = "", width = 0):
    path = os.path.basename(root)
    size = dirsize[root]
    fmt = "%" + str(width) + "d %s"
    line = fmt % (size, path)
    print prefix + line

    prefix += (" " * (width-1)) + "| "  + (" " * len(path))

    if kids.has_key(root):
        kid_list = kids[root]
        kid_list.sort(lambda x, y, dirsize = dirsize:
                          cmp(dirsize[x], dirsize[y]))
        width = len(str(dirsize[kid_list[-1]]))
        for kid in kid_list:
            output(kid, dirsize, kids, prefix, width)
def main():
    root, dirsize, kids = input(sys.argv[1:])
    getdots(root, dirsize, kids)
    output(root, dirsize, kids)

if __name__ == "__main__":
    main()

# @@PLEAC@@_7.0
input = open("/usr/local/widgets/data")
for line in input:
    if line.find("blue") != -1:
        print line[:-1]
input.close()
#---------
import sys, re
pattern = re.compile(r"\d")
for line in sys.stdin:
    if not pattern.search(line):
        sys.stderr.write("No digit found.\n")
    sys.stdout.write("Read: " + line)
sys.stdout.close()
#---------
logfile = open("/tmp/log", "w")
#---------
logfile.close()
#---------
# NOTE: this is poor Python style.
import sys
old_output, sys.stdout = sys.stdout, logfile
print "Countdown initiated ..."
sys.stdout = old_output
print "You have 30 seconds to reach minimum safety distance."
# NOTE: It is better to just use
print >> logfile, "Countdown initiated ..."
print >> sys.stdout, "You have 30 seconds to reach minimum safety distance."
#---------

# @@PLEAC@@_7.1
source = open(path)
sink = open(path, "w")
#---------
# NOTE: almost no one uses the low-level os.open and os.fdopen
# commands, so their inclusion here is just silly.  If the
# os.fdopen(os.open(...)) was needed often, it would be turned
# into its own function.  Instead, I'll use 'fd' to hint that
# os.open returns a file descriptor
import os
source_fd = os.open(path, os.O_RDONLY)
source = os.fdopen(fd)
sink_fd = os.open(path, os.O_WRONLY)
sink = os.fdopen(sink_fd)
#---------
file = open(filename, "w")
fd = os.open(filename, os.O_WRONLY | os.O_CREAT)
file = open(filename, "r+")
#---------
fd = os.open(name, flags)
fd = os.open(name, flags, mode)
#---------
file = open(path)
fd = os.open(path, os.O_RDONLY)
#-----------------------------
file = open(path, "w")
fd = os.open(path, os.O_WRONLY|os.O_TRUNC|os.O_CREAT)
fd = os.open(path, os.O_WRONLY|os.O_TRUNC|os.O_CREAT, 0600)
#-----------------------------
fd = os.open(path, os.O_WRONLY|os.O_EXCL|os.O_CREAT)
fd = os.open(path, os.O_WRONLY|os.O_EXCL|os.O_CREAT, 0600)
#-----------------------------
file = open(path, "a")
fd = os.open(path, os.O_WRONLY|os.O_APPEND|os.O_CREAT)
fd = os.open(path, os.O_WRONLY|os.O_APPEND|s.O_CREAT, 0600)
#-----------------------------
fd = os.open(path, os.O_WRONLY|os.O_APPEND)
#-----------------------------
file = open(path, "rw")
fd = os.open(path, os.O_RDWR)
#-----------------------------
fd = os.open(path, os.O_RDWR|os.O_CREAT)
fd = os.open(path, os.O_RDWR|os.O_CREAT, 0600)
#-----------------------------
fd = os.open(path, os.O_RDWR|os.O_EXCL|os.O_CREAT)
fd = os.open(path, os.O_RDWR|os.O_EXCL|os.O_CREAT, 0600)
#-----------------------------

# @@PLEAC@@_7.2
# Nothing different needs to be done with Python

# @@PLEAC@@_7.3
import os
filename = os.path.expanduser(filename)

# @@PLEAC@@_7.4
file = open(filename)   # raise an exception on error

try:
  file = open(filename)
except IOError, err:
  raise AssertionError("Couldn't open %s for reading : %s" %
                       (filename, err.strerror))

# @@PLEAC@@_7.5
import tempfile

file = tempfile.TemporaryFile()

#-----------------------------
# NOTE: The TemporaryFile() call is much more appropriate
# I would not suggest using this code for real work.
import os, tempfile

while 1:
  name = os.tmpnam()
  try:
    fd = os.open(name, os.O_RDWR|os.O_CREAT|os.O_EXCL)
    break
  except os.error:
    pass
file = tempfile.TemporaryFileWrapper(os.fdopen(fd), name)

# now go on to use the file ...
#-----------------------------
import os
while 1:
  tmpname = os.tmpnam()
  fd = os.open(tmpnam, os.O_RDWR | os.O_CREAT | os.O_EXCL)
  if fd:
    tmpfile = os.fdopen(fd)
    break

os.unlink(tmpnam)

#-----------------------------
import tempfile

file = tempfile.TemporaryFile(bufsize = 0)
for i in range(10):
  print >>file, i
file.seek(0)
print "Tmp file has:", file.read()
#-----------------------------

# @@PLEAC@@_7.6
DATA = """\
your data goes here
"""
for line in DATA.split("\n"):
    pass # process the line

# @@PLEAC@@_7.7
for line in sys.stdin:
    pass # do something with the line

#-----------------------------
import sys

def do_with(file):
  for line in file:
      print line[:-1]

filenames = sys.argv[1:]
if filenames:
    for filename in filenames:
        try:
            do_with(open(filename))
        except IOError, err:
            sys.stderr.write("Can't open %s: %s\n" % (filename, err.strerror))
            continue
else:
    do_with(sys.stdin)

#-----------------------------
import sys, glob
ARGV = sys.argv[1:] or glob.glob("*.[Cch]")
#-----------------------------
# NOTE: the getopt module is the prefered mechanism for reading
# command line arguments
import sys
args = sys.argv[1:]
chop_first = 0

if args and args[0] == "-c":
   chop_first += 1
   args = args[1:]

# arg demo 2: Process optional -NUMBER flag

# NOTE: You just wouldn't process things this way for Python,
# but I'm trying to preserve the same semantics.

import sys, re
digit_pattern = re.compile(r"-(\d+)$")

args = sys.argv[1:]
if args:
  match = digit_pattern.match(args[0])
  if match:
    columns = int(match.group(1))
    args = args[1:]

# NOTE: here's the more idiomatic way, which also checks
# for the "--" or a non "-" argument to stop processing

args = sys.argv[1:]
for i in range(len(args)):
  arg = args[i]
  if arg == "--" or not arg.startwith("-"):
    break
  if arg[1:].isdigit():
    columns = int(arg[1:])
    continue



# arg demo 3: Process clustering -a, -i, -n, or -u flags
import sys, getopt
try:
  args, filenames = getopt.getopt(sys.argv[1:], "ainu")
except getopt.error:
  raise SystemExit("usage: %s [-ainu] [filenames] ..." % sys.argv[0])

append = ignore_ints = nostdout = unbuffer = 0
for k, v in args:
  if   k == "-a": append += 1
  elif k == "-i": ignore_ints += 1
  elif k == "-n": nostdout += 1
  elif k == "-u": unbuffer += 1
  else:
    raise AssertionError("Unexpected argument: %s" % k)

#-----------------------------
# Note: Idiomatic Perl get translated to idiomatic Python
import fileinput
for line in fileinput.input():
  sys.stdout.write("%s:%s:%s" %
                   (fileinput.filename(), fileinput.filelineno(), line))
#-----------------------------
#!/usr/bin/env python
# findlogin1 - print all lines containing the string "login"
for line in fileinput.input(): # loop over files on command line
  if line.find("login") != -1:
    sys.stdout.write(line)

#-----------------------------
#!/usr/bin/env python
# lowercase - turn all lines into lowercase
### NOTE: I don't know how to do locales in Python
for line in fileinput.input(): # loop over files on command line
  sys.stdout.write(line.lower())

#-----------------------------
#!/usr/bin/env python
# NOTE: The Perl code appears buggy, in that "Q__END__W" is considered
#       to be a __END__ and words after the __END__ on the same line
#       are included in the count!!!
# countchunks - count how many words are used.
# skip comments, and bail on file if __END__
# or __DATA__ seen.
chunks = 0
for line in fileinput.input():
  for word in line.split():
    if word.startswith("#"):
      continue
    if word in ("__DATA__", "__END__"):
      fileinput.close()
      break
    chunks += 1
print "Found", chunks, "chunks"


# @@PLEAC@@_7.13
import select
while 1:
  rlist, wlist, xlist = select.select([file1, file2, file3], [], [], 0)
  for r in rlist:
    pass # Do something with the file handle

# @@PLEAC@@_7.16
# NOTE: this is all much easier in Python
def subroutine(file):
  print >>file, "Hello, file"

variable = file
subroutine(variable)

# @@PLEAC@@_7.18
for file in files:
  print >> file, stuff_to_print

# NOTE: This is unix specific
import os
file = os.popen("tee file1 file2 file3 >/dev/null", "w")
print >> file, "whatever"

# NOTE: the "make STDOUT go to three files" is bad programming style
import os, sys
sys.stdout.file = os.popen("tee file1 file2 file3", "w")
print "whatever"
sys.stdout.close()

# @@PLEAC@@_7.19
import os
file = os.fdopen(fdnum) # open the descriptor itself
file = os.fdopen(os.dup(fdnum)) # open to a copy of the descriptor

###
outcopy = os.fdopen(os.dup(sys.stdin.fileno()), "w")
incopy = os.fdopen(os.dup(sys.stdin.fileno()), "r")

