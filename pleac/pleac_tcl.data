
 # -*- tcl -*-

# @@PLEAC@@_NAME
# @@SKIP@@ Tcl

# @@PLEAC@@_WEB
# @@SKIP@@ http://purl.oclc.org/NET/tclhome

# @@PLEAC@@_INTRO
# @@SKIP@@ Version: Tcl 8.3

# @@PLEAC@@_1.0
 
set string {\n}                     ;# two characters, \ and an n
set string "Jon {Maddog} Orwant"    ;# literal braces
 
set string \n                       ;# a "newline" character
set string "\n"                     ;# another "newline" character
set string "Jon \"Maddog\" Orwant"  ;# literal double quotes
set string {Jon "Maddog" Orwant}    ;# literal double quotes, again
 
set a {
This is a multiline string
terminated by an unescaped and
{unnested} right brace (\})
}
 
# @@PLEAC@@_1.1
 
set value [string range $string $first $last]
set value [string range $string $first [expr {$first+$num-1}]]
set value [string range $string $first end]
 
set string [string replace $string $first $last $newstring]
set string [string replace $string $first [expr {$first+$num-1}] $newstring]
set string [string replace $string $first end $newtail]


# get a 5-byte string, skip 3, then grab 2 8-byte strings, then the rest
binary scan $data "A5 x3 A8 A8 A*" leading s1 s2 trailing
 
# Important note: this was all well and good when the Cookbook was 
# written and a character and a byte were the same size.  They still
# are for some programming languages, but Tcl for one uses 16-bit
# Unicode characters to encode strings.
 
#   The above unpack/scan works for strings containing only character
# codes in the range 0--255, but distorts other strings by truncating
# all codes to 8 bits.
 
#   To avoid this, the input string can be converted to an 8-bit
# encoding before scanning (\uhhhh is Tcl'ish for Unicode character
# code; each h stands for one hexadecimal digit):
 
set data "H\u2082O is the chemical formula for water"
set utf8data [encoding convertto utf-8 $data]
 
# split at five-byte boundaries (16-bit safe)
set fivers [list]
set temp [encoding convertto utf-8 $string]
while {[binary scan $temp a5a* group tail]} {
    lappend fivers $group
    set temp $tail
}
if {[string length $tail]} { lappend fivers $tail }
 
# To split at five-character boundaries, this is much more
# convenient, *and* 16-bit safe without re-encoding the data
set fivers [regexp -all -inline {.{1,5}} $data]
 
# chop string into individual characters:
# The binary command is a poor choice for this task.
# split is more elegant, and 16-bit safe too.
set chars [split $data {}]


set string "This is what you have"
#          +012345678901234567890  Indexing forwards (left to right)
#           098765432109876543210- Indexing from end (right to left)
#           note that 0 means 10 or 20, etc. above
 
# end is a special value that is available in list and string 
# commands.  It is defined as the index of the last element (in 
# lists), or character (in strings).
#   Likewise, end-1 is defined as the element/character
# preceding the last, and so on.
 
set first [string index $string 0]
# => "T"
set first [string range $string 0 0]
# => "T"
set start [string range $string 5 6]
# => "is"
set rest [string range $string 13 end]
# => "you have"
set last [string index $string end]
# => "e"
set end [string range $string end-3 end]
# => "have"
set piece [string range $string end-7 end-5]
# => "you"
 
set string "This is what you have"
puts $string
# => This is what you have
 
set string [string replace $string 5 6 wasn't]  ;# change "is" to "wasn't"
# => This wasn't what you have
 
set string [string replace $string end-11 end ondrous]
# => This wasn't wondrous
 
set string [string replace $string 0 0]  ;# delete first character
# => his wasn't wondrous
 
set string [string replace $string end-9 end]  ;# delete last 10 characters
# => his wasn'


# you can test substrings with regular expressions
if {[regexp $pattern [string range $string end-9 end]]} {
    set report "Pattern matches in last 10 characters"
}
 
# substitute "at" for "is", restricted to first five characters
regsub -all is [string range $string 0 4] at newstring
set string [string replace $string 0 4 $newstring]
 
# exchange the first and last letters in a string
# inelegant solution using substrings
set a "make a hat"
set a [string index $a end][string range $a 1 end-1][string index $a 0]
puts $a
# => take a ham
 
# better solution using regexp substitution:
regsub {(.)(.*)(.)} $a {\3\2\1} a


# extract column with unpack
set a "To be or not to be"
# this solution is not 16-bit safe
binary scan $a "x6 A6" b
puts $b
# => or not
 
# but this one is
set b [string range $a 6 11]
 
set b [string range $a 6 7]
set c [string range $a 3 4]
puts $b:$c
# => or:be


proc cut2fmt args {
    set positions $args
    set template  {}
    set lastpos   1
    foreach {place} $positions {
        append template "A[expr {$place-$lastpos}] "
        set lastpos $place
    }
    append template A*
    return $template
}
 
set fmt [cut2fmt 8 14 20 26 30]
puts $fmt
# => A7 A6 A6 A6 A4 A*
 
# @@PLEAC@@_1.2


# Perl: use $b if $b is true, else $c
 
# In Tcl, commands such as if or while require the value of the
# condition expression to be a proper boolean value.  If the 
# value is numeric, 0 is false and anything else is true.  For
# non-numeric strings, "true", "on", or "yes" is true and 
# "false", "off", or "no" is false.  Any other value for the
# condition expression raises an error.
#   The `boolean operators' return either "1" or "0".
 
# use $b if b has characters, else $c
if {[string length $b]} {
    set a $b
} else {
    set a $c
}


# use $b if b is nonzero, else $c
if {$b != 0} {
    set a $b
} else {
    set a $c
}


# set x to $y if $x has no characters
if {![string length $x]} {
    set x $y
}


# set x to $y if $x is zero
if {$x == 0} {
    set x $y
}


# set a to $b if b exists, else to $c
if {[info exists b]} {
    set a $b
} else {
    set a $c
}


# Perl: $dir = shift(@ARGV) || "/tmp";
set arg [lindex $argv 0]
set argv [lrange $argv 1 end]
if {[string length $arg]} {
    set dir $arg
} else {
    set dir /tmp
}


# Perl: $dir = $ARGV[0] || "/tmp";
set arg [lindex $argv 0]
if {[string length $arg]} {
    set dir $arg
} else {
    set dir /tmp
}


# Perl: $dir = defined($ARGV[0]) ? shift(@ARGV) : "/tmp";
if {[info exists argv] && [llength $argv]} {
    set dir [lindex $argv 0]
    set argv [lrange $argv 1 end]
} else {
    set dir /tmp
}


# Perl: $dir = @ARGV ? $ARGV[0] : "/tmp";
if {[llength $argv]} {
    set dir [lindex $argv 0]
} else {
    set dir /tmp
}


# Perl: $count{ $shell || "/bin/sh" }++;
if {![string length $shell]} {
    set shell /bin/sh
}
if {[info exist count($shell)]} {
    incr count($shell)
} else {
    set count($shell) 1
}


# find the user name on Unix systems
if {![catch {string length $env(USER)}]} {
    set user $env(USER)
} elseif {![catch {string length $env(LOGIN)}]} {
    set user $env(LOGIN)
} else {
    set user "Unknown user"
}
# The catch command intercepts errors raised.  In this
# case catch is used as an alternative idiom to 
# info exists <var>.
# The pros and cons of the different idioms is 
# discussed at <URL: http://mini.net/tcl/1322.html>.

# needs extension to check getlogin() and getpwuid()


if {![string length $starting_point]} {
    set starting_point Greenwich
}


# copy list only if empty
if {![llength $a]} {
    set a $b
}


# assign b if nonempty, else c
if {[llength $b]} {
    set a $b
} else {
    set a $c
}
 
# @@PLEAC@@_1.3


# cross-assignment
foreach {b a} [list $a $b] break


# cross-assignment with temp
set temp $a
set a $b
set b $temp


foreach {alpha beta production} [list January March August] break
# move beta       to alpha,
# move production to beta,
# move alpha      to production
foreach {alpha beta production} [list $beta $production $alpha] break
 
# @@PLEAC@@_1.4
 
set num [scan $char %c]
set char [format %c $num]


# works for 16-bit Unicode characters
format "Number %d is character %c" $num $num
# => "Number 101 is character e"


# works for 8-bit characters (skip encoding change) and
# 8-bit encodings of Unicode characters
set utf8data [encoding convertto utf-8 $string]
binary scan $utf8data c* codelist
set utf8data [binary format c* $codelist]
set string [encoding convertfrom utf-8 $utf8data]


set hal HAL
binary scan $hal c* codes
foreach {num} $codes {
    lappend newcodes [incr num]
}
set ibm [binary format c* $newcodes]
puts $ibm
# => prints "IBM"
 
# @@PLEAC@@_1.5
 
set a [split $string {}]
 
# works for 8-bit characters and 8-bit encodings
# of Unicode characters
set utf8data [encoding convertto utf-8 $string]
binary scan $utf8data c* a
 
# with -line, . never matches newline
foreach ch [regexp -inline -all -line . $string] {
    # do something with $ch
}


array set seen [list]
set string "an apple a day"
foreach {char} [split $string {}] {
    if {[info exists seen($char)]} {
        incr seen($char)
    } else {
        set seen($char) 1
    }
}
puts "unique chars are: [lsort [array names seen]]"
# => unique chars are: { } a d e l n p y
 
array set seen [list]
set string "an apple a day"
foreach {byte} [regexp -inline -all -line . $string] {
    if {[info exists seen($byte)]} {
        incr seen($byte)
    } else {
        set seen($byte) 1
    }
}
puts "unique chars are: [lsort [array names seen]]"
# => unique chars are: { } a d e l n p y
 
# Of course, if all you care about are which unique 
# characters appear, it's much easier:
lsort -unique [split $s {}]


# simplistic checksum calculation
set sum 0
binary scan $string c* codes
foreach {code} $codes {
    incr sum $code
}
puts "sum is $sum"
# => sum is 1248
# if $string was "an apple a day"


# ...I pass on the checksum tricks...


# slowcat - emulate a   s l o w   line printer
# usage: slowcat [-DELAY] [files ...]
set delay 1
if {[info exists argv] && [llength $argv]} {
    if {[regexp {^-([.\d]+)} [lindex $argv 0] match delay]} {
        set argv [lrange $argv 1 end]
    }
}
fconfigure stdout -buffering no
if {[info exists argv] && [llength $argv]} {
    foreach {arg} $argv {
        set f [open $arg]
        lappend channels $f
    }
} else {
    set channels stdin
}
foreach {chan} $channels {
    while {[gets $chan line] > -1} {
        foreach {ch} [split $line {}] {
            puts -nonewline $ch
            after [expr {int(5 * $delay)}]
        }
        puts {}
    }
}
 
# @@PLEAC@@_1.6
 
set revchars {}
for {set i [expr {[string length $string]-1}]} {$i >= 0} {incr i -1} {
    append revchars [string index $string $i]
}


set revwords {}
set words [split $string]
for {set i [expr {[llength $words]-1}]} {$i >= 0} {incr i -1} {
    lappend revwords [lindex $words $i]
}
join $revwords


# again, another way
 
# reverse letters in string
set gnirts {}
for {set i 0} {$i < [string length $string]} {incr i} {
    append gnirts [string index $string end-$i]
}
 
# reverse elements in words
set sdrow {}
for {set i 0} {$i < [llength $words]} {incr i} {
    lappend sdrow [lindex $words end-$i]
}


# reverse word order where list symbols appear (braces, double quotes)
set words [split {Yoda said, "can you see this?"}]
set revwords {}
for {set i 0} {$i < [llength $words]} {incr i} {
    lappend revwords [lindex $words end-$i]
}
puts [join $revwords]
# => this?" see you "can said, Yoda


# this solution is equivalent to the previous one
set revwords {}
set list [split $string " "]
for {set i [expr {[llength $list]-1}]} {$i >= 0} {incr i -1} {
    lappend revwords [lindex $list $i]
}
set revwords [join $revwords " "]


proc reverse {string} {
    for {set i [expr {[string length $string]-1}]} {$i >= 0} {incr i -1} {
        append res [string index $string $i]
    }
    return $res
}
set word reviver
set is_palindrome [string equal $word [reverse $word]]
# => 1
set word revive
set is_palindrome [string equal $word [reverse $word]]
# => 0
 
# @@PLEAC@@_1.7
 
while {[regexp -indices {\t+} $string where]} {
    foreach {first last} $where break
    regsub {\t+} $string \
        [string repeat { } [expr {8*($last-$first+1)-$first%8}]] string
}


# There is a standard module for exanding/collapsing
# tabs, but all it does is straight substitution;
# tabs <-> N spaces. (tcllib 1.0)
package require textutil

set expandedText [::textutil::tabify::untabify $collapsedText]
set collapsedText [::textutil::tabify::tabify $expandedText]


package require textutil

while {[gets stdin line] >= 0} {
    puts [::textutil::tabify::untabify $line 4]
}
 
package require textutil

while {[gets stdin line] >= 0} {
    puts [::textutil::tabify::tabify $line]
}
 
# @@PLEAC@@_1.8
 
#You owe $debt to me.
#-----------------------------
 
# Use subst if all variables are expected to be in scope:
puts [subst $string]
 
#-----------------------------
# uplevel the command as required if the variables 
# exist in an enclosing scope:
uplevel puts [list [subst $string]]
 
#-----------------------------
foreach {rows cols} {24 80} break
set text {I am $rows high and $cols long} ;# braces prevent substitution
set text [subst $text]
puts $text
# => I am 24 high and 80 long
 
#-----------------------------
set string "I am 17 years old"
regsub -all {(\d+)} $string {[expr {\1*2}]} string
subst $string
# => I am 34 years old
 
#-----------------------------
# expand variables in $text, but put an error message in
# if the variable isn't defined.
# This code assumes that the variables exist in an 
# enclosing scope; if not, remove the [uplevel]s.
while {[regexp {\$(\w+)} $text match var]} {
    if {[uplevel info exists $var]} {
        regsub \\$match $text [uplevel set $var] text
    } else {
        regsub \\$match $text "\[NO VARIABLE: $var\]" text
    }
}
 
# @@PLEAC@@_1.9
 
set big [string toupper $little]
# "bo peep" -> "BO PEEP"
set little [string tolower $big]
# "BO PEEP" -> "bo peep"
set Title [string totitle $little]
# "bo peep" -> "Bo peep"
 
set big [string toupper $little 0]
# "bo peep" -> "Bo peep"
set little [string tolower $big 0]
# "Bo Peep" -> "bo Peep"


# capitalize each word's first character, downcase the rest
set text "thIS is a loNG liNE"
set text [string tolower $text]
set pos 0
while {[regexp -indices -start $pos {(\w+)} $text where]} {
    foreach {first last} $where break
    set text [string toupper $text $first]
    set pos $last
    incr pos
}
# => This Is A Long Line


# case insensitive string comparison
string equal -nocase $a $b


# randcap: filter to randomly capitalize 20% of the letters
set pos 0
while {[regexp -indices -start $pos {(\w)} $text where]} {
    foreach {first last} $where break
    if {rand()<=0.2} {
        set text [string toupper $text $first]
    } else {
        set text [string tolower $text $first]
    }
    set pos $last
    incr pos
}
# =>
# 001:001 in the bEginnInG God CreatEd the Heaven aNd The eaRth.
# 
# 001:002 and ThE earth wAs wIthout form, aNd voId; aNd darkness was
#         uPoN The faCE Of the deEP. aNd the spirIt of god moved uPon
#         the facE of thE wATers.
#
# 001:003 AnD god SAiD, let tHere be lIght: and TheRe was light.
 
# @@PLEAC@@_1.10
 
# Interpolating functions and expressions within strings
set answer $var1[func]$var2
 
set phrase "I have [expr {$n + 1}] guanacos."
 
some_cmd "What you want is [llength [split $rec :]] items"
 
set text {
To: $naughty
From: Your Bank
Cc: [get_manager_list $naughty]
Date: [clock format [clock seconds]] (today)
 
Dear $naughty,
 
Today, you bounced check number [expr {500 + int(rand()*100)}] to us.
Your account is now closed.
 
Sincerely,
the management
}
if {![send_mail $text $target]} {
    error "Couldn't send mail"
}
 
# @@PLEAC@@_1.11
 
# all in one
regsub -line -all {^\s+} {
    your text
    goes here
} {} var
 
# or with two steps
set var {
    your text
    goes here
}
regsub -line -all {^\s+} $var {} var
 
regsub -line -all {^\s+} {
    The five varieties of camelids
    are the familiar camel, his friends
    the llama and the alpaca, and the
    rather less well-known guanaco
    and vicuña.
} {} definition


proc fix {string} {
    regsub -line -all {^\s+} $string {} string
    return $string
}
 
puts [fix {
    My stuff goes here
}]


regsub -line -all {^\s+} {
    ...we will have peace, when you and all your works have
    perished--and the works of your dark master to whom you would
    deliver us. You are a liar, Saruman, and a corrupter of men's
    hearts.  --Theoden in /usr/src/perl/taint.c
} {} quote
# move attribution to line of its own
regsub {\s+--} $quote \n-- quote


dequote {
    @@@ int
    @@@ runops() {
    @@@     SAVEI32(runlevel);
    @@@     runlevel++;
    @@@     while ( op = (*op->op_ppaddr)() ) ;
    @@@     TAINT_NOT;
    @@@     return 0;
    @@@ }
}
# add more code here if you want


dequote {
   Now far ahead the Road has gone,
      And I must follow, if I can,
   Pursuing it with eager feet,
      Until it joins some larger way
   Where many paths and errands meet.
      And whither then? I cannot say.
            --Bilbo in /usr/src/perl/pp_ctl.c
}


proc quotemeta {string} {
    regsub -all {(\W)} $string {\\\1} string
    return $string
}
 
proc dequote {text} {
    if {[regexp -line {^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+(?:\s*)$} $text m 1 2]} {
        set white $2
        set leader [quotemeta $1]
    } else {
        regexp -line {^\n?(\s+)} $text m white
        set leader {}
    }
    regsub -line -all ^\\s*?$leader\(?:$white\) $text {} text
    return [string trimright $text]\n
}
 
# @@PLEAC@@_1.12
 
# The tcllib 1.0 textutil module can adjust text
# to a specified line length, justify left, right,
# and plain, and fill lines to the right margin.
# However, it can't add indentation.
 
# A naive implementation of wrap.  Arguments:
# text	the text
# col	the line length (default 72)
# lead	first line indentation (def empty string)
# follow	indentation for following lines (def empty string)
proc wrap {text {col 72} {lead {}} {follow {}}} {
    set newtext {}
    set text $lead[string trimleft $text]
    set upto $col
    while {![string is wordchar [string index $text $upto]]} {incr upto -1}
    set upto [string wordstart $text $upto]
    if {$upto == 0} {
        set upto [string wordend $text $upto]
    } else {
        incr upto -1
    }
    append newtext [string range $text 0 $upto]\n
    set text [string replace $text 0 $upto]
    while {[string length $text]} {
        set text $follow[string trimleft $text]
        if {[string length $text] > $col} {
            set upto $col
            while {![string is wordchar [string index $text $upto]]} {incr upto -1}
            set upto [string wordstart $text $upto]
            if {$upto == 0} {
                set upto [string wordend $text $upto]
            } else {
                incr upto -1
            }
            append newtext [string range $text 0 $upto]\n
            set text [string replace $text 0 $upto]
        } else {
            append newtext $text
            set text {}
        }       
    }
    return $newtext
}


set input [concat "Folding and splicing is the work of an editor," \
      "not a mere collection of silicon" \
      "and" \
      "mobile electrons!"]
puts [string repeat 0123456789 2]
puts [wrap $input 20 {    } {  }]
# =>
# 01234567890123456789
#     Folding and 
#   splicing is the 
#   work of an 
#   editor, not a 
#   mere collection 
#   of silicon and 
#   mobile electrons!
return [wrap $input 20 {    } {  }]
 
# @@PLEAC@@_1.13
 
# backslash
set pattern {}
append pattern {([} $charlist {])}
regsub -all $pattern $var {\\\1} var
 
# double
set pattern {}
append pattern {([} $charlist {])}
regsub -all $pattern $var {\1\1} var


set string {Mom said, "Don't do that."}
regsub -all {(['"])} $string {\\\1} string
 
set string {Mom said, "Don't do that."}
regsub -all {(['"])} $string {\1\1} string
 
regsub -all {([^A-Z])} $string {\\\1} string
# equivalent to:
regsub -all {([^[:upper:]])} $string {\\\1} string
 
regsub -all {([^[:alnum:]])} "is a test!" {\\\1} string
set string "this $string"
# => this is\ a\ test\!
 
# @@PLEAC@@_1.14
 
regsub {^\s+} $string {} string
regsub {\s+$} $string {} string
set string [string trim $string]
 
# The input command, gets, automatically
# strips off newlines.
 
# @@PLEAC@@_1.15
 
package require csv
 
set line {XYZZY,,"O'Reilly, Inc","Wall, Larry","a ""glug"" bit",5,"Error, Core Dumped"}
set fields [::csv::split $line]
for {set i 0} {$i < [llength $fields]} {incr i} {
    puts "$i : [lindex $fields $i]"
}
# =>
# 0 : XYZZY
# 1 : 
# 2 : O'Reilly, Inc
# 3 : Wall, Larry
# 4 : a "glug" bit
# 5 : 5
# 6 : Error, Core Dumped
 
# @@PLEAC@@_1.17
 
# fixstyle - switch one set of strings to another set
#   usage: <scriptname> [-v] [files ...]
array set data {
    analysed         analyzed
    built-in         builtin
    chastized        chastised
    commandline      command-line
    de-allocate      deallocate
    dropin           drop-in
    hardcode         hard-code
    meta-data        metadata
    multicharacter   multi-character
    multiway         multi-way
    non-empty        nonempty
    non-profit       nonprofit
    non-trappable    nontrappable
    pre-define       predefine
    preextend        pre-extend
    re-compiling     recompiling
    reenter          re-enter
    turnkey          turn-key
}
 
set testtext {
    Yesterday we analysed the efficiency of the 
    built-in thingummies and were considerably 
    chastized by the results.  It seems that 
    commandline invocation forced the 
    whatchamacallit to de-allocate dropin 
    maguffins.  First, we tested instead to 
    hardcode meta-data -- especially when in 
    multicharacter and multiway format
    (obviously only for non-empty data sets).  
    However, that turned out to be a non-profit 
    improvement.  Dr Egnarts then demonstrated 
    using non-trappable signals in pre-define 
    mode to preextend save rates.  When 
    re-compiling we saw the application reenter 
    acceptable ratings on turnkey operations.
}
 
set verbose no
 
proc fixstyle {text} {
    global data verbose
    set newtext [list]
    foreach w $text {
        if {[catch {set word $data($w)}]} {
            set word $w
        } else {
            if {$verbose} {
                puts stderr "$w => $word"
            }
        }
        lappend newtext $word
    }
    return $newtext
}
 
set channels [list]
 
if {[info exists argv]} {
    if {[llength $argv] && [string equal [lindex $argv 0] -v]} {
        set verbose yes
        set argv [lrange $argv 1 end]
    }
    foreach {fn} [lrange $argv 0 end] {
        if {![catch {open $fn} chan]} { lappend channels $chan}
    }
}
 
if {![llength $channels]} {
    set channels [list stdin]
    if {[tell stdin] == -1} {
        puts stderr "[info script]: Reading from stdin"
    }
}
 
set text {}
 
foreach {chan} $channels { append text [read $chan] }
 
puts [fixstyle $text]
 
# @@PLEAC@@_2.1
 
if {[regexp {\D} $string]} {
    error "$string has nondigits"
}
# => -3 has nondigits
# => 3.0 has nondigits
# => 3.0e4 has nondigits
 
if {![regexp {^\d+$} $string]} {
    error "$string is not a natural number"
}
# => -3 is not a natural number
# => 3.0 is not a natural number
# => 3.0e4 is not a natural number
 
if {![regexp {^[+-]?\d+$} $string]} {
    error "$string is not an integer"
}
# => 3.0 is not an integer
# => 3.0e4 is not an integer
 
if {![regexp {^-?(?:\d+(?:\.\d*)?|\.\d+)$} $string]} {
    error "$string is not a real number"
}
# => 3.0e4 is not a real number
 
if {![regexp {^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$} $string]} {
    error "$string is not a C float"
}
 


# Regexps like the above are sometimes necessary for making fine
# distinctions among string representations of numbers.
# If the only thing in questions is whether $x is a number
# or not, or whether it is an integer or a real number, Tcl
# can help:
if {[string is integer $x]} {
    set res "$x is an integer"
} elseif {[string is double $x]} {
    set res "$x is a real number"
} else {
    set res "$x is not a number"
}
puts stderr $res
# => A is not a number
# => 3 is an integer
# => -3 is an integer
# => 3.0 is a real number
# => 3.0e4 is a real number
 
# @@PLEAC@@_2.2
 
# limit number of decimals when determining equality of
# floating point values to avoid rounding errors.
proc equal {num1 num2 accuracy} {
    expr {[format %.${accuracy}f $num1] == [format %.${accuracy}f $num2]}
}


set wage 536                  ;# $5.36/hour
set week [expr {40 * $wage}]  ;# $214.40
puts [format "One week's wage is: \$%.2f" [expr {$week/100.0}]]
#One week's wage is: $214.40
 
# @@PLEAC@@_2.3
 
set rounded [format %${FORMAT}f $unrounded]


set a 0.255
set b [format %.2f $a]
puts "Unrounded: $a\nRounded: $b"
puts [format "Unrounded: $a\nRounded: %.2f" $a]
puts number\tint\tfloor\tceil
set a [list 3.3 3.5 3.7 -3.3]
foreach n $a {
    puts [format %.1f\t%.1f\t%.1f\t%.1f \
        $n \
        [expr {int($n)}] \
        [expr {floor($n)}] \
        [expr {ceil($n)}]]
}
# => number	int	floor	ceil
# => 3.3	3.0	3.0	4.0
# => 3.5	3.0	3.0	4.0
# => 3.7	3.0	3.0	4.0
# => -3.3	-3.0	-4.0	-3.0
 
# @@PLEAC@@_2.4
 
proc dec2bin {string} {
    binary scan [binary format I $string] B32 str
    return [string trimleft $str 0]
}
 
proc bin2dec {string} {
    set string [format %032s $string]
    binary scan [binary format B32 $string] I str
    return $str
}
 
# @@PLEAC@@_2.5
 
for {set i $X} {$i <= $Y} {incr i} {
    # $i is set to every integer from X to Y, inclusive
}
 
for {set i $X} {$i <= $Y} {incr i 7} {
    # $i is set to every integer from X to Y, stepsize = 7
}


puts -nonewline "Infancy is: "
for {set i 0} {$i <= 2} {incr i} {
    puts -nonewline "$i "
}
puts {}
 
puts -nonewline "Toddling is: "
for {set i 3} {$i <= 4} {incr i} {
    puts -nonewline "$i "
}
puts {}
 
puts -nonewline "Childhood is: "
for {set i 5} {$i <= 12} {incr i} {
    puts -nonewline "$i "
}
puts {}
 
# @@PLEAC@@_2.6
 
# Does a module for automatic conversion of Roman numerals serve 
# any other purpose than filling out CPAN?
 
# It *can* be done in Tcl, of course.  See
# <URL: http://mini.net/tcl/1749.html>
# (which even has arithmetic in Roman numerals).
 
# @@PLEAC@@_2.7
 
set random [expr {int(rand()*$Y)+$X}]
# The rand function returns a floating point number from zero to
# just less than one or, in mathematical terms, the range [0,1).
# The seed comes from the internal clock of the machine or may be
# set manual with the srand function.
 
set random [expr {int(rand()*51)+25}]
puts $random


# The math module of the standard distribution has a wrapper for
# rand called random; it supports generation of pseudo-random
# numbers in the [0,n) and [n,m) ranges.
 
package require math
 
set random [::math::random 25 76]
puts $random
# same as above


set elt [lindex $list [expr {int(rand()*[llength $list])}]]


set chars [list]
for {set c [scan A %c]} {$c <= [scan Z %c]} {incr c} {
    lappend chars [format %c $c]
}
for {set c [scan a %c]} {$c <= [scan z %c]} {incr c} {
    lappend chars [format %c $c]
}
lappend chars ! @ \$ % ^ & *
set password {}
for {set i 0} {$i < 8} {incr i} {
    append password [lindex $chars [expr {int(rand()*[llength $chars])}]]
}
 
# @@PLEAC@@_2.8
 
expr {srand($value)}
 
# @@PLEAC@@_2.9
 
# There is no standard module known to me that implements better
# random number generators than the one in the C library, but at
# <URL: http://www.elf.org/etc/randomnumbers.html> there is Tcl
# and C source for a ``very long period random number generator''.
 
# Also see <URL: http://mini.net/cgi-bin/wikit/1551.html> for a
# `post-processor' that improves the randomness of the output of
# rand().
 
# @@PLEAC@@_2.11
 
# You'd typically want a variable like PI to be 
# contained within a namespace and not automatically
# set in the global namespace.  [namespace current]
# returns the qualified name of the current namespace,
# or :: for the global namespace.
set [namespace current]::PI [expr {acos(-1)}]
 
proc deg2rad {degrees} {
    # The [variable] command creates a local variable
    # that references the same value as the namespace
    # variable with the same name.
    variable PI
    return [expr {(double($degrees) / 180) * $PI}]
}
 
proc rad2deg {radians} {
    variable PI
    return [expr {($radians / $PI) * 180}]
}
# The core Tcl command [expr] has most of the commonly
# used trigonometric functions defined, so there is
# less need for a Trig module.

 
proc degreeSine {degrees} {
    set radians [deg2rad $degrees]
    return [expr {sin($radians)}]
}
 
# @@PLEAC@@_2.12
 
# The tangent function is already available in the [expr]
# command, as is the arcus cosine and many more.
 
# In some cases, the [expr] functions raise an error because
# of overflow or division by zero.  To trap such errors, wrap
# in [catch]:
 
if {[catch {expr {1/0}}]} { return }
 
# @@PLEAC@@_2.13
 
set logE [expr {log($value)}]
 
set log10 [expr {log10($value)}]
 
proc logBase {base value} {
    return [expr {log($value) / log($base)}]
}
 
set answer [logBase 10 10000]
puts "log10(10,000) = $answer"
# => log10(10,000) = 4
 
# @@PLEAC@@_2.16
 
# Tcl does not have hex/oct functions, but
# they are easy to implement.  If [expr]
# gets handed an invalid octal/hex number,
# it raises an error instead of returning
# 0 as the Perl functions do.
 
proc hex {string} {
    if {[regexp -nocase {^0x} $string]} {
        return [expr $string]
    } else {
        return [expr 0x$string]
    }
}
 
proc oct {string} {
    if {[regexp -nocase {^0x} $string]} {
        return [hex $string]
    } else {
        return [expr 0$string]
    }
}


puts "Gimme a number in decimal, octal, or hex: "
set num [gets stdin]
if {[string length $num]} {
    if {[regexp ^0 $num]} {
        set num [oct $num]
    }
    puts [format "%d %x %o" $num $num $num]
}
 
# @@PLEAC@@_2.17
 
proc reverse {string} {
    for {set i 0} {$i < [string length $string]} {incr i} {
        append gnirts [string index $string end-$i]
    }
    return $gnirts
}
 
proc commify {string} {
    set text [reverse $string]
    regsub -all {(\d\d\d)(?=\d)(?!\d*\.)} $text {\1,} text
    return [reverse $text]
}
 
# See the Online Tcl Cookbook for a more elegant solution:
# <URL: http://aspn.activestate.com/ASPN/Cookbook/Tcl/Recipe/68381>
 
# @@PLEAC@@_3.0
 
# A single command, [clock] is used for a wide range
# of date/time-related tasks.  Subcommands include
# seconds, which returns a seconds-since-epoch value,
# and format, which formats a date/time-string like
# the result of POSIX strftime.
 
set now [clock seconds]
set fmt "Today is day %j of the current year."
puts [clock format $now -format $fmt]
 
# @@PLEAC@@_3.1
 
foreach {day month year} [clock format $now -format "%d %m %Y"] break
 
set now [clock seconds]
set fmt "The current date is %Y %m %d"
puts [clock format $now -format $fmt]
 
# @@PLEAC@@_3.2
 
# 'timelocal'
# this is one of several possible variants of scannable
# date/time strings
set time [clock scan "$hours:$min:$sec $year-$mon-$mday"]
 
# 'timegm'
set time [clock scan "$hours:$min:$sec $year-$mon-$mday" -gmt yes]
 
# a time today in the current time zone.
set time [clock scan "$hours:$min:$sec"]
 
# @@PLEAC@@_3.3
 
set now [clock seconds]
set vars [list seconds minutes hours day_of_month month year wday yday]
set desc [list S       M       H     d            m     Y    w    j]
foreach v $vars d $desc {
    set $v [clock format $now -format %$d]
}
 
# @@PLEAC@@_3.4
 
set when [expr {$now + $difference}]
set when [expr {$now - $difference}]
 
# more idiomatic
set when [clock scan "$difference seconds"]
set when [clock scan "$difference seconds ago"]
set when [clock scan "-$difference seconds"] ;# same as previous


foreach {y2 m2 d2} [clock format [clock scan "$y-$m-$d $offset days"] -format "%Y %m %d"] break


set vars [list year2 month2 day2 h2 m2 s2]
set desc [list Y     m      d    H  M  S]
set time [clock scan "$y-$m-$d $h:$m:$s
    $days_offset days $hour_offset hours $minute_offset minutes $second_offset seconds"]
foreach v $vars d $desc {
    set $v [clock format $time -format %$d]
}


# The hard way
set birthtime [clock scan "18-Jan-1973 3:45:50 am"]
set interval [expr {5 + 17 * 60 + 2 * 60 * 60 + 55 * 60 * 60 * 24}]
set then [expr {$birthtime + $interval}]
puts [clock format $then]
# => Wed Mar 14 06:02:55 1973
# (note: I deleted time zone information from the above result)
 
# The easy way
set then [clock scan "18-Jan-1973 3:45:50 am 5 seconds 17 minutes 2 hours 55 days"]
puts [clock format $then]
 
# @@PLEAC@@_3.5
 
set bree [clock scan "16 Jun 1981 4:35:25"]
set nat  [clock scan "18 Jan 1973 3:45:50"]
 
set difference [expr {$bree - $nat}]
puts "There were $difference seconds between Nat and Bree"
# => There were 265333775 seconds between Nat and Bree
 
set vars    {seconds minutes hours days}
set factors {60      60      24    7}
foreach v $vars f $factors {
    set $v [expr {$difference % $f}]
    set difference [expr {($difference-[set $v]) / $f}]
}
set weeks $difference
puts "($weeks weeks, $days days, $hours:$minutes:$seconds)"
# => (438 weeks, 4 days, 23:49:35)
 
# @@PLEAC@@_3.6
 
set then [clock scan 6/16/1981]
set dayname [clock format $then -format %A]
set weeknum [expr {[clock format $then -format %W] + 1}]
puts "6/16/1981 was a $dayname in week number $weeknum"
# => 6/16/1981 was a Tuesday in week number 25
 
# @@PLEAC@@_3.7
 
set epoch_seconds [clock scan "1998-06-03"]
set epoch_seconds [clock scan "2 weeks ago Friday"]
set epoch_seconds [clock scan "today"]
 
# second Friday of 1996:
set epoch_seconds [clock scan "friday" -base [clock scan "1996-01-01 1 week"]]
 
# @@PLEAC@@_3.8
 
puts [clock format [clock scan 01/18/73] -format "%A %D"]
# => Thursday 01/18/73
 
puts [clock format [clock scan "18 Jan 1973 3:45:50"] \
    -format "%a %b %e %H:%M:%S %Z %Y" -gmt yes]
# => Thu Jan 18 02:45:50 GMT 1973
 
# @@PLEAC@@_3.9
 
puts "Press return when ready"
set before [clock clicks -milliseconds]
set line [gets stdin]
set elapsed [expr {([clock clicks -milliseconds] - $before) / 1000.0}]
puts "You took $elapsed seconds"
 
# => Press return when ready
# => You took 0.33 seconds


set size 500
set numberOfTimes 100
set totalTime 0
 
 
for {set i 0} {$i < $numberOfTimes} {incr i} {
    set a [list]
    for {set j 0} {$j < $size} {incr j} {
        lappend a [expr {rand()}]
    }
    set begin [clock clicks -milliseconds]
    set a [lsort -real $a]
    set time [expr {[clock clicks -milliseconds]-$begin}]
    incr totalTime $time
}
puts [format "On average, sorting %d random numbers takes %.5f seconds" \
    $size [expr {(double($totalTime)/$numberOfTimes)/1000}]]
# => On average, sorting 500 random numbers takes 0.00170 seconds
 
# Since one of Tcl's hats is software testing, this 'benchmark'
# is of course better written as
set size 500
set numberOfTimes 100
 
set a [list]
for {set j 0} {$j < $size} {incr j} {
    lappend a [expr {rand()}]
}
puts "Sorting $size random numbers:"
puts [time {
    set a [lsort -real $a]
} $numberOfTimes]
# => Sorting 500 random numbers:
# => 1100 microseconds per iteration
 
# @@PLEAC@@_3.10
 
# Sleep 25 milliseconds
after 25
 
# Interrupt a ticking timer
set id [after 2500]
# ...
after cancel $id
 
# @@PLEAC@@_4.0
 
# after assignment, $list has 4 elements
set list [list this that the other]
# after assignment, $list has 3 elements, the last
# of which is a list with 2 elements
set list [list this that {the other}]


proc flatten {args} {
    set res [list]
    foreach {i} $args {
        if {[llength $i] > 1} {
            set res [concat $res [eval flatten $i]]
        } else {
            set res [concat $res $i]
        }
    }
    set res
}
 
# after assignment, $list has 4 elements
set list [flatten this that {the other}]


set tune [list the star-spangled banner]
puts [lindex $tune 0]
# => the
puts [lindex $tune 1]
# => star-spangled
 
# @@PLEAC@@_4.1
 
set a [list quick brown fox]
 
set a [list Why are you teasing me?]
 
set lines [list]
foreach {l} [split {
    The boy stood on the burning deck,
    It was as hot as glass.
} \n ] {
    set line [string trimleft $l]
    if {[string length $line]} {
        lappend lines $line
    }
}


set biglist [list]
set data [open mydatafile]          ;# Automatically raises error on failure
while {[gets $data item] >= 0} {
    lappend biglist $item
}


# Three ways to create a three-element list
# (in the first example, banner must be empty).
lappend banner Costs only \$4.95
set banner [list Costs only \$4.95]
set banner [split {Costs only $4.95}]


set ships [list Niña Pinta Santa María]   ;# WRONG (4 ships)
set ships [list Niña Pinta {Santa María}] ;# right (3 ships)
 
# @@PLEAC@@_4.2
 
set list [list red yellow green]
 
puts "I have $list marbles."
# => I have red yellow green marbles.


set lists {
    {{just one thing}}
    {Mutt Jeff}
    {Peter Paul Mary}
    {{to our parents} {Mother Theresa} God}
    {{pastrami} {ham and cheese} {peanut butter and jelly} {tuna}}
    {{recycle tired, old phrases} {ponder big, happy thoughts}}
    {{recycle tired, old phrases} \
     {ponder big, happy thoughts} \
     {sleep and dream peacefully} \
    }
}
 
proc commifySeries {args} {
    if {[regexp , $args]} {
        set sepchar ";"
    } else {
        set sepchar ,
    }
    # Tcl has a switch command, nyah nyah nyah
    switch [llength $args] {
        0 { return {} }
        1 { eval return $args }
        2 { return [join $args { and }] }
        default {
            set args [lreplace $args end end [concat and [lindex $args end]]]
            return [join $args "$sepchar "]
        }
    }
}
 
foreach {list} $lists {
    puts "The list is: [eval commifySeries $list]."
}
 
# => The list is: just one thing.
# => The list is: Mutt and Jeff.
# => The list is: Peter, Paul, and Mary.
# => The list is: to our parents, Mother Theresa, and God.
# => The list is: pastrami, ham and cheese, peanut butter and jelly, and tuna.
# => The list is: recycle tired, old phrases and ponder big, happy thoughts.
# => The list is: recycle tired, old phrases; ponder big, happy thoughts; and sleep and dream peacefully.
 
# @@PLEAC@@_4.3
 
# Tcl lists (which more or less correspond to
# Perl arrays) can be extended, but only by
# appending to the end of the list:
 
set list [list a b c]
lappend list d
# => a b c d
 
lappend list e f g
# => a b c d e f g


# Shrinking a list:
set list [lrange $list 0 4]
# => a b c d e
 
# @@PLEAC@@_4.4
 
# A foreach loop
foreach {item} {LIST} {
     # do something with $item
}
 
foreach {user} $badUsers {
    complain $user
}
 
foreach key [lsort [array names env]] {
    puts $key->$env($key)
}
 
foreach {user} $allUsers {
    set diskSpace [getUsage $user]
    if {$diskSpace > $MAXQUOTA} {
        complain $user
    }
}
 
# There is no implicit variable like Perl's $_ in Tcl.
foreach {user} [exec who] {
    if {[regexp tchrist $user]} {
        puts $user
    }
}
# You can't manipulate values by reference in Tcl.
# If you need to mutate a list, this is the preferred
# idiom:
 
set mylist [mutate $mylist args]
 
# You *can* 'simulate' manipulation by reference by
# using call-by-name and connecting a local variable
# to a variable with that name in the outer scope:
 
set mylist [list 1 2 3]
 
proc timesSeven {listname} {
    upvar $listname listref
    set temp [list]
    foreach {item} $listref {
        lappend temp [expr {$item * 7}]
    }
    set listref $temp
}
 
timesSeven mylist
# => 7 14 21
 
# @@PLEAC@@_4.6
 
set uniq [lsort -unique $list]


set uniqueUsers [lsort -unique [exec who]]
puts "Users logged in: $uniqueUsers"
 
# @@PLEAC@@_4.7
 
# Use the standard package TclX (contained in
# the ActiveTcl distribution).
package require Tclx
 
set listA [list 1 1 2 2 3 3 3 4 5]
set listB [list 1 2 4]
set res [intersect3 $listA $listB]
 
# [intersect3] yields three result lists,
# we want the first:
 
lindex $res 0
 
# => 3 5
 
# @@PLEAC@@_4.8
 
# Use the standard package TclX (contained in
# the ActiveTcl distribution).
package require Tclx
 
set listA [list 1 1 2 2 3 3 3 4 5]
set listB [list 1 2 4 4 6 7]
 
foreach {difference intersection -} [intersect3 $listA $listB] break
set union [union $listA $listB]
 
# difference:   3 5
# intersection: 1 2 4
# union:        1 2 3 4 5 6 7
 
# @@PLEAC@@_4.9
 
# Concatenating variables whose values are lists
set dislist [concat $dislist $datlist]
 
# Growing a list by adding new members
set mylist [list athos porthos aramis]
lappend mylist d'artagnan
 
set members [list Time Flies]
lappend members An Arrow
# => Time Flies An Arrow
 
set members [linsert $members 2 Like]
# => Time Flies Like An Arrow
 
set members [lreplace $members 0 0 Fruit]
set members [lreplace $members end-1 end A Banana]
# => Fruit Flies Like A Banana
 
# @@PLEAC@@_4.10
 
set newlist [list]
for {set i 0} {$i < [llength $list]} {incr i} {
    lappend newlist [lindex $list end-$i]
}


# sort in decreasing order, i.e. largest values first
set sorted [lsort -decreasing $list]
 
# @@PLEAC@@_4.11
 
# list operations in Tcl are generally non-destructive,
# so one has to copy out the elements first, and then
# update the list to have only the other elements.
 
# set front to the first $n elements in $list;
# remove those elements from list.
 
set front [lrange $list 0 [expr {$n-1}]]
set list [lrange $list $n end]


# set end to the last $n elements in $list;
# remove those elements from list.
 
set end [lrange $list end-[expr {$n-1}] end]
set list [lrange $list 0 end-$n]


proc shift2 {listname} {
    upvar $listname list
    set front [lrange $list 0 1]
    set list [lrange $list 2 end]
    return $front
}
 
set friends [list Peter Paul Mary Jim Tim]
foreach {this that} [shift2 friends] break


proc pop2 {listname} {
    upvar $listname list
    set end [lrange $list end-1 end]
    set list [lrange $list 0 end-2]
    return $end
}
 
set beverages [list Dew Jolt Cola Sprite Fresca]
set pair [pop2 beverages]
 
# @@PLEAC@@_4.12
 
set found {}
foreach {item} $list {
    if {[criterion]} {
        set match $item    ;# must save
        set found 1
        break
    }
}
if {$found} {
    ## do something with $match
} else {
    ## unfound
}
 
set matchIdx {}
for {set i 0} {$i < [llength $list]} {incr i} {
    if {[criterion]} {
        set matchIdx $i    ;# save the index
        break
    }
}
if {[string length $matchIdx]} {
    ## found in [lindex $list $matchIdx]
} else {
    ## unfound
}
 
# assuming $employees is a list of lists, with each sublist
# having the elements category, name, and salary:
foreach employee $employees {
    if {[string match [lindex $employee 0] engineer]} {
        set highestEngineer $employee
        break
    }
}
puts "Highest paid engineer is: [lindex $highestEngineer 1]"
 
# @@PLEAC@@_4.13
 
# If the test is matching an element's value against
# an exact string, a wildcard pattern, or a regular
# expression, use the standard package TclX (contained
# in the ActiveTcl distribution).
 
package require Tclx
 
set matching [lmatch $list $matchThis]


# For other tests, use a foreach loop:
set matching [list]
foreach {elt} $list {
    if {[TEST $elt]} {
        lappend matching $elt
    }
}


# A procedure similar to Perl's grep might look
# like this:
 
proc grep {test list} {
    set matching [list]
    foreach {_} $list {
        if {[expr $test]} {
            lappend matching $_
        }
    }
    return $matching
}
 
set bigs [grep {$_ > 1000000} $nums]
set pigs [grep {$::users($_) > 1e7} [array names ::users]]
 
set matching [grep {[regexp {^gnat } $_]} [exec who]]
 
# assuming applicants is a list of lists where each sublist
# has at least one element; income:
set secondaryAssistance [grep {[lindex $_ 0] >= 26000 && [lindex $_ 0] < 30000} $applicants]
 
# @@PLEAC@@_4.14
 
# Numerical sorting (elements treated as reals).
set sorted [lsort -real $unsorted]


# Use the standard package TclX (contained in
# the ActiveTcl distribution).
package require Tclx
 
# Note: the TclX kill command is not available
# on Win9x/NT.  
 
foreach {pid} [lsort -integer $pids] {
    puts $pid
} 
puts "Select a process ID to kill:";
set pid [gets stdin]
if {$pid == 0 || [regexp {\D} $pid]} {
    error Exiting...
}
kill TERM $pid
sleep 2
kill KILL $pid


set descending [lsort -decreasing -real $unsorted]


# You can specify -command CMD to the lsort command
# to use a custom comparison command (see next solution).
# The lsort command *is* reentrant, so CMD may use lsort
# during its execution. 
 
# @@PLEAC@@_4.15
 
set ordered [lsort -command compare $unordered]


# An ersatz map command:
proc map {op list} {
    foreach {_} $list {
        lappend res [subst $op]
    }
    return $res
}
 
# The Perl compute takes no argument.  I assume this is
# a mistake, as one would expect it to make some sort of
# operation on the value of the element.
 
set precomputed [map {[list [compute $_] $_]} $unordered]
set orderedPrecomputed [lsort -index 0 $precomputed]
set ordered [map {[lindex $_ 1]} $orderedPrecomputed]


set ordered [map {[lindex $_ 1]} \
            [lsort -index 0 \
            [map {[list [compute $_] $_]} $unordered]]]


# For the following examples, assume that employees is a 
# list of lists, where the elements of each sublist are
# - name
# - salary
# - SSN
# - age
 
set ordered [lsort -dictionary -index 0 $employees]
 
foreach {e} [lsort -dictionary -index 0 $employees] {
    puts "[lindex $e 0] earns [lindex $e 1]" 
}
 
set sortedEmployees [lsort -dictionary -index 0 $employees]
foreach {e} $sortedEmployees {
    puts "[lindex $e 0] earns [lindex $e 1]" 
}
# load bonus array
foreach {e} $sortedEmployees {
    if {$bonus([lindex $e 2])} {
    puts "[lindex $e 0] got a bonus!"
    }
}


proc multiSort {a b} {
    set cmp [string compare [lindex $a 0] [lindex $b 0]]
    if {$cmp == 0} {
        return [expr {[lindex $a 3]-[lindex $b 3]}]
    } else {
        return $cmp
    }
}


proc sortBySecondLetter {a b} {
    return [string compare [string range $a 1 1] [string range $b 1 1]]
}
 
set sorted [lsort -command sortBySecondLetter $names]


proc sortByLength {a b} {
    return [string compare [string length $a] [string length $b]]
}
 
set sorted [lsort -command sortByLength $names]
 
# @@PLEAC@@_4.16
 
set circular [concat [lrange $list 1 end] [lindex $list 0]]
set circular [concat [lindex $list end] [lrange $list 0 end-1]]


proc grabAndRotate {listname} {
    upvar $listname list
    set first [lindex $list 0]
    set list [concat [lrange $list 1 end] $first]
    return $first
}
 
set processes [list 1 2 3 4 5]
while 1 {
    set process [grabAndRotate processes]
    puts "Handling process $process"
    after 1000
}
 
# @@PLEAC@@_4.17
 
proc FisherYatesShuffle {listname} {
    upvar $listname list
    for {set i [expr {[llength $list]-1}]} {$i >= 0} {incr i -1} {
        set j [expr {int(rand()*$i+1)}]
        if {$i != $j} {
            set temp [lindex $list $i]
            set list [lreplace $list $i $i [lindex $list $j]]
            set list [lreplace $list $j $j $temp]
        }
    }
}


# Several shuffle algorithms in Tcl are compared for performance
# here: <URL: http://mini.net/cgi-bin/nph-wikit/941.html>.
# This is a very efficient algorithm for small lists:
 
proc K { x y } { set x } ;# Donal Fellows
 
proc shuffle5a { list } {
    set n 1
    set slist {}
    foreach item $list {
        set index [expr {int(rand()*$n)}]
        set slist [linsert [K $slist [set slist {}]] $index $item]
        incr n
    }
    return $slist
} ;# Christoph Bauer


set len [llength $list]
set perm [factorial $len]
set shuffle [list]
foreach {i} [n2perm [expr {1+int(rand()*$perm)}] [expr {$len-1}]] {
    lappend shuffle [lindex $list $i]
}
 
# @@PLEAC@@_4.19
 
array set ::fact [list 0 1]
 
proc factorial {n} {
    global fact
    if {![info exists fact($n)]} {
        set fact($n) [expr {$n * [factorial [expr {$n - 1}]]}]
    }
    return $fact($n)
}
 
# n2pat N len : produce the $N-th pattern of length $len
proc n2pat {N len} {
    set i 1
    set pat [list]
    while {$i <= $len + 1} {
        lappend pat [expr {$N % $i}]
        set N [expr {int($N/$i)}]
        incr i
    }
    return $pat
}
 
# pat2perm pat : turn pattern returned by n2pat into
# permutation of integers.  XXX: splice is already O(N)
proc pat2perm {args} {
    if {[llength $args] == 1} {
        set pat [lindex $args 0]
    } else {
        set pat $args
    }
    set source [list]
    for {set i 0} {$i < [llength $pat]} {incr i} {
        lappend source $i
    }
    set perm [list]
    while {[llength $pat]} {
        set i [lindex $pat end]
        set pat [lrange $pat 0 end-1]
        lappend perm [lindex $source $i]
        set source [lreplace $source $i $i]
    }
    return $perm;
}
 
# n2perm N len : generate the $Nth permutation of $len objects
proc n2perm {N len} {
    return [pat2perm [n2pat $N $len]]
}
 
proc main {} {
    while {[gets stdin _] >= 0} {
        set data [split $_]
        set len [llength $data]
        set numPermutations [factorial $len]
        set last [expr {$len - 1}]
    }
    for {set i 0} {$i < $numPermutations} {incr i} {
        set permutation [list]
        foreach {p} [n2perm $i $last] {
            lappend permutation [lindex $data $p]
        }
        puts $permutation
    }
}
 
main
 
