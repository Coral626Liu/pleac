 # -*- tcl -*-
 
# @@PLEAC@@_NAME
Tcl
 
# @@PLEAC@@_WEB
http://purl.oclc.org/NET/tclhome
 
# @@PLEAC@@_1.0
#-----------------------------
set string {\n}                     ;# two characters, \ and an n
set string "Jon {Maddog} Orwant"    ;# literal braces
#-----------------------------
set string \n                       ;# a "newline" character
set string "\n"                     ;# another "newline" character
set string "Jon \"Maddog\" Orwant"  ;# literal double quotes
set string {Jon "Maddog" Orwant}    ;# literal double quotes, again
#-----------------------------
set a {
This is a multiline string
terminated by an unescaped and
{unnested} right brace (\})
}
#-----------------------------
 
# @@PLEAC@@_1.1
#-----------------------------
set value [string range $string $first $last]
set value [string range $string $first [expr {$first+$num-1}]]
set value [string range $string $first end]
 
set string [string replace $string $first $last $newstring]
set string [string replace $string $first [expr {$first+$num-1}] $newstring]
set string [string replace $string $first end $newtail]
#-----------------------------
 
# get a 5-byte string, skip 3, then grab 2 8-byte strings, then the rest
binary scan $data "A5 x3 A8 A8 A*" leading s1 s2 trailing
 
# Important note: this was all well and good when the Cookbook was 
# written and a character and a byte were the same size.  They still
# are for some programming languages, but Tcl for one uses 16-bit
# Unicode characters to encode strings.
#   The above unpack/scan works for strings containing only character
# codes in the range 0--255, but distorts other strings by truncating
# all codes to 8 bits.
#   To avoid this, the input string can be converted to an 8-bit
# encoding before scanning (\uhhhh is Tcl'ish for Unicode character
# code; each h stands for one hexadecimal digit):
 
set data "H\u2082O is the chemical formula for water"
set utf8data [encoding convertto utf-8 $data]
 
# split at five-byte boundaries (16-bit safe)
set fivers [list]
set temp [encoding convertto utf-8 $string]
while {[binary scan $temp a5a* group tail]} {
    lappend fivers $group
    set temp $tail
}
if {[string length $tail]} { lappend fivers $tail }
 
# To split at five-character boundaries, this is much more
# convenient, *and* 16-bit safe without re-encoding the data
set fivers [regexp -all -inline {.{1,5}} $data]
 
# chop string into individual characters:
# The binary command is a poor choice for this task.
# split is more elegant, and 16-bit safe too.
set chars [split $data {}]
 
#-----------------------------
set string "This is what you have"
#          +012345678901234567890  Indexing forwards (left to right)
#           098765432109876543210- Indexing from end (right to left)
#           note that 0 means 10 or 20, etc. above

# end is a special value that is available in list and string 
# commands.  It is defined as the index of the last element (in 
# lists), or character (in strings).
#   Likewise, end-1 is defined as the element/character
# preceding the last, and so on.
 
set first [string index $string 0]            ;# => "T"
set first [string range $string 0 0]          ;# => "T"
set start [string range $string 5 6]          ;# => "is"
set rest [string range $string 13 end]        ;# => "you have"
set last [string index $string end]           ;# => "e"
set end [string range $string end-3 end]      ;# => "have"
set piece [string range $string end-7 end-5]  ;# => "you"
 
#-----------------------------
set string "This is what you have"
puts $string
# => This is what you have
 
set string [string replace $string 5 6 wasn't]  ;# change "is" to "wasn't"
# => This wasn't what you have
 
set string [string replace $string end-11 end ondrous]
# => This wasn't wondrous
 
set string [string replace $string 0 0]  ;# delete first character
# => his wasn't wondrous
 
set string [string replace $string end-9 end]  ;# delete last 10 characters
# => his wasn'
 
#-----------------------------
# you can test substrings with regular expressions
if {[regexp $pattern [string range $string end-9 end]]} {
    set report "Pattern matches in last 10 characters"
}
 
#-----------------------------
# substitute "at" for "is", restricted to first five characters
regsub -all is [string range $string 0 4] at newstring
set string [string replace $string 0 4 $newstring]
 
#-----------------------------
# exchange the first and last letters in a string
# inelegant solution using substrings
set a "make a hat"
set a "[string index $a end][string range $a 1 end-1][string index $a 0]"
puts $a
# => take a ham
 
# better solution using regexp substitution:
regsub {(.)(.*)(.)} $a {\3\2\1} a
 
#-----------------------------
# extract column with unpack
set a "To be or not to be"
# this solution is not 16-bit safe
binary scan $a "x6 A6" b
puts $b
# => or not
 
# but this one is
set b [string range $a 6 11]
 
#-----------------------------
set b [string range $a 6 7]
set c [string range $a 3 4]
puts $b:$c
# => or:be
 
#-----------------------------
proc cut2fmt args {
    set positions $args
    set template  {}
    set lastpos   1
    foreach {place} $positions {
        append template "A[expr {$place-$lastpos}] "
        set lastpos $place
    }
    append template A*
    return $template
}
 
set fmt [cut2fmt 8 14 20 26 30]
puts $fmt
# => A7 A6 A6 A6 A4 A*
#-----------------------------
 
# @@PLEAC@@_1.2
#-----------------------------
# Perl: use $b if $b is true, else $c
# In Tcl, commands such as if or while require the value of the
# condition expression to be a proper boolean value.  If the 
# value is numeric, 0 is false and anything else is true.  For
# non-numeric strings, "true", "on", or "yes" is true and 
# "false", "off", or "no" is false.  Any other value for the
# condition expression raises an error.
#   The `boolean operators' return either "1" or "0".
 
# use $b if b has characters, else $c
if {[string length $b]} {
    set a $b
} else {
    set a $c
}
 
# use $b if b is nonzero, else $c
if {$b != 0} {
    set a $b
} else {
    set a $c
}
 
# set x to $y if $x has no characters
if {![string length $x]} {
    set x $y
}
 
# set x to $y if $x is zero
if {$x == 0} {
    set x $y
}
 
#-----------------------------
# set a to $b if b exists, else to $c
if {[info exists b]} {
    set a $b
} else {
    set a $c
}
 
#-----------------------------
if {[string length $bar]} {
    set foo $bar
} else {
    set foo "DEFAULT VALUE"
}
 
#-----------------------------
# Perl: $dir = shift(@ARGV) || "/tmp";
set arg [lindex $argv 0]
set argv [lreplace $argv 0 0]
if {[string length $arg]} {
    set dir $arg
} else {
    set dir /tmp
}
 
#-----------------------------
# Perl: $dir = $ARGV[0] || "/tmp";
set arg [lindex $argv 0]
if {[string length $arg]} {
    set dir $arg
} else {
    set dir /tmp
}
 
#-----------------------------
# Perl: $dir = defined($ARGV[0]) ? shift(@ARGV) : "/tmp";
if {[info exists argv] && [llength $argv]} {
    set dir [lindex $argv 0]
    set argv [lreplace $argv 0 0]
} else {
    set dir /tmp
}
 
#-----------------------------
# Perl: $dir = @ARGV ? $ARGV[0] : "/tmp";
if {[llength $argv]} {
    set dir [lindex $argv 0]
} else {
    set dir /tmp
}
 
#-----------------------------
# Perl: $count{ $shell || "/bin/sh" }++;
if {![string length $shell]} {
    set shell /bin/sh
}
if {[info exist count($shell)]} {
    incr count($shell)
} else {
    set count($shell) 1
}
 
#-----------------------------
# find the user name on Unix systems
if {![catch {string length $env(USER)}]} {
    set user $env(USER)
} elseif {![catch {string length $env(LOGIN)}]} {
    set user $env(LOGIN)
} else {
    set user "Unknown user"
}
# The catch command intercepts errors raised.  In this
# case catch is used as an alternative idiom to 
# info exists <var>.
# The pros and cons of the different idioms is 
# discussed at <URL: http://mini.net/tcl/1322.html>.

# needs extension to check getlogin() and getpwuid()
 
#-----------------------------
if {![string length $starting_point]} {
    set starting_point Greenwich
}
 
#-----------------------------
# copy list only if empty
if {![llength $a]} {
    set a $b
}
 
# assign b if nonempty, else c
if {[llength $b]} {
    set a $b
} else {
    set a $c
}
#-----------------------------
 
# @@PLEAC@@_1.3
#-----------------------------
# cross-assignment
foreach {b a} [list $a $b] break
 
#-----------------------------
# cross-assignment with temp
set temp $a
set a $b
set b $temp
 
#-----------------------------
set a alpha
set b omega
foreach {b a} [list $a $b] break
 
#-----------------------------
foreach {alpha beta production} [list January March August] break
# move beta       to alpha,
# move production to beta,
# move alpha      to production
foreach {alpha beta production} [list $beta $production $alpha] break
#-----------------------------
 
# @@PLEAC@@_1.4
#-----------------------------
# works for 16-bit Unicode characters
set num [scan $char %c]
set char [format %c $num]
 
#-----------------------------
# works for 16-bit Unicode characters
format "Number %d is character %c" $num $num
# => "Number 101 is character e"
 
#-----------------------------
# works for 8-bit characters (skip encoding change) and
# 8-bit encodings of Unicode characters
set utf8data [encoding convertto utf-8 $string]
binary scan $utf8data c* codelist
 
set utf8data [binary format c* $codelist]
set string [encoding convertfrom utf-8 $utf8data]
 
#-----------------------------
set char_code [scan e %c]      ;# now 101
set character [format %c 101]  ;# now "e"
 
#-----------------------------
puts [format "Number %d is character %c" 101 101]
 
#-----------------------------
binary scan sample c* char_codes
puts $char_codes
# => 115 97 109 112 108 101
 
set word [binary format c* $char_codes]
set word [binary format c* [list 115 97 109 112 108 101]] ;# same
puts $word
# => sample
 
#-----------------------------
set hal HAL
binary scan $hal c* codes
foreach {num} $codes {
    lappend newcodes [incr num]
}
set ibm [binary format c* $newcodes]
puts $ibm
# => prints "IBM"
     
#-----------------------------
     
# @@PLEAC@@_1.5
#-----------------------------
set a [split $string {}]
 
# works for 8-bit characters and 8-bit encodings
# of Unicode characters
set utf8data [encoding convertto utf-8 $string]
binary scan $utf8data c* a
 
#-----------------------------
 
# with -line, . never matches newline
foreach ch [regexp -inline -all -line . $string] {
    # do something with $ch
}
#-----------------------------
 
array set seen [list]
set string "an apple a day"
foreach {char} [split $string {}] {
    if {[info exists seen($char)]} {
        incr seen($char)
    } else {
        set seen($char) 1
    }
}
puts "unique chars are: [lsort [array names seen]]"
# => unique chars are: { } a d e l n p y
#-----------------------------
 
array set seen [list]
set string "an apple a day"
foreach {byte} [regexp -inline -all -line . $string] {
    if {[info exists seen($byte)]} {
        incr seen($byte)
    } else {
        set seen($byte) 1
    }
}
puts "unique chars are: [lsort [array names seen]]"
# => unique chars are: { } a d e l n p y
#-----------------------------
 
# simplistic checksum calculation
set sum 0
binary scan $string c* codes
foreach {code} $codes {
    incr sum $code
}
puts "sum is $sum"
# => sum is 1248
# if $string was "an apple a day"
#-----------------------------
 
#-----------------------------
# ...I pass on the checksum tricks...
#-----------------------------
 
#-----------------------------
# slowcat - emulate a   s l o w   line printer
# usage: slowcat [-DELAY] [files ...]
set delay 1
if {[info exists argv] && [llength $argv]} {
    if {[regexp {^-([.\d]+)} [lindex $argv 0] match delay]} {
        set argv [lreplace $argv 0 0]
    }
}
fconfigure stdout -buffering no
if {[info exists argv] && [llength $argv]} {
    foreach {arg} $argv {
        set f [open $arg]
        lappend channels $f
    }
} else {
    set channels stdin
}
foreach {chan} $channels {
    while {[gets $chan line] > -1} {
        foreach {ch} [split $line {}] {
            puts -nonewline $ch
            after [expr {int(5 * $delay)}]
        }
        puts {}
    }
}
#-----------------------------
 
# @@PLEAC@@_1.6
#-----------------------------
set revchars {}
for {set i [expr {[string length $string]-1}]} {$i >= 0} {incr i -1} {
    append revchars [string index $string $i]
}
 
#-----------------------------
# this works for strings that do not
# contain list symbol characters, see below
set revwords {}
for {set i [expr {[llength $string]-1}]} {$i >= 0} {incr i -1} {
    lappend revwords [lindex $string $i]
}
 
#-----------------------------
# reverse letters in string
set gnirts {}
for {set i 0} {$i < [string length $string]} {incr i} {
    append gnirts [string index $string end-$i]
} ;# end for (i)
 
# reverse elements in words
set sdrow {}
for {set i 0} {$i < [llength $words]} {incr i} {
    lappend sdrow [lindex $words end-$i]
} ;# end for (i)
 
#-----------------------------
# reverse word order where list symbols appear (braces, double quotes)
set words [split "Yoda said, \"can you see this?\""]
set revwords {}
for {set i 0} {$i < [llength $words]} {incr i} {
    lappend revwords [lindex $words end-$i]
} ;# end for (i)
puts [join $revwords]
# => this?" see you "can said, Yoda
 
#-----------------------------
# this solution is equivalent to the previous one
set revwords {}
set list [split $string " "]
for {set i [expr {[llength $list]-1}]} {$i >= 0} {incr i -1} {
    lappend revwords [lindex $list $i]
}
set revwords [join $revwords " "]
 
#-----------------------------
proc reverse {string} {
    for {set i [expr {[string length $string]-1}]} {$i >= 0} {incr i -1} {
        append res [string index $string $i]
    }
    return $res
}
set word reviver
set is_palindrome [string equal $word [reverse $word]]
# => 1
set word revive
set is_palindrome [string equal $word [reverse $word]]
# => 0
#-----------------------------
 
# @@PLEAC@@_1.7
#-----------------------------
# substitute spaces for tabs
while {[regexp -indices {\t+} $string where]} {
    foreach {first last} $where break
    regsub {\t+} $string \
        [string repeat { } [expr {8*($last-$first+1)-$first%8}]] string
}
 
#-----------------------------
# There is a standard module for exanding/collapsing
# tabs, but all it does is straight substitution;
# tabs <-> N spaces. (tcllib 1.0)
package require textutil

set expandedText [::textutil::tabify::untabify $collapsedText]
set collapsedText [::textutil::tabify::tabify $expandedText]
 
#-----------------------------
package require textutil

while {[gets stdin line] >= 0} {
    puts [::textutil::tabify::untabify $line 4]
}
 
package require textutil

while {[gets stdin line] >= 0} {
    puts [::textutil::tabify::tabify $line]
}
#-----------------------------
 
# @@PLEAC@@_1.8
#-----------------------------
#You owe $debt to me.
#-----------------------------
 
# Use subst if all variables are expected to be in scope:
puts [subst $string]
 
#-----------------------------
# uplevel the command as required if the variables 
# exist in an enclosing scope:
uplevel puts [list [subst $string]]
 
#-----------------------------
foreach {rows cols} {24 80} break
set text {I am $rows high and $cols long} ;# braces prevent substitution
set text [subst $text]
puts $text
# => I am 24 high and 80 long
 
#-----------------------------
set string "I am 17 years old"
regsub -all {(\d+)} $string {[expr {\1*2}]} string
subst $string
# => I am 34 years old
 
#-----------------------------
# expand variables in $text, but put an error message in
# if the variable isn't defined.
# This code assumes that the variables exist in an 
# enclosing scope; if not, remove the [uplevel]s.
while {[regexp {\$(\w+)} $text match var]} {
    if {[uplevel info exists $var]} {
        regsub \\$match $text [uplevel set $var] text
    } else {
        regsub \\$match $text "\[NO VARIABLE: $var\]" text
    }
}
#-----------------------------
 
# @@PLEAC@@_1.9
#-----------------------------
set big [string toupper $little]
# "bo peep" -> "BO PEEP"
set little [string tolower $big]
# "BO PEEP" -> "bo peep"
set Title [string totitle $little]
# "bo peep" -> "Bo peep"
 
#-----------------------------
set big [string toupper $little 0]
# "bo peep" -> "Bo peep"
set little [string tolower $big 0]
# "Bo Peep" -> "bo Peep"
 
#-----------------------------
# capitalize each word's first character, downcase the rest
set text "thIS is a loNG liNE"
set text [string tolower $text]
set pos 0
while {[regexp -indices -start $pos {(\w+)} $text where]} {
    foreach {first last} $where break
    set text [string toupper $text $first]
    set pos $last
    incr pos
}
# => This Is A Long Line
 
#-----------------------------
# case insensitive string comparison
string equal -nocase $a $b
 
#-----------------------------
# randcap: filter to randomly capitalize 20% of the letters
set pos 0
while {[regexp -indices -start $pos {(\w)} $text where]} {
    foreach {first last} $where break
    if {rand()<=0.2} {
        set text [string toupper $text $first]
    } else {
        set text [string tolower $text $first]
    }
    set pos $last
    incr pos
}
# =>
# 001:001 in the bEginnInG God CreatEd the Heaven aNd The eaRth.
# 
# 001:002 and ThE earth wAs wIthout form, aNd voId; aNd darkness was
#         uPoN The faCE Of the deEP. aNd the spirIt of god moved uPon
#         the facE of thE wATers.
#
# 001:003 AnD god SAiD, let tHere be lIght: and TheRe was light.
#-----------------------------
 
# @@PLEAC@@_1.10
#-----------------------------
# Interpolating functions and expressions within strings
set answer $var1[func]$var2
#-----------------------------
set phrase "I have [expr {$n + 1}] guanacos."
 
#-----------------------------
some_cmd "What you want is [llength [split $rec :]] items"
 
#-----------------------------
set text {
To: $naughty
From: Your Bank
Cc: [get_manager_list $naughty]
Date: [clock format [clock seconds]] (today)
 
Dear $naughty,
 
Today, you bounced check number [expr {500 + int(rand()*100)}] to us.
Your account is now closed.
 
Sincerely,
the management
}
if {![send_mail $text $target]} {
    error "Couldn't send mail"
}
#-----------------------------
 
# @@PLEAC@@_1.11
#-----------------------------
# all in one
regsub -line -all {^\s+} {
    your text
    goes here
} {} var
 
# or with two steps
set var {
    your text
    goes here
}
regsub -line -all {^\s+} $var {} var
 
#-----------------------------
regsub -line -all {^\s+} {
    The five varieties of camelids
    are the familiar camel, his friends
    the llama and the alpaca, and the
    rather less well-known guanaco
    and vicuña.
} {} definition
 
#-----------------------------
proc fix {string} {
    regsub -line -all {^\s+} $string {} string
    return $string
}
puts [fix {
    My stuff goes here
}]
 
#-----------------------------
regsub -line -all {^\s+} {
    ...we will have peace, when you and all your works have
    perished--and the works of your dark master to whom you would
    deliver us. You are a liar, Saruman, and a corrupter of men's
    hearts.  --Theoden in /usr/src/perl/taint.c
} {} quote
# move attribution to line of its own
regsub {\s+--} $quote \n-- quote
 
#-----------------------------
dequote {
    @@@ int
    @@@ runops() {
    @@@     SAVEI32(runlevel);
    @@@     runlevel++;
    @@@     while ( op = (*op->op_ppaddr)() ) ;
    @@@     TAINT_NOT;
    @@@     return 0;
    @@@ }
}
# add more code here if you want
 
#-----------------------------
dequote {
   Now far ahead the Road has gone,
      And I must follow, if I can,
   Pursuing it with eager feet,
      Until it joins some larger way
   Where many paths and errands meet.
      And whither then? I cannot say.
            --Bilbo in /usr/src/perl/pp_ctl.c
}
 
#-----------------------------
proc quotemeta {string} {
    regsub -all {(\W)} $string {\\\1} string
    return $string
}
 
proc dequote {text} {
    if {[regexp -line {^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+(?:\s*)$} $text m 1 2]} {
        set white $2
        set leader [quotemeta $1]
    } else {
        regexp -line {^\n?(\s+)} $text m white
        set leader {}
    }
    regsub -line -all ^\\s*?$leader\(?:$white\) $text {} text
    return [string trimright $text]\n
}
#-----------------------------
 
# @@PLEAC@@_1.12
#-----------------------------
# The tcllib 1.0 textutil module can adjust text
# to a specified line length, justify left, right,
# and plain, and fill lines to the right margin.
# However, it can't add indentation.
 
# A naive implementation of wrap.  Arguments:
# text	the text
# col	the line length (default 72)
# lead	first line indentation (def empty string)
# follow	indentation for following lines (def empty string)
proc wrap {text {col 72} {lead {}} {follow {}}} {
    set newtext {}
    set text $lead[string trimleft $text]
    set upto $col
    while {![string is wordchar [string index $text $upto]]} {incr upto -1}
    set upto [string wordstart $text $upto]
    if {$upto == 0} {
        set upto [string wordend $text $upto]
    } else {
        incr upto -1
    }
    append newtext [string range $text 0 $upto]\n
    set text [string replace $text 0 $upto]
    while {[string length $text]} {
        set text $follow[string trimleft $text]
        if {[string length $text] > $col} {
            set upto $col
            while {![string is wordchar [string index $text $upto]]} {incr upto -1}
            set upto [string wordstart $text $upto]
            if {$upto == 0} {
                set upto [string wordend $text $upto]
            } else {
                incr upto -1
            }
            append newtext [string range $text 0 $upto]\n
            set text [string replace $text 0 $upto]
        } else {
            append newtext $text
            set text {}
        }       
    }
    return $newtext
}
 
set input [concat "Folding and splicing is the work of an editor," \
      "not a mere collection of silicon" \
      "and" \
      "mobile electrons!"]
puts [string repeat 0123456789 2]
puts [wrap $input 20 {    } {  }]
# =>
# 01234567890123456789
#     Folding and 
#   splicing is the 
#   work of an 
#   editor, not a 
#   mere collection 
#   of silicon and 
#   mobile electrons!
return [wrap $input 20 {    } {  }]
#-----------------------------
 
# @@PLEAC@@_1.13
#-----------------------------
# backslash
set pattern {}
append pattern {([} $charlist {])}
regsub -all $pattern $var {\\\1} var
 
# double
set pattern {}
append pattern {([} $charlist {])}
regsub -all $pattern $var {\1\1} var
 
#-----------------------------
set string {Mom said, "Don't do that."}
regsub -all {(['"])} $string {\\\1} string
 
#-----------------------------
set string {Mom said, "Don't do that."}
regsub -all {(['"])} $string {\1\1} string
 
#-----------------------------
regsub -all {([^A-Z])} $string {\\\1} string
# equivalent to:
regsub -all {([^[:upper:]])} $string {\\\1} string
 
#-----------------------------
regsub -all {([^[:alnum:]])} "is a test!" {\\\1} string
set string "this $string"
# => this is\ a\ test\!
#-----------------------------
 
# @@PLEAC@@_1.14
#-----------------------------
regsub {^\s+} $string {} string
regsub {\s+$} $string {} string
set string [string trim $string]
 
#-----------------------------
# The input command, gets, automatically
# strips off newlines.
#-----------------------------
 
# @@PLEAC@@_1.15
#-----------------------------
package require csv
 
set line {XYZZY,,"O'Reilly, Inc","Wall, Larry","a ""glug"" bit",5,"Error, Core Dumped"}
set fields [::csv::split $line]
for {set i 0} {$i < [llength $fields]} {incr i} {
    puts "$i : [lindex $fields $i]"
}
# =>
# 0 : XYZZY
# 1 : 
# 2 : O'Reilly, Inc
# 3 : Wall, Larry
# 4 : a "glug" bit
# 5 : 5
# 6 : Error, Core Dumped
#-----------------------------
