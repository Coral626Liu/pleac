-- -*- haskell -*-

-- @@PLEAC@@_NAME
-- @@SKIP@@ Haskell

-- @@PLEAC@@_WEB
-- @@SKIP@@ http://www.haskell.org/

-- @@PLEAC@@_INTRO
-- @@SKIP@@ Many auxiliary functions can be found in appendix (Helpers).
-- @@SKIP@@ You need hugs98 or ghc (tested with 5.002) and the external library: 
-- @@SKIP@@ http://www.dcs.gla.ac.uk/~meurig/regexp/
-- @@SKIP@@ The time section only work with ghc, s/--ghc // if you have ghc.

-- @@PLEAC@@_APPENDIX
module Pleac where

import Prelude hiding (($),(^))
import Regexp
import List
import Random hiding (split)
import Monad hiding (join,when,unless)
import System
import Complex

-- seems ghc need it for chr,ord, readHex, readOct
import Char 
import Numeric 

--ghc import Time
--ghc import Locale

----------------------------------------------------------------------------------------------------
-- @@PLEAC@@_1.0

str  = "\\n"                             -- two characters, \ and an n
str2 = "Jon 'Maddog' Orwant"             -- in haskell we can do string only with ", no single quote
str3 = "\n"                              -- a "newline" character
str4 = "Jon \"Maddog\" Orwant"           -- literal double quotes
-- no qq stuff or multiline in haskell

-- @@PLEAC@@_1.1
s     = "This is what you have"
first = s![0]                            -- "T"
start = s![5..7]                         -- "is"
rest  = s![13..]                         -- "you have"
las   = s![-1]                           -- "e"
las2  = s#last                           -- "e"
end   = s![-4 .. -1]                     -- "have"
piece = s![-8 .. -5]                     -- "you"


[lead,ss1,ss2,trailing]     = s#unpack [Grab 2, Forward 3, Grab 1, Grab 2, GrabAll] 
-- Regexp with repetition are better for this, why introduce extra concept (unpack)
[lead2,ss12,ss22,trailing2] = s#match "^(..)...(.)(..)(.*)"
fivers                      = s#unpack ((Grab 5)#replicate (s#length `div` 5))
-- in haskell string == [Char] => no need to do  unpack("A1" x length($string), $string)
characters = s

-- can't modify string in haskell
s'    = s#substr 5 2 "wasn't"       -- "This wasn't what you have"
s''   = s'#substr2 (-12) "ondrous"  -- "This wasn't wondrous",note the () arount negative number :(
s'''  = s''#substr 0 1 ""           -- "his wasn't wondrous", delete first character <=> tail
s'''' = s'''#substr2 (-10) ""       -- "his wasn'"  ,delete last 10 characters

m     = if s![-10 .. -1] =~ "have" 
	then putStrLn "Pattern matches in last 10 characters" 
	else return ()
m'    = putStrLn "Pattern matches in last 10 characters" `when` (s![-10 .. -1] =~ "have" )

-- cant do as short as in perl cos cant use affection in haskell
news = s![0..5]#(substS "is" "at" [Global_Match]) ++ s![6..] -- "That at what you have"

a1  = "make a hat"
a1' = a1![-1] ++ a1![1..(a1#length -2)] ++ a1![0] -- "take a ham"

b1 = "to be or not to be"
b2      = b1#unpack [Forward 6, Grab 6]  -- "or not"
[b3,c3] = b1#unpack [Forward 6, Grab 2, Backward 5, Grab 2] -- ["or","be"]

cut2fmt xs = xs#foldl aux (1,[])#snd#(GrabAll:)#reverse 
    where aux (n,l) i = (i,(Grab (i - n)) : l)
fmt = cut2fmt [8,14,20,26,30] -- [Grab 7,Grab 6,Grab 6,Grab 6,Grab 4,GrabAll]


-- @@PLEAC@@_1.2

v3 = "a" ||| "b" -- -> "a"
v4 = ""  ||| "b" -- -> "b"

-- force to put the type :(
v5 = (2::Int) &&& "ee" -- -> "ee"
v6 = (0::Int) &&& "ee" -- -> ""

-- no x ||= y
v3' = v3 ||| v4

dir = argv >>> (\x -> (x ||| ["/tmp"])#head)
-- @@PLEAC@@_1.3
-- no side effect in haskell => swap is a nosense

-- @@PLEAC@@_1.4
i1 = ord 'a'
c1 = chr 97

-- ascii = string.unpack("C*"), string = ascii.pack("C*"), no need in haskell, String = [Char]
--  there is also packedString that are more efficient but less cool cos not list anymore
ibm = "HAL"#map next_char                   -- "IBM"

-- @@PLEAC@@_1.5
s1 = "unique chars are: " ++ ("an apple a day"#unique#sort)
sum1 = ("sum is " ^ s1#map ord#sum)#putStrLn

-- TODO, script.hs HERE


-- @@PLEAC@@_1.6
s2 = s1#reverse

-- can do: s3 = (unwords . reverse . words) s1, or s3 = (words $ reverse $ unwords) s1, or
s3 = s1#words#reverse#unwords 

s3' = s1#split " "#reverse#join " " -- not the same, cos words = split "\s+"
s3''= s1#split "\\s+"#reverse#join " " 

-- eval long_palindromes or long_palindromes >>= (mapM putStrLn)
long_palindromes = cat "/usr/share/dict/words" >>> filter(\s -> s == s#reverse && s#length > 4) 

-- @@PLEAC@@_1.7
-- TODO, must do: \s if s == [] then [] else foldr1 .... ? must make a foldr1sure
expand_tabs = split "\t" $ (foldr1 (\a b -> a ++ (times (8 - a#length `mod` 8) ' ') ++ b)) -- more efficient
-- expand_tabs = fixpoint (break_char '\t' (\a b -> a ++ (' '#times (8 - a#length `mod` 8)) ++ b))
-- expand_tabs "to		andd	audela"
				
-- @@PLEAC@@_1.8
-- cant do that in haskell, too meta, too reflexif

s4 = "I am 17 years old"#subst "\\d+" (\n -> show ((read n) * 2))

-- @@PLEAC@@_1.9
s5 = "bo beep"#upcase
s6 = s5#downcase
s7 = s6#capitalize

s8 = "thIS is a loNG liNE"#words#map capitalize

-- @@PLEAC@@_1.10
--s9 = "I have " ++ (show (10+1)) ++ " guanacos."
s9 = "I have "^10+1^" guanacos."

-- TODO 1.11

-- @@PLEAC@@_1.12
-- in fact this fonction is wrong, cos it insert a space at the front of the sentence (must use a foldl1)
wrap width s = let (all, line) = (words s)#foldl (\ (all, line) w -> 
					    if (line++" "++w)#length > width 
					    then (all++[line], w)
					    else (all, line++" "++w)
					    ) ([],"") in
	       join "\n" (all++[line])

-- TODO 1.13

-- @@PLEAC@@_1.14
s10 = "    titi"#substS "^\\s+" "" []
s11 = "  titi  "#substS "\\s+$" "" []

trim = substS "^\\s+" "" [] . substS "\\s+$" "" []

-- TODO 1.15
----------------------------------------------------------------------------------------------------
-- @@PLEAC@@_2.1
is_integer s = if s =~ "^[+-]?\\d+$" 
	       then putStrLn "is an integer"
	       else putStrLn "is not"
m0 s = do putStrLn "has non digits" `when`   (s =~ "[^\\d]") -- no \D
	  putStrLn "not a natural"  `unless` (s =~ "^\\d+$")
	  putStrLn "not an integer" `unless` (s =~ "^-?\\d+$")
	  putStrLn "not an integer" `unless` (s =~ "^[+-]?\\d+$")
	  putStrLn "not a decimal"  `unless` (s =~ "^-?\\d+\\.\\d*$")
	  putStrLn "not a float"    `unless` (s =~ "^[+-]?\\d+((\\.\\d+([eE]-?\\d+)?)|([eE]-?\\d+))$")
-- in haskell, regexp are first class, then can be appended, sometimes easier to read
m0' s = let sign       = "-"
	    opt_sign   = sign ++ "?"
	    dec_number = "\\d+"
	    integer    = opt_sign ++ dec_number
	    exp        = "eE" ++ opt_sign ++ dec_number
	    real       = "(" ++ opt_sign ++ dec_number ++ "\\." ++ dec_number ++ exp ++"?" ++ ")" ++
			 "|" ++ "(" ++ opt_sign ++ dec_number ++ exp ++ ")" in
	    do putStrLn "not a natural"  `unless` (s ==~ dec_number)
	       putStrLn "not an integer" `unless` (s ==~ integer)
	       putStrLn "not a decimal"  `unless` (s ==~ (integer ++ "\\." ++ dec_number))
	       putStrLn "not a float"    `unless` (s ==~ real)

m0test = m0 "124"      

-- @@PLEAC@@_2.2
equal_num n1 n2 nbdecimal = (abs (n1 - n2)) < 1 / (10 ^^ nbdecimal)
eqnum = equal_num 10.001 10.002 4 -- with 3 give True cos 10.001 - 10.002 != 0.001 but 0.000999

wage = 536          -- $5.36/hour
week = 40 * wage    -- $214.40
weekwage = putStrLn ("One week's wage is: $"++show_float 2 (tonum week/100.0))

-- @@PLEAC@@_2.3
i = 2.3#round
a2  = 0.255
sa2 = show_float 2 a2
mprinta = putStrLn ("Unrounded: "^a2^"\nRounded: "^sa2)

-- TODO, i dont exactly produce the good ouput, negative number are not centered
mprintfloat = do putStrLn "number\tint\tfloor\tceil"
		 [3.3 , 3.5 , 3.7, -3.3]#mapM(\n -> putStrLn ((show_float 1 n)^"\t"^
							      (n#round)^"\t"^
							      (n#floor)^"\t"^
							      (n#ceiling)))

-- @@PLEAC@@_2.4
-- TODO? not exacly this, as 54 = 110 110 we dont see the pb of big endian
bin2i xs = aux 1 (reverse xs)
    where aux power []     = 0
	  aux power (x:xs) = aux (2*power) xs+(if x == '0' then 0 else power)
bin2i' xs = xs#reverse#map (\c -> read [c])#zipWith (\a b -> b*(2^^a)) [0..]#sum
i10 = bin2i' "0110110" -- 54

i2bin i = if i == 0 then "0" else aux i
	  where aux i = if i == 0  then "" else aux (i `div` 2) ++ show (i `mod` 2)
bin10 = i2bin 54 -- "110110"

-- @@PLEAC@@_2.5
m1 = putStr "Infancy is: " >> [0..2]#mapM(\e -> putStr (e^" "))
m2 = putStr "Infancy is: " >> [0..2]#map show#unwords#putStr

-- TODO, 2.6, cf code from clf


-- @@PLEAC@@_2.7
ran = rand (25, 75)

chars = concat [['A'..'Z'],['a'..'z'],['0'..'9'],"!@$%^&*"]

--password = [1..8]#foldM (\a _ -> rand (0, chars#length) >>= (\i -> return (a++chars![i]))) "" 
--password = [1..8]#mapM (\_ -> rand (0, chars#length) >>= (\i -> return (chars!!i)))
password = [1..8]#mapM (\_ -> rand (0, chars#length) >>> (chars!!)) -- no join, string = [Char] :) hihi section :)

-- @@PLEAC@@_2.8
randfixed = do srand 2
	       rand(1,10)

-- @@PLEAC@@_2.9
-- uses a Perl module.., in haskell too you can provide your own random generator by
-- playing with the StdGen type

-- @@PLEAC@@_2.10
gaussian_rand = do r1 <- stdrand
		   r2 <- stdrand
		   let u1 = 2 * r1 - 1
		       u2 = 2 * r2 - 1
		       w  = u1*u1 + u2*u2 in
		       if w >= 1 then gaussian_rand
		       else let w2 = sqrt ((-2 * log w)/w) in
				return [u2*w2, u1*w2]

mean = 25
sdev = 2
salary = gaussian_rand >>> (\l -> l#head * (tonum sdev) + (tonum mean))
msalary = do r <- salary
	     putStrLn ("You have been hired at $"^show_float 2 r)

-- @@PLEAC@@_2.11
deg2rad d = d * pi / 180
rad2deg r = r * 180 / pi

-- @@PLEAC@@_2.12
sin_val = sin(pi)
cos_val = cos(pi)
tan_val = tan(pi)

asin_val = asin(1)
acos_val = acos(1)

-- @@PLEAC@@_2.13
log_e = log(10)
log_10 = log10 100 -- 2

-- in haskell we dont have by default log10 but we have logBase
log10 = logBase 10

answer = logBase 10 10000
mlog = putStrLn ("log10(10,000)="^answer)

-- @@PLEAC@@_2.14
matrixa = Matrix[[3, 2, 3], 
		 [5, 9, 8]]
matrixb = Matrix[[4, 7], 
		 [9, 3], 
		 [8, 1]]
matrixc = matrixa * matrixb

masize = matrixa#row_size
mbsize = matrixa#column_size

--TODO,transposed = matrixc#transpose
--determined = matrixa#det

-- @@PLEAC@@_2.15
ca = 3 :+ 5
cb = 2 :+ -2
mcomplex = putStrLn ("c = "^(ca*cb))
cc = ca*cb
cd = 3 + 4*complex_i

mcomplex2 = putStrLn ("sqrt("^cd^") = "^sqrt cd)

-- @@PLEAC@@_2.16
i2 = hex "0x45"
i3 = oct "0o45"

m3 = do putStrLn "Gimme a number in decimal, octal, or hex: "
	s <- getLine
	let i = s#pattern_matches [("^0x", hex s),("^0o", oct s),("", read s)] in
		putStrLn (concat [show i," ",tohex i," ", tooct i,"\n"])
-- no printf :((

m3' = do putStrLn "Enter file permission in octal: "
	 permissions <- getLine
	 putStrLn ("The decimal value is "^permissions#oct)


-- @@PLEAC@@_2.17
commify s = if s#length <= 3 then s else 
	    let (a,b) = splitAt (s#length -3) s in commify a ++ "," ++ b

----------------------------------------------------------------------------------------------------
--ghc -- @@PLEAC@@_3.0
--ghc mtime1 = now >>= (\d -> putStrLn (calendarTimeToString d))
--ghc mtime2 = do d <- now
--ghc 		  putStrLn ("Today is day "^d#ctYDay^" of the current year")
--ghc 		  putStrLn ("Today is day "^d#ctDay^ " of the current month")
--ghc 
--ghc 
--ghc -- @@PLEAC@@_3.1
--ghc (day,month,year) = (now >>> ctDay, now >>> ctMonth, now >>> ctYear)
--ghc tl = now >>= localtime
--ghc 
--ghc mtime3 = do date <- tl
--ghc 		  putStrLn ("The current date is "^date#ctYear^" "^date#ctMonth^" "^date#ctDay)
--ghc 
--ghc mtime4 = do d <- now
--ghc 		  putStrLn (strftime "%Y-%m-%d" d)
--ghc 
--ghc -- TODO 3.2, 3.3
--ghc 
--ghc -- @@PLEAC@@_3.4
--ghc add_sec sec d = d#toClockTime#addToClockTime (nulltime {tdSec= sec})
--ghc when_ = now >>> (\d -> d#add_sec 100)
--ghc then_ = now >>> (\d -> d#add_sec (-100))
--ghc 
--ghc -- @@PLEAC@@_3.5, TODO, not complete
--ghc bree = 361535725
--ghc nat  =  96201950
--ghc 
--ghc differenc = bree - nat
--ghc mtime5 = putStrLn ("there were "^differenc^"seconds between Nat and Bree")
--ghc 
--ghc seconds = differenc `mod` 60
--ghc differenc' = (differenc - seconds) `div` 60
--ghc minutes = differenc' `mod` 60
--ghc differenc2 = (differenc' - minutes) `div` 60
--ghc hours   = differenc2 `mod` 24
--ghc differenc3 = (differenc2 - hours) `div` 24
--ghc days    = differenc3 `mod` 7
--ghc weeks   = (differenc3 - days) `div` 7
--ghc 
--ghc -- (438 weeks, 4 days, 23:49:35)
--ghc mtime6 = putStrLn ("("^weeks^" weeks, "^days^" days, "^hours^":"^minutes^":"^seconds^")")
--ghc 
--ghc -- @@PLEAC@@_3.6
--ghc (monthday, weekday, yearday) = (now >>> ctDay, now >>> ctWDay, now >>> ctYDay)
--ghc 
--ghc weeknum = now >>> (\d -> d#strftime "%U"#read + 1)
--ghc 
--ghc -- @@PLEAC@@_3.9
--ghc usec = now >>> ctPicosec -- is this ?
--ghc 
--ghc -- @@PLEAC@@_3.10
--ghc -- have sleep::Int but not Double :(

----------------------------------------------------------------------------------------------------
-- @@PLEAC@@_4.0
single_level = [ "this", "that", "the", "other" ]
-- can make nested list, but must all have the same depth

-- @@PLEAC@@_4.1
a  = ["quick", "brown", "fox"]
a' = "Why are you teasing me?"#words
-- no multiline in haskell

big_array = cat "pleac.hs" 
name1 = "toto"
banner_scalar = "Speak, "^name1^" and welcome!"

his_host = "www.haskell.org"
host_info = exec ("host "^his_host)

psinfo1 = exec ("ps $$") -- that's the new shell's $$
banner_array1 = ["Costs","only","$4.95"]
banner_array2 = "Costs only $4.95"#words
banner_array3 = "Costs only $4.95"#split " "

-- @@PLEAC@@_4.2
commify_series :: [String] -> String
commify_series []  = ""
commify_series [x] = x
commify_series xs  = join ", " (init xs)  ++ " and " ++ (last xs)
-- commify_series ["cava", "etoi","ouais"] => "cava, etoi and ouais"

array = ["red", "yellow", "green"]
s12 = "I have "++commify_series array++" marbles"
marray1 = putStrLn ("I have "^(concat  array)^" marbles") -- I have redyellowgreen marbles
marray2 = putStrLn ("I have "^(unwords array)^" marbles") -- I have red yellow green marbles



-- @@PLEAC@@_4.3
-- grow/shring the array by assigning nil to past the end of array
change_size n xs = if n <= xs#length then take n xs
		   else xs++(null_val#replicate (n - xs#length))

change_val ix e xs = let xs' = if ix <= xs#length then xs else change_size ix xs in
			 xs'![0..ix-1]++[e]++xs'![ix+1..]
		     
array2 = array#change_size 5
array3 = array#change_val 5 "toto"

array4 = "toto"#replicate 5

what_about_that_array x = 
    "The array now has "^length x^"elements.\n"^
    "The index of the last element is "^length x - 1^".\n"^
    "Element #3 is`"^x!!3^"'.\n"

s13 = "Crosby Stills Nash Young"#words#what_about_that_array

-- @@PLEAC@@_4.4
-- in hugs even this take time :), sort is insertion sort :) by default
m4 = env >>= (\l -> l#keys#sort#mapM(\var -> (var ^"=" ^ (l@@var))#putStrLn))
m5 = env >>= (\l -> l#mapM(\(var,val) -> (var^"="^val)#putStrLn)) -- but non-sorted
m6 = env >>= (\l -> l#sortBy(\(a,_) (b,_) -> a <=> b)#mapM(\(var,val) -> (var^"="^val)#putStrLn))

-- @@PLEAC@@_4.5
-- not relevant in Haskell since we have always kind of references


-- @@PLEAC@@_4.6
users  = exec "who" >>> map (words $ head) $ sort $ unique
users2 = exec "who" >>> map (match "(\\w+)" $ head) $ sort $ unique
-- cant do as short as ruby: puts("users logged in: #{commify_series(users)}")
--  monad are too intrusive and we need to introduce an extra var l, :(((  
m10 = do l <- users 
         putStrLn ("users logged in:"++(commify_series l))

-- @@PLEAC@@_4.7
l1 = [1..5] `difference` [2,5] -- could make [1..5] - [2,5], just have to make an instance Num

instance (Eq a,Show a) => Num ([a]) where
    (+) a b = a `union` b
    (-) a b = a `difference` b
    (*) a b = a `intersect` b

l1' = [1..5] - [2,5]

-- @@PLEAC@@_4.8
l2 = [1..5]
l3 = [2,5,7]
l4 = l2 `union` l3
l4' = l2 + l3
l5 = l2 `intersect` l3
l5' = l2 * l3
l6 = difference (union l2 l3) (intersect l2 l3)
l6' = (l2 + l3) - (l2 * l3)

-- @@PLEAC@@_4.9
members = ["Times","Flies"]
initiates = ["An", "Arrow"]
newmembers  = members ++ initiates
newmembers2 = members#insert_at 2 ("Like":initiates)

newmembers3 = members#replace [(0, "Fruit")]
newmembers4 = members#replace [(2, "Fruit"),(3,"Banana")]

-- @@PLEAC@@_4.10

reversed = [1..5]#reverse
array5 = [3,2,5,1]
descending  = array5#sort#reverse
descending' = array5#sortBy (\a b -> b <=> a)
descending2 = array5#sortBy (flip (<=>))

-- @@PLEAC@@_4.11
-- remove n elements from front of ary (shift n)
(front,newarray) = array5#splitAt 1

-- remove n elements from the end of ary (pop n)
(newarray',end')  = array5#splitAt (array5#length - 1)


shift2 (x:y:ys) = ((x,y),ys) -- shift2 = zip ... shift ... TODO
pop2 xs = let (a,[x,y]) = splitAt (xs#length -2) xs in ((x,y),a)


friends = "Peter Paul Mary Jim Tim"#words
((this, that), newfriends) = friends#shift2

beverages = "Dew Jolt Cola Sprite Fresca"#words
(pair,newbeverages) = beverages#pop2

-- @@PLEAC@@_4.12
data Employee = Employee {category,name:: String, income::Int} deriving (Show,Eq)
employees = [Employee {category="neuneu",name="ben",income=1000}
	    ,Employee {category="neuneu",name="pixel",income=1000}
	    ,Employee {category="engineer",name="pad",income=27000}
	    ,Employee {category="engineer",name="guit",income=100000}
	     ]
-- can do also with classic assoc list
-- employees = [("ben","neuneu1"),("pixel","neuneu2"),("pad","engineer"),("guit","engineer")]
-- category = snd
-- name = fst
(Just highest_engineer) = employees#find(\employee -> employee#category == "engineer")

s14 = "Highest paid engineer is: "++ highest_engineer#name


-- @@PLEAC@@_4.13
bigs = [5..200]#filter (>50) -- hihi section :)

matching  = exec "who" >>> filter (=~ "^gnat")

engineers  = [ x | x <- employees, category x == "engineer"]
engineers' = employees#filter (\x -> category x == "engineer")

secondary_assistance = employees#filter(\x -> x#income >= 26000 && x#income < 30000)

-- @@PLEAC@@_4.14
-- normally you would have an array of Numeric (Float or
-- Fixnum or Bignum), so you would use:
sorted1 = [11,5,2,8]#sort

-- if you have strings representing Integers or Floats
-- you may specify another sort method (not lexicographic ordering):
sorted2  = ["11","5","1","8"]#sort -- ["1","11","5","8"]
sorted2' = ["11","5","1","8"]#sortBy (\a b -> ((read a)::Int) <=> read b) -- ["1","5","8","11"]

-- cant inline expression :(
pidsorted = do ps <- exec "ps ux" 
	       myenv <- env
	       ps![1..] -- avoid the indication string: USER TTY ....
		     #filter (=~ (myenv@@"USER"))
		     #map (words $ (!!1))
		     #sortBy (\a b -> ((read a)::Int) <=> read b)
		     #mapM_ putStrLn
			 
mkill = do putStr "Select a process ID to kill:"	   
	   pids <- getLine
	   (putStrLn "Exiting" >> exit 0) `unless` (pids =~ "\\d+")
	   _ <- exec ("kill "^pids)
	   _ <- exec ("sleep 2")
	   exec ("kill -9 "^pids)

unordered = [1,-3,2,6]
ordered = unordered#sort
precomputed = unordered#map (\e -> [abs e, e])
ordered_precomputed = precomputed#sortBy (\a b -> (a!!0) <=> (b!!0))
ordered' = ordered_precomputed#map (!!1)

ordered'' = unordered#map (\e -> [abs e,e])#sortBy (\a b -> (a!!0) <=> (b!!0))#map (!!1)

employee_sorted = employees#sortBy (\a b -> (a#name) <=> (b#name))

musers  = cat "/etc/passwd" >>= (map (split ":" $ head) $ sort $ mapM putStrLn)
musers' = cat "/etc/passwd" >>= (\x -> x#map (\l -> l#split ":"#head)#sort#mapM putStrLn)
----------------------------------------------------------------------------------------------------
-- @@PLEAC@@_APPENDIX
----------------------------------------------------------------------------------------------------
-- to allow s![1..]
-- note: a 'try (...) with' would be more efficient that constantly check for array bound
-- note: we stop as soon as we have a big index => xs ! [1000, 2,3] if length xs < 1000 will give [] 
--   (to handle infinite list)
(!) :: [b] -> [Int] -> [b]
(!) xs [] = []
(!) xs (i:is) | i >= length xs = [] -- handle infinite list
	      | i < 0          = xs!!(length xs + i) : xs!is
	      | otherwise      = xs!!i : xs!is
-- TODO allow s![-4..]

-- less expressive, more elegant
(!!!) :: [b] -> [Int] -> [b]
(!!!) xs = map (xs !!) -- (!!!) xs is = map (xs !!) is

----------------------------------------------------------------------------------------------------
substr start len insert s = 
    if start >= 0 then s![0..start-1] ++ insert ++ s![start+len..] -- [0.. -1] -> []
    else s![0..(length s + start -1)] ++ insert ++ s![start+len.. -1]
--substr s start len insert = take s start ++ insert ++ s![start+len..]
substr2 start insert s = substr start (if start >= 0 then (length s - start) else -start) insert s

data Unpack_option = Grab Int 
		   | Forward Int 
		   | Backward Int 
		   | GrabAll 
		     deriving Show
unpack :: [Unpack_option] -> [a] -> [[a]]
unpack opt s = opt#(foldl aux (0,[]))#snd#reverse --(snd $ reverse) (foldl aux (0,[]) opt)
    where aux (n,l) (Grab i)      = (n+i, s![n..n+i-1] : l)
	  aux (n,l) (Forward i)   = (n+i, l)
	  aux (n,l) (Backward i)  = (n-i, l)
	  aux (n,l) GrabAll       = (length s + 1, s![n..] : l)
-- could do a foldr so that no need reverse but need reverse opt
-- could to a str2Unpack_option so that str2Unpack_option "A5 A*" => [Grab 5,GrabAll]
----------------------------------------------------------------------------------------------------

-- use http://www.dcs.gla.ac.uk/~meurig/regexp/ for substS, ...
subst re f s = let matchresult = searchS re [] s in
		   if matchedAny matchresult then 
		      beforeMatch matchresult ++ 
		      f (wholeMatch matchresult) ++ 
		      afterMatch matchresult
		   else s

(=~) s re = let matchresult = searchS re [] s in
	    matchedAny matchresult
(==~) s re = s =~ ("^"++s++"$")

-- the Regexp lib require regexp of the form   " var@(...) var2@(...)" i dont
-- like put name on this, prefer anonymous as in perl, that is "(...) (...)"
match re s = let (max,re2) = re#foldl (\(i,acc) c -> 
			    if c == '(' then (i+1,acc++" "++show i++"@(") else (i,acc++[c])
				   ) (1,[])
		 matchresult = searchS re2 [] s
		 -- there is a pb cos in match "(\\w+)=(.*)" "MAIL=", we dont get ["MAIL",""]
		 -- but only ["MAIL"], the lib does not handle well empty match
		 subs  = allSubexps matchresult
		 subs2 = if   (subs#length > 0  && subs#last#fst /= show (max-1))
			     ||(subs#length == 0 && max > 1)
			  then subs++[(show (max-1),"")]
			  else subs
		 subs3 = subs2#foldl (\(i,acc) (j,str)-> 
			      if show i == j then (i+1, acc++[str])
			      else ((read j)+1, acc++replicate ((read j)-i) ""++[str])
				       ) (1,[]) in
		 subs3#snd

--myl = "cava et toi"#match  "(a..) et (t)oi"
--myl = match "(\\w+)" "pad tty etrre"
--myl = match "(\\w+)=" "PAD=/home/pad"
--myl = match "(\\w+)=(.*)" "PAD_MAIL="

pattern_matches ((re, v):xs) s = if s =~ re then v else pattern_matches xs s

----------------------------------------------------------------------------------------------------
-- an imitation of the '?' C operator
(?) True  (a,b) = a
(?) False (a,b) = b

-- TODO, would like to overload # to behave as >>> when monad, but hard to do, and want that ?
-- it is cool that record get autogenerated func, => we could do object#record_selector
-- consistency
(#) o f = f o -- object notation for object fan

(f $ g) x = (g . f) x

next_char c = chr (ord c + 1)

show_float i f = showFFloat (Just i) f ""

infixl 1 >>>
(>>>) monad f = monad >>= (return . f)
eval x = x >>= (putStrLn . show)

action `when` bool   = if bool then action else return ()
action `unless` bool = action `when` (not bool)
cat file = readFile file >>> lines
-- i know it is just poor code, but haskell force me
-- TODO, dont work, seems monad are lazy too, dont understand io in haskell anymore :(
--  if do {l <- exec "ps ux"; l2 <- exec "who"; l#mapM putStrLn} print the contents of l2 !!
exec s = do _ <- system (s++" > /tmp/file")
	    cat "/tmp/file"


fixpoint f d | f d == d  = d
	     | otherwise = fixpoint f (f d)
times = replicate

join e [] = []
join e xs = foldr1 (\a x -> a ++ e ++ x) xs 
-- join e []     = []
-- join e [x]    = x
-- join e (x:xs) = x ++ e ++ join e xs
-- ex: join " " ["bi","te","di","ck"] == "bi te di ck"

-- string only split
--split e xs = splitaux e [] xs
--splitaux e a xs | xs#length < e#length     = [a ++ xs]
--		  | take (e#length) xs == e  = a:(splitaux e [] (drop (e#length) xs))
--		  | otherwise                = splitaux e (a++[head xs]) (tail xs)
-- better split, handle regexp
split re xs = let matchresult = searchS re [] xs in
		   if matchedAny matchresult 
		   then (beforeMatch matchresult):(split re (afterMatch matchresult))
		   else [xs]
--test=split "\\s+" "toto titi  tia to"

break_char c f s = let (a,b) = break (== c) s in
		   if b == [] then a else f a (tail b)

upcase      = map toUpper
downcase    = map toLower
capitalize (x:xs) = toUpper x : xs

rand :: (Int, Int) -> IO Int -- force to do that to resolve overloading :(
rand = getStdRandom . randomR
stdrand :: IO Double
stdrand = getStdRandom (randomR (0::Double,1))

srand val = setStdGen (mkStdGen val)

tonum x = fromInteger x

hex ('0':('x':s)) = fst (head (readHex s)) -- TODO do some check
oct ('0':('o':s)) = fst (head (readOct s)) -- TODO do some check
tohex i = "0x"++aux i 
    where aux i = if i == 0 then "" else aux (i `div` 16)++((['0'..'9']++['A'..'F'])![i `mod` 16])
tooct i = "0o"++aux i 
    where aux i = if i == 0 then "" else aux (i `div` 8)++(['0'..'7']![i `mod` 8])

difference :: (Eq a) => [a] -> [a] -> [a] -- dont know why but forced to put the type
difference = (\\)

unique                     :: (Eq a) => [a] -> [a] -- dont know why but forced to put the type
unique = nub

insert_at :: Int -> [a] -> [a] -> [a]
insert_at i toadd xs = let (a,b) = splitAt i xs in
			   a++toadd++b

replace :: [(Int, a)] -> [a] -> [a]
replace assoc xs = assoc#foldl (\a (i,e) -> let (x,y) = splitAt i a in x++[e]++y ) xs

shift (x:xs) = (x,xs)
pop xs = (init xs, last xs) -- more efficient let (a,[b]) = splitAt (xs#length - 1) xs in (a,b)

foldl_index f acc xs = foldl f acc (zip [1..] xs)

-- in haskell we have getEnv::String -> String, but not getEnvs :(
env = exec "env" >>> map (\s -> let [a,b] = s#match "(\\w+)=(.*)" in (a,b))
-- env = getEnvironment  -- for ghc
argv = getArgs

just (Just x) = x
just _ = error "Common:just"

complex_i = 0 :+ 1

(<=>) a b = compare a b

exit i = primExitWith i
----------------------------------------------------------------------------------------------------
--ghc now = do cl <- getClockTime
--ghc 	       return (toUTCTime cl)
--ghc localtime = toCalendarTime . toClockTime 
--ghc strftime fmt time = formatCalendarTime defaultTimeLocale  fmt time
--ghc nulltime = TimeDiff {tdYear=0, tdMonth=0, tdDay=0, tdHour=0, tdMin=0, tdSec=0, tdPicosec = 0}

----------------------------------------------------------------------------------------------------
-- hash
keys = map fst

(@@)           :: Eq a => [(a,b)] -> a -> b
(@@) [] k      = error "Common:@@"
(@@) ((x,y):xys) k
      | k==x      = y
      | otherwise = xys@@k


-- printf a la danvy
-- type fmt a = 
----------------------------------------------------------------------------------------------------
-- matrix, there exist some implementation on the web, TODO dont do list but fixed size vector =>
-- could make compile-time check, ex *, we must have row_size a = column_size b
-- TODO, could be made a class of FinitMap, and that we could have a generic accessor
newtype Matrix a = Matrix [[a]] -- prefer a newtype, cos dont want to allow + on every list of list
    deriving (Eq,Show) -- newtype force you to redefine the deriving stuff
row_size    (Matrix m) = m#length
column_size (Matrix m) = m#head#length
(%%) (Matrix m) (i,j)  = m!!i!!j

-- could so straessen, this is very inefficient cos we dont have 0(1) access to element
-- TODO, use list comprehension, cf hugs demo
instance Num a => Num (Matrix a) where
    ma * mb | ma#column_size == mb#row_size = Matrix aux
	    where aux = [0..ma#row_size -1]
			#foldl (\acc i -> 
				acc++[
				      [0..mb#column_size -1]
				      #foldl (\acc j ->
					      acc++[
						    [0..ma#column_size-1]
						    #foldl (\acc k ->
							    acc+
							    (ma%%(i,k) * (mb %%(k,j))))
						    0]
					      ) []
				      ]
				) []


----------------------------------------------------------------------------------------------------
class Eq a => Default_val a where
    null_val :: a
    is_null :: a -> Bool
    is_null = (== null_val)

-- not really logical, cos we dont really need to force Default_val a, we dont care about a
instance Default_val a => Default_val [a]  where null_val = []
-- and need provide extra instance
instance Default_val Char  where null_val = 'a'

-- need -98 option, still dont know why we need to put the constraint Eq [a] for working
--instance Eq [a] => Default_val [a]  where null_val = []

instance Default_val Int    where null_val = 0
instance Default_val Float  where null_val = 0.0

-- v1 = (2::Int) &&& "ee" --  "ee" -- need the type annotation :(
-- v2 = 0.0 &&& "ee" --  ""

-- overloading on return value
(&&&):: (Default_val a, Default_val b) => b -> a -> a
a &&& b = if a#is_null then null_val else b

(|||):: Default_val a => a -> a -> a
a ||| b = if a#is_null then b else a

----------------------------------------------------------------------------------------------------
-- class Show a => Showbis a where
--    showbis :: a -> String
--    showbis x = show x
-- cant do instance Showbis [Char] where showbis x = x
--  cos we cant specialise so far in haskell, we specialise "chacun son tour" =>
--  first [] then Char => to handle that, do as in the class Show, make 2 func
-- (as you may have note,  show "123" => "123" and show '1' => '1', strange, might expect
--  ['1','2','3'] cos String = [Char]
--  in fact, show [a] is not a map show !! cf Prelude to understand the trick
--  they introduce another func in the class definition to allow specialisation for [a]

--    showbisList :: [a] -> String
--    showbisList [] = "[]"
--    showbisList (x:xs) = "[" ++ join "," (map show (x:xs)) ++ "]"

--instance Showbis a => Showbis [a] where showbis = showbisList
--instance Num a => Showbis a where showbis = show

-- the beautfile one, but hugs/ghc do special case with show; when 
--   do 1 ~~ 2 then he wants (1::Int) ~~ (2::Int) :((
-- (~~) a b = showbis a ++ showbis b

-- the ugly one, if you have a type that when show put a " at begin and end, then pb !!
--  but as it is rarely the case, no matter, same for \
update_anti_slash [] = []
update_anti_slash [x] = [x]
update_anti_slash ('\\':x:xs) = 
    (case x of 
     'n' -> '\n'
     't' -> '\t'
     x   -> x
     ) : update_anti_slash xs
update_anti_slash (x:xs) = x : update_anti_slash xs

del_enclose :: String -> String
del_enclose xs | length xs <= 1 = xs
	       | head xs == '"' && last xs == '"' = xs#tail#init
	       | otherwise = xs
(^) a b = (update_anti_slash . del_enclose . show) a ++ (update_anti_slash . del_enclose . show) b 
--(^) a b  = let op = update_anti_slash . del_enclose . show in op a ++ op b -- dont WORK !! AMAZING
infixl 1 ^

