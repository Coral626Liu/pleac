"-*- smalltalk -*-"

" @@PLEAC@@_NAME "
" @@SKIP@@ Smalltalk @@SKIP@@ "

" @@PLEAC@@_1.0 "
"In Smalltalk, everything is an object.  Including strings.  Strings are
instances of the class String."

|string|
string := '\n'.  "Two Characters, \ and an n - literal form"
string := String with: $\ with: $n.  "As above, but creating the string
by passing messages"
string := 'Jon ''Maddog'' Orwant'.  "Literal string containing single
quotes"
string := String with: Character cr.  "String with a newline character"
string := 'Jon "Maddog" Orwant'.  "Literal string containing double
quotes"

"ANSI standard Smalltalk does not allow arbitrary literal string
delimiters"

"Reading a stream of characters up to (but not including) 'EOF'.  Most
String handling in Smalltalk is done using streams (instances of class
Stream or one of its subclasses."

|sourceStream a|
sourceStream := ReadStream on: 'This is a multiline here document
terminated by EOF on a line by itself
EOF'.
a := sourceStream upToAll: 'EOF'.


" @@PLEAC@@_2.1 "
"Even numbers are objects in Smalltalk.  There is no special syntax for
manipulating numbers other than the literal forms of numbers.

For example, evaluating '1 + 2' results in the object 1 being sent the
message '+' with the single argument 2.  The '+' method returns the
object 3.

An object is either a subclass of Number (in which case it is a number)
or it's not.  An instance of String is not a number, though it might
contain the literal form of a number.

So let's say we have an instance of class String which we think might
contain a number in some form or other..."

|result|
result := '123.45' isNumber.   "false is assigned to result. '123.45' is
a String, not a Number."
result := 123.45 isNumber.  "true is assigned to result. 123.45 is
indeed a number."
result := Number readFrom: ('123.45' readStream). "result is the
Fraction(!) 2469/20"
result := result asFloat. "result is now the Float 123.45"
result := Number readFrom: ('this is not a number' readStream). "result
is the Integer zero."
result := Number readFrom: ('123abc' readStream). "result is the Integer
123"
result := 'This is not a number' isNumeric. "result is false"
result := '123' isNumeric. "result is true"
result := '123abc' isNumeric. "result is false"
result := '123' asNumber. "result is the Integer 123"

|number result|
number := '123' asNumber.
result := number isInteger.  "result is true"
result := number isRational. "result is true"
number := 123 / 456. "result is the Fraction 41/152"
result := number isInteger. "result is false"
result := number isRational. "result is true"

"Other tests that all Number objects respond to are:
>>isFinite
>>isInfinite
>>odd
>>positive"


" @@PLEAC@@_3.0"
"Dates and time are objects in Smalltalk too ... of course!"

Date today. "Evaluates to an instance of class Date."
Time now. "Evaluates to an instance of class Time."
DateTime now. "Evaluates to an instance of class DateTime."


" @@PLEAC@@_3.1"
"We saw Date, Time and DateTime objects being created in the
introduction.  Let's now see how we can show the value of these
objects."

Date today printString.   " ->  '3-Jun-2005' "
Time now printString.  " ->  '22:09:35' "
DateTime now printString. " -> ' 2005-06-03T22:10:22+10:00' "

"The message >>printString can be sent to any object.  It is up to the
object to return an interesting instance of class String."


" @@PLEAC@@_3.2"

"We can create arbitrary dates and time using other class methods on the
Date, Time and DateTime classes."

|myDateTime|

"The following creates a DateTime of the time I wrote this code as if it
was GMT"
myDateTime := DateTime year: 2005 month: 6 day: 3 hour: 22 minute: 18
second: 26.

"The following creates the DateTime with the correct offset for Sydney,
Australia."
myDateTime := DateTime year: 2005 month: 6 day: 3 hour: 22 minute: 18
second: 26 offset: (Duration days: 0 hours: 10 minutes: 0 seconds: 0).

"And now we can get the seconds from myDateTime."
myDateTime asSeconds.  "Evaluates to an Integer"
myDateTime asSeconds printString. "Evaluates to an instance of String
representing the above integer."


" @@PLEAC@@_3.2"

"We can also create a Dates and Times from a number of seconds"

| myDateTime aNumberOfSeconds aDate aTime|
myDateTime := DateTime year: 2005 month: 6 day: 3 hour: 22 minute: 18
second: 26 offset: (Duration days: 0 hours: 10 minutes: 0 seconds: 0).
aNumberOfSeconds := myDateTime asSeconds.
aDate := Date fromSeconds: aNumberOfSeconds.
aTime := Time fromSeconds: aNumberOfSeconds.
