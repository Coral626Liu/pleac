;;;; -*- lisp -*-
;;;; @@PLEAC@@_NAME
;;;; @@SKIP@@ Common Lisp

;;;; @@PLEAC@@_WEB
;;;; @@SKIP@@ http://www.lisp.org/
;;;; @@SKIP@@ http://www.sbcl.org/

;;;; @@PLEAC@@_INTRO
;;;; @@SKIP@@ Newer submissions use SBCL, and make use of a number of
;;;; @@SKIP@@ SBCL and third-party libraries (see Appendix for
;;;; @@SKIP@@ details).

;;;; @@PLEAC@@_APPENDIX

(declaim (optimize (speed 0) (safety 3) (debug 3)))

(defun chomp (string)
  "Similar to Perl's chomp(), although it returns the new value of
STRING rather than the number of characters removed, and doesn't
modify its argument."
  (string-right-trim #(#\Newline #\Return) string))

;;;; @@SKIP@@ Common Lisp code makes use of the following for
;;;; @@SKIP@@ package/loading: 
;;;; @@SKIP@@  (require :PACKAGENAME)

;;;; @@SKIP@@ SBCL code makes use of the following for package /
;;;; @@SKIP@@ library loading:
;;;; @@SKIP@@  (asdf:operate 'asdf:load-op :date-calc) ; load the package
;;;; @@SKIP@@  (use-package 'date-calc)                ; import the symbols
;;;; @@SKIP@@  (load "time.lisp")              ; replace with your location of the pdl library
;;;; @@SKIP@@  (use-package 'CyberTiggyr-Time) ; for printing times in various formats

;;;; @@SKIP@@ Packages / libraries used include:
;;;; @@SKIP@@  http://www.cliki.net/cl-ppcre
;;;; @@SKIP@@  http://www.cliki.net/cl-interpol
;;;; @@SKIP@@  http://www.cliki.net/date-calc
;;;; @@SKIP@@  http://www.cliki.net/asdf
;;;; @@SKIP@@  http://cybertiggyr.com/gene/pdl/

;;; @@PLEAC@@_1.0
;;;-----------------------------
(setf string "\\n")                     ; two characters, \ and an n
(setf string "John 'Maddog' Orwant")    ; literal single quotes
;;;-----------------------------
;; newlines may be inserted literally
(setf string "                          
")                                      ; a "newline" character
;; or by creating a string explicitly
(setf string (make-string 1 :initial-element #\Newline))
;; or by using format with a nil output stream
(setf string (format nil "~%"))
(setf string "John \"Maddog\" Orwant")  ; literal double quotes
;;;-----------------------------
(setf string "John 'Maddog' Orwant")  ; literal single quotes
;;;-----------------------------
(setf string "
This is a multiline string, terminated by a
double quotation mark.
")
;;;-----------------------------
;; There are no CL equivalents to Perl's other ways of quoting
;; strings (q//, etc).
;;;-----------------------------

;;; @@PLEAC@@_1.1
;;;-----------------------------
;; assign a substring to a variable
(setf value (subseq string offset (+ offset count)))
(setf value (subseq string offset))

;; edit a substring
(setf string (concatenate 'string 
                          (subseq string 0 offset) 
                          newstring
                          (subseq string (+ offset count))))
(setf string (concatenate 'string 
                          (subseq string 0 offset) 
                          newtail))

;;;-----------------------------
;; get a 5-byte string, skip 3, then grab 2 8-byte strings, then the
;; rest
(setf leading (subseq data 5)
      s1 (subseq data 8 8)
      s2 (subseq data 16 8)
      trailing (subseq data 24))

;; split at five byte boundries
(let ((length (length string)))
  (loop for idx from 0 upto length by 5
     collect (subseq string idx (min length (+ idx 5)))))

;; chop string into individual characters
(loop for idx from 0 upto (1- (length string))
      collect (char string idx))
;;;-----------------------------
(defparameter *string* "This is what you have")
;;;             +012345678901234567890  Indexing forwards  (left to right)
;;;              109876543210987654321- Indexing backwards (right to left)

(let ((first (subseq *string* 0 1))                        ; "T"
      (start (subseq *string* 5 7))                        ; "is"
      (rest (subseq *string* 13))                       ; "you have"
      (last (subseq *string* (+ (length *string*) -1))) ; "e"
      (end (subseq *string* (+ (length *string*) -4)))   ; "have"
      (piece (subseq *string*
                     (+ (length *string*) -8)
                     (+ (length *string*) -8 3)))) ; "you"
  (list first start rest last end piece))
;; ("T" "is" "you have" "e" "have" "you")
;;;-----------------------------
(defparameter *string* "This is what you have")
(print *string*)
;; This is what you have

;; Change "is" to "wasn't"
(setf *string*
       (concatenate 'string
                    (subseq *string* 0 5)
                    "wasn't"
                    (subseq *string* (+ 5 2))))
;; This wasn't what you have

;; Replace last 12 characters
(setf *string*
       (concatenate 'string
                    (subseq *string* 0 (+ (length *string*) -12))
                    "ondrous"))
;; This wasn't wondrous

;; Delete first character
(setf *string* (subseq *string* 1))
;; his wasn't wondrous

;; Delete last 10 characters
(setf *string* (subseq *string* 0 (+ (length *string*) -10)))
;; his wasn'
;;;-----------------------------
;; you can test substrings with the :start and :end keyword parameters
;; of CL-PPCRE:SCAN
(when (cl-ppcre:scan "pattern" *string* :start (- (length *string*) 10))
  (format t "Pattern matches in last 10 characters~%"))

;; substitute "at" for "is", restricted to first five characters
(concatenate 'string
              (cl-ppcre:regex-replace "is" *string* "at"
                                      :start 0
                                      :end (min (length *string*) 5))
              (when (> (length *string*) 5)
                (subseq *string* 5)))
;;;-----------------------------
;; exchange the first and last letters in a string
(let ((a "make a hat"))
  ;; ROTATEF is CL's general-purpose swap macro
  (rotatef (char a 0) (char a (1- (length a))))
  (princ a))
;; take a ham
;;;-----------------------------
;; extract column with SUBSEQ
(let* ((a "To be or not to be")
       (b (subseq a 6 12))) ; skip 6, grab 6
  (format t "~A~%" b)
;; or not

  ;; forward 6, grab 2; backward 5, grab 2
  (destructuring-bind (b c) `(,(subseq a 6 8) ,(subseq a 3 5))
    (format t "~A~%~A~%" b c)))
;; or
;; be
;;;-----------------------------
(defun cut2fmt (&rest positions)
  "Useless in CL, which lacks Perl's unpack(); here for completeness."
  (let ((template "")
        (lastpos 1))
    (dolist (place positions)
      (setf template (format nil "~AA~D " template (- place lastpos)))
      (setf lastpos place))
    (setf template (concatenate 'string template "A*"))
    template))
(let ((fmt (cut2fmt 8 14 20 26 30)))
  (format t "~A~%" fmt))
;; A7 A6 A6 A6 A4 A*
;;;-----------------------------

;;; @@PLEAC@@_1.2
;;;-----------------------------
;; use b if b is true, else c
(setf a (or b c))

;; set x to y unless x is already true
(unless x (setf x y))
;;;-----------------------------
;; use b if b is defined, otherwise c
(setf a (if (boundp 'b) b c))
;;;-----------------------------
(setf foo (or bar "DEFAULT VALUE"))
;;;-----------------------------
#+sbcl 
(defparameter ARGV (copy-seq (cdr *posix-argv*)) "Arguments from shell, Perl style")

(setf dir (or (pop ARGV) "/tmp"))
;;;-----------------------------
(setf dir (or (nth 0 ARGV) "/tmp"))
;;;-----------------------------
(setf dir (if (plusp (length ARGV)) (pop ARGV) "/tmp"))
;;;-----------------------------
(setf dir (if (plusp (length ARGV)) (nth 0 ARGV) "/tmp"))
;;;-----------------------------
(setf count (make-hash-table))
(incf (gethash (or shell "/bin/sh") count 0))
;;;-----------------------------
;; find the user name on Unix systems
(setf user (or (posix-getenv "USER")
               (posix-getenv "LOGNAME")
               #+sbcl
               (let ((uid (sb-posix:getuid)))
                 (or (sb-posix:passwd-name (sb-posix:getpwuid uid))
                     (format nil "Unknown uid number ~a" uid)))
               #-sbcl
               "Unknown uid"))
;;;-----------------------------
(setf starting-point (or starting-point "Greenwich"))
;;;-----------------------------
;; Perl array-to-array assignment copies the array, hence the need for
;; COPY-SEQ below.
(unless (plusp (length a))
  (setf a (copy-seq b)))                ; copy only if empty
(setf a (copy-seq (if (plusp (length b))
                      b
                      c)))              ; assign b if nonempty, else c
;;;-----------------------------

;;; @@PLEAC@@_1.3
;;;-----------------------------
;; There are several ways to swap variables in CL.  ROTATEF is usually
;; the simplest choice.
(rotatef VAR1 VAR2)
(psetq VAR1 VAR2 VAR2 VAR1)
(multiple-value-setq (VAR1 VAR2) 
  (values VAR2 VAR1))
;;;-----------------------------
(setf temp a
      a b
      b temp)
;;;-----------------------------
(let ((a "alpha")
      (b "omega"))
  (rotatef a b))           ; the first shall be last -- and versa vice
;;;-----------------------------
(destructuring-bind (alpha beta production)
    ;; In CL one would normally use symbols here:
    ;; '(January March August)
    '("January" "March" "August")
  ;; move beta       to alpha,
  ;; move production to beta,
  ;; move alpha      to production
  (rotatef alpha beta production))
;;;-----------------------------

;;; @@PLEAC@@_1.4
;;-----------------------------
(setq num (char-code char))
(setq char (code-char num))
;;-----------------------------
(setq char (format nil "~c" (code-char num)))
(format t "Number ~d is character ~c~%" num (code-char num))
;; Number 101 is character e
;;;-----------------------------
(setq ASCII (map 'list #'char-code string))
(setq string (map 'string #'code-char ASCII))
;;-----------------------------
(setq ascii-value (char-code #\e))             ; now 101
(setq character (code-char 101))               ; now #\e
;;-----------------------------
(format t "Number ~D is character ~C~%" 101 (code-char 101))
;;-----------------------------
(let ((ascii-character-numbers (map 'list #'char-code "sample")))
  (format t "~{~A~^ ~}~%" ascii-character-numbers)
;; 115 97 109 112 108 101
  (setf word (map 'string #'code-char ascii-character-numbers))
  (setf word (map 'string #'code-char #(115 97 109 112 108 101))) ; same
  (format t "~A~%" word))
;; sample
;;;-----------------------------
(let* ((hal "HAL")
       (ibm (map 'string
                 (lambda (char)
                   (code-char (1+ (char-code char)))) ; add one to each ASCII value
                 hal)))
  (format t "~A~%" ibm))                ; prints "IBM"
;;;-----------------------------

;;; @@PLEAC@@_1.5
;;;-----------------------------
(setq array (map 'list #'string string))

(setq array (loop for char across string
               collect (char-code char)))
;;;-----------------------------
(cl-ppcre:do-matches-as-strings (match "(.)" string)
  ;; do something with MATCH
  )
;;;-----------------------------
(let ((seen (make-hash-table))
      (string "an apple a day"))
  (loop for char across string do
       (incf (gethash char seen 0)))
  (let ((chars (loop for char being each hash-key of seen
                  collect char)))
    (format t "unique chars are: ~{~C~}~%" 
            (sort chars '< :key 'char-code))))
;; unique chars are:  adelnpy
;;;-----------------------------
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (reduce #'+ string :key #'char-code)))
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (loop for char across string
                summing (char-code char))))
;;;-----------------------------
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (loop for char across string
             sum (char-code char))))
;; prints "1248" if string was "an apple a day"
;;;-----------------------------
;; There's no equivalent to Perl's unpack(), this is about as close as
;; you can get.
(setf sum (loop for char across string
             sum (char-code char)))
;;;-----------------------------
;; In CL it makes more sense to call this function from the REPL than
;; it does to put it into a separate script.  E.g.,
;;  > (sum "/tmp/xyz")
(defun sum (&rest files)
  (let ((sum 0))
    (dolist (filename files)
      (with-open-file (file filename :element-type 'unsigned-byte)
        (do ((b (read-byte file nil :eof)
                (read-byte file nil :eof)))
            ((eql b :eof))
          (incf sum b))))
    (let ((r (+ (mod sum (expt 2 16))
                (truncate (/ (mod sum (expt 2 32))
                             (expt 2 16))))))
      (+ (mod r (expt 2 16))
         (truncate (/ r (expt 2 16)))))))
;;;-----------------------------
;;CL-USER> (sum "/mach.sym")
;;24298
;;;-----------------------------
;;%cksum -o 2 /mach.sym
;;24298 1203 /mach.sym
;;;-----------------------------
(defun slowcat (number-or-filename &rest more-files)
  "The first argument can be a number of seconds to sleep between
characters, otherwise it should be a file name."
  (let ((delay (if (numberp number-or-filename) number-or-filename 1))
        (files (if (numberp number-or-filename) more-files (cons number-or-filename more-files))))
    (dolist (filename files)
      (with-open-file (file filename)
        (do ((c (read-char file nil :eof)
                (read-char file nil :eof)))
            ((eql c :eof))
          (format t "~C" c)
          (finish-output)
          (sleep (* delay 0.005)))))))

;;; @@PLEAC@@_1.6
;;;-----------------------------
(setq revbytes (reverse string))
;;;-----------------------------
(setq revwords (format nil "~{~A~^ ~}"
                       (reverse (cl-ppcre:split " " string))))
(setq revwords (reverse
                (do* ((stringstream (make-string-input-stream string))
                      (result nil (cons next result))
                      (next (read stringstream nil 'eos)
                            (read stringstream nil 'eos)))
                     ((equal next 'eos)
                      (reverse result)))))
;;;-----------------------------
(setq gnirts (reverse string))          ; reverse letters in string

(setq sdrow (reverse words))            ; reverse elements in words

(setq confused (reverse (apply #'concatenate 'string words))) ; reverse letters in join("", @words)
;;;-----------------------------
(setq string "Yoda said, \"can you see this?\"")
(setq allwords (cl-ppcre:split " " string))
(setq revwords (format nil "~{~A~^ ~}" (reverse allwords)))
(format t "~A~%" revwords)
;this?" see you "can said, Yoda
;;;-----------------------------
(setq revwords (format nil "~{~A~^ ~}" (reverse (cl-ppcre:split " " string))))
;;;-----------------------------
(setq revwords (apply #'concatenate 'string
                      (cl-ppcre:split "(\\s+)" string :with-registers-p t)))
;;;-----------------------------
(defun palindrome-p (word)
  (string= word (reverse word)))
(palindrome-p "reviver")
;; T
;;;-----------------------------
(with-open-file (inf "/usr/share/dict/words")
  (loop for word = (read-line inf nil nil)
        while word
        when (and (string= word (reverse word)) 
                  (> (length word) 5))
        do (format t "~a~%" word)))
;; deedeed
;; degged
;; hallah
;; kakkak
;; murdrum
;; redder
;; repaper
;; retter
;; reviver
;; rotator
;; sooloos
;; tebbet
;; terret
;;;-----------------------------

;;; @@PLEAC@@_1.7
;;;-----------------------------

;;;-----------------------------
(defun tab-expand (string &optional (tabstop 8))
  (flet ((needed-spaces (target-string start end match-start match-end reg-starts reg-ends)
           (declare (ignore target-string start end reg-starts reg-ends))
           (make-string (- (* (- match-end match-start) tabstop)
                           (mod match-start tabstop))
                        :initial-element #\Space)))
    (cl-ppcre:regex-replace-all "\\t+" string #'needed-spaces)))

(defun tab-unexpand (string &optional (tabstop 8))
  (flet ((needed-tabs (target-string start end match-start match-end reg-starts reg-ends)
           (declare (ignore target-string start end reg-starts reg-ends))
           (let ((match-length (- match-end match-start)))
             (concatenate 'string
                          (make-string (floor match-length tabstop)
                                       :initial-element #\Tab)
                          (make-string (mod match-length tabstop)
                                       :initial-element #\Space)))))
    (cl-ppcre:regex-replace-all "  +" string #'needed-tabs)))
;;;-----------------------------
(loop for line = (read-line *standard-input* nil nil)
      while line do
      (format t "~a~%" (tab-expand line)))
;;;-----------------------------
(loop for line = (read-line *standard-input* nil nil)
      while line do
      (format t "~a~%" (tab-unexpand line)))
;;;-----------------------------

;;; @@PLEAC@@_1.8
;;;-----------------------------

(setf text "You owe $debt to me")
;;;-----------------------------
(defun global-deref (match var-name)
  "Helper function to simulate Perl's string interpolation in
regexps."
  (write-to-string (symbol-value (intern (string-upcase var-name)))))

(setf text (cl-ppcre:regex-replace-all "\\$(\\w+)" text #'global-deref
                                       :simple-calls t))
;;;-----------------------------
(setq rows 24 cols 80)
(setq text "I am $rows high and $cols long")
(setq text (cl-ppcre:regex-replace-all "\\$(\\w+)" text
                                       #'global-deref
                                       :simple-calls t))
(format t "~A~%" text)
;; I am 24 high and 80 long
;;;-----------------------------
(setf text "I am 17 years old")
(setf text (cl-ppcre:regex-replace-all "(\\d+)" text
                                       (lambda (match num-str)
                                         (declare (ignore match))
                                         (write-to-string
                                          (* 2 (parse-integer num-str))))
                                       :simple-calls t))
;;;-----------------------------
(* 2 17)
;;;-----------------------------
;; expand variables in text, but put an error message in
;; if the variable isn't defined
(flet ((deref-with-err (match word)
         (declare (ignore match))
         (let ((word-sym (intern (string-upcase word))))
           (if (boundp word-sym)
               (write-to-string (symbol-value word-sym))
               (format nil "[NO VARIABLE: $~a]" word-sym)))))
  (setf text (cl-ppcre:regex-replace-all "\\$(\\w+)" text
                                         #'deref-with-err
                                         :simple-calls t)))
;;;-----------------------------


;;; @@PLEAC@@_1.9
;;;-----------------------------
(setf big (string-upcase little))       ; "bo peep" -> "BO PEEP"
(setf little (string-downcase big))     ; "JOHN"    -> "john"
;; Reminder: the following depends on CL-INTERPOL.
(setf big #?"\U$(little)")              ; "bo peep" -> "BO PEEP"
(setf little #?"\L$(big)")              ; "JOHN" -> "john"
;;;-----------------------------
(setf big (string-upcase little :end 1)    ; "bo"      -> "Bo"
(setf little (string-downcase BIG :end 1)) ; "BoPeep"    -> "boPeep"
(setf big #?"\u$(little)")                 ; "bo"      -> "Bo"
(setf little #?"\l$(big)")                 ; "BoPeep"    -> "boPeep"
;;;-----------------------------
(setf beast "dromedary")
;; Capitalize various parts of beast
(setf capit (string-upcase beast :end 1))      ; Dromedary
(setf capit #?"\u\L$(beast)")                  ; (same)
(setf capall (string-upcase beast))            ; DROMEDARY
(setf capall #?"\U$(beast)")                   ; (same)
(setf caprest (string-downcase (string-upcase beast) :end 1)) ; dROMEDARY
(setf caprest #?"\l\U$(beast)")                               ; (same)
;;;-----------------------------
;; capitalize each word's first character, downcase the rest
(setf text "thIS is a loNG liNE")
(format t "~A~%" (string-capitalize text))
;; This Is A Long Line
;;;-----------------------------
;; string= is case-sensitive, string-equal is case-insensitive
(when (string-equal a b)
  (format t "a and b are the same~%"))
;;;----------------------------- 
;; It's considered bad form to perform bitwise operations on character
;; types, and breaks unicode-aware lisps.  Trust the compiler to
;; optimize.
(defun randcase (char)
  (if (< (random 100) 20)
      (char-upcase char)
      (char-downcase char)))
;;;-----------------------------

;;; @@PLEAC@@_1.10
;;;-----------------------------
(setf answer (concatenate 'string var1 (func) var2))
;;;-----------------------------
(setf answer (format nil "STRING ~{~A~} MORE STRING" list-expr))
(setf answer (format nil "STRING ~A MORE STRING" atomic-expr))
;;;-----------------------------
(setf phrase (format nil "I have ~D guanacos." (1+ n)))
(setf phrase #?"I have ${(1+ n)} guanacos.") ; uses CL-INTERPOL
;;;-----------------------------
(format t "I have ~D guanacos.~%" (1+ n))
;;;-----------------------------
(some-func (format nil "What you want is ~{~A~} items"
                   (cl-ppcre:split ":" rec)))
;;;-----------------------------
(let ((text (format nil "~
To: ~A
From: Your Bank
Cc: ~{~A~^, ~}
Date: ~A (today)

Dear ~A,

Today, you bounced check number ~D to us.
Your account is now closed.

Sincerely,
the management
"
                    naughty
                    (get-manager-list naughty)
                    (let (date-str (with-output-to-string (str)
                                     (run-program "/bin/date" nil
                                                  :output str)))
                      (subseq date-str 0 (1- (length date-str))))
                    naughty
                    (+ 500 (random 100)))))
  (unless (send-mail text target)
    (error "Couldn't send mail")))
;;;-----------------------------

;;; @@PLEAC@@_1.11
;;;-----------------------------
;; all in one
(setf var (cl-ppcre:regex-replace-all
           (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
"your text
goes here
" ""))

;; or with two steps
(setf var "your text
goes here
")
(setf var (cl-ppcre:regex-replace-all 
           (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
           var
           ""))
;;-----------------------------
(setf var (cl-ppcre:regex-replace-all 
           (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
"    The five varieties of camelids
    are the familiar camel, his friends
    the llama and the alpaca, and the
    rather less well-known guanaco
    and vicuña.
" ""))
;;;-----------------------------
(defun fix (string)
  (cl-ppcre:regex-replace-all
   (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
   string
   ""))

(format t "~A~%" (fix "    My stuff goes here
")
;;;-----------------------------
(setf quote 
      (cl-ppcre:regex-replace-all
       (cl-ppcre:create-scanner #?r"\s+--")
       (cl-ppcre:regex-replace-all 
        (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
"        ...we will have peace, when you and all your works have
        perished--and the works of your dark master to whom you would
        deliver us. You are a liar, Saruman, and a corrupter of mens
        hearts.  --Theoden in /usr/src/perl/taint.c
"
       "")
       "
--"))
;;-----------------------------
(when *remember-the-main*
  (setf perl-main-C (dequote
"        @@@ int
         @@@ runops() {
         @@@     SAVEI32(runlevel);
         @@@     runlevel++;
         @@@     while ( op = (*op->op_ppaddr)() ) ;
         @@@     TAINT_NOT;
         @@@     return 0;
         @@@ }
"
  ;; add more code here if you want
   )))
;;;-----------------------------
(setf poem (dequote
"       Now far ahead the Road has gone,
          And I must follow, if I can,
       Pursuing it with eager feet,
          Until it joins some larger way
       Where many paths and errands meet.
          And whither then? I cannot say.
                --Bilbo in /usr/src/perl/pp_ctl.c
"))

(format t "Here's your poem:~%~%~A~%" poem)
;;;-----------------------------
(defun dequote (string)
  ;; Can't get multiple values returned thru the OR, hence the use of
  ;; DESTRUCTURING-BIND instead of MULTIPLE-VALUE-BIND
  (destructuring-bind (white leader) ; common whitespace and common leading string
      (or (cl-ppcre:register-groups-bind ($1 $2)
              (#?r/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/ string)
            (list $2 (cl-ppcre:quote-meta-chars $1)))
          (list (cl-ppcre:scan-to-strings #?r"^(\s+)" string) ""))
    (cl-ppcre:regex-replace-all
     (cl-ppcre:create-scanner (format nil #?r"^\s*?~a(?:~a)?" leader white) :multi-line-mode t)
     string
     "")))
;;;-----------------------------

;;; @@PLEAC@@_1.13
;; backslash
(setf var (cl-ppcre:regex-replace-all "([CHARLIST])" var "\\\1"))

;; double
(setf var (cl-ppcre:regex-replace-all "([CHARLIST])" var "\\1\\1"))
;;;-----------------------------
(setf string (cl-ppcre:regex-replace-all "%" string "%%"))
;;;-----------------------------
(setf string "Mom said, \"Don't do that.\"")
(setf string (cl-ppcre:regex-replace-all "(['\"])" string #?r"\\\1"))
;;;-----------------------------
(setf string "Mom said, \"Don't do that.\"")
(setf string (cl-ppcre:regex-replace-all "(['\"])" string #?r"\1\1"))
;;;-----------------------------
(setf string (cl-ppcre:regex-replace-all #?r"([^A-Z])" string #?r"\\\1"))
;;;-----------------------------
(setf string #?r"this \Qis a test!\E")
(setf string "this is\\ a\\ test\\!")
(setf string (concatenate 'string "this " (cl-ppcre:quote-meta-chars "is a test!")))
;;;-----------------------------

;;; @@PLEAC@@_1.14
;;;-----------------------------
(setf string (cl-ppcre:regex-replace #?r/^\s+/ string "")) 
(setf string (cl-ppcre:regex-replace #?r/\s+$/ string ""))
;;;-----------------------------

;;; The closest thing to Perl's wantarray is CL's ability to return
;;; multiple values from a function.  Unless the caller uses
;;; MULTIPLE-VALUE-BIND (or, this case MULTIPLE-VALUE-LIST), they will
;;; only "see" the first value.  Note also that, normally, you'd use
;;; CL's built-in STRING-TRIM function for this.
(defun trim (&rest strings)
  (values-list 
   (loop for string in strings
      collect (cl-ppcre:regex-replace #?r/^\s+/ 
                                      (cl-ppcre:regex-replace #?r/\s+$/ string "")
                                      ""))))

(setf string (trim string))
(setf many (multiple-value-list (apply 'trim many)))
;;;-----------------------------
;; print what's typed, but surrounded by >< symbols
(loop
   (let ((line (read-line)))
     (chomp line)
     (format t #?">$(line)<~%")))
;;;-----------------------------

;;; @@PLEAC@@_2.1
;;;-----------------------------
(if (every #'digit-char-p string)
    (progn
      ;; is a number
      )
    (progn
      ;; is not
      ))
;;;-----------------------------
;;; Strings and numbers are separate data types in CL. These tests
;;; check whether a string represents a number
(unless (every #'digit-char-p string)
  (format *error-output* "string has nondigits"))
(unless (cl-ppcre:scan "^\\d+$" string) ; rejects -3
  (format *error-output* "not a natural number"))
(unless (cl-ppcre:scan "^-?\\d+$" string) ; rejects +3
  (format *error-output* "not an integer"))
(unless (cl-ppcre:scan "^[+-]?\\d+$" string)
  (format *error-output* "not an integer"))
(unless (cl-ppcre:scan "^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)$" string)
  (format *error-output* "not an integer"))
(unless (cl-ppcre:scan "^([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?\\d+))?$"
                       string)
  (format *error-output* "not a C float"))
;;;-----------------------------
(defun getnum (string)
  "This function is not safe to call on untrusted input."
  (with-input-from-string 
      (is (cl-ppcre:regex-replace #?"\s+$" 
                                  (cl-ppcre:regex-replace #?"^\s+" string "") ""))
    (let ((num (read is nil nil nil)))
      (and
       ;; Make sure there's no junk following the number
       (eql (read-char is nil :eof nil) :eof)
       (numberp num)
       num))))

(defun is-numeric (string)
  (not (null (getnum string))))
;;;-----------------------------

;;; @@PLEAC@@_2.2
;;;-----------------------------
(defun equal-to-accuracy (number1 number2 dp)
  "Return non-nil if NUMBER1 and NUMBER2 are equal to DP number of
decimal places."
  (let* ((difference (abs (- number1 number2)))
         (delta (expt 10 (- dp))))
    (< difference delta)))
;;;-----------------------------
(let* ((wage 536)                       ; $5.36/hour
       (week (* 40 wage)))              ; $214.40
  (format t "One week's wage is: $~,2F~%" (/ week 100)))
;;One week's wage is: $214.40
;;;-----------------------------

;;; @@PLEAC@@_2.3
;;;-----------------------------
(setf rounded (format nil "~FORMATF" unrounded))
;;;-----------------------------
(let* ((a 0.255)
       (b (/ (fround a 0.01) 100)))
  (format t "Unrounded: ~F~%Rounded: ~,2F~%" a b))
;;Unrounded: 0.255
;;Rounded: 0.26
;;;-----------------------------
(progn
  (format t "~&number~Tint~Tfloor~Tceil~%")
  (let ((as '(3.3 3.5 3.7 -3.3)))
    (dolist (a as)
      (format t "~@{~4,1F~^~T~}~%"
              a
              (ftruncate a)
              (ffloor a)
              (fceiling a)))))
;;number int floor ceil
;; 3.3  3.0  3.0  4.0
;; 3.5  3.0  3.0  4.0
;; 3.7  3.0  3.0  4.0
;;-3.3 -3.0 -4.0 -3.0
;;;-----------------------------

;;; @@PLEAC@@_2.4
;;;-----------------------------
(defun dec2bin (dec)
  (format nil "~2R" dec))
;;;-----------------------------
(defun bin2dec (bin)
  "BIN is a string containing only #\1 and #\0 characters.  Returns
its integer equivalent."
  (read (make-string-input-stream (concatenate 'string "#b" bin)) 
        t nil nil))
;;;-----------------------------
(setf num (bin2dec "0110110"))          ; $num is 54
(setf binstr (dec2bin 54))              ; binstr is "110110"
;;;-----------------------------

;;; @PLEAC@@_2.5
;;;-----------------------------
(loop for i from x upto y
     do
   ;; i is set to every integer from X to Y, inclusive
)

(loop for i from y downto x
     do 
   ;; i is set to every integer from Y to X, inclusive
)

(do ((i x (1+ i)))
    ((> i y))
   ;; i is set to every integer from X to Y, inclusive
  )

(loop for i from x upto y by 7
     do
   ;; i is set to every integer from X to Y, stepsize = 7
)
;;;-----------------------------
(format t "Infancy is: ~{~A~^ ~}~%"
        (loop for i from 0 to 2 collect i))

(format t "Toddling is: ~{~A~^ ~}~%"
        (loop for i from 3 to 4 collect i))

(format t "Childhood is: ~{~A~^ ~}~%"
        (loop for i from 5 to 12 collect i))
;;Infancy is: 0 1 2
;;Toddling is: 3 4
;;Childhood is: 5 6 7 8 9 10 11 12
;;;-----------------------------

;;; @@PLEAC@@_2.6
;;;-----------------------------

;;; CL has a built in FORMAT directive (used below) to print out
;;; numbers as roman numerals, but doesn't have a built-in mechanism
;;; to convert back.  Here are some rough CL equivalents of Perl's
;;; Roman package.

(defun romanchar->num (x) 
  (case (char-downcase x)
    (#\m 1000)
    (#\d 500)
    (#\c 100)
    (#\l 50)
    (#\x 10)
    (#\v 5)
    (#\i 1)
    (t 0)))

(defun isroman (string)
  (every #'(lambda (c)
             (plusp (romanchar->num c)))
         string))

(defun arabic (string)
  (let ((digits (map 'list #'romanchar->num string)))
    (reduce #'+ (mapcar #'(lambda (digit next-digit)
                            (if (< digit next-digit) 
                                (- digit) 
                                digit))
                        digits
                        (append (rest digits) '(0))))))

(setf roman (format nil "~@R" arabic))  ; convert to roman numerals
(when (isroman roman) (setf arabic (arabic roman))) ; convert from roman numerals 
;;;-----------------------------
(setf roman-fifteen (format nil "~@R" 15))
(format t "Roman for fifteen is ~A~%" roman-fifteen)
(setf arabic-fifteen (arabic roman-fifteen))
(format t "Converted back, ~A is ~A~%" roman-fifteen arabic-fifteen)
;;Roman for fifteen is XV
;;Converted back, XV is 15
;;;-----------------------------

;;; @@PLEAC@@_2.7
;;;-----------------------------
(setf random (+ (random (+ y (- x) 1)) x)
;;;-----------------------------
(setf random (+ (random 51) 25))
(format t "~A~%" random)
;; If you wanted to use floats...
(+ (random 51.0) 25.0)
;;;-----------------------------
(setf elt (aref array (random (length array))))
;;;-----------------------------
(setf chars "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345789!@$%^&*")
(setf password (coerce (loop repeat 8 collect (aref chars (random (length chars)))) 'string))
;;;-----------------------------

;;; @@PLEAC@@_2.8
;;;-----------------------------
;; CL intentionally does not have an equivalent of Perl's srand(); you
;; can call MAKE-RANDOM-STATE but its inner workings are not exposed.
(setf *random-state* (make-random-state t))
;;;-----------------------------

;;; @@PLEAC@@_2.9
;;;-----------------------------
;; In CL, RANDOM is supposed to return a truly random,
;; uniformly-distributed value.
(setf random (random))
;;;-----------------------------

;;; @@PLEAC@@_2.10
;;;-----------------------------
;; Note: (random 1.0) is the same as calling Perl's rand() with no
;; arguments.
(defun gaussian-rand ()
  (do* ((u1 (1- (* 2 (random 1.0)))
            (1- (* 2 (random 1.0))))
        (u2 (1- (* 2 (random 1.0)))
            (1- (* 2 (random 1.0))))
        (w (+ (* u1 u1) (* u2 u2))
           (+ (* u1 u1) (* u2 u2))))
       ((< w 1.0)
        (let* ((w2 (sqrt (/ (* -2 (log w)) w)))
               (g2 (* u1 w2))
               (g1 (* u2 w2)))
          ;; No need for wantarray in CL because functions can return
          ;; multiple values.
          (values g1 g2)))))
;;;-----------------------------
(defun weight-to-dist (weights)
  "Takes a hash mapping key to weight and returns a hash mapping key
to probability.  WEIGHTS is an alist."
  (let ((dist (make-hash-table))
        (total (loop for (key . ignored-value) in weights sum key)))
    (loop for (key . weight) in weights
         do (setf (gethash key dist) (/ weight total)))
    dist))

(defun weighted-rand (dist)
  "Takes a hash mapping key to probability, and returns the
corresponding element."
  (loop
     for rand = (random 1.0)
     do
     (loop for key being the hash-keys of dist using (hash-value weight)
        do
        (decf rand weight)
        (when (minusp rand)
          (return-from weighted-rand key)))))
;;;-----------------------------
;; gaussian_rand as above
(let* ((mean 25)
       (sdev 2)
       (salary (+ (* (gaussian-rand) sdev) mean)))
  (format t "You have been hired at $~,2F~%" salary))
;;;-----------------------------

;;; @@PLEAC@@_2.11
;;;-----------------------------
(defun deg2rad (degrees) 
  (* (/ degrees 180) pi))

(defun rad2deg (radians) 
  (* (/ radians pi) 180))
;;;-----------------------------
(setf radians (deg2rad degrees))
(setf degrees (rad2deg radians))
;;;-----------------------------
;; deg2rad and rad2deg defined either as above
(defun degree-sine (degrees)
  (let ((radians (deg2rad degrees)))
    (sin radians)))
;;;-----------------------------

;;; @@PLEAC@@_2.12
;;;-----------------------------
;; tangent is built in to CL
(tan theta)
;;;-----------------------------
(setf y (acos 3.7))
;;;-----------------------------
(setf y (tan (/ pi 2)))
;;;-----------------------------

;;; @@PLEAC@@_2.13
;;;-----------------------------
(setf log-e (log value))
;;;-----------------------------
(setf log-10 (log value 10))
(setf log-base-whatever (log value base))
;;;-----------------------------
;; In CL, don't need custom log_base function as LOG already does it
;;;-----------------------------
(setf answer (log 10000 10))
(format t "log10(10,000) = ~D~%" answer)
;; log10(10,000) = 4.0
;;;-----------------------------
(format t "log2(1024) = ~A~%" (log 1024 2))
;; log2(1024) = 10.0
;;;-----------------------------

;;; @@PLEAC@@_2.14
;;;-----------------------------
;;;-----------------------------
(defun mmult (m1 m2)
  (check-type m1 (array * (* *)))
  (check-type m2 (array * (* *)))
  (let* ((m1-rows (array-dimension m1 0))
         (m1-columns (array-dimension m1 1))
         (m2-rows (array-dimension m2 0))
         (m2-columns (array-dimension m2 1)))
    (unless (= m1-columns m2-rows)
      (error 'simple-type-error
             :format-control "IndexError: matrices don't match: ~A != ~A"
             :format-args (list m1-columns m2-rows)))
    (let ((result (make-array (list m1-rows m2-columns))))
      (dotimes (i m1-rows)
        (dotimes (j m2-columns)
          (setf (aref result i j)
                (loop for k from 0 below m1-columns
                      summing (* (aref m1 i k) (aref m2 k j))))))
      result)))

(defun range (n)
  (loop for i from 0 below n collect i))

;; This isn't really necessary in CL, but is here to match the Perl
;; function.
(defun veclen (vector)
  (check-type vector simple-vector)
  (array-dimension vector 0))

;; This isn't really necessary in CL, but is here to match the Perl
;; function.
(defun matdim (matrix)
  (values (array-dimension matrix 0)
          (array-dimension matrix 1)))
;;;-----------------------------
;; Can't find an obvious equivalent to PDL (yet)
;;;-----------------------------
(setf x #2a((3 2 3)
            (5 9 8))
      y #2a((4 7)
            (9 3)
            (8 1)))

(setf z (mmult x y))
;;;-----------------------------

;;; @@PLEAC@@_2.15
;;;-----------------------------
;; Complex numbers are built in to CL so there is no need to compute
;; their product by hand.
;;;-----------------------------
;; c = a * b using built-in CL functionality
(setf c (* a b))
;;;-----------------------------
;; Again, no need to do complex number stuff by hand.
;;;-----------------------------
(setf a #c(3 5))
(setf b #c(2 -2))
(setf c (* a b))
(format t "c = ~D+~Di~%" (realpart c) (imagpart c))
;; c = 16+4i
;;;-----------------------------
(setf c (* #c(3 5) #c(2 -2)))
(setf d #c(3 4))
(let ((sqrt-d (sqrt d)))
  (format t "sqrt(3+4i) = ~D+~Di~%" (realpart sqrt-d) (imagpart sqrt-d)))
;; sqrt(3+4i) = 2.0+1.0i
;;;-----------------------------

;;; @@PLEAC@@_2.16
;;;-----------------------------
(setf number (parse-integer hexadecimal :radix 16))
(setf number (parse-integer octal :radix 8))
;;;-----------------------------
;; @@INCOMPLETE@@


; @@PLEAC@@_3.1
; use get-decoded-time to fetch the time
(multiple-value-bind
	(second minute hour date month year day-of-week dst-p tz)
	(get-decoded-time) 
	year) ;; prints out year using standard library

; alternatively date-calc provides overlapping functionality
(multiple-value-bind
	(year month day h m s)
	(today-and-now) ; imported from date-calc
	year)           ; date-calc approach 

; how to print out current date as "YYYY-MM-DD" (in approved ISO 8601 fashion)
(multiple-value-bind
    (year month day) 
    (today) ;imported from date-calc
    (format t "The current date is ~A-~2,'0d-~2,'0d" year month day))

; Alternatively, you could use the format-time function from the CyberTiggyr-Time package:
(format-time t "%Y-%m-%d" (get-universal-time))

; As you can see, format-time operates on epoch time

; @@PLEAC@@_3.2 
; to encode time into universal time using date-calc
(multiple-value-bind
	(second minute hour date month year day-of-week dst-p tz)
	(get-decoded-time)
  (encode-universal-time second minute hour date month year))

;; the last two return values for get-decoded-time correspond to daylight savings and the
;; timezone.  Both are useful for timezone-related arithmatic.

; @@INCOMPLETE@@
; An example of a GMT computation with and without daylight savings is appropriate here since
; the built-in perl functions handle this.

; @@PLEAC@@_3.3
(let ((time (get-universal-time))) ; get epoch seconds
  (multiple-value-bind
      (second minute hour day month year day-of-week dst-p tz)
      (decode-universal-time time) ; decode and...
    (list day month year hour minute second))) ; return

; @@PLEAC@@_3.4
; when using universal time you add or subtract seconds
; here we add one hour
(let ((firstdate 
       (encode-universal-time 0 12 6 23 11 2006))
      (onehour (* 60 60 1)))
  (+ onehour firstdate))

; or you could use date-calc function
; here we'll add one day
(add-delta-ymdhms 2006 11 24 18 12 0  0 0 1 0 0 0)

; @@PLEAC@@_3.5
; We'll use the epoch seconds to perform subtraction, 
; then divide by seconds per day
(let ((first (encode-universal-time 52 45 20 13 12 1901))
      (second (encode-universal-time 7 14 3 19 1 2038)))
  (float (/ (- second first) (* 60 60 24))))

; method two uses delta-days from the date-calc package:
(delta-days 1901 12 13 2038 1 19)

; delta-days does not yet have the granularity of seconds, minutes or hours. 

; @@PLEAC@@_3.6
; The week of the year is computed as follows:
(week-number 2006 12 1) ; week-of-year is imported from date-calc

; similar functions exist for day of week, day of year, etc.

; @@PLEAC@@_3.7
(parse-time "2006-08-20")

; parse-time can recognize many of the commonly found date formats

; format-time comes with several ways to format...
(format-time t *format-time-date* (get-universal-time))

; results in: 25 Nov 2006

(format-time t *format-time-iso8601-short* (get-universal-time))

; results in: 20061125T172917 -5

(format-time t "%Y-%m-%d" (get-universal-time))

; results in: 2006-11-25

;;; @@PLEAC@@_4.0
(setf nested '("this" "that" "the" "other")
(setf nested '("this" "that" ("the" "other")))
;;-----------------------------
(setf tune '("The" "Star-Spangled" "Banner"))

;;; @@PLEAC@@_4.1
(setf a '("quick" "brown" "fox")
;;-----------------------------
(setf a '("Why" "are" "you" "teasing" "me?"))
;;-----------------------------
(setf lines (cl-ppcre:regex-replace-all (cl-ppcre:create-scanner "^\\s*(.+)" :multi-line-mode t )
"    The boy stood on the burning deck,
    It was as hot as glass.
" "\\1"))
;;;----------------------------- 

;;; You don't really need an explicit call to the CL equivalent of
;;; Perl's die().  Its behavior is the same by default (it does put
;;; you into the CL debugger, but that's not a bad thing).  You could,
;;; alternatively, handle this error with HANDLER-BIND or HANLDER-CASE
;;; if you wanted to be more precisely like the Perl version.
(let ((bigarray '()))
  (with-open-file (data "mydatafile")
    (loop for line = (read-line data nil nil)
       while line
       do (push (string-right-trim #(#\Newline #\Return)
                                   line) bigarray))))
;;-----------------------------
(setf banner "The Mines of Moria")
;;-----------------------------
(setf name "Gandalf")
(setf banner (format nil "Speak ~A and enter!" name))
(setf banner "Speak $name and welcome!")
;;-----------------------------

;;; @@PLEAC@@_4.2
;;-----------------------------
(defun commify_series (list)
  (case (length list)
    (0 "")
    (1 (car list))
    (2 (format nil "~{~A~^ and ~}" list))
    (t (concatenate 'string
                    (format nil "~{~A~^, ~}" (butlast list))
                    (format nil " and ~A" (car (last list)))))))
;;-----------------------------
(let ((array '("red" "yellow" "green")))
  (format t "I have ~D marbles.~%" (length array))
  (format t "I have ~{~a~} marbles.~%" array))
;;I have 3 marbles.
;;I have redyellowgreen marbles.
;;-----------------------------
;; @@INCLUDE@@ include/commonlisp/ch04/commify_series.lisp
;;-----------------------------

;;; @@PLEAC@@_4.4
;;-----------------------------
(dolist (item list)
  ;; do something with ITEM
  )
;;-----------------------------
(dolist (user bad-users)
  (complain user))
;;-----------------------------
(dolist (var (sort (loop for x being the hash-keys of axl
                      collect x) #'<))
  (format t "~A=~A~%" var (gethash var ENV)))
;;-----------------------------
(dolist (user all-users)
  (let ((disk-space (get-usage user)))
    (when (> disk-space +max-quota+)
      (complain user))))
;;-----------------------------
;;-----------------------------
;;; @@INCOMPLETE@@


;;; @@PLEAC@@_4.6
;;-----------------------------

(let ((seen (make-hash-table))
      (uniq '()))
  (dolist (item list)
    (unless (gethash item seen)
      ;; if we are here, we have not seen it before
      (setf (gethash item seen) 1)
      (push item uniq))))
;;-----------------------------
;;-----------------------------
;;; @@INCOMPLETE@@

;;; @@PLEAC@@_4.9
;;-----------------------------
(append array1 array2)
;;-----------------------------
(let ((members '("Time" "Flies"))
      (initiates '("An" "Arrow")))
  (setf members (append members initiates))
;;; members is now ("Time" "Flies" "An" "Arrow")
;;;-----------------------------
  (setf members `(,@(subseq members 0 2) "Like" ,@initiates))
  (format t "~{~a~^ ~}~%" members)
  (setf members `("Fruit" ,@(subseq members 1)))
  (setf members `(,@(subseq members 0 (- (length members) 2)) "A" "Banana"))
  (format t "~{~a~^ ~}~%" members))
;;;-----------------------------
;;Time Flies Like An Arrow
;;Fruit Flies Like A Banana

;;; @@PLEAC@@_4.10
;;-----------------------------
;; reverse ARRAY into REVERSED
(setf reversed (reverse *array*))
;;-----------------------------
(do ((i (1- (array-dimension *array* 0)) (1- i)))
    ((minusp i))
  ;; do something with (aref array i)
  )
;;-----------------------------
;; SORT is destructive, hence COPY-SEQ
(setf ascending (sort (copy-seq users) #'string-lessp))
(setf descending (reverse ascending))
;;-----------------------------
(setf descending (reverse (sort (copy-seq users) #'string-lessp)))
;;-----------------------------

;;; @@PLEAC@@_4.13
;;-----------------------------
(setf matching (find-if-not #'test list))
;;-----------------------------
(let ((matching '()))
  (dolist (item list)
    (when (test item) (push item matching))))
;;;-----------------------------
(setf bigs (remove-if-not #'(lambda (num) (> num 1000000)) nums))
(setf pigs (loop for user being the hash-keys of users using (hash-value uid)
              when (> uid 1e7)
              collect user))

;;;-----------------------------
#+sbcl
(remove-if-not #'(lambda (line)
                   (cl-ppcre:scan "^gnat " line))
               (cl-ppcre:split #\Newline
                               (with-output-to-string (output)
                                 (sb-ext:run-program "who" nil :search t :output output))))
;;;-----------------------------
;;; Assumes DEFSTRUCT or DEFCLASS of EMPLOYEE with a POSITION slot.
(setf engineers (remove "Engineer" employees :key #'employee-position :test-not 'string=))
;;-----------------------------
(setf secondary-assistance (remove-if-not #'(lambda (applicant)
                                              (and (>= (applicant-income applicant) 26000)
                                                   (<  (applicant-income applicant) 30000)))
                                          applicants))
;;;-----------------------------

;;; @@PLEAC@@_4.16
;;;-----------------------------

;;; The following aren't efficient on long lists
(setf circular `(,@(last circular) ,@(nbutlast circular))) ; the last shall be first
(setf circular `(,@(cdr circular) ,(car circular))) ; and vice versa
;;;-----------------------------
;;; There is probably a less ugly way to do this
(defmacro grab-and-rotate (list)
  `(prog1 (car ,list)
     (setf ,list `(,@(cdr ,list) ,(car ,list)))))

(let ((processes '(1 2 3 4 5)))
  (loop 
     (let ((process (grab-and-rotate processes)))
       (format t "Handling process ~A~%" process)
       (sleep 1))))    
;;;-----------------------------

;;; @@PLEAC@@_4.17
;;-----------------------------
(defun fisher-yates-shuffle (vector)
  "Randomly shuffle elements of VECTOR."
  (loop for i from (1- (length vector)) downto 1
     for j = (random i)
     unless (= i j)
     do (rotatef (aref vector i) (aref vector j)))
  vector)
;;;
(defun shuffle (vector)
  "Return a fresh permuted copy of VECTOR."
  (let* ((n-permutations (factorial (length vector)))
         (permutation (nth-permutation (random n-permutations)
                                       (length vector))))
    (map 'vector (lambda (i) (aref vector i)) permutation)))
;;;
(defun naive-shuffle (vector)
  (loop with n = (length vector)
        for i from 0 below n
        for j = (random n)
        do (rotatef (aref vector i) (aref vector j)))
  vector)

;;; @@PLEAC@@_4.19
(defun factorial (n)
  (loop for result = 1 then (* result i)
        for i from 1 to n
        finally (return result)))

(factorial 500) ; => 1220136... (1135 digits total)

(defun map-vector-permutations (function vector)
  (labels ((permute (end)
             (if (= end 0)
                 (funcall function vector)
                 (dotimes (i end)
                   (rotatef (aref vector (1- end)) (aref vector i))
                   (permute (1- end))
                   (rotatef (aref vector (1- end)) (aref vector i))))))
    (permute (length vector))))
(map-vector-permutations #'print #(1 2 3))

(defun map-list-permutations (function list)
  (labels ((permute (tail)
             (if (null tail)
                 (funcall function list)
                 (loop for subtail on tail
                       do (rotatef (car tail) (car subtail))
                          (permute (cdr tail))
                          (rotatef (car tail) (car subtail))))))
    (permute list)))
(map-list-permutations #'print '(1 2 3))
;;; permute words in each line of input stream
(loop for line = (read-line *standard-input* nil nil)
      while line
      do (map-list-permutations (lambda (words)
                                  (format t "~{~A~^ ~}~%" words))
                                (cl-ppcre:split "\\s+" line)))

;;;
(let ((memo (make-hash-table)))
  (setf (gethash 0 memo) 1)
  (defun factorial (n)
    (or (gethash n memo)
        (setf (gethash n memo) (* n (factorial (1- n)))))))

(defun nth-pattern (n length)
  (loop for i from length downto 1
        for (new-n elem) = (multiple-value-list (truncate n i))
        collect elem
        do (setf n new-n)))

(defun pattern-permutation (pattern)
  (loop with source = (cons nil
                            (loop for i from 0 below (length pattern)
                                  collect i))
        for i in pattern
        for pred = (nthcdr i source)
        for (elem . rest) = (cdr pred)
        collect elem
        do (setf (cdr pred) rest)))

(defun nth-permutation (n length)
  (pattern-permutation (nth-pattern n length)))

; @@PLEAC@@_5.0

(setf age (make-hash-table :test 'equal))

(setf (gethash "Nat" age) 24
      (gethash "Jules" age) 25
      (gethash "Josh" age) 17)
;;-----------------------------

(mapcar #'(lambda (l)
            (setf (gethash (car l) age) (cdr l)))
        '(("Nat" . 24)
          ("Jules" . 25)
          ("Josh" . 17)))
;;-----------------------------
(setf food-color (make-hash-table :test 'equal))

(mapcar #'(lambda (l)
            (setf (gethash (car l) food-color) (cdr l)))
        '(("Apple" . "red")
          ("Banana" . "yellow")
          ("Lemon" . "yellow")
          ("Carrot" . "orange")))

;;-----------------------------

(mapcar #'(lambda (l)
            (setf (gethash (car l) food-color) (cdr l)))
        '((Apple . "red")
          (Banana . "yellow")
          (Lemon . "yellow")
          (Carrot . "orange")))
;;-----------------------------


; @@PLEAC@@_5.1
;;-----------------------------
(setf (gethash key hash) value)
;;-----------------------------

(setf (gethash "Raspberry" food-color) "pink")

(format t "Known foods:~%~{~a~%~}"
        (loop for f being the hash-keys food-color
           collect f))

; @@PLEAC@@_5.2
;;-----------------------------
;; does %HASH have a value for $KEY ?
(if (nth-value 1 (gethash key hash))
    'it-exists
    'it-does-not)
;;;-----------------------------
;; food-color per the introduction
(dolist (name '("Banana" "Martini"))
  (format t "~A is a ~A.~%"
          name
          (if (nth-value 1 (gethash name food-color))
              "food" "drink")))
;;-----------------------------
(setf age (make-hash-table :test 'equal))
(setf (gethash "Toddler" age) 3)
(setf (gethash "Unborn" age) 0)
(setf (gethash "Phantasm" age) nil)
(dolist (thing '("Toddler" "Unborn" "Phantasm" "Relic"))
  (format t "~a: " thing)
  (multiple-value-bind (defined exists)
      (gethash thing age)
      (when exists
        (format t "Exists ")
        (when defined 
          (format t "Defined ")
          ;; 0 is not false in CL, so must explicitly mimic Perl here
          (unless (zerop defined)
            (format t "True ")))))
  (format t "~%"))

;;; @@PLEAC@@_5.3
;;;-----------------------------
;;; remove $KEY and its value from %HASH
(remhash key hash)
;;;-----------------------------


; @@PLEAC@@_8.2
;; Should we count the last line, if it does not end with a newline?
;; This version counts:
(with-open-file (stream #p"numbers.html")
  (loop for line = (read-line stream nil)
        while line
        count t))
;; and this does not:
(with-open-file (stream #p"numbers.html")
  (loop for (line missing-newline-p) =
            (multiple-value-list (read-line stream nil))
        while line
        count (not missing-newline-p)))

;;; @@PLEAC@@_10.0
;;;-----------------------------
(defparameter *greeted* 0)              ; global variable
(defun hello ()
  (incf *greeted*)
  (format t "hi there!~%"))
;;;-----------------------------
(hello)           ; call subroutine hello with no arguments/parameters
;;;-----------------------------

;;; @@PLEAC@@_10.1
;;;-----------------------------
;; It would be strange to declare arguments using &rest when you know
;; there are exactly two, in CL, but you could, if you wanted to
;; emulate what the Perl example does.
(defun hypotenuse (&rest args)
  (sqrt (+ (expt (elt args 0) 2) 
           (expt (elt args 1) 2))))

(setf diag (hypotenuse 3 4))            ; DIAG is 5.0
;;;-----------------------------
(defun hypotenuse (side1 side2)
  (sqrt (+ (expt side1 2) 
           (expt side2 2))))
;;;-----------------------------
(format t "~D~%" (truncate (hypotenuse 3 4))) ; prints 5

(let ((a '(3 4)))
  (format t "~D~%" (truncate (apply 'hypotenuse a)))) ; prints 5
;;;-----------------------------
(setf both (append men women))
(setf both `(,@men ,@women)) ; alternative way of doing the same thing
;;;-----------------------------
(setf nums '(1.4 3.5 6.7))
(setf ints (apply 'int-all nums))       ; NUMS unchanged
(defun int-all (&rest retlist)
  (loop for n in retlist collect (truncate n)))
;;;-----------------------------
(setf nums '(1.4 3.5 6.7))
(trunc-em nums)                         ; NUMS now (1 3 6)
(defun trunc-em (reals)
  (map-into reals 'truncate reals))     ; truncate each element of arg list
;;;-----------------------------

;;; @@PLEAC@@_10.2
;;;-----------------------------
(defun somefunc ()
  (let (variable              ; VARIABLE is invisible outside SOMEFUNC
        another an-array a-hash)    ; declaring many variables at once
    ;; ...
    ))
;;;-----------------------------
(destructuring-bind (name age) *posix-argv*
  ;; Use NAME, AGE here
  )

(setf start (fetch-time))
;;;-----------------------------
(destructuring-bind (a b) pair
  (let ((c (fetch-time)))
    ;; ...
    ))

(defun check-x (x)
  (let ((y "whatever"))
    (run-check)
    (when condition
      (format t "got ~A~%" x))))
;;;-----------------------------
(defun save-array (&rest arguments)
  ;; There's probably a better way to do this.
  (setf *global-array* (append *global-array* (copy-seq arguments))))
;;;-----------------------------

;;; @@PLEAC@@_10.3
;;;-----------------------------
(let (variable)
  (defun mysub ()
    ;; ... accessing VARIABLE
    ))
;;;-----------------------------
(let ((variable 1))
  (defun othersub ()
    ;; ... accessing VARIABLE
    ))
;;;-----------------------------
(let ((counter 0))
  (defun next-counter ()
    (incf counter)))
;;;-----------------------------
(let ((counter 42))
  (defun next-counter ()
    (incf counter))
  (defun prev-counter ()
    (decf counter)))
;;;-----------------------------

;;; @@PLEAC@@_10.4
;;;-----------------------------
;; There is no standard equivalent of Perl's caller(), in CL.
;; Functions can get inlined (among other things), so it's not even
;; clear what something like caller() should actually return, anyway.
;;;-----------------------------

;;; @@PLEAC@@_10.5
;;;-----------------------------
(array-diff array1 array2)              ; params are already references
;;;-----------------------------
(setf a #(1 2))
(setf b #(5 8))
(setf c (add-vecpair a b))
(format t "~{~A~^ ~}~%" (map 'list 'identity c))
;; 6 10

;; This function would be simpler with lists instead of arrays, or the
;; use of the SERIES package.  We're using arrays because the Perl
;; does.
(defun add-vecpair (x y)        ; assumes both vectors the same length
  (map-into (make-array (length x))
            '+ x y))
;;;-----------------------------
;; Normally one would use CHECK-TYPE or ASSERT here, but this example
;; is trying to match the Perl.
(unless (and (typep x 'vector)
             (typep y 'vector))
  (error "usage: add_vecpair VECTOR1 VECTOR2"))
;;;-----------------------------

;;; @@PLEAC@@_10.6
;;;-----------------------------
;; There is no equivalent to Perl's wantarray() in CL.  The most
;; similar language feature is CL's ability to return multiple values,
;; which the caller may choose to ignore.
;;;-----------------------------

;;; @@PLEAC@@_10.7
;;;-----------------------------
(thefunc :increment "20s" :start "+5m" :finish "+30m")
(thefunc :start "+5m" :finish "+30m")
(thefunc :finish "+30m")
(thefunc :start "+5m" :increment "15s")
;;;-----------------------------
;; &allow-other-keys is used to emulate the Perl example's use of @_
;; in the %args hash.
(defun thefunc (&key (increment "10s") finish start &allow-other-keys)
  (when (cl-ppcre:scan "m$" increment)
    ;; ...
    ))
;;;-----------------------------

;;; @@PLEAC@@_10.8
;;;-----------------------------
;; Use of gensym here is unusual, just trying to mimic the Perl (there
;; is probably a better way to do that, too).  Also, normally you'd do
;; MULTIPLE-VALUE-BIND.
(multiple-value-setq (a #.(gensym) c) (func))
;;;-----------------------------
;; I don't know of a quicker built-in way to do exactly what the Perl
;; is doing here.  There is NTH-VALUE but it only returns one value.
(let ((results (multiple-value-list (func))))
  (setf a (elt results 0)
        c (elt results 2)))

;; However you can easily define a macro that does roughly the same
;; thing.
(defmacro nth-values ((&rest positions) &body body)
  (let ((results (gensym "results-")))
    `(let ((,results (multiple-value-list ,@body)))
       (values
        ,@(mapcar #'(lambda (pos) `(elt ,results ,pos)) positions)))))

(multiple-value-setq (a c) (nth-values (0 2) (func)))
;;;-----------------------------
#+sbcl
(multiple-value-setq (dev ino dummy dummy uid)  (sb-unix:unix-stat filename))
;;;-----------------------------
#+sbcl
(multiple-value-setq (dev ino #.(gensym) #.(gensym) uid)  (sb-unix:unix-stat filename))
;;;-----------------------------
;; Using the non-standard NTH-VALUES macro defined above.
#+sbcl
(multiple-value-setq (dev ino uid gid) (nth-values (0 1 4 5) (sb-unix:unix-stat filename)))
;;;-----------------------------

;;; @@PLEAC@@_10.9
;;;-----------------------------
(multiple-value-setq (array hash) (somefunc))

(defun somefunc ()
  (let ((array (make-array ...))
        (hash (make-hash-table ...)))
    ;; ...
    (values array hash)))
;;;-----------------------------
(defun fn ()
  ;; ...
  (values a b c))                 ; assuming a, b and c are all hashes
;;;-----------------------------
(multiple-value-setq (h0 h1 h2) (fn))   ; unlike Perl example, not "wrong"
(setf list-of-hashes (multiple-value-list (fn))) ; eg: (gethash "keystring" (elt list-of-hashes 2))
(multiple-value-setq (r0 r1 r2) (fn)) ; everything's a reference, no difference from previous
;;;-----------------------------

;;; @@PLEAC@@_10.10
;;;-----------------------------
;; In CL everything returns a value.
;;;-----------------------------
(defun empty-retval ())                 ; returns nil
;; If you want to distinguish between returning "empty" vs "undefined"
;; then you can return return a second value indicating which.
(defun empty-retval ()
  (values nil nil))
;;;-----------------------------
(let ((a (yourfunc)))
  (when a
    ;; ...
    ))
;;;-----------------------------
;; The following are all the same, just mirroring the Perl here.
(let ((a (sfunc)))
  (unless a
    (error "sfunc failed")))

(let ((a (afunc)))
  (unless a
    (error "afunc failed")))

(let ((a (hfunc)))
  (unless a
    (error "hfunc failed")))
;;;-----------------------------
;; Note: this is for illustrating the use of OR and ERROR, there is no
;; built-in ioctl or strerror in CL.
(or (ioctl ...) (error "can't ioctl: ~A" strerror))
;;;-----------------------------

;;; @@PLEAC@@_10.11
;;;-----------------------------
(setf results (myfunc 3 5))
;;;-----------------------------
;; Unlike Perl, you can't call functions without using outer parens
;; (unless you develop macros to let you do so in specific
;; circumstances)
(setf results (myfunc 3 5))
;;;-----------------------------
;;;-----------------------------
(setf results `(,@(myfunc 3) 5))
;;;-----------------------------
(defun lock-sh () 1)
(defun lock-ex () 2)
(defun lock-un () 4)
;;;-----------------------------
(defun mypush (list &rest remainder)
  ;; ...
  )
;;;-----------------------------
(mypush (if (> x 10) a b) 3 5)          ; unlike Perl, not wrong
;;;-----------------------------
;; Params are already passed as references in CL
;;;-----------------------------
(defun hpush (href &rest keys-and-values)
  (loop
     for k in keys-and-values by #'cddr
     for v in (cdr keys-and-values) by #'cddr
     do (setf (gethash k href) v))
  href)                                 ; return this for caller's convenience

(hpush pieces "queen" 9 "rook" 5)
;;;-----------------------------

;;; @@PLEAC@@_10.12
;;;-----------------------------
(error "some message")                  ; raise exception
;;;-----------------------------
(multiple-value-bind (result condition)
    (ignore-errors (eval (func)))
  (when condition (warn "func raised an exception: ~A" condition)))
;;;-----------------------------
(multiple-value-bind (result condition)
    (ignore-errors (eval (setf val (func))))
  (when condition (warn "func blew up: ~A" condition)))
;;;-----------------------------
(multiple-value-bind (result condition)
    (ignore-errors (eval (setf val (func))))
  (when condition (warn "func blew up: ~A" condition)))
;;;-----------------------------
(multiple-value-bind (result condition)
    (ignore-errors (eval (setf val (func))))
  (when (and condition
             (not (cl-ppcre:scan "Full moon" 
                                 ;; There's probably a better way to
                                 ;; do this.
                                 (format nil "~A" condition))))
    (warn "func blew up: ~A" condition)))
;;;-----------------------------
;; No equivalent to wantarray().
;;;-----------------------------

;;; @@PLEAC@@_10.13
;;;-----------------------------
(defparameter *age* 18)                 ; global variable
(when CONDITION
  (let ((*age* 23))
    (func)                              ; sees temporary value of 23
    ) ; restore old value at block exit
;;;-----------------------------
(setf para (get-paragraph fh))
(defun get-paragraph (fh)
  (chomp
   (coerce (loop for c = (read-char fh nil :eof)
              until (or (eq c :eof)
                        (and (eql c #\Newline)
                             (eql (peek-char nil fh nil #\Newline) #\Newline)))
              collect c)
           'string)))
;;;-----------------------------
(setf contents (get-motd))
(defun get-motd ()
  (with-open-file (motd "/etc/motd") ; will do die()-like stuff automatically
    (coerce (loop
               for c = (read-char motd nil :eof)
               until (eq c :eof)
               collect c)
            'string)))
;;;-----------------------------
;;;-----------------------------
;; Note: in the spirit of the Perl, this section should be done using
;; LET and DECLARE SPECIAL but I couldn't get that to work.
(defparameter *nums* '(0 1 2 3 4 5))

(defun my-second ()     ; don't redefine CL's standard SECOND function
  (format t "~{~A~^ ~}~%" *nums*))

(defun my-first ()
  (let ((*nums* (copy-list *nums*)))
    (setf (elt *nums* 3) 3.14159)
    (my-second)))

(my-second)
;; 0 1 2 3 4 5
(my-first)
;; 0 1 2 3.14159 4 5
;;;-----------------------------
;; No obvious equivalent to %SIG
;;;-----------------------------

;;;-----------------------------
;;; @@INCOMPLETE@@

;;; @@PLEAC@@_10.14
;;;-----------------------------
(fmakunbound 'grow) ; not sure this is necessary, but more like the Perl
(setf (symbol-function 'grow) #'expand)
(grow)                                  ; calls EXPAND
;;;-----------------------------
(setf one:var two:table)                ; make ONE:VAR alias for TWO:TABLE
(setf (symbol-function 'one:big) #'two:small) ; make ONE:BIG alias for TWO:SMALL
;;;-----------------------------
(let ((fred #'barney))              ; temporarily alias FRED to BARNEY
  ;; ...
  )
;;;-----------------------------
(setf string (red "careful here"))
(format t "~A" string)
;; <FONT COLOR='red'>careful here</FONT>
;;;-----------------------------
(defun red (string)
  (concatenate 'string "<FONT COLOR='red'>" string "</FONT>"))
;;;-----------------------------
(defmacro color-font (color)
  `(defun ,(intern (string-upcase color)) (string)
     (concatenate 'string "<FONT COLOR='" ,color "'>" string "</FONT>")))

(color-font "red")
(color-font "green")
(color-font "blue")
(color-font "purple")
;; etc
;;;-----------------------------
(defmacro color-fonts (&rest colors)
  (append '(progn)
          (loop for color in colors
             collect `(color-font ,color))))

(color-fonts "red" "green" "blue" "yellow" "orange" "purple" "violet")
;;;-----------------------------

;;; @@PLEAC@@_10.16
;;;-----------------------------
(defun outer (arg)
  (let* ((x (+ arg 35))
         ;; You're much less likely to do this accidentally in CL, but
         ;; I'm trying to match the spirit of the Perl example.
         (inner (block nil
                  (return (* x 19)))))  ; WRONG
    (+ x (inner))))
;;;-----------------------------
(defun outer (arg)
  (let ((x (+ arg 35)))
    (flet ((inner () (* x 19)))
      (+ x (inner)))))
;;;-----------------------------

;;; @@PLEAC@@_10.17
;;;-----------------------------

(defgeneric cmp (a b)
  (:documentation "Vaguely like Perl's cmp() function."))

(defmethod cmp ((a string) (b string))
  (cond
    ((string= a b) 0)
    ((string-lessp a b) -1)
    (t 1)))

(defmethod cmp ((a number) (b number))
  (cond
    ((= a b) 0)
    ((< a b) -1)
    (t 1)))

(defmethod cmp (a b)
  0)

(defun bysub1 (&rest filenames)
  (let ((sub (make-array 0 :fill-pointer 0))
        (msgs (make-array 0 :fill-pointer 0)))
    (dolist (filename filenames)
      (with-open-file (file filename)
        ;; GET-PARAGRAPH defined in section 10.13
        (loop
           for paragraph = (get-paragraph file)
           until (string-equal paragraph "")
           do (when (cl-ppcre:scan (cl-ppcre:create-scanner #?r"^From" :multi-line-mode t) 
                                   paragraph)
                (vector-push-extend
                 (or
                  (cl-ppcre:register-groups-bind (subject)
                      ((cl-ppcre:create-scanner #?r/^Subject:\s*(?:Re:\s*)*(.*)/
                                                :case-insensitive-mode t :multi-line-mode t)
                       paragraph)
                    (string-downcase subject))
                  "")
                 sub))
           (vector-push-extend paragraph msgs))))
    (let ((indices (make-array (length msgs)
                               :initial-contents (loop
                                                    for i below (length msgs) 
                                                    collect i))))
      (sort indices #'(lambda (a b)
                        (case (if (and (< a (length sub)) (< b (length sub)))
                                  (cmp (aref sub a) (aref sub b))
                                  0)
                              (0 (< a b))
                              (-1 t))))
      (map nil #'(lambda (i)
                   (format t "~A~%" (aref msgs i)))
           indices))))

;; bysub2 illustrates a Perl-specific idiom and will be skipped.

;; The following could be made more efficient by using faster TEST
;; functions if the keys appear to be simpler, for example.
(defun mkhash (&rest keys/values)
  "Utility for making new hashes easily, used by BYSUB3 below."
  (let ((newhash (make-hash-table :test 'equal ; use EQUAL so strings work as keys
                                  :size (truncate (/ (length keys/values) 
                                                     2)))))
    (loop 
       for key in keys/values by #'cddr
       for value in (cdr keys/values) by #'cddr
       do (setf (gethash key newhash) value))
    newhash))

(defun print-hash (hashtable)
  "Useful for debugging."
  (loop
     for key being the hash-keys of hashtable using (hash-value value)
     do (format t "~A: ~A~%" key value)))
       
(defun bysub3 (&rest filenames)
  (let ((msgs (make-array 0 :fill-pointer 0)))
    (dolist (filename filenames)
      (with-open-file (file filename)
        (loop
           for paragraph = (get-paragraph file)
           until (string-equal paragraph "")
           do 
           (when (cl-ppcre:scan (cl-ppcre:create-scanner #?r"^From" :multi-line-mode t) 
                                paragraph)
             (vector-push-extend
              (mkhash
               :subject (cl-ppcre:register-groups-bind (subject)
                            ((cl-ppcre:create-scanner #?r/^Subject:\s*(?:Re:\s*)*(.*)/
                                                      :case-insensitive-mode t :multi-line-mode t) paragraph)
                          (string-downcase subject))
               :number (fill-pointer msgs)
               :text "")
              msgs))
           (let ((mail-record (aref msgs (1- (fill-pointer msgs)))))
             (setf (gethash :text mail-record) (concatenate 'string (gethash :text mail-record) paragraph))))))
    (map nil #'(lambda (msg)
                 (format t "~A" (gethash :text msg)))
         (sort msgs #'(lambda (a b)
                        (let ((subject-a (gethash :subject a))
                              (subject-b (gethash :subject b)))
                          (case (cmp subject-a subject-b)
                            (0 (< (gethash :number a) (gethash :number b)))
                            (-1 t))))))))

;; Can be downloaded using ASDF-INSTALL
(require :metatilities)

(defun datesort (&rest filenames)
  (let ((msgs (make-array 0 :fill-pointer 0)))
    (dolist (filename filenames)
      (with-open-file (file filename)
        (loop
           for paragraph = (get-paragraph file)
           until (string-equal paragraph "")
           do 
           (when (cl-ppcre:scan (cl-ppcre:create-scanner #?r"^From" :multi-line-mode t) 
                                paragraph)
             (vector-push-extend
              (mkhash
               :subject (cl-ppcre:register-groups-bind (subject)
                            ((cl-ppcre:create-scanner #?r/^Subject:\s*(?:Re:\s*)*(.*)/
                                                      :case-insensitive-mode t :multi-line-mode t) paragraph)
                          (string-downcase subject))
               :number (fill-pointer msgs)
               ;; Need IGNORE-ERRORS because PARSE-DATE-AND-TIME can
               ;; signal conditions
               :date (ignore-errors 
                       (metatilities:parse-date-and-time
                        (cl-ppcre:register-groups-bind (date)
                            ((cl-ppcre:create-scanner #?r/^Date:\s*(.*)/ :multi-line-mode t) paragraph)
                          (car (cl-ppcre:split #?r"\s+\(" date)))))
               :text "")
              msgs))
           (let ((mail-record (aref msgs (1- (fill-pointer msgs)))))
             (setf (gethash :text mail-record) (concatenate 'string (gethash :text mail-record) paragraph))))))
    (map nil #'(lambda (msg)
                 (format t "~A" (gethash :text msg)))
         (sort msgs #'(lambda (a b)
                        (case (cmp (gethash :subject a) (gethash :subject b))
                          (-1 t)
                          (0 (case (cmp (gethash :date a) (gethash :date b))
                               (-1 t)
                               (0 (< (gethash :number a) (gethash :number b)))))))))))

;;; @@PLEAC@@_11.0
;;;-----------------------------
(format t "~A" sref) ; prints the value that the reference SREF refers to
(setf sref 3)                           ; assigns SREF's referent
;;;-----------------------------
;; The Perl subsection here isn't any different from the above, in CL.
;;print ${$sref};             # prints the scalar $sref refers to
;;${$sref} = 3;               # assigns to $sref's referent
;;;-----------------------------
;; We're calling this MY-AREF instead of AREF to avoid confusion with
;; CL's built-in AREF function.
(setf my-aref array)       ; no special synatx needed to get reference
;;;-----------------------------
;; Not sure what the Perl here is trying to show.  Probably has no
;; realistic equivalent in CL.
;; $pi = \3.14159;
;; $$pi = 4;           # runtime error
;;;-----------------------------
(setf my-aref #(3 4 5)) ; new array (no "anonymous" distinction in CL)
;; MKHASH defined above, not standard CL
(setf href (mkhash "How" "Now" "Brown" "Cow"))
;;;-----------------------------
(makunbound 'my-aref)
(setf my-aref #(1 2 3))
(format t "~A" my-aref)
;; #(1 2 3)
;;;-----------------------------
;;; @@INCOMPLETE@@
;;;-----------------------------
;; MKHASH defined above
(setf nat (mkhash "Name" "Leonhard Euler"
                  "Address" (format nil "1729 Ramanujan Lane~%Mathworld, PI 31416")
                  "Birthday" #x5bb5580))
;;;-----------------------------

;;; @@PLEAC@@_11.1
;;;-----------------------------
(setf my-aref array) 
(setf anon-array #(1 3 5 7 9))
(setf anon-copy (copy-seq array))
(setf implicit-creation (copy-seq #(2 4 6 8 10))) ; not sure this is what the Perl means
;;;-----------------------------
(vector-push-extend 11 anon-array)      ; ANON-ARRAY must have fill pointer (unlike above)
;;;-----------------------------
(setf two (aref implicit-creation 0))
;;;-----------------------------
(setf last-idx (1- (length my-aref)))
(setf num-items (length my-aref))
;;;-----------------------------
;; check wehther SOMEREF contains a simple array reference
(check-type someref simple-vector) ; CHECK-TYPE does a die() implicitly, if necessary

(format t "~{~A~^ ~}~%" (coerce array-ref 'list))

;; SORT modifies the original array so we use STABLE-SORT to be more
;; like the Perl example.
(setf order (stable-sort array-ref '<))

;; Only works if ARRAY-REF has a fill-pointer
(setf array-ref (make-array 0 :adjustable t :fill-pointer 0)) ; for example
(vector-push-extend item array-ref)
;;;-----------------------------
(defun array-ref ()
  ;; This is probably the closest to what the Perl would return.
  (make-array 0 :adjustable t :fill-pointer 0))

(setf aref1 (array-ref))
(setf aref2 (array-ref))
;;;-----------------------------
(format t "~A" (aref array-ref n))      ; access item in position N, works on any array
(format t "~A" (svref array-ref n)) ; access item in position N, possibly fastest, only
                                    ; works on type SIMPLE-VECTOR (single-dimensional arrays)
(format t "~A" (elt array-ref n))       ; same, works on any sequence type, but possibly slower
;;;-----------------------------
(setf pie #(0 1 2 3 4 5 6 7 8 9))
(make-array 3 :displaced-to pie :displaced-index-offset 3) ; array slice
;;;-----------------------------
(setf (subseq pie 3 6) #("blackberry" "blueberry" "pumpkin")) ; note 6 instead of 5, not a typo
;;;-----------------------------
(setf sliceref (make-array 3 :displaced-to pie :displaced-index-offset 3)) ; not wrong
;;;-----------------------------
(map nil
     #'(lambda (item)
         ;; ITEM has data
         )
     array-ref)

(dotimes (idx (array-dimension array-ref 0))
  ;; (svref array-ref idx) has data
  )
;;;-----------------------------

;;; @@PLEAC@@_11.2
;;;-----------------------------
;; Note: HASH must be creaed with :TEST 'EQUAL
(push "new value" (gethash "KEYNAME" hash))
;;;-----------------------------
(loop
   for string being the hash-keys of hash
   do (format t "~A: ~A~%" string (gethash string hash)))
;;;-----------------------------
(setf (gethash "a key" hash) #(3 4 5))  ; anonymous array
(setf (gethash "a key" hash) '(3 4 5))  ; ...or a list would work too
;;;-----------------------------
(setf values (gethash "a key" hash))
;;;-----------------------------
(push value (gethash "a key" hash))
;;;-----------------------------
(setf residents (gethash number phone2name)) ; will be NIL if not found
;;;-----------------------------
;; The Perl example would translate to the same thing as the previous
;; subsection in CL (since GETHASH returns NIL when there is no value,
;; and NIL is the empty list).  However, to match the "sprit" of the
;; Perl example (and return an empty array instead of an empty list),
;; you could do the following, which takes advantage of the fact that
;; GETHASH returns a second value indicating whether or not the hash
;; key actually has a value.
(setf residents (multiple-value-bind (value exists) (gethash number phone2name)
                  (if exists
                      value
                      #())))
;;;-----------------------------


;;; @@PLEAC@@_11.3
;;;-----------------------------
(setf href hash)
(setf anon-hash (mkhash "key1" "value1" "key2" "value2" ...)) ; MKHASH defined above

;; Couldn't find anything like this in standard CL.  Someone please
;; correct me if I'm wrong.
(defun copy-hash-table (hash-table)
  "Make shallow copy of HASH."
  (let ((newhash (make-hash-table :test (hash-table-test hash-table) 
                                  :size (hash-table-size hash-table))))
    (loop for key being the hash-keys of hash-table using (hash-value value)
         do (setf (gethash key newhash) (gethash key hash-table)))
    newhash))

(setf anonymous-hash-copy (copy-hash-table hash))
;;;-----------------------------
(setf hash href)
(setf value (gethash key href))

(setf slice (loop for key in (list key1 key2 key3)
                 collect (gethash key href)))
(setf keys (loop for key being the hash-keys of href collect key))
;;;-----------------------------
(check-type someref hash-table) ; CHECK-TYPE does a die() implicitly, if necessary
;;;-----------------------------
(dolist (href (list env inc)) ; ENV and INC don't exist in CL, just matching the Perl
  (loop for key being the hash-keys of href using (hash-value value)
       do (format t "~A => ~A~%" key value)))
;;;-----------------------------
(setf values (loop for key in '("key1" "key2" "key3")
                collect (gethash key hash-ref)))

;; The following will NOT work like the Perl example, VAL is a copy of
;; the hash value because numeric values are copied.
(dolist val (loop for key in '("key1" "key2" "key3")
               collect (gethash key hash-ref))
        (incf val 7))              ; does NOT modify hash table at all

;; You'd have to do something like this instead.
(loop for key in '("key1" "key2" "key3")
   do (incf (gethash key hash-ref 0) 7))
;;;-----------------------------
        
;;; @@PLEAC@@_11.4
;;;-----------------------------

;; If you want to be able to call the function using the alias like
;; "normal" (i.e., as the first element of a form) SETF its
;; SYMBOL-FUNCTION:
(setf (symbol-function 'cref) #'func)
(setf (symbol-function 'cref) #'(lambda (...)))

;; If you do the following instead, you'll have to use APPLY and/or
;; FUNCALL.
(setf 'cref2 #'func)
(setf 'cref2 #'(lambda (...)))
;;;-----------------------------
(setf returned (cref ...))
;; If you have a list of arguments (more like the Perl example):
(setf returned (apply 'cref arguments))
;; Or you can use FUNCALL (not that you really need to in this case)
(setf returned (funcall 'cref ...))

;; If you didn't use SYMBOL-FUNCTION, then you can do the following:
(setf returned (apply cref arguments)) ; note the lack of a ' in front of CREF
(setf returned (funcall cref ...))      ; ditto
;;;-----------------------------
(defun thefunc ()
  ;; ...
  )
(setf funcname "THEFUNC")  ; upper-case to pick up correct symbol name
(funcall (intern funcname))
;;;-----------------------------
;; MKHASH defined above
(defparameter *commands*
  (mkhash "happy" #'joy
          "sad" #'sullen
          "done" #'(lambda () (error "See ya!"))
          "mad" #'angry))

(format t "How are you?")
(let* ((string (chomp (read-line))) ; CHOMP defined in appendix
       (command (gethash string *commands*)))
  (if command
      (funcall command)
      (format t "No such command: ~A~%" string)))
;;;-----------------------------
(defun counter-maker ()
  (let ((start 0))
    #'(lambda ()
        (prog1 start                       ; return value of START prior to increment
          (incf start)))))

(setf (symbol-function 'counter) (counter-maker))

(loop repeat 5 
     do (format t "~A~%" (counter)))
;;;-----------------------------
(setf (symbol-function 'counter1) (counter-maker)
      (symbol-function 'counter2) (counter-maker))

(loop repeat 5 
     do (format t "~A~%" (counter1)))
(format t "~A ~A~%" (counter1) (counter2))
;; 0
;; 1
;; 2
;; 3
;; 4
;; 5 0
;;;-----------------------------
(defun timestamp ()
  (let ((start-time (get-universal-time)))
    #'(lambda ()
        (- (get-universal-time) start-time))))

(setf (symbol-function 'early) (timestamp))
(sleep 20)
(setf (symbol-function 'later) (timestamp))
(sleep 10)
(format t "It's been ~D seconds since early.~%" (early))
(format t "It's been ~D seconds since later.~%" (later))
;; It's been 30 seconds since early.
;; It's been 10 seconds since later.
;;;-----------------------------

;;; @@PLEAC@@_11.7
;;;-----------------------------
(setf c1 (mkcounter 20)
      c2 (mkcounter 77))

(format t "next c1: ~d~%" (funcall (gethash "NEXT" c1))) ; 21 
(format t "next c2: ~d~%" (funcall (gethash "NEXT" c2))) ; 78 
(format t "next c1: ~d~%" (funcall (gethash "NEXT" c1))) ; 22 
(format t "last c1: ~d~%" (funcall (gethash "PREV" c1))) ; 21 
(format t "old  c2: ~d~%" (funcall (gethash "RESET" c2))) ; 77
;;;-----------------------------
(defun mkcounter (start)
  (let* ((count start)
         (bundle
          ;; MKHASH defined above
          (mkhash 
           "NEXT"   #'(lambda () (incf count))
           "PREV"   #'(lambda () (decf count))
           "GET"    #'(lambda () count)
           "SET"    #'(lambda (new-count) (setf count new-count))
           "BUMP"   #'(lambda (delta) (incf count delta))
           "RESET"  #'(lambda () (setf count start)))))
    (setf (gethash "LAST" bundle) (gethash "PREV" bundle))
    bundle))
;;;-----------------------------

;;; @@PLEAC@@_11.8
;;;-----------------------------
;; Methods in CL are generic functions that can be specialized on any
;; of their arguments.  The technique that the Perl code is using to
;; allow calling meth() without the $obj-> is needless in CL.  You can
;; make a reference to a method, the same way you might make a
;; referece a normal function.  There's not much point in doing this,
;; normally.
(setf (symbol-function 'mref) #'meth)
;; later...
(mref "args" "go" "here")
;;;-----------------------------
(setf (symbol-funtion 'sref) #'meth)
;;;-----------------------------

;;; @@PLEAC@@_11.15
;;;-----------------------------

;;; Binary trees example
(deftype tree () '(or null tree-node))
(defstruct (tree-node
             (:conc-name #:tree-))
  value
  ;; subtrees
  (left nil :type tree)
  (right nil :type tree))

(defun tree-insert (tree value)
  "Return TREE with destructively inserted VALUE."
  (declare (type tree tree))
  (if tree
      (progn (if (< value (tree-value tree))
                 (setf (tree-left tree)
                       (tree-insert (tree-left tree) value))
                 (setf (tree-right tree)
                       (tree-insert (tree-right tree) value)))
             tree)
      (make-tree-node :value value)))

(defun print-tree-in-order (tree)
  (when tree
    (print-tree-in-order (tree-left tree))
    (format t "~S " (tree-value tree))
    (print-tree-in-order (tree-right tree))))

(defun print-tree-in-preorder (tree)
  (when tree
    (format t "~S " (tree-value tree))
    (print-tree-in-preorder (tree-left tree))
    (print-tree-in-preorder (tree-right tree))))

(defun print-tree-in-postorder (tree)
  (when tree
    (print-tree-in-postorder (tree-left tree))
    (print-tree-in-postorder (tree-right tree))
    (format t "~S " (tree-value tree))))

(defun search-tree (tree value)
  "Return a subtree of TREE with the specified VALUE in root."
  (when tree
    (if (= (tree-value tree) value)
        tree
        (search-tree (if (< value (tree-value tree))
                         (tree-left tree)
                         (tree-right tree))
                     value))))

(defun test-trees ()
  (let ((tree nil))
    (dotimes (i 20)
      (setf tree (tree-insert tree (random 1000))))
    (format t "~&Pre order: ") (print-tree-in-preorder tree)
    (format t "~&In order:  ") (print-tree-in-order tree)
    (format t "~&Postorder: ") (print-tree-in-postorder tree)
    (terpri)

    (loop do
         (format t "~&Search? ")
         (finish-output)
         (let* ((eof (gensym)) ; some hard-to-enter object
                (value (read *standard-input* nil eof)))
           (when (eq value eof) (loop-finish))
           (let ((found (search-tree tree value)))
             (if found
                 (format t "Found ~S at ~S~%" value found)
                 (format t "No ~S in tree~%" value)))))))
