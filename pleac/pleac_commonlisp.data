;;;; -*- lisp -*-
;;;; @@PLEAC@@_NAME
;;;; @@SKIP@@ Common Lisp

;;;; @@PLEAC@@_WEB
;;;; @@SKIP@@ http://www.lisp.org/
;;;; @@SKIP@@ http://www.sbcl.org/

;;;; @@PLEAC@@_INTRO

;;;; @@SKIP@@ Newer submissions use SBCL, and make use of a number of
;;;; @@SKIP@@ SBCL and third-party libraries (see Appendix for
;;;; @@SKIP@@ details).

;;;; @@PLEAC@@_APPENDIX

(defmacro chomp (string)
  "Similar to Perl's chomp(), although it returns the new value of
STRING rather than the number of characters removed."
  `(setf ,string (string-right-trim #(#\Newline #\Return) ,string)))

;;;; @@SKIP@@ Common Lisp code makes use of the following for
;;;; @@SKIP@@ package/loading: 
;;;; @@SKIP@@  (require :PACKAGENAME)

;;;; @@SKIP@@ SBCL code makes use of the following for package /
;;;; @@SKIP@@ library loading:
;;;; @@SKIP@@  (asdf:operate 'asdf:load-op :date-calc) ; load the package
;;;; @@SKIP@@  (use-package 'date-calc)                ; import the symbols
;;;; @@SKIP@@  (load "time.lisp")              ; replace with your location of the pdl library
;;;; @@SKIP@@  (use-package 'CyberTiggyr-Time) ; for printing times in various formats

;;;; @@SKIP@@ Packages / libraries used include:
;;;; @@SKIP@@  http://www.cliki.net/cl-ppcre
;;;; @@SKIP@@  http://www.cliki.net/cl-interpol
;;;; @@SKIP@@  http://www.cliki.net/date-calc
;;;; @@SKIP@@  http://www.cliki.net/asdf
;;;; @@SKIP@@  http://cybertiggyr.com/gene/pdl/

;;; @@PLEAC@@_1.0
;;;-----------------------------
(setf string "\\n")                     ; two characters, \ and an n
(setf string "John 'Maddog' Orwant")    ; literal single quotes
;;;-----------------------------
;; newlines may be inserted literally
(setf string "                          
")                                      ; a "newline" character
;; or by creating a string explicitly
(setf string (make-string 1 :initial-element #\Newline))
;; or by using format with a nil output stream
(setf string (format nil "~%"))
(setf string "John \"Maddog\" Orwant")  ; literal double quotes
;;;-----------------------------
(setf string "John 'Maddog' Orwant")  ; literal single quotes
;;;-----------------------------
(setf string "
This is a multiline string, terminated by a
double quotation mark.
")
;;;-----------------------------
;; There are no CL equivalents to Perl's other ways of quoting
;; strings (q//, etc).
;;;-----------------------------

;;; @@PLEAC@@_1.1
;;;-----------------------------
;; assign a substring to a variable
(setf value (subseq string offset (+ offset count)))
(setf value (subseq string offset))

;; edit a substring
(setf string (concatenate 'string 
                          (subseq string 0 offset) 
                          newstring
                          (subseq string (+ offset count))))
(setf string (concatenate 'string 
                          (subseq string 0 offset) 
                          newtail))

;;;-----------------------------
;; get a 5-byte string, skip 3, then grab 2 8-byte strings, then the
;; rest
(setf leading (subseq data 5)
      s1 (subseq data 8 8)
      s2 (subseq data 16 8)
      trailing (subseq data 24))

;; split at five byte boundries
(let ((length (length string)))
  (loop for idx from 0 upto length by 5
     collect (subseq string idx (min length (+ idx 5)))))

;; chop string into individual characters
(loop for idx from 0 upto (1- (length string))
      collect (char string idx))
;;;-----------------------------
(defparameter *string* "This is what you have")
;;;             +012345678901234567890  Indexing forwards  (left to right)
;;;              109876543210987654321- Indexing backwards (right to left)

(let ((first (subseq *string* 0 1))                        ; "T"
      (start (subseq *string* 5 7))                        ; "is"
      (rest (subseq *string* 13))                       ; "you have"
      (last (subseq *string* (+ (length *string*) -1))) ; "e"
      (end (subseq *string* (+ (length *string*) -4)))   ; "have"
      (piece (subseq *string*
                     (+ (length *string*) -8)
                     (+ (length *string*) -8 3)))) ; "you"
  (list first start rest last end piece))
;; ("T" "is" "you have" "e" "have" "you")
;;;-----------------------------
(defparameter *string* "This is what you have")
(print *string*)
;; This is what you have

;; Change "is" to "wasn't"
(setf *string*
       (concatenate 'string
                    (subseq *string* 0 5)
                    "wasn't"
                    (subseq *string* (+ 5 2))))
;; This wasn't what you have

;; Replace last 12 characters
(setf *string*
       (concatenate 'string
                    (subseq *string* 0 (+ (length *string*) -12))
                    "ondrous"))
;; This wasn't wondrous

;; Delete first character
(setf *string* (subseq *string* 1))
;; his wasn't wondrous

;; Delete last 10 characters
(setf *string* (subseq *string* 0 (+ (length *string*) -10)))
;; his wasn'
;;;-----------------------------
;; you can test substrings with the :start and :end keyword parameters
;; of CL-PPCRE:SCAN
(when (cl-ppcre:scan "pattern" *string* :start (- (length *string*) 10))
  (format t "Pattern matches in last 10 characters~%"))

;; substitute "at" for "is", restricted to first five characters
(concatenate 'string
              (cl-ppcre:regex-replace "is" *string* "at"
                                      :start 0
                                      :end (min (length *string*) 5))
              (when (> (length *string*) 5)
                (subseq *string* 5)))
;;;-----------------------------
;; exchange the first and last letters in a string
(let ((a "make a hat"))
  ;; ROTATEF is CL's general-purpose swap macro
  (rotatef (char a 0) (char a (1- (length a))))
  (princ a))
;; take a ham
;;;-----------------------------
;; extract column with SUBSEQ
(let* ((a "To be or not to be")
       (b (subseq a 6 12))) ; skip 6, grab 6
  (format t "~A~%" b)
;; or not

  ;; forward 6, grab 2; backward 5, grab 2
  (destructuring-bind (b c) `(,(subseq a 6 8) ,(subseq a 3 5))
    (format t "~A~%~A~%" b c)))
;; or
;; be
;;;-----------------------------
(defun cut2fmt (&rest positions)
  "Useless in CL, which lacks Perl's unpack(); here for completeness."
  (let ((template "")
        (lastpos 1))
    (dolist (place positions)
      (setf template (format nil "~AA~D " template (- place lastpos)))
      (setf lastpos place))
    (setf template (concatenate 'string template "A*"))
    template))
(let ((fmt (cut2fmt 8 14 20 26 30)))
  (format t "~A~%" fmt))
;; A7 A6 A6 A6 A4 A*
;;;-----------------------------

;;; @@PLEAC@@_1.2
;;;-----------------------------
;; use b if b is true, else c
(setf a (or b c))

;; set x to y unless x is already true
(unless x (setf x y))
;;;-----------------------------
;; use b if b is defined, otherwise c
(setf a (if (boundp 'b) b c))
;;;-----------------------------
(setf foo (or bar "DEFAULT VALUE"))
;;;-----------------------------
#+sbcl 
(defparameter ARGV (copy-seq (cdr *posix-argv*)) "Arguments from shell, Perl style")

(setf dir (or (pop ARGV) "/tmp"))
;;;-----------------------------
(setf dir (or (nth 0 ARGV) "/tmp"))
;;;-----------------------------
(setf dir (if (plusp (length ARGV)) (pop ARGV) "/tmp"))
;;;-----------------------------
(setf dir (if (plusp (length ARGV)) (nth 0 ARGV) "/tmp"))
;;;-----------------------------
(setf count (make-hash-table))
(incf (gethash (or shell "/bin/sh") count 0))
;;;-----------------------------
;; find the user name on Unix systems
(setf user (or (posix-getenv "USER")
               (posix-getenv "LOGNAME")
               #+sbcl
               (let ((uid (sb-posix:getuid)))
                 (or (sb-posix:passwd-name (sb-posix:getpwuid uid))
                     (format nil "Unknown uid number ~a" uid)))
               #-sbcl
               "Unknown uid"))
;;;-----------------------------
(setf starting-point (or starting-point "Greenwich"))
;;;-----------------------------
;; Perl array-to-array assignment copies the array, hence the need for
;; COPY-SEQ below.
(unless (plusp (length a))
  (setf a (copy-seq b)))                ; copy only if empty
(setf a (copy-seq (if (plusp (length b))
                      b
                      c)))              ; assign b if nonempty, else c
;;;-----------------------------

;;; @@PLEAC@@_1.3
;;;-----------------------------
;; There are several ways to swap variables in CL.  ROTATEF is usually
;; the simplest choice.
(rotatef VAR1 VAR2)
(psetq VAR1 VAR2 VAR2 VAR1)
(multiple-value-setq (VAR1 VAR2) 
  (values VAR2 VAR1))
;;;-----------------------------
(setf temp a
      a b
      b temp)
;;;-----------------------------
(let ((a "alpha")
      (b "omega"))
  (rotatef a b))           ; the first shall be last -- and versa vice
;;;-----------------------------
(destructuring-bind (alpha beta production)
    ;; In CL one would normally use symbols here:
    ;; '(January March August)
    '("January" "March" "August")
  ;; move beta       to alpha,
  ;; move production to beta,
  ;; move alpha      to production
  (rotatef alpha beta production))
;;;-----------------------------

;;; @@PLEAC@@_1.4
;;-----------------------------
(setq num (char-code char))
(setq char (code-char num))
;;-----------------------------
(setq char (format nil "~c" (code-char num)))
(format t "Number ~d is character ~c~%" num (code-char num))
;; Number 101 is character e
;;;-----------------------------
(setq ASCII (map 'list #'char-code string))
(setq string (map 'string #'code-char ASCII))
;;-----------------------------
(setq ascii-value (char-code #\e))             ; now 101
(setq character (code-char 101))               ; now #\e
;;-----------------------------
(format t "Number ~D is character ~C~%" 101 (code-char 101))
;;-----------------------------
(let ((ascii-character-numbers (map 'list #'char-code "sample")))
  (format t "~{~A~^ ~}~%" ascii-character-numbers)
;; 115 97 109 112 108 101
  (setf word (map 'string #'code-char ascii-character-numbers))
  (setf word (map 'string #'code-char #(115 97 109 112 108 101))) ; same
  (format t "~A~%" word))
;; sample
;;;-----------------------------
(let* ((hal "HAL")
       (ibm (map 'string
                 (lambda (char)
                   (code-char (1+ (char-code char)))) ; add one to each ASCII value
                 hal)))
  (format t "~A~%" ibm))                ; prints "IBM"
;;;-----------------------------

;;; @@PLEAC@@_1.5
;;;-----------------------------
(setq array (map 'list #'string string))

(setq array (loop for char across string
               collect (char-code char)))
;;;-----------------------------
(cl-ppcre:do-matches-as-strings (match "(.)" string)
  ;; do something with MATCH
  )
;;;-----------------------------
(let ((seen (make-hash-table))
      (string "an apple a day"))
  (loop for char across string do
       (incf (gethash char seen 0)))
  (let ((chars (loop for char being each hash-key of seen
                  collect char)))
    (format t "unique chars are: ~{~C~}~%" 
            (sort chars '< :key 'char-code))))
;; unique chars are:  adelnpy
;;;-----------------------------
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (reduce #'+ string :key #'char-code)))
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (loop for char across string
                summing (char-code char))))
;;;-----------------------------
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (loop for char across string
             sum (char-code char))))
;; prints "1248" if string was "an apple a day"
;;;-----------------------------
;; There's no equivalent to Perl's unpack(), this is about as close as
;; you can get.
(setf sum (loop for char across string
             sum (char-code char)))
;;;-----------------------------
;; In CL it makes more sense to call this function from the REPL than
;; it does to put it into a separate script.  E.g.,
;;  > (sum "/tmp/xyz")
(defun sum (&rest files)
  (let ((sum 0))
    (dolist (filename files)
      (with-open-file (file filename :element-type 'unsigned-byte)
        (do ((b (read-byte file nil :eof)
                (read-byte file nil :eof)))
            ((eql b :eof))
          (incf sum b))))
    (let ((r (+ (mod sum (expt 2 16))
                (truncate (/ (mod sum (expt 2 32))
                             (expt 2 16))))))
      (+ (mod r (expt 2 16))
         (truncate (/ r (expt 2 16)))))))
;;;-----------------------------
;;CL-USER> (sum "/mach.sym")
;;24298
;;;-----------------------------
;;%cksum -o 2 /mach.sym
;;24298 1203 /mach.sym
;;;-----------------------------
(defun slowcat (number-or-filename &rest more-files)
  "The first argument can be a number of seconds to sleep between
characters, otherwise it should be a file name."
  (let ((delay (if (numberp number-or-filename) number-or-filename 1))
        (files (if (numberp number-or-filename) more-files (cons number-or-filename more-files))))
    (dolist (filename files)
      (with-open-file (file filename)
        (do ((c (read-char file nil :eof)
                (read-char file nil :eof)))
            ((eql c :eof))
          (format t "~C" c)
          (finish-output)
          (sleep (* delay 0.005)))))))

;;; @@PLEAC@@_1.6
;;;-----------------------------
(setq revbytes (reverse string))
;;;-----------------------------
(setq revwords (format nil "~{~A~^ ~}"
                       (reverse (cl-ppcre:split " " string))))
(setq revwords (reverse
                (do* ((stringstream (make-string-input-stream string))
                      (result nil (cons next result))
                      (next (read stringstream nil 'eos)
                            (read stringstream nil 'eos)))
                     ((equal next 'eos)
                      (reverse result)))))
;;;-----------------------------
(setq gnirts (reverse string))          ; reverse letters in string

(setq sdrow (reverse words))            ; reverse elements in words

(setq confused (reverse (apply #'concatenate 'string words))) ; reverse letters in join("", @words)
;;;-----------------------------
(setq string "Yoda said, \"can you see this?\"")
(setq allwords (cl-ppcre:split " " string))
(setq revwords (format nil "~{~A~^ ~}" (reverse allwords)))
(format t "~A~%" revwords)
;this?" see you "can said, Yoda
;;;-----------------------------
(setq revwords (format nil "~{~A~^ ~}" (reverse (cl-ppcre:split " " string))))
;;;-----------------------------
(setq revwords (apply #'concatenate 'string
                      (cl-ppcre:split "(\\s+)" string :with-registers-p t)))
;;;-----------------------------
(defun palindrome-p (word)
  (string= word (reverse word)))
(palindrome-p "reviver")
;; T
;;;-----------------------------
(with-open-file (inf "/usr/share/dict/words")
  (loop for word = (read-line inf nil nil)
        while word
        when (and (string= word (reverse word)) 
                  (> (length word) 5))
        do (format t "~a~%" word)))
;; deedeed
;; degged
;; hallah
;; kakkak
;; murdrum
;; redder
;; repaper
;; retter
;; reviver
;; rotator
;; sooloos
;; tebbet
;; terret
;;;-----------------------------

;;; @@PLEAC@@_1.7
;;;-----------------------------

;;;-----------------------------
(defun tab-expand (string &optional (tabstop 8))
  (flet ((needed-spaces (target-string start end match-start match-end reg-starts reg-ends)
           (declare (ignore target-string start end reg-starts reg-ends))
           (make-string (- (* (- match-end match-start) tabstop)
                           (mod match-start tabstop))
                        :initial-element #\Space)))
    (cl-ppcre:regex-replace-all "\\t+" string #'needed-spaces)))

(defun tab-unexpand (string &optional (tabstop 8))
  (flet ((needed-tabs (target-string start end match-start match-end reg-starts reg-ends)
           (declare (ignore target-string start end reg-starts reg-ends))
           (let ((match-length (- match-end match-start)))
             (concatenate 'string
                          (make-string (floor match-length tabstop)
                                       :initial-element #\Tab)
                          (make-string (mod match-length tabstop)
                                       :initial-element #\Space)))))
    (cl-ppcre:regex-replace-all "  +" string #'needed-tabs)))
;;;-----------------------------
(loop for line = (read-line *standard-input* nil nil)
      while line do
      (format t "~a~%" (tab-expand line)))
;;;-----------------------------
(loop for line = (read-line *standard-input* nil nil)
      while line do
      (format t "~a~%" (tab-unexpand line)))
;;;-----------------------------

;;; @@PLEAC@@_1.8
;;;-----------------------------

(setf text "You owe $debt to me")
;;;-----------------------------
(defun global-deref (match var-name)
  "Helper function to simulate Perl's string interpolation in
regexps."
  (write-to-string (symbol-value (intern (string-upcase var-name)))))

(setf text (cl-ppcre:regex-replace-all "\\$(\\w+)" text #'global-deref
                                       :simple-calls t))
;;;-----------------------------
(setq rows 24 cols 80)
(setq text "I am $rows high and $cols long")
(setq text (cl-ppcre:regex-replace-all "\\$(\\w+)" text
                                       #'global-deref
                                       :simple-calls t))
(format t "~A~%" text)
;; I am 24 high and 80 long
;;;-----------------------------
(setf text "I am 17 years old")
(setf text (cl-ppcre:regex-replace-all "(\\d+)" text
                                       (lambda (match num-str)
                                         (declare (ignore match))
                                         (write-to-string
                                          (* 2 (parse-integer num-str))))
                                       :simple-calls t))
;;;-----------------------------
(* 2 17)
;;;-----------------------------
;; expand variables in text, but put an error message in
;; if the variable isn't defined
(flet ((deref-with-err (match word)
         (declare (ignore match))
         (let ((word-sym (intern (string-upcase word))))
           (if (boundp word-sym)
               (write-to-string (symbol-value word-sym))
               (format nil "[NO VARIABLE: $~a]" word-sym)))))
  (setf text (cl-ppcre:regex-replace-all "\\$(\\w+)" text
                                         #'deref-with-err
                                         :simple-calls t)))
;;;-----------------------------


;;; @@PLEAC@@_1.9
;;;-----------------------------
(setf big (string-upcase little))       ; "bo peep" -> "BO PEEP"
(setf little (string-downcase big))     ; "JOHN"    -> "john"
;; Reminder: the following depends on CL-INTERPOL.
(setf big #?"\U$(little)")              ; "bo peep" -> "BO PEEP"
(setf little #?"\L$(big)")              ; "JOHN" -> "john"
;;;-----------------------------
(setf big (string-upcase little :end 1)    ; "bo"      -> "Bo"
(setf little (string-downcase BIG :end 1)) ; "BoPeep"    -> "boPeep"
(setf big #?"\u$(little)")                 ; "bo"      -> "Bo"
(setf little #?"\l$(big)")                 ; "BoPeep"    -> "boPeep"
;;;-----------------------------
(setf beast "dromedary")
;; Capitalize various parts of beast
(setf capit (string-upcase beast :end 1))      ; Dromedary
(setf capit #?"\u\L$(beast)")                  ; (same)
(setf capall (string-upcase beast))            ; DROMEDARY
(setf capall #?"\U$(beast)")                   ; (same)
(setf caprest (string-downcase (string-upcase beast) :end 1)) ; dROMEDARY
(setf caprest #?"\l\U$(beast)")                               ; (same)
;;;-----------------------------
;; capitalize each word's first character, downcase the rest
(setf text "thIS is a loNG liNE")
(format t "~A~%" (string-capitalize text))
;; This Is A Long Line
;;;-----------------------------
;; string= is case-sensitive, string-equal is case-insensitive
(when (string-equal a b)
  (format t "a and b are the same~%"))
;;;----------------------------- 
;; It's considered bad form to perform bitwise operations on character
;; types, and breaks unicode-aware lisps.  Trust the compiler to
;; optimize.
(defun randcase (char)
  (if (< (random 100) 20)
      (char-upcase char)
      (char-downcase char)))
;;;-----------------------------

;;; @@PLEAC@@_1.10
;;;-----------------------------
(setf answer (concatenate 'string var1 (func) var2))
;;;-----------------------------
(setf answer (format nil "STRING ~{~A~} MORE STRING" list-expr))
(setf answer (format nil "STRING ~A MORE STRING" atomic-expr))
;;;-----------------------------
(setf phrase (format nil "I have ~D guanacos." (1+ n)))
(setf phrase #?"I have ${(1+ n)} guanacos.") ; uses CL-INTERPOL
;;;-----------------------------
(format t "I have ~D guanacos.~%" (1+ n))
;;;-----------------------------
(some-func (format nil "What you want is ~{~A~} items"
                   (cl-ppcre:split ":" rec)))
;;;-----------------------------
(let ((text (format nil "~
To: ~A
From: Your Bank
Cc: ~{~A~^, ~}
Date: ~A (today)

Dear ~A,

Today, you bounced check number ~D to us.
Your account is now closed.

Sincerely,
the management
"
                    naughty
                    (get-manager-list naughty)
                    (let (date-str (with-output-to-string (str)
                                     (run-program "/bin/date" nil
                                                  :output str)))
                      (subseq date-str 0 (1- (length date-str))))
                    naughty
                    (+ 500 (random 100)))))
  (unless (send-mail text target)
    (error "Couldn't send mail")))
;;;-----------------------------

;;; @@PLEAC@@_1.11
;;;-----------------------------
;; all in one
(setf var (cl-ppcre:regex-replace-all
           (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
"your text
goes here
" ""))

;; or with two steps
(setf var "your text
goes here
")
(setf var (cl-ppcre:regex-replace-all 
           (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
           var
           ""))
;;-----------------------------
(setf var (cl-ppcre:regex-replace-all 
           (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
"    The five varieties of camelids
    are the familiar camel, his friends
    the llama and the alpaca, and the
    rather less well-known guanaco
    and vicuña.
" ""))
;;;-----------------------------
(defun fix (string)
  (cl-ppcre:regex-replace-all
   (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
   string
   ""))

(format t "~A~%" (fix "    My stuff goes here
")
;;;-----------------------------
(setf quote 
      (cl-ppcre:regex-replace-all
       (cl-ppcre:create-scanner #?r"\s+--")
       (cl-ppcre:regex-replace-all 
        (cl-ppcre:create-scanner #?r"^\s+" :multi-line-mode t)
"        ...we will have peace, when you and all your works have
        perished--and the works of your dark master to whom you would
        deliver us. You are a liar, Saruman, and a corrupter of mens
        hearts.  --Theoden in /usr/src/perl/taint.c
"
       "")
       "
--"))
;;-----------------------------
(when *remember-the-main*
  (setf perl-main-C (dequote
"        @@@ int
         @@@ runops() {
         @@@     SAVEI32(runlevel);
         @@@     runlevel++;
         @@@     while ( op = (*op->op_ppaddr)() ) ;
         @@@     TAINT_NOT;
         @@@     return 0;
         @@@ }
"
  ;; add more code here if you want
   )))
;;;-----------------------------
(setf poem (dequote
"       Now far ahead the Road has gone,
          And I must follow, if I can,
       Pursuing it with eager feet,
          Until it joins some larger way
       Where many paths and errands meet.
          And whither then? I cannot say.
                --Bilbo in /usr/src/perl/pp_ctl.c
"))

(format t "Here's your poem:~%~%~A~%" poem)
;;;-----------------------------
(defun dequote (string)
  ;; Can't get multiple values returned thru the OR, hence the use of
  ;; DESTRUCTURING-BIND instead of MULTIPLE-VALUE-BIND
  (destructuring-bind (white leader) ; common whitespace and common leading string
      (or (cl-ppcre:register-groups-bind ($1 $2)
              (#?r/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/ string)
            (list $2 (cl-ppcre:quote-meta-chars $1)))
          (list (cl-ppcre:scan-to-strings #?r"^(\s+)" string) ""))
    (cl-ppcre:regex-replace-all
     (cl-ppcre:create-scanner (format nil #?r"^\s*?~a(?:~a)?" leader white) :multi-line-mode t)
     string
     "")))
;;;-----------------------------

;;; @@PLEAC@@_1.13
;; backslash
(setf var (cl-ppcre:regex-replace-all "([CHARLIST])" var "\\\1"))

;; double
(setf var (cl-ppcre:regex-replace-all "([CHARLIST])" var "\\1\\1"))
;;;-----------------------------
(setf string (cl-ppcre:regex-replace-all "%" string "%%"))
;;;-----------------------------
(setf string "Mom said, \"Don't do that.\"")
(setf string (cl-ppcre:regex-replace-all "(['\"])" string #?r"\\\1"))
;;;-----------------------------
(setf string "Mom said, \"Don't do that.\"")
(setf string (cl-ppcre:regex-replace-all "(['\"])" string #?r"\1\1"))
;;;-----------------------------
(setf string (cl-ppcre:regex-replace-all #?r"([^A-Z])" string #?r"\\\1"))
;;;-----------------------------
(setf string #?r"this \Qis a test!\E")
(setf string "this is\\ a\\ test\\!")
(setf string (concatenate 'string "this " (cl-ppcre:quote-meta-chars "is a test!")))
;;;-----------------------------

;;; @@PLEAC@@_1.14
;;;-----------------------------
(setf string (cl-ppcre:regex-replace #?r/^\s+/ string "")) 
(setf string (cl-ppcre:regex-replace #?r/\s+$/ string ""))
;;;-----------------------------

;;; The closest thing to Perl's wantarray is CL's ability to return
;;; multiple values from a function.  Unless the caller uses
;;; MULTIPLE-VALUE-BIND (or, this case MULTIPLE-VALUE-LIST), they will
;;; only "see" the first value.  Note also that, normally, you'd use
;;; CL's built-in STRING-TRIM function for this.
(defun trim (&rest strings)
  (values-list 
   (loop for string in strings
      collect (cl-ppcre:regex-replace #?r/^\s+/ 
                                      (cl-ppcre:regex-replace #?r/\s+$/ string "")
                                      ""))))

(setf string (trim string))
(setf many (multiple-value-list (apply 'trim many)))
;;;-----------------------------
;; print what's typed, but surrounded by >< symbols
(loop
   (let ((line (read-line)))
     (chomp line)
     (format t #?">$(line)<~%")))
;;;-----------------------------

;;; @@PLEAC@@_2.1
;;;-----------------------------
(if (every #'digit-char-p string)
    (progn
      ;; is a number
      )
    (progn
      ;; is not
      ))
;;;-----------------------------
;;; Strings and numbers are separate data types in CL. These tests
;;; check whether a string represents a number
(unless (every #'digit-char-p string)
  (format *error-output* "string has nondigits"))
(unless (cl-ppcre:scan "^\\d+$" string) ; rejects -3
  (format *error-output* "not a natural number"))
(unless (cl-ppcre:scan "^-?\\d+$" string) ; rejects +3
  (format *error-output* "not an integer"))
(unless (cl-ppcre:scan "^[+-]?\\d+$" string)
  (format *error-output* "not an integer"))
(unless (cl-ppcre:scan "^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)$" string)
  (format *error-output* "not an integer"))
(unless (cl-ppcre:scan "^([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?\\d+))?$"
                       string)
  (format *error-output* "not a C float"))
;;;-----------------------------
(defun getnum (string)
  "This function is not safe to call on untrusted input."
  (with-input-from-string 
      (is (cl-ppcre:regex-replace #?"\s+$" 
                                  (cl-ppcre:regex-replace #?"^\s+" string "") ""))
    (let ((num (read is nil nil nil)))
      (and
       ;; Make sure there's no junk following the number
       (eql (read-char is nil :eof nil) :eof)
       (numberp num)
       num))))

(defun is-numeric (string)
  (not (null (getnum string))))
;;;-----------------------------

;;; @@PLEAC@@_2.2
;;;-----------------------------
(defun equal-to-accuracy (number1 number2 dp)
  "Return non-nil if NUMBER1 and NUMBER2 are equal to DP number of
decimal places."
  (let* ((difference (abs (- number1 number2)))
         (delta (expt 10 (- dp))))
    (< difference delta)))
;;;-----------------------------
(let* ((wage 536)                       ; $5.36/hour
       (week (* 40 wage)))              ; $214.40
  (format t "One week's wage is: $~,2F~%" (/ week 100)))
;;One week's wage is: $214.40
;;;-----------------------------

;;; @@PLEAC@@_2.3
;;;-----------------------------
(setf rounded (format nil "~FORMATF" unrounded))
;;;-----------------------------
(let* ((a 0.255)
       (b (/ (fround a 0.01) 100)))
  (format t "Unrounded: ~F~%Rounded: ~,2F~%" a b))
;;Unrounded: 0.255
;;Rounded: 0.26
;;;-----------------------------
(progn
  (format t "~&number~Tint~Tfloor~Tceil~%")
  (let ((as '(3.3 3.5 3.7 -3.3)))
    (dolist (a as)
      (format t "~@{~4,1F~^~T~}~%"
              a
              (ftruncate a)
              (ffloor a)
              (fceiling a)))))
;;number int floor ceil
;; 3.3  3.0  3.0  4.0
;; 3.5  3.0  3.0  4.0
;; 3.7  3.0  3.0  4.0
;;-3.3 -3.0 -4.0 -3.0
;;;-----------------------------

;;; @@PLEAC@@_2.4
;;;-----------------------------
(defun dec2bin (dec)
  (format nil "~2R" dec))
;;;-----------------------------
(defun bin2dec (bin)
  "BIN is a string containing only #\1 and #\0 characters.  Returns
its integer equivalent."
  (read (make-string-input-stream (concatenate 'string "#b" bin)) 
        t nil nil))
;;;-----------------------------
(setf num (bin2dec "0110110"))          ; $num is 54
(setf binstr (dec2bin 54))              ; binstr is "110110"
;;;-----------------------------

;;; @PLEAC@@_2.5
;;;-----------------------------
(loop for i from x upto y
     do
   ;; i is set to every integer from X to Y, inclusive
)

(loop for i from y downto x
     do 
   ;; i is set to every integer from Y to X, inclusive
)

(do ((i x (1+ i)))
    ((> i y))
   ;; i is set to every integer from X to Y, inclusive
  )

(loop for i from x upto y by 7
     do
   ;; i is set to every integer from X to Y, stepsize = 7
)
;;;-----------------------------
(format t "Infancy is: ~{~A~^ ~}~%"
        (loop for i from 0 to 2 collect i))

(format t "Toddling is: ~{~A~^ ~}~%"
        (loop for i from 3 to 4 collect i))

(format t "Childhood is: ~{~A~^ ~}~%"
        (loop for i from 5 to 12 collect i))
;;Infancy is: 0 1 2
;;Toddling is: 3 4
;;Childhood is: 5 6 7 8 9 10 11 12
;;;-----------------------------

;;; @@PLEAC@@_2.6
;;;-----------------------------

;;; CL has a built in FORMAT directive (used below) to print out
;;; numbers as roman numerals, but doesn't have a built-in mechanism
;;; to convert back.  Here are some rough CL equivalents of Perl's
;;; Roman package.

(defun romanchar->num (x) 
  (case (char-downcase x)
    (#\m 1000)
    (#\d 500)
    (#\c 100)
    (#\l 50)
    (#\x 10)
    (#\v 5)
    (#\i 1)
    (t 0)))

(defun isroman (string)
  (every #'(lambda (c)
             (plusp (romanchar->num c)))
         string))

(defun arabic (string)
  (let ((digits (map 'list #'romanchar->num string)))
    (reduce #'+ (mapcar #'(lambda (digit next-digit)
                            (if (< digit next-digit) 
                                (- digit) 
                                digit))
                        digits
                        (append (rest digits) '(0))))))

(setf roman (format nil "~@R" arabic))  ; convert to roman numerals
(when (isroman roman) (setf arabic (arabic roman))) ; convert from roman numerals 
;;;-----------------------------
(setf roman-fifteen (format nil "~@R" 15))
(format t "Roman for fifteen is ~A~%" roman-fifteen)
(setf arabic-fifteen (arabic roman-fifteen))
(format t "Converted back, ~A is ~A~%" roman-fifteen arabic-fifteen)
;;Roman for fifteen is XV
;;Converted back, XV is 15
;;;-----------------------------

;;; @@PLEAC@@_2.7
;;;-----------------------------
(setf random (+ (random (+ y (- x) 1)) x)
;;;-----------------------------
(setf random (+ (random 51) 25))
(format t "~A~%" random)
;; If you wanted to use floats...
(+ (random 51.0) 25.0)
;;;-----------------------------
(setf elt (aref array (random (length array))))
;;;-----------------------------
(setf chars "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345789!@$%^&*")
(setf password (coerce (loop repeat 8 collect (aref chars (random (length chars)))) 'string))
;;;-----------------------------

;;; @@PLEAC@@_2.8
;;;-----------------------------
;; CL appears not to have any equivalent of srand; you can call
;; MAKE-RANDOM-STATE but its inner workings are not exposed.
(setf *random-state* (make-random-state t))
;;;-----------------------------

;;; @@PLEAC@@_2.10
;;;-----------------------------
;; Note: (random 1.0) is the same as calling Perl's rand() with no
;; arguments.
(defun gaussian-rand ()
  (do* ((u1 (1- (* 2 (random 1.0)))
            (1- (* 2 (random 1.0))))
        (u2 (1- (* 2 (random 1.0)))
            (1- (* 2 (random 1.0))))
        (w (+ (* u1 u1) (* u2 u2))
           (+ (* u1 u1) (* u2 u2))))
       ((< w 1.0)
        (let* ((w2 (sqrt (/ (* -2 (log w)) w)))
               (g2 (* u1 w2))
               (g1 (* u2 w2)))
          ;; No need for wantarray in CL because functions can return
          ;; multiple values.
          (values g1 g2)))))
        



; @@PLEAC@@_2.11
; degrees to radians
(defun deg2rad (degrees) (* (/ degrees 180) pi))

; radians to degrees
(defun rad2deg (radians) (* (/ radians pi) 180))


; @@PLEAC@@_2.12
; tangent
(tan theta)

(setf y (acos 3.7))


; @@PLEAC@@_2.13
; natural log
(setf log_e (log value))

(setf log_base_whatever (log value base))


; @@PLEAC@@_2.14
(defun multiply-matrices (m1 m2)
  (check-type m1 (array * (* *)))
  (check-type m2 (array * (* *)))
  (let* ((m1-rows (array-dimension m1 0))
         (m1-columns (array-dimension m1 1))
         (m2-rows (array-dimension m2 0))
         (m2-columns (array-dimension m2 1)))
    (unless (= m1-columns m2-rows)
      (error 'simple-type-error
             :format-control "Matrices ~S and ~S do not match."
             :format-args (list m1 m2)))
    (let ((result (make-array (list m1-rows m2-columns))))
      (dotimes (i m1-rows)
        (dotimes (j m2-columns)
          (setf (aref result i j)
                (loop for k from 0 below m1-columns
                      summing (* (aref m1 i k) (aref m2 k j))))))
      result)))
;;-----------------------------
(let ((x #2a((3 2 3)
             (5 9 8)))
      (y #2a((4 7)
             (9 3)
             (8 1))))
  (multiply-matrices x y))

; @@PLEAC@@_3.1
; use get-decoded-time to fetch the time
(multiple-value-bind
	(second minute hour date month year day-of-week dst-p tz)
	(get-decoded-time) 
	year) ;; prints out year using standard library

; alternatively date-calc provides overlapping functionality
(multiple-value-bind
	(year month day h m s)
	(today-and-now) ; imported from date-calc
	year)           ; date-calc approach 

; how to print out current date as "YYYY-MM-DD" (in approved ISO 8601 fashion)
(multiple-value-bind
    (year month day) 
    (today) ;imported from date-calc
    (format t "The current date is ~A-~2,'0d-~2,'0d" year month day))

; Alternatively, you could use the format-time function from the CyberTiggyr-Time package:
(format-time t "%Y-%m-%d" (get-universal-time))

; As you can see, format-time operates on epoch time

; @@PLEAC@@_3.2 
; to encode time into universal time using date-calc
(multiple-value-bind
	(second minute hour date month year day-of-week dst-p tz)
	(get-decoded-time)
  (encode-universal-time second minute hour date month year))

;; the last two return values for get-decoded-time correspond to daylight savings and the
;; timezone.  Both are useful for timezone-related arithmatic.

; @@INCOMPLETE@@
; An example of a GMT computation with and without daylight savings is appropriate here since
; the built-in perl functions handle this.

; @@PLEAC@@_3.3
(let ((time (get-universal-time))) ; get epoch seconds
  (multiple-value-bind
      (second minute hour day month year day-of-week dst-p tz)
      (decode-universal-time time) ; decode and...
    (list day month year hour minute second))) ; return

; @@PLEAC@@_3.4
; when using universal time you add or subtract seconds
; here we add one hour
(let ((firstdate 
       (encode-universal-time 0 12 6 23 11 2006))
      (onehour (* 60 60 1)))
  (+ onehour firstdate))

; or you could use date-calc function
; here we'll add one day
(add-delta-ymdhms 2006 11 24 18 12 0  0 0 1 0 0 0)

; @@PLEAC@@_3.5
; We'll use the epoch seconds to perform subtraction, 
; then divide by seconds per day
(let ((first (encode-universal-time 52 45 20 13 12 1901))
      (second (encode-universal-time 7 14 3 19 1 2038)))
  (float (/ (- second first) (* 60 60 24))))

; method two uses delta-days from the date-calc package:
(delta-days 1901 12 13 2038 1 19)

; delta-days does not yet have the granularity of seconds, minutes or hours. 

; @@PLEAC@@_3.6
; The week of the year is computed as follows:
(week-number 2006 12 1) ; week-of-year is imported from date-calc

; similar functions exist for day of week, day of year, etc.

; @@PLEAC@@_3.7
(parse-time "2006-08-20")

; parse-time can recognize many of the commonly found date formats

; format-time comes with several ways to format...
(format-time t *format-time-date* (get-universal-time))

; results in: 25 Nov 2006

(format-time t *format-time-iso8601-short* (get-universal-time))

; results in: 20061125T172917 -5

(format-time t "%Y-%m-%d" (get-universal-time))

; results in: 2006-11-25

;;; @@PLEAC@@_4.0
(setf nested '("this" "that" "the" "other")
(setf nested '("this" "that" ("the" "other")))
;;-----------------------------
(setf tune '("The" "Star-Spangled" "Banner"))

;;; @@PLEAC@@_4.1
(setf a '("quick" "brown" "fox")
;;-----------------------------
(setf a '("Why" "are" "you" "teasing" "me?"))
;;-----------------------------
(setf lines (cl-ppcre:regex-replace-all (cl-ppcre:create-scanner "^\\s*(.+)" :multi-line-mode t )
"    The boy stood on the burning deck,
    It was as hot as glass.
" "\\1"))
;;;----------------------------- 

;;; You don't really need an explicit call to the CL equivalent of
;;; Perl's die().  Its behavior is the same by default (it does put
;;; you into the CL debugger, but that's not a bad thing).  You could,
;;; alternatively, handle this error with HANDLER-BIND or HANLDER-CASE
;;; if you wanted to be more precisely like the Perl version.
(let ((bigarray '()))
  (with-open-file (data "mydatafile")
    (loop for line = (read-line data nil nil)
       while line
       do (push (string-right-trim #(#\Newline #\Return)
                                   line) bigarray))))
;;-----------------------------
(setf banner "The Mines of Moria")
;;-----------------------------
(setf name "Gandalf")
(setf banner (format nil "Speak ~A and enter!" name))
(setf banner "Speak $name and welcome!")
;;-----------------------------

;;; @@PLEAC@@_4.2
;;-----------------------------
(defun commify_series (list)
  (case (length list)
    (0 "")
    (1 (car list))
    (2 (format nil "~{~A~^ and ~}" list))
    (t (concatenate 'string
                    (format nil "~{~A~^, ~}" (butlast list))
                    (format nil " and ~A" (car (last list)))))))
;;-----------------------------
(let ((array '("red" "yellow" "green")))
  (format t "I have ~D marbles.~%" (length array))
  (format t "I have ~{~a~} marbles.~%" array))
;;I have 3 marbles.
;;I have redyellowgreen marbles.
;;-----------------------------
;; @@INCLUDE@@ include/commonlisp/ch04/commify_series.lisp
;;-----------------------------

;;; @@PLEAC@@_4.4
;;-----------------------------
(dolist (item list)
  ;; do something with ITEM
  )
;;-----------------------------
(dolist (user bad-users)
  (complain user))
;;-----------------------------
(dolist (var (sort (loop for x being the hash-keys of axl
                      collect x) #'<))
  (format t "~A=~A~%" var (gethash var ENV)))
;;-----------------------------
(dolist (user all-users)
  (let ((disk-space (get-usage user)))
    (when (> disk-space +max-quota+)
      (complain user))))
;;-----------------------------
;;-----------------------------
;;; @@INCOMPLETE@@


;;; @@PLEAC@@_4.6
;;-----------------------------

(let ((seen (make-hash-table))
      (uniq '()))
  (dolist (item list)
    (unless (gethash item seen)
      ;; if we are here, we have not seen it before
      (setf (gethash item seen) 1)
      (push item uniq))))
;;-----------------------------
;;-----------------------------
;;; @@INCOMPLETE@@

;;; @@PLEAC@@_4.9
;;-----------------------------
(append array1 array2)
;;-----------------------------
(let ((members '("Time" "Flies"))
      (initiates '("An" "Arrow")))
  (setf members (append members initiates))
;;; members is now ("Time" "Flies" "An" "Arrow")
;;;-----------------------------
  (setf members `(,@(subseq members 0 2) "Like" ,@initiates))
  (format t "~{~a~^ ~}~%" members)
  (setf members `("Fruit" ,@(subseq members 1)))
  (setf members `(,@(subseq members 0 (- (length members) 2)) "A" "Banana"))
  (format t "~{~a~^ ~}~%" members))
;;;-----------------------------
;;Time Flies Like An Arrow
;;Fruit Flies Like A Banana

;;; @@PLEAC@@_4.10
;;-----------------------------
;; reverse ARRAY into REVERSED
(setf reversed (reverse *array*))
;;-----------------------------
(do ((i (1- (array-dimension *array* 0)) (1- i)))
    ((minusp i))
  ;; do something with (aref array i)
  )
;;-----------------------------
;; SORT is destructive, hence COPY-SEQ
(setf ascending (sort (copy-seq users) #'string-lessp))
(setf descending (reverse ascending))
;;-----------------------------
(setf descending (reverse (sort (copy-seq users) #'string-lessp)))
;;-----------------------------

;;; @@PLEAC@@_4.13
;;-----------------------------
(setf matching (find-if-not #'test list))
;;-----------------------------
(let ((matching '()))
  (dolist (item list)
    (when (test item) (push item matching))))
;;;-----------------------------
(setf bigs (remove-if-not #'(lambda (num) (> num 1000000)) nums))
(setf pigs (loop for user being the hash-keys of users using (hash-value uid)
              when (> uid 1e7)
              collect user))

;;;-----------------------------
#+sbcl
(remove-if-not #'(lambda (line)
                   (cl-ppcre:scan "^gnat " line))
               (cl-ppcre:split #\Newline
                               (with-output-to-string (output)
                                 (sb-ext:run-program "who" nil :search t :output output))))
;;;-----------------------------
;;; Assumes DEFSTRUCT or DEFCLASS of EMPLOYEE with a POSITION slot.
(setf engineers (remove "Engineer" employees :key #'employee-position :test-not 'string=))
;;-----------------------------
(setf secondary-assistance (remove-if-not #'(lambda (applicant)
                                              (and (>= (applicant-income applicant) 26000)
                                                   (<  (applicant-income applicant) 30000)))
                                          applicants))
;;;-----------------------------

;;; @@PLEAC@@_4.16
;;;-----------------------------

;;; The following aren't efficient on long lists
(setf circular `(,@(last circular) ,@(nbutlast circular))) ; the last shall be first
(setf circular `(,@(cdr circular) ,(car circular))) ; and vice versa
;;;-----------------------------
;;; There is probably a less ugly way to do this
(defmacro grab-and-rotate (list)
  `(prog1 (car ,list)
     (setf ,list `(,@(cdr ,list) ,(car ,list)))))

(let ((processes '(1 2 3 4 5)))
  (loop 
     (let ((process (grab-and-rotate processes)))
       (format t "Handling process ~A~%" process)
       (sleep 1))))    
;;;-----------------------------

;;; @@PLEAC@@_4.17
;;-----------------------------
(defun fisher-yates-shuffle (vector)
  "Randomly shuffle elements of VECTOR."
  (loop for i from (1- (length vector)) downto 1
     for j = (random i)
     unless (= i j)
     do (rotatef (aref vector i) (aref vector j)))
  vector)
;;;
(defun shuffle (vector)
  "Return a fresh permuted copy of VECTOR."
  (let* ((n-permutations (factorial (length vector)))
         (permutation (nth-permutation (random n-permutations)
                                       (length vector))))
    (map 'vector (lambda (i) (aref vector i)) permutation)))
;;;
(defun naive-shuffle (vector)
  (loop with n = (length vector)
        for i from 0 below n
        for j = (random n)
        do (rotatef (aref vector i) (aref vector j)))
  vector)

;;; @@PLEAC@@_4.19
(defun factorial (n)
  (loop for result = 1 then (* result i)
        for i from 1 to n
        finally (return result)))

(factorial 500) ; => 1220136... (1135 digits total)

(defun map-vector-permutations (function vector)
  (labels ((permute (end)
             (if (= end 0)
                 (funcall function vector)
                 (dotimes (i end)
                   (rotatef (aref vector (1- end)) (aref vector i))
                   (permute (1- end))
                   (rotatef (aref vector (1- end)) (aref vector i))))))
    (permute (length vector))))
(map-vector-permutations #'print #(1 2 3))

(defun map-list-permutations (function list)
  (labels ((permute (tail)
             (if (null tail)
                 (funcall function list)
                 (loop for subtail on tail
                       do (rotatef (car tail) (car subtail))
                          (permute (cdr tail))
                          (rotatef (car tail) (car subtail))))))
    (permute list)))
(map-list-permutations #'print '(1 2 3))
;;; permute words in each line of input stream
(loop for line = (read-line *standard-input* nil nil)
      while line
      do (map-list-permutations (lambda (words)
                                  (format t "~{~A~^ ~}~%" words))
                                (cl-ppcre:split "\\s+" line)))

;;;
(let ((memo (make-hash-table)))
  (setf (gethash 0 memo) 1)
  (defun factorial (n)
    (or (gethash n memo)
        (setf (gethash n memo) (* n (factorial (1- n)))))))

(defun nth-pattern (n length)
  (loop for i from length downto 1
        for (new-n elem) = (multiple-value-list (truncate n i))
        collect elem
        do (setf n new-n)))

(defun pattern-permutation (pattern)
  (loop with source = (cons nil
                            (loop for i from 0 below (length pattern)
                                  collect i))
        for i in pattern
        for pred = (nthcdr i source)
        for (elem . rest) = (cdr pred)
        collect elem
        do (setf (cdr pred) rest)))

(defun nth-permutation (n length)
  (pattern-permutation (nth-pattern n length)))

; @@PLEAC@@_5.0

(setf age (make-hash-table :test 'equal))

(setf (gethash "Nat" age) 24
      (gethash "Jules" age) 25
      (gethash "Josh" age) 17)
;;-----------------------------

(mapcar #'(lambda (l)
            (setf (gethash (car l) age) (cdr l)))
        '(("Nat" . 24)
          ("Jules" . 25)
          ("Josh" . 17)))
;;-----------------------------
(setf food-color (make-hash-table :test 'equal))

(mapcar #'(lambda (l)
            (setf (gethash (car l) food-color) (cdr l)))
        '(("Apple" . "red")
          ("Banana" . "yellow")
          ("Lemon" . "yellow")
          ("Carrot" . "orange")))

;;-----------------------------

(mapcar #'(lambda (l)
            (setf (gethash (car l) food-color) (cdr l)))
        '((Apple . "red")
          (Banana . "yellow")
          (Lemon . "yellow")
          (Carrot . "orange")))
;;-----------------------------


; @@PLEAC@@_5.1
;;-----------------------------
(setf (gethash key hash) value)
;;-----------------------------

(setf (gethash "Raspberry" food-color) "pink")

(format t "Known foods:~%~{~a~%~}"
        (loop for f being the hash-keys food-color
           collect f))

; @@PLEAC@@_5.2
;;-----------------------------
;; does %HASH have a value for $KEY ?
(if (nth-value 1 (gethash key hash))
    'it-exists
    'it-does-not)
;;;-----------------------------
;; food-color per the introduction
(dolist (name '("Banana" "Martini"))
  (format t "~A is a ~A.~%"
          name
          (if (nth-value 1 (gethash name food-color))
              "food" "drink")))
;;-----------------------------
(setf age (make-hash-table :test 'equal))
(setf (gethash "Toddler" age) 3)
(setf (gethash "Unborn" age) 0)
(setf (gethash "Phantasm" age) nil)
(dolist (thing '("Toddler" "Unborn" "Phantasm" "Relic"))
  (format t "~a: " thing)
  (multiple-value-bind (defined exists)
      (gethash thing age)
      (when exists
        (format t "Exists ")
        (when defined 
          (format t "Defined ")
          ;; 0 is not false in CL, so must explicitly mimic Perl here
          (unless (zerop defined)
            (format t "True ")))))
  (format t "~%"))

;;; @@PLEAC@@_5.3
;;;-----------------------------
;;; remove $KEY and its value from %HASH
(remhash key hash)
;;;-----------------------------


; @@PLEAC@@_8.2
;; Should we count the last line, if it does not end with a newline?
;; This version counts:
(with-open-file (stream #p"numbers.html")
  (loop for line = (read-line stream nil)
        while line
        count t))
;; and this does not:
(with-open-file (stream #p"numbers.html")
  (loop for (line missing-newline-p) =
            (multiple-value-list (read-line stream nil))
        while line
        count (not missing-newline-p)))


; @@PLEAC@@_11.15
;;; Binary trees example
(deftype tree () '(or null tree-node))
(defstruct (tree-node
             (:conc-name #:tree-))
  value
  ;; subtrees
  (left nil :type tree)
  (right nil :type tree))

(defun tree-insert (tree value)
  "Return TREE with destructively inserted VALUE."
  (declare (type tree tree))
  (if tree
      (progn (if (< value (tree-value tree))
                 (setf (tree-left tree)
                       (tree-insert (tree-left tree) value))
                 (setf (tree-right tree)
                       (tree-insert (tree-right tree) value)))
             tree)
      (make-tree-node :value value)))

(defun print-tree-in-order (tree)
  (when tree
    (print-tree-in-order (tree-left tree))
    (format t "~S " (tree-value tree))
    (print-tree-in-order (tree-right tree))))

(defun print-tree-in-preorder (tree)
  (when tree
    (format t "~S " (tree-value tree))
    (print-tree-in-preorder (tree-left tree))
    (print-tree-in-preorder (tree-right tree))))

(defun print-tree-in-postorder (tree)
  (when tree
    (print-tree-in-postorder (tree-left tree))
    (print-tree-in-postorder (tree-right tree))
    (format t "~S " (tree-value tree))))

(defun search-tree (tree value)
  "Return a subtree of TREE with the specified VALUE in root."
  (when tree
    (if (= (tree-value tree) value)
        tree
        (search-tree (if (< value (tree-value tree))
                         (tree-left tree)
                         (tree-right tree))
                     value))))

(defun test-trees ()
  (let ((tree nil))
    (dotimes (i 20)
      (setf tree (tree-insert tree (random 1000))))
    (format t "~&Pre order: ") (print-tree-in-preorder tree)
    (format t "~&In order:  ") (print-tree-in-order tree)
    (format t "~&Postorder: ") (print-tree-in-postorder tree)
    (terpri)

    (loop do
         (format t "~&Search? ")
         (finish-output)
         (let* ((eof (gensym)) ; some hard-to-enter object
                (value (read *standard-input* nil eof)))
           (when (eq value eof) (loop-finish))
           (let ((found (search-tree tree value)))
             (if found
                 (format t "Found ~S at ~S~%" value found)
                 (format t "No ~S in tree~%" value)))))))
