; -*- lisp -*-
;
; @@PLEAC@@_NAME
; @@SKIP@@ Common Lisp

; @@PLEAC@@_WEB
; @@SKIP@@ http://www.lisp.org/
; @@SKIP@@ http://www.sbcl.org/

; @@PLEAC@@_INTRO
; @@SKIP@@ Newer submissions use SB-CL, and make use of a number of SB-CL and third party libraries [see Appendix for details]

; @@PLEAC@@_APPENDIX
; Common Lisp code makes use of the following for package / library loading:
;   (require :PACKAGENAME)
;
; SB-CL code makes use of the following for package / library loading:
;   (asdf:operate 'asdf:load-op :date-calc) ; load the package
;   (use-package 'date-calc)                ; import the symbols
;   (load "time.lisp")                      ; replace with your location of the pdl library
;   (use-package 'CyberTiggyr-Time)         ; useful function for printing out times in various formats
;
; Packages / libraries used include:
;
;   http://www.cliki.net/cl-ppcre
;   http://www.cliki.net/date-calc
;   http://www.cliki.net/asdf
;
;   http://cybertiggyr.com/gene/pdl/
;

; @@PLEAC@@_1.0
;;-----------------------------
(setq string "\\n")                   ; two characters, \ and an n
(setq string "John 'Maddog' Orwant")  ; literal single quotes
(setq string "John \"Maddog\" Orwant") ; literal double quotes
;;-----------------------------
;; newlines may be inserted literally
(setq string "
")
;; or by creating a string explicitly
(setq string (make-string 1 :initial-element #\newline))
;; or by using format with a nil output stream
(setq string (format nil "~%"))
;;-----------------------------
(setq string "
This is a multiline string, terminated by a
double quotation mark.
")
;;-----------------------------


; @@PLEAC@@_1.1
; assign a substring to a variable
(setq value (subseq string offset (+ offset count)))
(setq value (subseq string offset))

; edit a substring
(setq string (concatenate 'string (subseq string 0 offset) newstring
                          (subseq string (+ offset count))))
(setq string (concatenate 'string (subseq string 0 offset) newtail))

;;-----------------------------
; get a 5-byte string, skip 3, then grab 2 8-byte strings, then the
; rest
(setq leading (subseq data 5)
      s1 (subseq data 8 8)
      s2 (subseq data 16 8)
      trailing (subseq data 24))

; split at five byte boundries
(let ((length (length string)))
  (loop for idx from 0 upto length by 5
     collect (subseq string idx (min length (+ idx 5)))))

; chop string into individual characters
(loop for idx from 0 upto (1- (length string))
      collect (char string idx))

;;-----------------------------
(defparameter *string* "This is what you have")
;;             +012345678901234567890  Indexing forwards  (left to right)
;;              109876543210987654321- Indexing backwards (right to left)

(subseq *string* 0 1)                        ; "T"
(subseq *string* 5 7)                        ; "is"
(subseq *string* 13)                         ; "you have"
(subseq *string* (+ (length *string*) -1))   ; "e"
(subseq *string* (+ (length *string*) -4))   ; "have"
(subseq *string*
         (+ (length *string*) -8)
         (+ (length *string*) -8 3)) ; "you"

(print *string*)
;; This is what you have

;; Change "is" to "wasn't"
(setq *string*
       (concatenate 'string
                    (subseq *string* 0 5)
                    "wasn't"
                    (subseq *string* (+ 5 2))))
;; This wasn't what you have

;; Replace last 12 characters
(setq *string*
       (concatenate 'string
                    (subseq *string* 0 (+ (length *string*) -12))
                    "ondrous"))
;; This wasn't wondrous

;; Delete first character
(setq *string* (subseq *string* 1))
;; his wasn't wondrous

;; Delete last 10 characters
(setq *string* (subseq *string* 0 (+ (length *string*) -10)))
;; his wasn'

;;-----------------------------
;; You can test substrings with the :start and :end keyword
;; parameters of cl-pcre:scan
(when (cl-ppcre:scan "pattern" *string*
                      :start (- (length *string*) 10))
   (format t "Pattern matches in last 10 characters~%"))

;; substitute "at" for "is", restricted to first five characters
(concatenate 'string
              (cl-ppcre:regex-replace "is" *string* "at"
                                      :start 0
                                      :end (min (length *string*) 5))
              (when (> (length *string*) 5)
                (subseq *string* 5)))

;;-----------------------------
;; Exchange the first and last letters in a string
(setq *string* "make a hat")
(rotatef (char *string* 0) (char *string* (1- (length *string*))))
(princ *string*)
;; take a ham
;;-----------------------------

; edit a substring
(setq string (concatenate 'string 
                          (substring string 0 offset) newstring
                          (substring string (+ offset count))))
(setq string (concatenate 'string (substring string 0 offset) newtail))


; @@PLEAC@@_1.2
; use b if b is true, else c
(setq a (or b c))

; set x to y unless x is already true
(unless x (setq x y))

;; use b if b is defined, otherwise c
(setq a (if (boundp 'b) b c))
;;-----------------------------
(setq foo (or bar "DEFAULT VALUE"))
;;-----------------------------
#+sbcl 
(defparameter ARGV (copy-seq (cdr *posix-argv*)) "Arguments from shell, Perl style")

(setq dir (or (pop ARGV) "/tmp"))
;;-----------------------------
(setq dir (or (nth 0 ARGV) "/tmp"))
;;-----------------------------
(setq dir (if (boundp 'ARGV) (pop ARGV) "/tmp"))
;;-----------------------------
(setq dir (if (plusp (length ARGV)) (nth 0 ARGV) "/tmp"))
;;-----------------------------
(setf count (make-hash-table))
(incf (gethash (or shell "/bin/sh") count 0))
;;-----------------------------
(setq user (or (posix-getenv "USER")
               (posix-getenv "LOGNAME")
               #+sbcl
               (let ((uid (sb-posix:getuid)))
                 (or (sb-posix:passwd-name (sb-posix:getpwuid uid))
                     (format nil "Unknown uid number ~a" uid)))
               #-sbcl
               "Unknown uid"))
;;-----------------------------
(setq starting-point (or starting-point "Greenwich"))
;;-----------------------------
(unless a
  (setq a (copy-seq b)))                ; copy only if empty
(setq a (or b c))                       ; assign b if nonempty, else c


; @@PLEAC@@_1.3
;;--------------------------------------------------
(psetq VAR1 VAR2 VAR2 VAR1)
(multiple-value-setq (VAR1 VAR2) (values VAR2 VAR1))
(rotatef VAR1 VAR2)
;;--------------------------------------------------
(setq a "alpha")
(setq b "omega")
(rotatef a b) ;; the first shall be last -- and versa vice
;;--------------------------------------------------
(destructuring-bind (alpha beta production)
     '(January March August)
   ;; move beta       to alpha,
   ;; move production to beta,
   ;; move alpha      to production
  (rotatef alpha beta production))


; @@PLEAC@@_1.4
;;--------------------------------------------------
(setq num (char-code char))
(setq char (code-char num))
;;--------------------------------------------------
(setq char (format nil "~c" (code-char num)))
(format t "Number ~d is character ~c~%" num (code-char num))
;--> Number 101 is character e
;;--------------------------------------------------
(setq ASCII (map 'list #'char-code string))
(setq string (map 'string #'code-char ASCII))
;;--------------------------------------------------
(setq ascii-value (char-code (char "e" 0)))    ; now 101
(setq character (code-char 101))               ; now #\e
;;--------------------------------------------------
(format t "Number ~d is character ~c~%" 101 (code-char 101))
;;--------------------------------------------------
(setq ascii-character-numbers (map 'list #'char-code "sample"))
(format t "~{~a~^ ~}" ascii-character-numbers)
;--> 115 97 109 112 108 101

(setq word (map 'string #'code-char ascii-character-numbers))
(setq word (map 'string #'code-char '(115 97 109 112 108 101)))
(format t "~a~%" word)
;--> sample
;;--------------------------------------------------
(let* ((hal "HAL")
       (ibm (map 'string
                 (lambda (char)
                   (code-char (1+ (char-code char))))
                 hal)))
  (format t "~a~%" ibm))
;;--------------------------------------------------


; @@PLEAC@@_1.5
;;--------------------------------------------------
(setq array (map 'list #'string string))

(setq array (loop for char across string
                  collect (char-code char)))
;;--------------------------------------------------
(loop for $1 across string do
      ;; do something with $1
      )

;;--------------------------------------------------
(let ((string "an apple a day")
      (seen (make-hash-table)))
  (loop for char across string do
       (incf (gethash char seen 0)))
  (let ((chars (loop for char being each hash-key of seen
                   collect char)))
    (format t "unique chars are: ~A~%" 
            (coerce 
             (sort chars #'>
                   :key (lambda (char) (gethash char seen)))
             'string))))
;;--------------------------------------------------
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (reduce #'+ string :key #'char-code)))
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (loop for char across string
                summing (char-code char))))
;;--------------------------------------------------


; @@PLEAC@@_1.6
;;--------------------------------------------------
(setq revbytes (reverse string))

(setq revwords (format nil "~{~a~^ ~}"
                       (reverse (cl-ppcre:split " " string))))
(setq revwords (reverse
                (do* ((stringstream (make-string-input-stream string))
                      (result nil (cons next result))
                      (next (read stringstream nil 'eos)
                            (read stringstream nil 'eos)))
                     ((equal next 'eos)
                      (reverse result)))))
;;--------------------------------------------------
(setq gnirts (reverse string))  ; reverse letters in string
(setq sdrow (reverse words))    ; reverse elements in words
(setq confused (reverse (apply #'concatenate 'string words)))
;;--------------------------------------------------
(setq string "Yoda said, \"can you see this?\"")
(setq allwords (cl-ppcre:split " " string))
(setq revwords (format nil "~{~a~^ ~}" (reverse allwords)))
(format t "~a~%" revwords)
;this?" see you "can said, Yoda
;;--------------------------------------------------
(setq revwords (format nil "~{~a~^ ~}" (reverse (cl-ppcre:split " "
string))))
;;--------------------------------------------------
(setq revwords (apply #'concatenate 'string
                      (cl-ppcre:split "(\\s+)" string :with-registers-p t)))
;;--------------------------------------------------
(defun palindrome-p (word)
  (string= word (reverse word)))
(palindrome-p "reviver")
; T
;;--------------------------------------------------
(with-open-file (inf "/usr/share/dict/words")
  (loop for word = (read-line inf nil nil)
        while word
        when (and (string= word (reverse word)) 
                  (> (length word) 5))
        do (format t "~a~%" word)))
;; deedeed
;; degged
;; hallah
;; kakkak
;; murdrum
;; redder
;; repaper
;; retter
;; reviver
;; rotator
;; sooloos
;; tebbet
;; terret
;;--------------------------------------------------


; @@PLEAC@@_1.7
;;--------------------------------------------------
(defun tab-expand (string &optional (tabstop 8))
  (flet ((needed-spaces (target-string start end match-start match-end
reg-starts reg-ends)
           (declare (ignore target-string start end reg-starts reg-ends))
           (make-string (- (* (- match-end match-start) tabstop)
                           (mod match-start tabstop))
                        :initial-element #\Space)))
    (cl-ppcre:regex-replace-all "\\t+" string #'needed-spaces)))

;;--------------------------------------------------
(defun tab-unexpand (string &optional (tabstop 8))
  (flet ((needed-tabs (target-string start end match-start match-end
reg-starts reg-ends)
           (declare (ignore target-string start end reg-starts reg-ends))
           (let ((match-length (- match-end match-start)))
             (concatenate 'string
                        (make-string (floor match-length tabstop)
                                     :initial-element #\Tab)
                        (make-string (mod match-length tabstop)
                                     :initial-element #\Space)))))
    (cl-ppcre:regex-replace-all "  +" string #'needed-tabs)))
;;--------------------------------------------------
(loop for line = (read-line *standard-input* nil nil)
      while line do
      (format t "~a~%" (tab-expand line)))
;;--------------------------------------------------
(loop for line = (read-line *standard-input* nil nil)
      while line do
      (format t "~a~%" (tab-unexpand line)))
;;--------------------------------------------------


; @@PLEAC@@_1.8
;;--------------------------------------------------
(setq text "You owe $debt to me")
;;--------------------------------------------------
(flet ((global-deref (match var-name)
         (write-to-string (symbol-value (intern var-name)))))
  (setq text (cl-ppcre:regex-replace-all "\\$(\\w+)" text #'global-deref
                                         :simple-calls t)))
;;--------------------------------------------------
(setq rows 24
      cols 80)
(setq text "I am $rows high and $cols long")
(flet ((global-deref (match var-name)
         (write-to-string (symbol-value (intern (string-upcase var-name))))))
  (setq text (cl-ppcre:regex-replace-all "\\$(\\w+)" text
                                         #'global-deref
                                         :simple-calls t)))
(format t "~a~%" text)
; I am 24 high and 80 long
;;--------------------------------------------------
(setq text "I am 17 years old")
(setq text (cl-ppcre:regex-replace-all "(\\d+)" text
                                       (lambda (match num-str)
                                         (declare (ignore match))
                                         (write-to-string
                                          (* 2 (parse-integer num-str))))
                                       :simple-calls t))
;;--------------------------------------------------
(* 2 17)
;;--------------------------------------------------
;; expand variables in text, but put an error message in
;; if the variable isn't defined
(flet ((deref-with-err (match word)
         (declare (ignore match))
         (let ((word-sym (intern (string-upcase word))))
         (if (boundp word-sym)
             (write-to-string (symbol-value word-sym))
             (format nil "[NO VARIABLE: $~a]" word-sym)))))
  (setq text (cl-ppcre:regex-replace-all "\\$(\\w+)" text
                                         #'deref-with-err
                                         :simple-calls t)))
;;--------------------------------------------------


; @@PLEAC@@_1.9
;;--------------------------------------------------
(setq big (string-upcase little))
(setq little (string-downcase big))
;;--------------------------------------------------
(setq big (string-upcase little :end 1)
(setq little (string-downcase BIG :end 1))
;;--------------------------------------------------
(setq beast "dromedary")
;; Capitalize various parts of beast
(setq capit (string-upcase beast :end 1))      ; Dromedary
(setq capall (string-upcase beast))            ; DROMEDARY
(setq caprest (string-upcase beast :start 1))  ; dROMEDARY
;;--------------------------------------------------
;; capitalize each word's first character, downcase the rest
(setq text "thIS is a loNG liNE")
(princ (string-capitalize text))
; This Is A Long Line
;;--------------------------------------------------
;; string= is case-sensitive, string-equal is case-insensitive
(when (string-equal a b)
  (format t "a and b are the same~%"))
;;--------------------------------------------------
;; It's considered bad form to perform bitwise operations
;; on character types, and breaks unicode-aware lisps.  Trust
;; the compiler to optimize.
(defun randcase (char)
  (if (< (random 100) 20)
      (char-upcase char)
      (char-downcase char)))
(map 'string #'randcase string)
;;--------------------------------------------------


; @@PLEAC@@_1.10
;;--------------------------------------------------
(setq answer (concatenate 'string var1 (func) var2))
;;--------------------------------------------------
(setq answer (format nil "STRING ~{~A~} MORE STRING" list-expr))
(setq answer (format nil "STRING ~A MORE STRING" atomic-expr))
;;--------------------------------------------------
(setq phrase (format nil "I have ~D guanacos." (1+ n)))
;;--------------------------------------------------
(format t "I have ~D guanacos.~%" (1+ n))
;;--------------------------------------------------
(some-func (format nil "What you want is ~{~A~} items"
                   (cl-ppcre:split ":" rec)))
;;--------------------------------------------------
(let ((text (format nil "~
To: ~A
From: Your Bank
Cc: ~{~A~^, ~}
Date: ~A (today)

Dear ~A,

Today, you bounced check number ~D to us.
Your account is now closed.

Sincerely,
the management
"
                    naughty
                    (get-manager-list naughty)
                    (let (date-str (with-output-to-string (str)
                                     (run-program "/bin/date" nil
                                                  :output str)))
                      (subseq date-str 0 (1- (length date-str))))
                    naughty
                    (+ 500 (random 100)))))
  (unless (send-mail text target)
    (error "Couldn't send mail")))
;;--------------------------------------------------

; @@PLEAC@@_1.11
;;--------------------------------------------------
;;; all in one
(setf var (cl-ppcre:regex-replace-all 
           (cl-ppcre:create-scanner "^\\s+" :multi-line-mode t)
"your text
goes here
" ""))

;;; or with two steps
(setf var "your text
goes here
")
(setf var (cl-ppcre:regex-replace-all 
           (cl-ppcre:create-scanner "^\\s+" :multi-line-mode t)
           var
           ""))
;;--------------------------------------------------
(setf var (cl-ppcre:regex-replace-all 
           (cl-ppcre:create-scanner "^\\s+" :multi-line-mode t)
"    The five varieties of camelids
    are the familiar camel, his friends
    the llama and the alpaca, and the
    rather less well-known guanaco
    and vicuña.
" ""))
;;--------------------------------------------------
(defun fix (string)
  (cl-ppcre:regex-replace-all
   (cl-ppcre:create-scanner "^\\s+" :multi-line-mode t)
   string
   ""))

(fix "    My stuff goes here
")
;;--------------------------------------------------
(setf quote 
      (cl-ppcre:regex-replace-all
       (cl-ppcre:create-scanner "\\s+--")
       (cl-ppcre:regex-replace-all 
        (cl-ppcre:create-scanner "^\\s+" :multi-line-mode t)
"        ...we will have peace, when you and all your works have
        perished--and the works of your dark master to whom you would
        deliver us. You are a liar, Saruman, and a corrupter of mens
        hearts.  --Theoden in /usr/src/perl/taint.c
"
       "")
       "
--"))
;;--------------------------------------------------
(when *remember-the-main*
  (setf perl-main-C (dequote
"        @@@ int
         @@@ runops() {
         @@@     SAVEI32(runlevel);
         @@@     runlevel++;
         @@@     while ( op = (*op->op_ppaddr)() ) ;
         @@@     TAINT_NOT;
         @@@     return 0;
         @@@ }
"
  ;; add more code here if you want
   )))
;;--------------------------------------------------
(setf poem (dequote
"       Now far ahead the Road has gone,
          And I must follow, if I can,
       Pursuing it with eager feet,
          Until it joins some larger way
       Where many paths and errands meet.
          And whither then? I cannot say.
                --Bilbo in /usr/src/perl/pp_ctl.c
"))

(format t "Here's your poem:~%~%~a~%" poem)
;;--------------------------------------------------
(defun dequote (string)
  ;; Can't get multiple values returned thru the OR, hence the use of
  ;; DESTRUCTURING-BIND instead of MULTIPLE-VALUE-BIND
  (destructuring-bind (white leader) ; common whitespace and common leading string
      (or (cl-ppcre:register-groups-bind ($1 $2)
              ("^\\s*(?:([^\\w\\s]+)(\\s*).*\\n)(?:\\s*\\1\\2?.*\\n)+$" string)
            (list $2 (cl-ppcre:quote-meta-chars $1)))
          (list (cl-ppcre:scan-to-strings "^(\\s+)" string) ""))
    (cl-ppcre:regex-replace-all
     (cl-ppcre:create-scanner (format nil "^\\s*?~a(?:~a)?" leader white) :multi-line-mode t)
     string
     "")))
;;--------------------------------------------------


  

; @@PLEAC@@_2.1
;;; Strings and numbers are separate data types in CL. These tests
;;; check whether a string represents a number
(unless (every #'digit-char-p string)
  (format *error-output* "string has nondigits"))
(unless (cl-ppcre:scan "^\\d+$" string) ; rejects -3
  (format *error-output* "not a natural number"))
(unless (cl-ppcre:scan "^-?\\d+$" string) ; rejects +3
  (format *error-output* "not an integer"))
(unless (cl-ppcre:scan "^[+-]?\\d+$" string)
  (format *error-output* "not an integer"))
(unless (cl-ppcre:scan "^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)$" string)
  (format *error-output* "not an integer"))
(unless (cl-ppcre:scan "^([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?\\d+))?$"
                       string)
  (format *error-output* "not a C float"))


; @@PLEAC@@_2.2
(defun equal-to-accuracy (number1 number2 dp)
  "Return non-nil if NUMBER1 and NUMBER2 are equal to DP number of
decimal places."
  (let* ((difference (abs (- number1 number2)))
         (delta (expt 10 (- dp))))
    (< difference delta)))
;;--------------------------------------------------
(let* ((wage 536)                       ; $5.36/hour
       (week (* 40 wage)))
  (format t "One week's wage is: $~,2F~%" (/ week 100)))
;;--------------------------------------------------

; @@PLEAC@@_2.3
;;--------------------------------------------------
(let* ((a 0.255)
       (b (/ (fround a 0.01) 100)))
  (format t "Unrounded: ~F~%Rounded: ~,2F~%" a b))
;;--------------------------------------------------
(progn
  (format t "~&number~Tint~Tfloor~Tceil~%")
  (let ((as '(3.3 3.5 3.7 -3.3)))
    (dolist (a as)
      (format t "~@{~4,1F~^~T~}~%"
              a
              (ftruncate a)
              (ffloor a)
              (fceiling a)))))


; @@PLEAC@@_2.4
; decimal to binary
(setq bin (format nil "~2R" dec))

; binary to decimal
(setq dec (format nil "~10R" bin))


; @@PLEAC@@_2.6
;arabic to roman
(setq roman (format nil "~@R" arabic))

;roman to arabic
(defun romanchar->num (x) 
  (case (char-downcase x)
    (#\m 1000)
    (#\d 500)
    (#\c 100)
    (#\l 50)
    (#\x 10)
    (#\v 5)
    (#\i 1)
    (t 0)))

(defun isroman (string)
  (every #'(lambda (c)
             (plusp (romanchar->num c)))
         string))

(defun arabic (string)
  (let ((digits (map 'list #'romanchar->num string)))
    (reduce #'+ (mapcar #'(lambda (digit next-digit)
                            (if (< digit next-digit) 
                                (- digit) 
                                digit))
                        digits
                        (append (rest digits) '(0))))))

(when (isroman roman) (setf arabic (arabic roman)))
;;-----------------------------
(setf roman-fifteen (format nil "~@R" 15))
(format t "Roman for fifteen is ~A~%" roman-fifteen)
(setf arabic-fifteen (arabic roman-fifteen))
(format t "Converted back, ~A is ~A~%" roman-fifteen arabic-fifteen)
;;-----------------------------

; @@PLEAC@@_2.7
;;-----------------------------
;integer
(+ (random 51) 25)

;float
(+ (random 51.0) 25.0)


; @@PLEAC@@_2.8
; Question: anyone know a way to give a pre-determined seed, rather than seeding from hardware?
(random limit (make-random-state t))


; @@PLEAC@@_2.11
; degrees to radians
(defun deg2rad (degrees) (* (/ degrees 180) pi))

; radians to degrees
(defun rad2deg (radians) (* (/ radians pi) 180))


; @@PLEAC@@_2.12
; tangent
(tan theta)

(setq y (acos 3.7))


; @@PLEAC@@_2.13
; natural log
(setq log_e (log value))

(setq log_base_whatever (log value base))


; @@PLEAC@@_2.14
(defun multiply-matrices (m1 m2)
  (check-type m1 (array * (* *)))
  (check-type m2 (array * (* *)))
  (let* ((m1-rows (array-dimension m1 0))
         (m1-columns (array-dimension m1 1))
         (m2-rows (array-dimension m2 0))
         (m2-columns (array-dimension m2 1)))
    (unless (= m1-columns m2-rows)
      (error 'simple-type-error
             :format-control "Matrices ~S and ~S do not match."
             :format-args (list m1 m2)))
    (let ((result (make-array (list m1-rows m2-columns))))
      (dotimes (i m1-rows)
        (dotimes (j m2-columns)
          (setf (aref result i j)
                (loop for k from 0 below m1-columns
                      summing (* (aref m1 i k) (aref m2 k j))))))
      result)))
;;--------------------------------------------------
(let ((x #2a((3 2 3)
             (5 9 8)))
      (y #2a((4 7)
             (9 3)
             (8 1))))
  (multiply-matrices x y))

; @@PLEAC@@_3.1
; use get-decoded-time to fetch the time
(multiple-value-bind
	(second minute hour date month year day-of-week dst-p tz)
	(get-decoded-time) 
	year) ;; prints out year using standard library

; alternatively date-calc provides overlapping functionality
(multiple-value-bind
	(year month day h m s)
	(today-and-now) ; imported from date-calc
	year)           ; date-calc approach 

; how to print out current date as "YYYY-MM-DD" (in approved ISO 8601 fashion)
(multiple-value-bind
    (year month day) 
    (today) ;imported from date-calc
    (format t "The current date is ~A-~2,'0d-~2,'0d" year month day))

; Alternatively, you could use the format-time function from the CyberTiggyr-Time package:
(format-time t "%Y-%m-%d" (get-universal-time))

; As you can see, format-time operates on epoch time

; @@PLEAC@@_3.2 
; to encode time into universal time using date-calc
(multiple-value-bind
	(second minute hour date month year day-of-week dst-p tz)
	(get-decoded-time)
  (encode-universal-time second minute hour date month year))

;; the last two return values for get-decoded-time correspond to daylight savings and the
;; timezone.  Both are useful for timezone-related arithmatic.

; @@INCOMPLETE@@
; An example of a GMT computation with and without daylight savings is appropriate here since
; the built-in perl functions handle this.

; @@PLEAC@@_3.3
(let ((time (get-universal-time))) ; get epoch seconds
  (multiple-value-bind
      (second minute hour day month year day-of-week dst-p tz)
      (decode-universal-time time) ; decode and...
    (list day month year hour minute second))) ; return

; @@PLEAC@@_3.4
; when using universal time you add or subtract seconds
; here we add one hour
(let ((firstdate 
       (encode-universal-time 0 12 6 23 11 2006))
      (onehour (* 60 60 1)))
  (+ onehour firstdate))

; or you could use date-calc function
; here we'll add one day
(add-delta-ymdhms 2006 11 24 18 12 0  0 0 1 0 0 0)

; @@PLEAC@@_3.5
; We'll use the epoch seconds to perform subtraction, 
; then divide by seconds per day
(let ((first (encode-universal-time 52 45 20 13 12 1901))
      (second (encode-universal-time 7 14 3 19 1 2038)))
  (float (/ (- second first) (* 60 60 24))))

; method two uses delta-days from the date-calc package:
(delta-days 1901 12 13 2038 1 19)

; delta-days does not yet have the granularity of seconds, minutes or hours. 

; @@PLEAC@@_3.6
; The week of the year is computed as follows:
(week-number 2006 12 1) ; week-of-year is imported from date-calc

; similar functions exist for day of week, day of year, etc.

; @@PLEAC@@_3.7
(parse-time "2006-08-20")

; parse-time can recognize many of the commonly found date formats

; format-time comes with several ways to format...
(format-time t *format-time-date* (get-universal-time))

; results in: 25 Nov 2006

(format-time t *format-time-iso8601-short* (get-universal-time))

; results in: 20061125T172917 -5

(format-time t "%Y-%m-%d" (get-universal-time))

; results in: 2006-11-25

;;; @@PLEAC@@_4.0
(setf nested '("this" "that" "the" "other")
(setf nested '("this" "that" ("the" "other")))
;;-----------------------------
(setf tune '("The" "Star-Spangled" "Banner"))

;;; @@PLEAC@@_4.1
(setf @a '("quick" "brown" "fox");
;;-----------------------------
(setf @a '("Why" "are" "you" "teasing" "me?"))
;;-----------------------------
(setf @lines (cl-ppcre:regex-mumble-fratz "m/^\s*(.+)/gm"
"    The boy stood on the burning deck,
    It was as hot as glass.
"))
;;-----------------------------
;;; You don't really need the explicit call to (something like) die()
;;; in CL.  Its behavior is essentially the same by default (it does
;;; throw you into the debugger, but that's not a bad thing
;;; generally).  You could, alternatively, handle this error with
;;; HANDLER-BIND or HANLDER-CASE if you wanted to.
(let ((bigarray '()))
  (with-open-file (data "mydatafile")
    (loop for line = (read-line data nil nil)
       while line
       do (push (string-right-trim #(#\Newline #\Return #\Space #\Tab) 
                                   line) bigarray))))
;;-----------------------------
(setf banner "The Mines of Moria")
;;-----------------------------
(setf name "Gandalf")
(setf banner (format nil "Speak ~a and enter!" name))
(setf banner "Speak $name and welcome!")
;;-----------------------------

;;; @@PLEAC@@_4.17
(defun fisher-yates-shuffle (vector)
  "Randomly shuffle elements of VECTOR."
  (loop for i from (1- (length vector)) downto 1
     for j = (random i)
     unless (= i j)
     do (rotatef (aref vector i) (aref vector j)))
  vector)
;;;
(defun shuffle (vector)
  "Return a fresh permuted copy of VECTOR."
  (let* ((n-permutations (factorial (length vector)))
         (permutation (nth-permutation (random n-permutations)
                                       (length vector))))
    (map 'vector (lambda (i) (aref vector i)) permutation)))
;;;
(defun naive-shuffle (vector)
  (loop with n = (length vector)
        for i from 0 below n
        for j = (random n)
        do (rotatef (aref vector i) (aref vector j)))
  vector)

;;; @@PLEAC@@_4.19
(defun factorial (n)
  (loop for result = 1 then (* result i)
        for i from 1 to n
        finally (return result)))

(factorial 500) ; => 1220136... (1135 digits total)

(defun map-vector-permutations (function vector)
  (labels ((permute (end)
             (if (= end 0)
                 (funcall function vector)
                 (dotimes (i end)
                   (rotatef (aref vector (1- end)) (aref vector i))
                   (permute (1- end))
                   (rotatef (aref vector (1- end)) (aref vector i))))))
    (permute (length vector))))
(map-vector-permutations #'print #(1 2 3))

(defun map-list-permutations (function list)
  (labels ((permute (tail)
             (if (null tail)
                 (funcall function list)
                 (loop for subtail on tail
                       do (rotatef (car tail) (car subtail))
                          (permute (cdr tail))
                          (rotatef (car tail) (car subtail))))))
    (permute list)))
(map-list-permutations #'print '(1 2 3))
;;; permute words in each line of input stream
(loop for line = (read-line *standard-input* nil nil)
      while line
      do (map-list-permutations (lambda (words)
                                  (format t "~{~A~^ ~}~%" words))
                                (cl-ppcre:split "\\s+" line)))

;;;
(let ((memo (make-hash-table)))
  (setf (gethash 0 memo) 1)
  (defun factorial (n)
    (or (gethash n memo)
        (setf (gethash n memo) (* n (factorial (1- n)))))))

(defun nth-pattern (n length)
  (loop for i from length downto 1
        for (new-n elem) = (multiple-value-list (truncate n i))
        collect elem
        do (setq n new-n)))

(defun pattern-permutation (pattern)
  (loop with source = (cons nil
                            (loop for i from 0 below (length pattern)
                                  collect i))
        for i in pattern
        for pred = (nthcdr i source)
        for (elem . rest) = (cdr pred)
        collect elem
        do (setf (cdr pred) rest)))

(defun nth-permutation (n length)
  (pattern-permutation (nth-pattern n length)))

; @@PLEAC@@_5.0

(setf age (make-hash-table :test 'equal))

(setf (gethash "Nat" age) 24
      (gethash "Jules" age) 25
      (gethash "Josh" age) 17)
;;--------------------------------------------------

(mapcar #'(lambda (l)
            (setf (gethash (car l) age) (cdr l)))
        '(("Nat" . 24)
          ("Jules" . 25)
          ("Josh" . 17)))
;;--------------------------------------------------
(setf food-color (make-hash-table :test 'equal))

(mapcar #'(lambda (l)
            (setf (gethash (car l) food-color) (cdr l)))
        '(("Apple" . "red")
          ("Banana" . "yellow")
          ("Lemon" . "yellow")
          ("Carrot" . "orange")))

;;--------------------------------------------------

(mapcar #'(lambda (l)
            (setf (gethash (car l) food-color) (cdr l)))
        '((Apple . "red")
          (Banana . "yellow")
          (Lemon . "yellow")
          (Carrot . "orange")))
;;--------------------------------------------------


; @@PLEAC@@_5.1
;;--------------------------------------------------
(setf (gethash $KEY $HASH) $VALUE)
;;--------------------------------------------------

(setf (gethash "Raspberry" food-color) "pink")

(format t "Known foods:~%~{~a~%~}"
        (loop for f being the hash-keys food-color
           collect f))

; @@PLEAC@@_5.2
;;--------------------------------------------------
;; does %HASH have a value for $KEY ?
(if (nth-value 1 (gethash key hash))
    'it-exists
    'it-does-not)
;;--------------------------------------------------
# food-color per the introduction
(dolist (name '("Banana" "Martini"))
  (format t "~a is a ~a.~%"
          name
          (if (nth-value 1 (gethash name food-color))
              "food" "drink")))
;;--------------------------------------------------
(setf age (make-hash-table :test 'equal))
(setf (gethash "Toddler" age) 3)
(setf (gethash "Unborn" age) 0)
(setf (gethash "Phantasm" age) nil)
(dolist (thing '("Toddler" "Unborn" "Phantasm" "Relic"))
  (format t "~a: " thing)
  (multiple-value-bind (defined exists)
      (gethash thing age)
      (when exists
        (format t "Exists ")
        (when defined 
          (format t "Defined ")
          ;; 0 is not false in CL, so must explicitly mimic Perl here
          (unless (zerop defined)
            (format t "True ")))))
  (format t "~%"))

; @@PLEAC@@_5.3
;;--------------------------------------------------


; @@PLEAC@@_8.2
;; Should we count the last line, if it does not end with a newline?
;; This version counts:
(with-open-file (stream #p"numbers.html")
  (loop for line = (read-line stream nil)
        while line
        count t))
;; and this does not:
(with-open-file (stream #p"numbers.html")
  (loop for (line missing-newline-p) =
            (multiple-value-list (read-line stream nil))
        while line
        count (not missing-newline-p)))


; @@PLEAC@@_11.15
;;; Binary trees example
(deftype tree () '(or null tree-node))
(defstruct (tree-node
             (:conc-name #:tree-))
  value
  ;; subtrees
  (left nil :type tree)
  (right nil :type tree))

(defun tree-insert (tree value)
  "Return TREE with destructively inserted VALUE."
  (declare (type tree tree))
  (if tree
      (progn (if (< value (tree-value tree))
                 (setf (tree-left tree)
                       (tree-insert (tree-left tree) value))
                 (setf (tree-right tree)
                       (tree-insert (tree-right tree) value)))
             tree)
      (make-tree-node :value value)))

(defun print-tree-in-order (tree)
  (when tree
    (print-tree-in-order (tree-left tree))
    (format t "~S " (tree-value tree))
    (print-tree-in-order (tree-right tree))))

(defun print-tree-in-preorder (tree)
  (when tree
    (format t "~S " (tree-value tree))
    (print-tree-in-preorder (tree-left tree))
    (print-tree-in-preorder (tree-right tree))))

(defun print-tree-in-postorder (tree)
  (when tree
    (print-tree-in-postorder (tree-left tree))
    (print-tree-in-postorder (tree-right tree))
    (format t "~S " (tree-value tree))))

(defun search-tree (tree value)
  "Return a subtree of TREE with the specified VALUE in root."
  (when tree
    (if (= (tree-value tree) value)
        tree
        (search-tree (if (< value (tree-value tree))
                         (tree-left tree)
                         (tree-right tree))
                     value))))

(defun test-trees ()
  (let ((tree nil))
    (dotimes (i 20)
      (setq tree (tree-insert tree (random 1000))))
    (format t "~&Pre order: ") (print-tree-in-preorder tree)
    (format t "~&In order:  ") (print-tree-in-order tree)
    (format t "~&Postorder: ") (print-tree-in-postorder tree)
    (terpri)

    (loop do
         (format t "~&Search? ")
         (finish-output)
         (let* ((eof (gensym)) ; some hard-to-enter object
                (value (read *standard-input* nil eof)))
           (when (eq value eof) (loop-finish))
           (let ((found (search-tree tree value)))
             (if found
                 (format t "Found ~S at ~S~%" value found)
                 (format t "No ~S in tree~%" value)))))))
