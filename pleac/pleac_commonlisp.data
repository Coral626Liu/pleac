; -*- lisp -*-
;
; @@PLEAC@@_NAME
; @@SKIP@@ Common Lisp

; @@PLEAC@@_WEB
; @@SKIP@@ http://www.lisp.org/


; @@PLEAC@@_APPENDIX
; Common Lisp does not support regular expressions. This code uses
; portable library CL-PPCRE (see www.cliki.net/cl-ppcre).
(require :cl-ppcre)


; @@PLEAC@@_1.0
;;-----------------------------
(setq string "\\n")                   ; two characters, \ and an n
(setq string "John 'Maddog' Orwant")  ; literal single quotes
(setq string "John \"Maddog\" Orwant") ; literal double quotes
;;-----------------------------
;; newlines may be inserted literally
(setq string "
")
;; or by creating a string explicitly
(setq string (make-string 1 :initial-element #\newline))
;; or by using format with a nil output stream
(setq string (format nil "~%"))
;;-----------------------------
(setq string "
This is a multiline string, terminated by a
double quotation mark.
")
;;-----------------------------


; @@PLEAC@@_1.1
; assign a substring to a variable
(setq value (subseq string offset (+ offset count)))
(setq value (subseq string offset))

; edit a substring
(setq string (concatenate 'string (subseq string 0 offset) newstring
(subseq string (+ offset count))))
(setq string (concatenate 'string (subseq string 0 offset) newtail))

;;-----------------------------
; get a 5-byte string, skip 3, then grab 2 8-byte strings, then the
; rest
(setq leading (subseq data 5)
       s1 (subseq data 8 8)
       s2 (subseq data 16 8)
       trailing (subseq data 24))

; split at five byte boundries
(let ((length (length string)))
   (loop for idx from 0 upto length by 5
      collect (subseq string idx (min length (+ idx 5)))))

; chop string into individual characters
(loop for idx from 0 upto (1- (length string))
      collect (char string idx))

;;-----------------------------
(defparameter *string* "This is what you have")
;;             +012345678901234567890  Indexing forwards  (left to right)
;;              109876543210987654321- Indexing backwards (right to left)

(subseq *string* 0 1)                        ; "T"
(subseq *string* 5 7)                        ; "is"
(subseq *string* 13)                         ; "you have"
(subseq *string* (+ (length *string*) -1))   ; "e"
(subseq *string* (+ (length *string*) -4))   ; "have"
(subseq *string*
         (+ (length *string*) -8)
         (+ (length *string*) -8 3)) ; "you"

(print *string*)
;; This is what you have

;; Change "is" to "wasn't"
(setq *string*
       (concatenate 'string
                    (subseq *string* 0 5)
                    "wasn't"
                    (subseq *string* (+ 5 2))))
;; This wasn't what you have

;; Replace last 12 characters
(setq *string*
       (concatenate 'string
                    (subseq *string* 0 (+ (length *string*) -12))
                    "ondrous"))
;; This wasn't wondrous

;; Delete first character
(setq *string* (subseq *string* 1))
;; his wasn't wondrous

;; Delete last 10 characters
(setq *string* (subseq *string* 0 (+ (length *string*) -10)))
;; his wasn'

;;-----------------------------
;; You can test substrings with the :start and :end keyword
;; parameters of cl-pcre:scan
(when (cl-ppcre:scan "pattern" *string*
                      :start (- (length *string*) 10))
   (format t "Pattern matches in last 10 characters~%"))

;; substitute "at" for "is", restricted to first five characters
(concatenate 'string
              (cl-ppcre:regex-replace "is" *string* "at"
                                      :start 0
                                      :end (min (length *string*) 5))
              (when (> (length *string*) 5)
                (subseq *string* 5)))

;;-----------------------------
;; Exchange the first and last letters in a string
(setq *string* "make a hat")
(let ((end (1- (length *string*)))
       (tmp (char *string* 0)))
   (setf (char *string* 0) (char *string* end)
         (char *string* end) tmp))
;; take a ham

; edit a substring
(setq string (concatenate 'string (substring string 0 offset) newstring
(substring string (+ offset count))))
(setq string (concatenate 'string (substring string 0 offset) newtail))


; @@PLEAC@@_1.2
; use b if b is true, else c
(setq a (or b c))

; set x to y unless x is already true
(unless x (setq x y))

;; use b if b is defined, otherwise c
(setq a (if (boundp 'b) b c))
;;-----------------------------
(setq foo (if bar bar "DEFAULT VALUE"))
;;-----------------------------
(setq dir (or (pop ARGV) "/tmp"))
;;-----------------------------
(setq dir (or (nth 0 ARGV) "/tmp"))
;;-----------------------------
(setq dir (if (boundp 'ARGV) (pop ARGV) "/tmp"))
;;-----------------------------
(setq dir (if (plusp (length ARGV)) (nth 0 ARGV) "/tmp"))
;;-----------------------------
(incf (gethash (or shell "/bin/sh") count 0))
;;-----------------------------
(setq user (or (posix-getenv "USER")
			   (posix-getenv "LOGNAME")
			   "Unknown uid"))
;;-----------------------------
(setq starting-point (or starting-point "Greenwich"))
;;-----------------------------
(unless a
  (setq a (copy-seq b)))   ; copy only if empty
(setq a (if b b c))        ; assign b if nonempty, else c


; @@PLEAC@@_1.3
;;--------------------------------------------------
(psetq VAR1 VAR2 VAR2 VAR1)
(multiple-value-setq (VAR1 VAR2) (values VAR2 VAR1))
;;--------------------------------------------------
(setq a "alpha")
(setq b "omega")
(psetq a b b a) ;; the first shall be last -- and versa vice
;;--------------------------------------------------
(destructuring-bind (alpha beta production)
     '(January March August)
   ;; move beta       to alpha,
   ;; move production to beta,
   ;; move alpha      to production
   (psetq alpha beta
          beta production
          production alpha))


; @@PLEAC@@_1.4
;;--------------------------------------------------
(setq num (char-code char))
(setq char (code-char ord))
;;--------------------------------------------------
(setq char (format nil "~c" (code-char num)))
(format t "Number ~d is character ~c\n" num (code-char num))
;--> Number 101 is character e
;;--------------------------------------------------
(setq ASCII (map 'list #'char-code string))
(setq string (map 'string #'code-char ASCII))
;;--------------------------------------------------
(setq ascii-value (char-code (char "e" 0)))    ; now 101
(setq character (code-char 101))               ; now #\e
;;--------------------------------------------------
(format t "Number ~d is character ~c\n" 101 (code-char 101))
;;--------------------------------------------------
(setq ascii-character-numbers (map 'list #'char-code "sample"))
(format t "~a~%" ascii-character-numbers)
;--> (115 97 109 112 108 101)

(setq word (map 'string #'code-char ascii-character-numbers))
(setq word (map 'string #'code-char '(115 97 109 112 108 101)))
(format t "~a~%" word)
;--> sample
;;--------------------------------------------------
(let* ((hal "HAL")
        (ibm (map 'string
                  (lambda (char)
                    (code-char (1+ (char-code char))))
                  hal)))
   (format t "~a~%" ibm))
;;--------------------------------------------------


; @@PLEAC@@_1.5
;;--------------------------------------------------
(setq array (map 'list #'string string))

(setq array (loop for char across string
                  collect (char-code char)))
;;--------------------------------------------------
(loop for $1 across string do
      ;; do something with $1
      )

;;--------------------------------------------------
(let ((string "an apple a day")
      (seen (make-hash-table)))
  (loop for char across string do
        (incf (gethash char seen 0)))
  (let* ((chars (loop for char being each hash-key of seen
                      collect char))
         (chars (sort (coerce chars 'string) #'>
                      :key (lambda (char) (gethash char seen)))))
    (format t "unique chars are: ~A~%" chars)))
;;--------------------------------------------------
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (reduce #'+ string :key #'char-code)))
(let ((string "an apple a day"))
  (format t "sum is ~D~%"
          (loop for char across string
                summing (char-code char))))
;;--------------------------------------------------


; @@PLEAC@@_1.6
;;--------------------------------------------------
(setq revbytes (reverse string))

(setq revwords (format nil "~{~a~^ ~}"
                       (reverse (cl-ppcre:split " " string))))
(setq revwords (reverse
                (do* ((stringstream (make-string-input-stream string))
                      (result nil (cons next result))
                      (next (read stringstream nil 'eos)
                            (read stringstream nil 'eos)))
                     ((equal next 'eos)
                      (reverse result)))))
;;--------------------------------------------------
(setq gnirts (reverse string))  ; reverse letters in string
(setq sdrow (reverse words))    ; reverse elements in words
(setq confused (reverse (apply #'concatenate 'string words)))
;;--------------------------------------------------
(setq string "Yoda said, \"can you see this?\"")
(setq allwords (cl-ppcre:split " " string))
(setq revwords (format nil "~{~a~^ ~}" (reverse allwords)))
(format t "~a~%" revwords)
;this?" see you "can said, Yoda
;;--------------------------------------------------
(setq revwords (format nil "~{~a~^ ~}" (reverse (cl-ppcre:split " "
string))))
;;--------------------------------------------------
(setq revwords (apply #'concatenate 'string
                      (cl-ppcre:split "(\\s+)" string :with-registers-p t)))
;;--------------------------------------------------
(defun palindrome-p (word)
  (string-equal word (reverse word)))
(palindrome-p "reviver")
; T
;;--------------------------------------------------
(with-open-file (inf "/usr/share/dict/words")
  (loop for word = (read-line inf nil nil)
        while word
        when (and (string-equal word (reverse word)) (> (length word) 5))
        do (format t "~a~%" word)))
; redder
; reviver
; rotator
;;--------------------------------------------------


; @@PLEAC@@_1.7
;;--------------------------------------------------
(defun tab-expand (string &optional (tabstop 8))
  (flet ((needed-spaces (target-string start end match-start match-end
reg-starts reg-ends)
           (declare (ignore target-string start end reg-starts reg-ends))
           (make-string (- (* (- match-end match-start) tabstop)
                           (mod match-start tabstop))
                        :initial-element #\Space)))
    (cl-ppcre:regex-replace-all "\\t+" string #'needed-spaces)))

;;--------------------------------------------------
(defun tab-unexpand (string &optional (tabstop 8))
  (flet ((needed-tabs (target-string start end match-start match-end
reg-starts reg-ends)
           (declare (ignore target-string start end reg-starts reg-ends))
           (let ((match-length (- match-end match-start)))
             (concatenate 'string
                        (make-string (floor match-length tabstop)
                                     :initial-element #\Tab)
                        (make-string (mod match-length tabstop)
                                     :initial-element #\Space)))))
    (cl-ppcre:regex-replace-all "  +" string #'needed-tabs)))
;;--------------------------------------------------
(loop for line = (read-line *standard-input* nil nil)
      while line do
      (format t "~a~%" (tab-expand line)))
;;--------------------------------------------------
(loop for line = (read-line *standard-input* nil nil)
      while line do
      (format t "~a~%" (tab-unexpand line)))
;;--------------------------------------------------


; @@PLEAC@@_1.8
;;--------------------------------------------------
(setq text "You owe $debt to me")
;;--------------------------------------------------
(flet ((global-deref (match var-name)
         (write-to-string (symbol-value (intern var-name)))))
  (setq text (cl-ppcre:regex-replace-all "\\$(\\w+)" text #'global-deref
                                         :simple-calls t)))
;;--------------------------------------------------
(setq rows 24
      cols 80)
(setq text "I am $rows high and $cols long")
(flet ((global-deref (match var-name)
         (write-to-string (symbol-value (intern (string-upcase
var-name))))))
  (setq text (cl-ppcre:regex-replace-all "\\$(\\w+)" text
                                         #'global-deref
                                         :simple-calls t)))
(format t "~a~%" text)
; I am 24 high and 80 long
;;--------------------------------------------------
(setq text "I am 17 years old")
(setq text (cl-ppcre:regex-replace-all "(\\d+)" text
                                       (lambda (match num-str)
                                         (declare (ignore match))
                                         (write-to-string
                                          (* 2 (parse-integer num-str))))
                                       :simple-calls t))
;;--------------------------------------------------
(* 2 17)
;;--------------------------------------------------
;; expand variables in text, but put an error message in
;; if the variable isn't defined
(flet ((deref-with-err (match word)
         (declare (ignore match))
         (let ((word-sym (intern (string-upcase word))))
         (if (boundp word-sym)
             (write-to-string (symbol-value word-sym))
             (format nil "[NO VARIABLE: $~a]" word-sym)))))
  (setq text (cl-ppcre:regex-replace-all "\\$(\\w+)" text
                                         #'deref-with-err
                                         :simple-calls t)))
;;--------------------------------------------------


; @@PLEAC@@_1.9
;;--------------------------------------------------
(setq big (string-upcase little))
(setq little (string-downcase big))
;;--------------------------------------------------
(setq big (string-upcase little :end 1)
(setq little (string-downcase BIG :end 1))
;;--------------------------------------------------
(setq beast "dromedary")
;; Capitalize various parts of beast
(setq capit (string-upcase beast :end 1))      ; Dromedary
(setq capall (string-upcase beast))            ; DROMEDARY
(setq caprest (string-upcase beast :start 1))  ; dROMEDARY
;;--------------------------------------------------
;; capitalize each word's first character, downcase the rest
(setq text "thIS is a loNG liNE")
(princ (string-capitalize text))
; This Is A Long Line
;;--------------------------------------------------
;; string= is case-sensitive, string-equal is case-insensitive
(when (string-equal a b)
  (format t "a and b are the same~%"))
;;--------------------------------------------------
;; It's considered bad form to perform bitwise operations
;; on character types, and breaks unicode-aware lisps.  Trust
;; the compiler to optimize.
(defun randcase (char)
  (if (< (random 100) 20)
      (char-upcase char)
      (char-downcase char)))
(map 'string #'randcase string)
;;--------------------------------------------------


; @@PLEAC@@_1.10
; func, obviously, must evaluate to a string
(setq answer (concatenate 'string var1 (func args) var2))
(setq answer (format nil "~@{~A~}" var1 (func args) var2))
;;--------------------------------------------------
(setq phrase (format nil "I have ~D guanacos." (+ n 1)))
;;--------------------------------------------------
(setq phrase (format nil "I have ~A guanacos.~%" (+ n 1)))


; @@PLEAC@@_2.1
;;; Strings and numbers are separate data types in CL. These tests
;;; check whether a string represents a number
(unless (every #'digit-char-p string)
  (format t "string has nondigits"))
(unless (cl-ppcre:scan "^\\d+$" string) ; rejects -3
  (format t "not a natural number"))
(unless (cl-ppcre:scan "^-?\\d+$" string) ; rejects +3
  (format t "not an integer"))
(unless (cl-ppcre:scan "^[+-]?\\d+$" string)
  (format t "not an integer"))
(unless (cl-ppcre:scan "^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)$" string)
  (format t "not an integer"))
(unless (cl-ppcre:scan "^([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?\\d+))?$"
                       string)
  (format t "not a C float"))


; @@PLEAC@@_2.2
(defun equal-to-accuracy (number1 number2 dp)
  "Return TRUE if NUMBER1 and NUMBER2 are equal to DP number of
  decimal places."
  (let* ((difference (abs (- number1 number2)))
         (delta (expt 10 (- dp))))
    (< difference delta)))
;;--------------------------------------------------
(let* ((wage 536)                       ; $5.36/hour
       (week (* 40 wage)))
  (format t "One week's wage is: $~,2F~%" (/ week 100)))
;;--------------------------------------------------
(let* ((a 0.255)
       (b (/ (fround a 0.01) 100)))
  (format t "Unrounded: ~F~%Rounded: ~,2F~%" a b))
;;--------------------------------------------------
(progn
  (format t "~&number~Tint~Tfloor~Tceil~%")
  (let ((as '(3.3 3.5 3.7 -3.3)))
    (dolist (a as)
      (format t "~@{~4,1F~^~T~}~%"
              a
              (ftruncate a)
              (ffloor a)
              (fceiling a)))))


; @@PLEAC@@_2.4
; decimal to binary
(setq bin (format nil "~2R" dec))

; binary to decimal
(setq dec (formant nil "~10R" bin))


; @@PLEAC@@_2.6
;arabic to roman
(setq roman (format nil "~@R" arabic))

;roman to arabic
(defun romanchar (x) (cond ((or (eq x #\m) (eq x #\M)) 1000)
			   ((or (eq x #\d) (eq x #\D)) 500)
			   ((or (eq x #\c) (eq x #\C)) 100)
			   ((or (eq x #\l) (eq x #\L)) 50)
			   ((or (eq x #\x) (eq x #\X)) 10)
		           ((or (eq x #\v) (eq x #\V)) 5)
			   ((or (eq x #\i) (eq x #\I)) 1)
			   (t 0)))

(defun roman2arabic (x) (let ((y (coerce x 'list))) 
				(if (eq 1 (length y)) 
				    (romanchar (car y)) 
				    (if (< (romanchar (car y)) (romanchar (cadr y)))
				 		(- (roman2arabic (rest y)) (romanchar (car y)))
						(+ (romanchar (car y)) (roman2arabic (rest y)))))))

(setq arabic (roman2arabic roman))


; @@PLEAC@@_2.7
;integer
(+ (random 51) 25)

;float
(+ (random 51.0) 25.0)


; @@PLEAC@@_2.8
; Question: anyone know a way to give a pre-determined seed, rather than seeding from hardware?
(random limit (make-random-state t))


; @@PLEAC@@_2.11
; degrees to radians
(defun deg2rad (degrees) (* (/ degrees 180) pi))

; radians to degrees
(defun rad2deg (radians) (* (/ radians pi) 180))


; @@PLEAC@@_2.12
; tangent
(tan theta)

(setq y (acos 3.7))


; @@PLEAC@@_2.13
; natural log
(setq log_e (log value))

(setq log_base_whatever (log value base))


; @@PLEAC@@_2.14
(defun multiply-matrices (m1 m2)
  (check-type m1 (array * (* *)))
  (check-type m2 (array * (* *)))
  (let* ((m1-rows (array-dimension m1 0))
         (m1-columns (array-dimension m1 1))
         (m2-rows (array-dimension m2 0))
         (m2-columns (array-dimension m2 1)))
    (unless (= m1-columns m2-rows)
      (error 'simple-type-error
             :format-control "Matrices ~S and ~S do not match."
             :format-args (list m1 m2)))
    (let ((result (make-array (list m1-rows m2-columns))))
      (dotimes (i m1-rows)
        (dotimes (j m2-columns)
          (setf (aref result i j)
                (loop for k from 0 below m1-columns
                      summing (* (aref m1 i k) (aref m2 k j))))))
      result)))
;;--------------------------------------------------
(let ((x #2a((3 2 3)
             (5 9 8)))
      (y #2a((4 7)
             (9 3)
             (8 1))))
  (multiply-matrices x y))


;;; @@PLEAC@@_4.17
(defun fisher-yates-shuffle (vector)
  "Randomly shuffle elements of VECTOR."
  (loop for i from (1- (length vector)) downto 1
        for j = (random i)
        unless (= i j)
          do (rotatef (aref vector i) (aref vector j)))
  vector)
;;;
(defun shuffle (vector)
  "Return a fresh permuted copy of VECTOR."
  (let* ((n-permutations (factorial (length vector)))
         (permutation (nth-permutation (random n-permutations)
                                       (length vector))))
    (map 'vector (lambda (i) (aref vector i)) permutation)))
;;;
(defun naive-shuffle (vector)
  (loop with n = (length vector)
        for i from 0 below n
        for j = (random n)
        do (rotatef (aref vector i) (aref vector j)))
  vector)

;;; @@PLEAC@@_4.19
(defun factorial (n)
  (loop for result = 1 then (* result i)
        for i from 1 to n
        finally (return result)))

(factorial 500) ; => 1220136... (1135 digits total)

(defun map-vector-permutations (function vector)
  (labels ((permute (end)
             (if (= end 0)
                 (funcall function vector)
                 (dotimes (i end)
                   (rotatef (aref vector (1- end)) (aref vector i))
                   (permute (1- end))
                   (rotatef (aref vector (1- end)) (aref vector i))))))
    (permute (length vector))))
(map-vector-permutations #'print #(1 2 3))

(defun map-list-permutations (function list)
  (labels ((permute (tail)
             (if (null tail)
                 (funcall function list)
                 (loop for subtail on tail
                       do (rotatef (car tail) (car subtail))
                          (permute (cdr tail))
                          (rotatef (car tail) (car subtail))))))
    (permute list)))
(map-list-permutations #'print '(1 2 3))
;;; permute words in each line of input stream
(loop for line = (read-line *standard-input* nil nil)
      while line
      do (map-list-permutations (lambda (words)
                                  (format t "~{~A~^ ~}~%" words))
                                (cl-ppcre:split "\\s+" line)))

;;;
(let ((memo (make-hash-table)))
  (setf (gethash 0 memo) 1)
  (defun factorial (n)
    (or (gethash n memo)
        (setf (gethash n memo) (* n (factorial (1- n)))))))

(defun nth-pattern (n length)
  (loop for i from length downto 1
        for (new-n elem) = (multiple-value-list (truncate n i))
        collect elem
        do (setq n new-n)))

(defun pattern-permutation (pattern)
  (loop with source = (cons nil
                            (loop for i from 0 below (length pattern)
                                  collect i))
        for i in pattern
        for pred = (nthcdr i source)
        for (elem . rest) = (cdr pred)
        collect elem
        do (setf (cdr pred) rest)))

(defun nth-permutation (n length)
  (pattern-permutation (nth-pattern n length)))


; @@PLEAC@@_8.2
;; Should we count the last line, if it does not end with a newline?
;; This version counts:
(with-open-file (stream #p"numbers.html")
  (loop for line = (read-line stream nil)
        while line
        count t))
;; and this does not:
(with-open-file (stream #p"numbers.html")
  (loop for (line missing-newline-p) =
            (multiple-value-list (read-line stream nil))
        while line
        count (not missing-newline-p)))


; @@PLEAC@@_11.15
;;; Binary trees example
(deftype tree () '(or null tree-node))
(defstruct (tree-node
             (:conc-name #:tree-))
  value
  ;; subtrees
  (left nil :type tree)
  (right nil :type tree))

(defun tree-insert (tree value)
  "Return TREE with destructively inserted VALUE."
  (declare (type tree tree))
  (if tree
      (progn (if (< value (tree-value tree))
                 (setf (tree-left tree)
                       (tree-insert (tree-left tree) value))
                 (setf (tree-right tree)
                       (tree-insert (tree-right tree) value)))
             tree)
      (make-tree-node :value value)))

(defun print-tree-in-order (tree)
  (when tree
    (print-tree-in-order (tree-left tree))
    (format t "~S " (tree-value tree))
    (print-tree-in-order (tree-right tree))))

(defun print-tree-in-preorder (tree)
  (when tree
    (format t "~S " (tree-value tree))
    (print-tree-in-preorder (tree-left tree))
    (print-tree-in-preorder (tree-right tree))))

(defun print-tree-in-postorder (tree)
  (when tree
    (print-tree-in-postorder (tree-left tree))
    (print-tree-in-postorder (tree-right tree))
    (format t "~S " (tree-value tree))))

(defun search-tree (tree value)
  "Return a subtree of TREE with the specified VALUE in root."
  (when tree
    (if (= (tree-value tree) value)
        tree
        (search-tree (if (< value (tree-value tree))
                         (tree-left tree)
                         (tree-right tree))
                     value))))

(defun test-trees ()
  (let ((tree nil))
    (dotimes (i 20)
      (setq tree (tree-insert tree (random 1000))))
    (format t "~&Pre order: ") (print-tree-in-preorder tree)
    (format t "~&In order:  ") (print-tree-in-order tree)
    (format t "~&Postorder: ") (print-tree-in-postorder tree)
    (terpri)

    (loop do
         (format t "~&Search? ")
         (finish-output)
         (let* ((eof (gensym)) ; some hard-to-enter object
                (value (read *standard-input* nil eof)))
           (when (eq value eof) (loop-finish))
           (let ((found (search-tree tree value)))
             (if found
                 (format t "Found ~S at ~S~%" value found)
                 (format t "No ~S in tree~%" value)))))))
