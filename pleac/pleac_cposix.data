// -*- c -*-

// @@PLEAC@@_NAME
// @@SKIP@@ C/Posix/GNU


// @@PLEAC@@_WEB
// @@SKIP@@ http://www.gnu.org/software/libc/libc.html


// @@PLEAC@@_3.0
//------------------------------------------------------------------
#include <stdio.h>
#include <time.h> // time_t, struct tm, localtime()
#include <stdlib.h>
#include <limits.h> // SSIZE_MAX

...

time_t timeval;
struct tm * tmval;

timeval = time(NULL);

if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else
  /* using tm fields : not recommended */
  printf("Today is day %02d of the current year\n",
  tmval->tm_yday);
/* using strftime */
// we first check the return of strftime to allocate a buffer of the correct size
  lg = strftime(NULL, SSIZE_MAX, "%j", tmval);
  if( lg > 0 ){
    buffer = malloc( lg + 1 );
    if( buffer == NULL ){          perror("malloc");
      exit(1);
    }
    strftime(buffer, lg + 1, "%j", tmval );
    fprintf( stdout, "Today is day %s of the current year\n", buffer );
    free( buffer );
  }

...


// @@PLEAC@@_3.1
//------------------------------------------------------------------
#include <stdio.h>
#include <time.h> // time_t, struct tm, localtime()

...

time_t timeval;
struct tm * tmval;

timeval = time(NULL);

if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else
  printf("The current date is %04d %02d %02d\n",
	 tmval->tm_year + 1900,
	 tmval->tm_mon + 1,
	 tmval->tm_mday); 
    
...


//------------------------------------------------------------------
#include <stdio.h>
#include <sys/time.h> // gettimeofday(), struct timeval, struct timezone
#include <time.h> // ctime()

...
  
time_t timer;
struct timeval timev;

// time()-like
gettimeofday(&timev, NULL);
timer = timev.tv_sec;

// ctime() is equivalent to asctime(localtime(date))
printf("today is %s\n", ctime(&timer));
// today is Fri Jun 10 22:09:46 2005
  
...

//------------------------------------------------------------------
#include <stdio.h>
#include <time.h> // time_t, struct tm, localtime() strftime()
#include <stdlib.h>
#include <limits.h> // SSIZE_MAX

...

time_t timeval;
struct tm * tmval;
int lg;
char * buffer;

timeval = time(NULL);

if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else{
   // we first check the return of strftime to allocate a buffer of the correct size
  lg = strftime(NULL, SSIZE_MAX, "%Y-%m-%d", tmval );
  if( lg > 0 ){
    buffer = malloc( lg + 1 );
    if( buffer == NULL ){      
      perror("malloc");
      exit(1);
    }
    strftime(buffer, lg + 1, "%Y-%m-%d", tmval );
    fprintf( stdout, "The courant date is %s\n", buffer );
    free( buffer );
  }
}

...


// @@PLEAC@@_3.3
//------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

...

struct tm * tmval;
time_t timeval;

timeval = time(NULL);
if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else
  printf("localtime is %s\n", asctime(tmval));
  ...

//------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h> ...
  struct tm * tmval;
time_t timeval;

timeval = time(NULL);
if((tmval = gmtime(&timeval)) == NULL)
  fprintf(stderr, "UTC time not available\n");
else
  printf("gmtime is %s\n", asctime(tmval));
  ...

//------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

...

struct tm * tmval;
time_t timeval;

timeval = time(NULL);
if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else
  fprintf( stdout, "Dateline: %02d:%02d:%02d-%04d/%02d/%02d\n",
	 tmval->tm_hour,
	 tmval->tm_min,
	 tmval->tm_sec,
	 tmval->tm_year + 1900,
	 tmval->tm_mon + 1,
	 tmval->tm_mday); ...

//------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>

...
struct tm * tmval;
time_t timeval;
int lg;
char * buffer;

timeval = time(NULL);
if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else {
  // we first check the return of strftime to allocate a buffer of the correct size
  lg = strftime(NULL, SSIZE_MAX, "%H:%M:%S-%Y/%m/%d", tmval );
  if( lg > 0 ){
    buffer = malloc( lg + 1 );
    if( buffer == NULL ){     perror("malloc");
      exit(1);
    }
    strftime(buffer, lg + 1, "%H:%M:%S-%Y/%m/%d", tmval );
    fprintf( stdout, "Dateline: %s\n", buffer );
    free( buffer );
  }
}

...


// @@PLEAC@@_9.0
//------------------------------------------------------------------
#include <stdio.h> // perror(), fprintf()
#include <unistd.h> // stat(), fstat(), lstat()
#include <sys/stat.h> // struct stat

...

struct stat entry;
if( stat("/usr/bin/vi", &entry) < 0 )
  perror("");
if( S_ISREG(entry.st_mode) )
  fprintf( stderr, "file\n" );

...

//------------------------------------------------------------------
#include <stdio.h> // perror(), fprintf()
#include <unistd.h> // stat(), fstat(), lstat()
#include <sys/stat.h> // struct stat

...

struct stat entry;
if( stat("/usr/bin", &entry) < 0 )
  perror("");
if( S_ISDIR( entry.st_mode) )
  fprintf( stderr, "directory\n" );

...

//------------------------------------------------------------------
// we can't access the inode of a file with a stream as parameter
// we need to pass a file descriptor parameter to fstat
#include <stdio.h> // perror(), fprintf()
#include <unistd.h> // stat(), fstat(), lstat()
#include <sys/stat.h> // struct stat
#include <fcntl.h> //open()

...

struct stat entry;
int fd; // file descriptor
FILE * fp;  // stream

if((fd = open("/etc/group", O_RDONLY)) < 0)
  perror("");

if( fstat(fd, &entry) < 0 )
  perror("");
  
if((fp = fdopen(fd, "r" )) == NULL ) // we attach the file descriptor to a stream
  perror("");

...

//------------------------------------------------------------------
#include <stdio.h> // perror()
#include <unistd.h> // stat(), fstat(), lstat()
#include <sys/stat.h> // struct stat
#include <sys/types.h> // off_t

...
  
struct stat entry;

time_t ctime;
off_t size;

if( stat("/usr/bin/vi", &entry) < 0 )
  perror("");

ctime = entry.st_ctime;
size = entry.st_size;
//fprintf( stdout, "ctime: %ld\nsize: %ld\n", ctime, size );
  
...  

//------------------------------------------------------------------
// No equivalent in C ANSI/POSIX/GNU for -T (file is a text file)?
/*
# -s for filesize (test if nonzero)
unless (-s F && -T _) {
  die "$filename doesn't have text in it.\n";
}
*/

//------------------------------------------------------------------
#include <stdio.h>
#include <dirent.h> // struct dirent, opendir(), readdir(), closedir()
#include <sys/types.h> // DIR type

...

DIR * dir;
struct dirent * entry;

dir = opendir("/usr/bin");
if( dir == NULL )
  perror("");
while((entry = readdir(dir)) != NULL)
  fprintf(stdout, "Inside /usr/bin is something called %s\n", entry->d_name);
fprintf(stdout, "\n");
closedir(dir);

...


// @@PLEAC@@_9.10
//------------------------------------------------------------------

//  we use the XPG version of basename which overrides
//  the GNU version (not portable) if libgen.h is included
//  /!\ do not call basename or dirname with a static string (bugs in glibc)

#include <stdio.h> // fprintf()
#include <stdlib.h> // free()
#include <string.h>  // strdup(), strrchr()
#include <libgen.h>  // basename(), dirname()

...
 char * dir, * file, * ext;
char * tmp_dirname, * tmp_file;
char * path = "/usr/lib/libc.a";

tmp_dirname = strdup(path);
tmp_file = strdup(path);
   dir = dirname(tmp_dirname);
file = basename(tmp_file);
ext = strrchr(path, '.'); // extension as everything after the last '.'

fprintf(stdout, "dir is %s, file is %s, ext is %s\n", dir, file, ext);
// dir is /usr/lib, file is libc.a, ext is .a
 free(tmp_file);
free(tmp_dirname);

...

//------------------------------------------------------------------
#include <stdio.h> // fprintf()
#include <stdlib.h> // free()
#include <string.h>  // strdup()
#include <libgen.h>  // basename(), dirname()

...

char * file, * dir, * tmp_file, * tmp_dirname;
char * path = "/usr/lib/libc.a";

tmp_file = strdup( path );
tmp_dirname = strdup( path );
dir = dirname( tmp_dirname );
file = basename( tmp_file );

fprintf( stdout, "dir is %s, file is %s\n", dir, file );
// dir is /usr/lib, file is libc.a
free(tmp_dirname);
free(tmp_file);
 ...

//------------------------------------------------------------------
// no equivalent in C for fileparse() but we can
//  implement a (very basic) similar function

#include <stdio.h> // fprintf()
#include <stdlib.h> // free()
#include <string.h>  // strdup(), strrchr(), strlen()

typedef struct Pathname_ {
  char * dirname;
  char * filename;
  char * extension;
}Pathname;

void fileparse( const char * path, Pathname * split_path) {
  char * tmp_path, * ptr, * extension;

  tmp_path = strdup(path);
 ptr= strrchr( tmp_path, '/');
  *ptr = '\0';
  ptr++;

  // dirname
  split_path->dirname = strdup(tmp_path);
  // filename
  split_path->filename = malloc(strlen(ptr) + 1);
  strcpy(split_path->filename, ptr);

  // extension
  extension = strrchr(path, '.'); // extension as everything
after the last '.'
  split_path->extension = strdup(extension);

  free(tmp_path);
 return;
}

int main( int argc, char * argv[] ) {

  Pathname fparsed;
  char * path = "/usr/lib/libc.a";
 fileparse(path, &fparsed);
 fprintf(stdout, "dir is %s, file is %s, ext is %s\n",
      fparsed.dirname,
      fparsed.filename,
      fparsed.extension);
  // dir is /usr/lib, file is libc.a, ext is .a
 free(fparsed.dirname);
  free(fparsed.filename);
  free(fparsed.extension);

  return 0;
}

//------------------------------------------------------------------
//  we are Unix centric so no equivalent for fileparse_set_fstype("MacOS");

//------------------------------------------------------------------
char * extension(const char * path){
  char * ext;
  ext = strrchr(path, '.');
  if(ext == NULL)
    return NULL;

  return ext;
}

// fprintf(stdout, "ext is %s\n", extension(path));
// ext is .a


// @@PLEAC@@_10.16
//------------------------------------------------------------------
// Nested functions are supported by GNU C as an extension
// See the documentation of your GCC version
int outer( int arg1 ){
  int x = arg1 + 35;
  int inner()
    { return x * 19; } // nested function can access
                       // all the variables of the containing function
                       // that are visible at the point of its definition

  return x + inner();
}
