// -*- c -*-

// @@PLEAC@@_NAME
// @@SKIP@@ C/Posix/GNU


// @@PLEAC@@_WEB
// @@SKIP@@ http://www.gnu.org/software/libc/libc.html


// @@PLEAC@@_2.7
//------------------------------------------------------------------
#include <stdlib.h> // rand() srand()

...

/*
    rand() function is not guaranted to produce random values
*/

int random;
  
// the same value between 0 and RAND_MAX
// for every run
random = rand();

...

//------------------------------------------------------------------
...

float random;

// the same value between 0 and 1.0
// for every run
random = (float) rand() / RAND_MAX;

...

//------------------------------------------------------------------
...

#define N 42

...

int random;

// the same value between 0 and N -1
// for every run
random = (int)( N * (double)rand() / (RAND_MAX + 1.0) );

...

// @@PLEAC@@_2.8
//------------------------------------------------------------------
#include <stdlib.h> // rand() srand()
#include <time.h> // time()

...

int random;

// seeds a new sequence of random number
srand(time(NULL));

// a different value between 0 and RAND_MAX
// for every run
random = rand();

...

// @@PLEAC@@_2.9
//------------------------------------------------------------------
/*
    under Linux /dev/random or /dev/urandom
*/

#include <stdio.h> // FILE *, fopen(), fread(), fclose()

...

FILE * fp;

unsigned int random;

if ((fp = fopen("/dev/random","r")) == NULL) {
  perror("fopen");
  exit(1);
}

fread(&random, sizeof(random), 1, fp);
printf("random number %u from /dev/random\n", random);

fclose(fp);

...

//------------------------------------------------------------------



// @@PLEAC@@_3.0
//------------------------------------------------------------------
#include <stdio.h>
#include <time.h> // time_t, struct tm, localtime()
#include <stdlib.h>
#include <limits.h> // SSIZE_MAX

...

time_t timeval;
struct tm * tmval;

timeval = time(NULL);

if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else
  /* using tm fields : not recommended */
  printf("Today is day %02d of the current year\n",
  tmval->tm_yday);
/* using strftime */
// we first check the return of strftime to allocate a buffer of the correct size
  lg = strftime(NULL, SSIZE_MAX, "%j", tmval);
  if( lg > 0 ){
    buffer = malloc( lg + 1 );
    if( buffer == NULL ){          perror("malloc");
      exit(1);
    }
    strftime(buffer, lg + 1, "%j", tmval );
    fprintf( stdout, "Today is day %s of the current year\n", buffer );
    free( buffer );
  }

...


// @@PLEAC@@_3.1
//------------------------------------------------------------------
#include <stdio.h>
#include <time.h> // time_t, struct tm, localtime()

...

time_t timeval;
struct tm * tmval;

timeval = time(NULL);

if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else
  printf("The current date is %04d %02d %02d\n",
	 tmval->tm_year + 1900,
	 tmval->tm_mon + 1,
	 tmval->tm_mday); 
    
...


//------------------------------------------------------------------
#include <stdio.h>
#include <sys/time.h> // gettimeofday(), struct timeval, struct timezone
#include <time.h> // ctime()

...
  
time_t timer;
struct timeval timev;

// time()-like
gettimeofday(&timev, NULL);
timer = timev.tv_sec;

// ctime() is equivalent to asctime(localtime(date))
printf("today is %s\n", ctime(&timer));
// today is Fri Jun 10 22:09:46 2005
  
...

//------------------------------------------------------------------
#include <stdio.h>
#include <time.h> // time_t, struct tm, localtime() strftime()
#include <stdlib.h>
#include <limits.h> // SSIZE_MAX

...

time_t timeval;
struct tm * tmval;
int lg;
char * buffer;

timeval = time(NULL);

if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else{
   // we first check the return of strftime to allocate a buffer of the correct size
  lg = strftime(NULL, SSIZE_MAX, "%Y-%m-%d", tmval );
  if( lg > 0 ){
    buffer = malloc( lg + 1 );
    if( buffer == NULL ){      
      perror("malloc");
      exit(1);
    }
    strftime(buffer, lg + 1, "%Y-%m-%d", tmval );
    fprintf( stdout, "The courant date is %s\n", buffer );
    free( buffer );
  }
}

...


// @@PLEAC@@_3.3
//------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

...

struct tm * tmval;
time_t timeval;

timeval = time(NULL);
if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else
  printf("localtime is %s\n", asctime(tmval));
  ...

//------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h> ...
  struct tm * tmval;
time_t timeval;

timeval = time(NULL);
if((tmval = gmtime(&timeval)) == NULL)
  fprintf(stderr, "UTC time not available\n");
else
  printf("gmtime is %s\n", asctime(tmval));
  ...

//------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

...

struct tm * tmval;
time_t timeval;

timeval = time(NULL);
if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else
  fprintf( stdout, "Dateline: %02d:%02d:%02d-%04d/%02d/%02d\n",
	 tmval->tm_hour,
	 tmval->tm_min,
	 tmval->tm_sec,
	 tmval->tm_year + 1900,
	 tmval->tm_mon + 1,
	 tmval->tm_mday); ...

//------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>

...
struct tm * tmval;
time_t timeval;
int lg;
char * buffer;

timeval = time(NULL);
if((tmval = localtime(&timeval)) == NULL)
  fprintf(stderr, "local time not available\n");
else {
  // we first check the return of strftime to allocate a buffer of the correct size
  lg = strftime(NULL, SSIZE_MAX, "%H:%M:%S-%Y/%m/%d", tmval );
  if( lg > 0 ){
    buffer = malloc( lg + 1 );
    if( buffer == NULL ){     perror("malloc");
      exit(1);
    }
    strftime(buffer, lg + 1, "%H:%M:%S-%Y/%m/%d", tmval );
    fprintf( stdout, "Dateline: %s\n", buffer );
    free( buffer );
  }
}

...


// @@PLEAC@@_5.0
//------------------------------------------------------------------
#define _GNU_SOURCE

#include <search.h> // hcreate_r() hdestroy_r() struct hsearch_data
#include <string.h>// memset()
#include <stdio.h>// perror()
#include <stdlib.h> //exit()

#define TAB 4

...

struct hsearch_data hash;
size_t max_element = 42; // of elements in search table

...

char * food[] = { "Apple",
		  "Banana",
		  "Lemon",
		  "Carrot"
};
char * color[] = { "red",
		   "yellow",
		   "yellow",
		   "orange"
};

// we create the hash
memset( &hash, 0, sizeof(hash) );
if( hcreate_r(max_element, &hash) == 0 ) {
  perror("hcreate_r");
  exit(1);
}

/*
  adding some elements
*/
  
// we destroy the hash
hdestroy_r( &hash );
  
...

// @@PLEAC@@_5.1
//------------------------------------------------------------------

...

void hash_add_element(char * elmt_key,
		      char * elmt_data,
		      struct hsearch_data * table) {

  ENTRY item;
  ENTRY * ret;
    
  item.key = strdup(elmt_key);
  item.data = strdup(elmt_data);

  if( hsearch_r(item, ENTER, &ret, table) == 0 ) {
    perror("hsearch_r");
    exit(1);
  }
  
  return;
}

...

ENTRY entry;
ENTRY * found;
 
int i;

/*
  hash creation
*/

hash_add_element(food[0], color[0], &hash);
hash_add_element(food[1], color[1], &hash);
hash_add_element(food[2], color[2], &hash);
hash_add_element(food[3], color[3], &hash);

fprintf(stdout, "Known foods:\n");
for( i = 0; i < TAB; i++ ) {
  entry.key = food[i];
  hsearch_r( entry, FIND, &found, &hash );
  fprintf(stdout, "%s\n", found->key);

  // It is the responsibility of the program code
  // to free the elements contained in the hashing table
  free(found->key);
  free(found->data);
}

/*
  hash destruction
*/

...

# Known foods:
# Apple
# Banana
# Lemon
# Carrot

// @@PLEAC@@_5.2
//------------------------------------------------------------------

...

entry.key = "Martini";

if( hsearch_r( entry, FIND, &found, &hash ) != 0 )
  // Martini exists
else
  // it doesn't

...

// @@PLEAC@@_5.3
//------------------------------------------------------------------

// we can't delete an element with the hashing table
// provided by the GNU C library


// @@PLEAC@@_7.4
//------------------------------------------------------------------
#include <stdio.h>
#include <string.h> // strerror()
#include <errno.h> // errno

...

FILE * fp;

if( (fp = fopen(filename, mode)) == NULL )
  fprintf( stderr, "Couldn't open %s for reading : %s\n",
           filename,
           strerror(errno) );

...

// @@PLEAC@@_7.5
//------------------------------------------------------------------
#include <stdio.h> // tmpfile()

...

FILE * file;

// /!\ the temporary filename isn't accessible
file = tmpfile(); 

...

//------------------------------------------------------------------
#include <stdio.h> // remove()
#include <stdlib.h> // mkstemp()

...

int fd;
char template[20];

strcpy( template, "tmp/XXXXXX" );
fd = mkstemp( template );

if( fd < 0 ) {
  perror( mkstemp );
  exit( 1 );
}

remove( template );

// now go on to use the file ...

...

//------------------------------------------------------------------
#include <stdio.h> // tempnam()
#include <stdlib.h>
#include <unistd.h> // unlink()
#include <fcntl.h> // open()
#include <sys/stat.h> 
#include <sys/types.h>

...

char * tmpname = NULL;
int fd;

while(1) {
  tmpname = tempnam( NULL, NULL );
  if( tmpname == NULL ) {
    perror( "tempname" );
    exit(1);
  }

  // is another process creating a temporary file at the same moment?
  // we don't know.
  // => we have to ensure an exclusive open
  fd = open( tmpname, O_CREAT | O_EXCL | O_RDWR, 0600 );

  // temporary file will be destroy on close() call
  unlink( tmpname );

  free( tmpname );
  if( fd < 0 )
    perror( "open" );
  else
    break;
}

// now go on to use the file ...

...


// @@PLEAC@@_8.2
//------------------------------------------------------------------
/*
  using external program : wc -l
*/
#include <stdio.h>
#include <stdlib.h> // system(), exit(); malloc(), free()
#include <string.h> // strlen()
#include <errno.h> // errno

...

char file[100] = argv[1]; // a pathname
char * command;

// we format the shell command
command = malloc( (strlen("wc -l ") + 1) + (strlen(file) + 1) );
sprintf(command, "%s %s", "wc -l", argv[1]);

// bad solution

system(command);

// good solution : using popen() instead of system()

FILE * message;
if( (message = popen(command, "r")) == NULL ) {
  fprintf(stderr, "error popen %d\n", errno);
  exit(1);
}

char wc_output[100];
fgets(wc_output, sizeof wc_output, message);
fprintf(stdout, "%s", wc_output);

pclose(message);
  
free(command);

...

//------------------------------------------------------------------
/*
    using standard C library
*/
#include <stdio.h>

...

char file[100] = argv[1]; // a pathname
FILE * fp;

if( (fp = fopen( file, "r" )) == NULL ) {
  perror("fopen");
  exit(1);
}

int line = 0;
char ch;

while ( (ch = getc(fp)) != EOF )
 if (ch == '\n')
   line++;

fprintf(stdout, "number of lines : %d\n", line );
fclose(fp);

...

//------------------------------------------------------------------
/*
    using system calls
    /!\ fast implementation, the whole file is in memory
*/
#include <stdio.h>
#include <stdlib.h>

#include <fcntl.h> // open()
#include <sys/stat.h> 
#include <sys/types.h>
#include <unistd.h> // lseek(), close()

...

char file[100] = argv[1]; // a pathname
int fd;

fd = open(file, O_RDONLY);

size_t size;

size = lseek(fd, 0, SEEK_END ); // size of the buffer
  
char * buffer;
buffer = malloc(size);
  
lseek(fd, 0, SEEK_SET); // back to the beginning of the file

if( (read(fd, buffer, size)) != size ) {
  perror("read");
  exit(1);
}
  
close(fd);

int line = 0;

int i;
for( i = 0; i < size; i++ ) {
  if(buffer[i] == '\n')
    line++;
}

free(buffer);
  
fprintf(stdout, "number of lines : %d\n", line );

...


// @@PLEAC@@_9.0
//------------------------------------------------------------------
#include <stdio.h> // perror(), fprintf()
#include <unistd.h> // stat(), fstat(), lstat()
#include <sys/stat.h> // struct stat

...

struct stat entry;
if( stat("/usr/bin/vi", &entry) < 0 )
  perror("");
if( S_ISREG(entry.st_mode) )
  fprintf( stderr, "file\n" );

...

//------------------------------------------------------------------
#include <stdio.h> // perror(), fprintf()
#include <unistd.h> // stat(), fstat(), lstat()
#include <sys/stat.h> // struct stat

...

struct stat entry;
if( stat("/usr/bin", &entry) < 0 )
  perror("");
if( S_ISDIR( entry.st_mode) )
  fprintf( stderr, "directory\n" );

...

//------------------------------------------------------------------
// we can't access the inode of a file with a stream as parameter
// we need to pass a file descriptor parameter to fstat
#include <stdio.h> // perror(), fprintf()
#include <unistd.h> // stat(), fstat(), lstat()
#include <sys/stat.h> // struct stat
#include <fcntl.h> //open()

...

struct stat entry;
int fd; // file descriptor
FILE * fp;  // stream

if((fd = open("/etc/group", O_RDONLY)) < 0)
  perror("");

if( fstat(fd, &entry) < 0 )
  perror("");
  
if((fp = fdopen(fd, "r" )) == NULL ) // we attach the file descriptor to a stream
  perror("");

...

//------------------------------------------------------------------
#include <stdio.h> // perror()
#include <unistd.h> // stat(), fstat(), lstat()
#include <sys/stat.h> // struct stat
#include <sys/types.h> // off_t

...
  
struct stat entry;

time_t ctime;
off_t size;

if( stat("/usr/bin/vi", &entry) < 0 )
  perror("");

ctime = entry.st_ctime;
size = entry.st_size;
//fprintf( stdout, "ctime: %ld\nsize: %ld\n", ctime, size );
  
...  

//------------------------------------------------------------------
// No equivalent in C ANSI/POSIX/GNU for -T (file is a text file)?
/*
# -s for filesize (test if nonzero)
unless (-s F && -T _) {
  die "$filename doesn't have text in it.\n";
}
*/

//------------------------------------------------------------------
#include <stdio.h>
#include <dirent.h> // struct dirent, opendir(), readdir(), closedir()
#include <sys/types.h> // DIR type

...

DIR * dir;
struct dirent * entry;

dir = opendir("/usr/bin");
if( dir == NULL )
  perror("");
while((entry = readdir(dir)) != NULL)
  fprintf(stdout, "Inside /usr/bin is something called %s\n", entry->d_name);
fprintf(stdout, "\n");
closedir(dir);

...


// @@PLEAC@@_9.10
//------------------------------------------------------------------

//  we use the XPG version of basename which overrides
//  the GNU version (not portable) if libgen.h is included
//  /!\ do not call basename or dirname with a static string (bugs in glibc)

#include <stdio.h> // fprintf()
#include <stdlib.h> // free()
#include <string.h>  // strdup(), strrchr()
#include <libgen.h>  // basename(), dirname()

...
 char * dir, * file, * ext;
char * tmp_dirname, * tmp_file;
char * path = "/usr/lib/libc.a";

tmp_dirname = strdup(path);
tmp_file = strdup(path);
   dir = dirname(tmp_dirname);
file = basename(tmp_file);
ext = strrchr(path, '.'); // extension as everything after the last '.'

fprintf(stdout, "dir is %s, file is %s, ext is %s\n", dir, file, ext);
// dir is /usr/lib, file is libc.a, ext is .a
 free(tmp_file);
free(tmp_dirname);

...

//------------------------------------------------------------------
#include <stdio.h> // fprintf()
#include <stdlib.h> // free()
#include <string.h>  // strdup()
#include <libgen.h>  // basename(), dirname()

...

char * file, * dir, * tmp_file, * tmp_dirname;
char * path = "/usr/lib/libc.a";

tmp_file = strdup( path );
tmp_dirname = strdup( path );
dir = dirname( tmp_dirname );
file = basename( tmp_file );

fprintf( stdout, "dir is %s, file is %s\n", dir, file );
// dir is /usr/lib, file is libc.a
free(tmp_dirname);
free(tmp_file);
 ...

//------------------------------------------------------------------
// no equivalent in C for fileparse() but we can
//  implement a (very basic) similar function

#include <stdio.h> // fprintf()
#include <stdlib.h> // free()
#include <string.h>  // strdup(), strrchr(), strlen()

typedef struct Pathname_ {
  char * dirname;
  char * filename;
  char * extension;
}Pathname;

void fileparse( const char * path, Pathname * split_path) {
  char * tmp_path, * ptr, * extension;

  tmp_path = strdup(path);
 ptr= strrchr( tmp_path, '/');
  *ptr = '\0';
  ptr++;

  // dirname
  split_path->dirname = strdup(tmp_path);
  // filename
  split_path->filename = malloc(strlen(ptr) + 1);
  strcpy(split_path->filename, ptr);

  // extension
  extension = strrchr(path, '.'); // extension as everything
after the last '.'
  split_path->extension = strdup(extension);

  free(tmp_path);
 return;
}

int main( int argc, char * argv[] ) {

  Pathname fparsed;
  char * path = "/usr/lib/libc.a";
 fileparse(path, &fparsed);
 fprintf(stdout, "dir is %s, file is %s, ext is %s\n",
      fparsed.dirname,
      fparsed.filename,
      fparsed.extension);
  // dir is /usr/lib, file is libc.a, ext is .a
 free(fparsed.dirname);
  free(fparsed.filename);
  free(fparsed.extension);

  return 0;
}

//------------------------------------------------------------------
//  we are Unix centric so no equivalent for fileparse_set_fstype("MacOS");

//------------------------------------------------------------------
char * extension(const char * path){
  char * ext;
  ext = strrchr(path, '.');
  if(ext == NULL)
    return NULL;

  return ext;
}

// fprintf(stdout, "ext is %s\n", extension(path));
// ext is .a


// @@PLEAC@@_10.16
//------------------------------------------------------------------
// Nested functions are supported by GNU C as an extension
// See the documentation of your GCC version
int outer( int arg1 ){
  int x = arg1 + 35;
  int inner()
    { return x * 19; } // nested function can access
                       // all the variables of the containing function
                       // that are visible at the point of its definition

  return x + inner();
}


// @@PLEAC@@_11.15
//------------------------------------------------------------------
/* binary tree demo program */
#define _GNU_SOURCE // getline(), tdestroy()

#include <stdio.h>
#include <search.h> // tsearch(), tfind(), tdelete(), tdestroy(); twalk()
#include <stdlib.h> // rand(), malloc(), free()

static VISIT walk_type;

int compar_int( const void * elm1, const void * elm2) {
  return ( *((int *) elm1) - *((int *) elm2) );
}

void walk( const void * node, const VISIT method, const int level) {
  int * data;
  
  data = *(int **)node;
  
  if(method == walk_type)
    fprintf( stdout, "%d ", *data );
  if( method == leaf )
    fprintf( stdout, "%d ", *data );
  return;
}

void free_elmt( void * node ){
  free( node );

  return;
}

int main( void ) {

  void * root = NULL;
    
  int i, *ptr;

  // first generate 20 random inserts
  for( i = 0; i < 20; i++ ) {
    ptr = malloc(sizeof(int));
    *ptr = (int)( 1000 * (double)rand() / (RAND_MAX + 1.0) );

    if( tsearch( ptr, &root, compar_int ) == NULL ) {
      perror("tsearch");
      exit(1);
    }
  }

  // now dump out the tree all three ways
  fprintf(stdout, "Pre order\n");
  walk_type = preorder;
  twalk( root, walk );
  printf("\n");

  fprintf(stdout, "In order\n");
  walk_type = postorder; // /!\  postorder is rather confusing
  twalk( root, walk );
  printf("\n");

  fprintf(stdout, "Post order\n");
  walk_type = endorder;
  twalk( root, walk );
  printf("\n");

  // prompt until EOF
  char * istr;
  size_t size;
  ssize_t ret;

  while(1) {
    fprintf(stdout, "Search? : ");
    size = 0;
    istr = NULL;
    ret = getline( &istr, &size, stdin );
    if( ret == -1 )
      break;
    sscanf( istr, "%d", &i );
    free(istr);

    if( tfind( &i, &root, compar_int ) == NULL )
      fprintf( stdout, "No %d in tree\n", i );
    else
      fprintf( stdout, "Found %d\n", i );
  }

  tdestroy( root, free_elmt );
  
  return 0;
}


// @@PLEAC@@_15.10
//------------------------------------------------------------------
// /!\ this function is deprecated
#include <unistd.h> // getpass()

...

char * password = getpass( "password : " );

...

//------------------------------------------------------------------
// gcc -Wall -o checkuser checkuser.c -lcrypt
#define _GNU_SOURCE

#include <stdio.h> // gnu version of getline()
#include <stdlib.h> // at_exit()
#include <string.h>
#include <unistd.h> // getlogin()
#include <termios.h> // struct termios, tcgetattr(), tcsetattr()
#include <pwd.h> // struct passwd, fgetpwent()
#include <crypt.h>  // crypt() 

static struct termios stored_settings;

void restore_term_setting( void ) {
  /*
    restore terminal setting
  */
  tcsetattr( 0, TCSANOW, &stored_settings);
}

int main( void ) {

  struct termios new_settings;
  char * cryptpw; // our encrypted password
  char * my_login = getlogin(); // our login

  /*
    we ask for password
  */
  fprintf( stdout, "Password : " );
  
  /*
    we disable echo input
  */
  
  // we first set an exit handler to restore terminal setting
  // * if something go wrong
  // * on the final return
  if( atexit( restore_term_setting ) != 0 ) {
    fprintf( stderr, "error on atexit\n" );
    exit(1);
  }

  
  tcgetattr( 0, &stored_settings ); // save terminal setting

  new_settings = stored_settings;
  new_settings.c_lflag &= (~ECHO); // disable echo input characters
  tcsetattr( 0, TCSANOW, &new_settings );

  /*
    we get the plain password
  */
  char * passwd = NULL;
  size_t size = 0;
  ssize_t ret;

  if( (ret = getline( &passwd, &size, stdin )) == -1 )
    exit(1);

  // we "chomp" the plain password
  char *p = strchr( passwd, '\n' );
  *p = 0;

  /*
    we get our login encrypted password
    /!\ most of the Linux system use shadow password
    we have to use /etc/shadow instead of /etc/passwd
    /!\ we have to be root in order to read /etc/shadow
  */
  FILE * fp;

  if( (fp = fopen( "/etc/shadow", "r" )) == NULL ) {
    perror("fopen");
    exit(1);
  }
  
  struct passwd * shadow_pwd_ent;
  cryptpw = NULL;
  
  while( (shadow_pwd_ent = fgetpwent(fp)) != NULL ) {
    // we search our login in the entry returned
    if( strcmp( my_login, shadow_pwd_ent->pw_name ) == 0 ) {
      cryptpw = shadow_pwd_ent->pw_passwd;
      break;
    }
  }

  fclose(fp);
    
  /*
    password matching
  */
  int match = strcmp( crypt(passwd, cryptpw), cryptpw );
    
  // we hurry to free the plain version of the password
  free(passwd), passwd = NULL;
  
  puts( "" );
  if( match == 0 )
    printf( "Welcome, %s\n", my_login );
  else 
    printf( "You are not %s\n", my_login );
  
  return 0;
}


// @@PLEAC@@_17.8
//------------------------------------------------------------------
#include <stdio.h>
#include <unistd.h> // gethostname()
#include <stdlib.h> // malloc(), realloc(), free()
#include <errno.h> // errno

...

char * hostname = NULL;
size_t sizebuf = 8;

hostname = malloc(size);
  

while( gethostname(hostname, sizebuf ) != 0 ) {
  if( errno != ENAMETOOLONG ) {
    perror("gethostname");
    exit(1);
  }
  // the buffer size is too small
  sizebuf += 8;
  hostname = realloc(hostname, sizebuf);
}
  
printf("my hostname : %s\n", hostname);

free(hostname);
  
...

//------------------------------------------------------------------
#include <stdio.h>
#include <sys/utsname.h> // struct utsname, uname()

...

struct utsname my_utsname;

uname( &my_utsname );

printf("my hostname : %s\n", my_utsname.nodename);

...

//------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

#include <netdb.h> // gethostbyname(), gethostbyaddr(), h_errno, herror()
#include <netinet/in.h> // struct in_addr
#include <arpa/inet.h> // inet_ntoa()

...

// we don't handle IPV6 for more simplicity
struct in_addr address;
struct in_addr * ip; 
struct hostent * host;
int i;

/*
    gethostbyname()
*/
char hostname[] = "a_valid_hostname";

if( (host = gethostbyname(hostname)) == NULL ) {
  herror("gethostbyname");
  exit(1);
}

for( i = 0; host->h_addr_list[i] != NULL; i++ ) {
  ip = ( struct in_addr *)(host->h_addr_list[i]);
  printf("address for %s : %s\n", hostname ,inet_ntoa(*ip));
} 

/*
    gethostbyaddr()
*/
char addr[] = "127.0.0.1";

// we verify the IPV4 address
if( inet_aton(addr, &address) == 0 ) {
  fprintf(stderr, "invalid address\n");
  return 1;
}

if( (host = gethostbyaddr( (char *)&address, sizeof(struct in_addr), AF_INET )) == NULL ) {
  herror("gethostbyaddr");
  exit(1);
}

printf("hostname for %s : %s\n", addr, host->h_name );
  
...
