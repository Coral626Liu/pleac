<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=latin1">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span class="c1">;;; -*- scheme -*-</span>

<span class="c1">;;; @@PLEAC@@_NAME</span>
<span class="c1">;;; @@SKIP@@ Guile 1.8</span>

<span class="c1">;;; @@PLEAC@@_WEB</span>
<span class="c1">;;; @@SKIP@@ http://www.gnu.org/software/guile/</span>

<span class="c1">;;; @@PLEAC@@_INTRO</span>
<span class="c1">;;; @@SKIP@@ Sections 1 - 3, and 7 - 9, largely completed using Guile 1.5; subsequent additions use Guile 1.8.</span>

<span class="c1">;;; @@PLEAC@@_APPENDIX</span>
<span class="c1">;;; @@SKIP@@ General-purpose, custom functions that might be used in several sections, appear here</span>

<span class="c1">;; Helper which aims to reduce code clutter by:</span>
<span class="c1">;; * Replacing the oft-used, &#39;(display item) (newline)&#39; combination</span>
<span class="c1">;; * Avoiding overuse of &#39;(string-append)&#39; for simple output tasks</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print</span> <span class="nv">item</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">all-item</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">rest</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot; &quot;</span><span class="p">))</span>
      <span class="nv">all-item</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">;; Slightly modified version of &#39;(qx)&#39; from Chapter 4</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">popen</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">drain-output</span> <span class="nv">port</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">chars</span> <span class="o">&#39;</span><span class="p">())</span>
             <span class="p">(</span><span class="nf">next</span> <span class="p">(</span><span class="nb">read-char </span><span class="nv">port</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">next</span><span class="p">)</span>
        <span class="c1">; Modified to not return last &#39;line&#39; with newline</span>
        <span class="p">(</span><span class="nb">list-&gt;string </span><span class="p">(</span><span class="nf">reverse!</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">chars</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">next</span> <span class="nv">chars</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">read-char </span><span class="nv">port</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">qx</span> <span class="nv">pipeline</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">pipe</span> <span class="p">(</span><span class="nf">open-input-pipe</span> <span class="nv">pipeline</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">output</span> <span class="p">(</span><span class="nf">drain-output</span> <span class="nv">pipe</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">close-pipe</span> <span class="nv">pipe</span><span class="p">)</span>
    <span class="nv">output</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">;; @@PLEAC@@_1.0</span>
<span class="p">(</span><span class="k">define </span><span class="nv">string</span> <span class="s">&quot;\\n&quot;</span><span class="p">)</span>                    <span class="c1">; two characters, \ and an n</span>
<span class="p">(</span><span class="k">define </span><span class="nv">string</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span>                     <span class="c1">; a &quot;newline&quot; character</span>
<span class="p">(</span><span class="k">define </span><span class="nv">string</span> <span class="s">&quot;Jon \&quot;Maddog\&quot; Orwant&quot;</span><span class="p">)</span>  <span class="c1">; literal double quotes</span>
<span class="p">(</span><span class="k">define </span><span class="nv">string</span> <span class="s">&quot;Jon &#39;Maddog&#39; Orwant&quot;</span><span class="p">)</span>    <span class="c1">; literal single quotes</span>

<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="s">&quot;This is a multiline here document</span>
<span class="s">terminated by a closing double quote&quot;</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_1.1</span>
<span class="c1">;; Use substring</span>

<span class="p">(</span><span class="nb">substring </span><span class="nv">str</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
<span class="p">(</span><span class="nb">substring </span><span class="nv">str</span> <span class="nv">start</span><span class="p">)</span>

<span class="c1">;; You can fill portions of a string with another string</span>

<span class="p">(</span><span class="nf">substring-move-right!</span> <span class="nv">str</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">newstring</span> <span class="nv">newstart</span><span class="p">)</span>
<span class="p">(</span><span class="nf">substring-move-left!</span> <span class="nv">str</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">newstring</span> <span class="nv">newstart</span><span class="p">)</span>

<span class="c1">;; Guile has a separate character type, and you can treat strings as a</span>
<span class="c1">;; character array.</span>

<span class="p">(</span><span class="nb">string-ref </span><span class="nv">str</span> <span class="nv">pos</span><span class="p">)</span>
<span class="p">(</span><span class="nb">string-set! </span><span class="nv">str</span> <span class="nv">pos</span> <span class="nv">char</span><span class="p">)</span>
<span class="p">(</span><span class="nb">string-fill! </span><span class="nv">str</span> <span class="nv">char</span><span class="p">)</span>
<span class="p">(</span><span class="nf">substring-fill!</span> <span class="nv">str</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">char</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">s</span> <span class="s">&quot;This is what you have&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">first</span> <span class="p">(</span><span class="nb">substring </span><span class="nv">s</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>                     <span class="c1">; &quot;T&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">start</span> <span class="p">(</span><span class="nb">substring </span><span class="nv">s</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">))</span>                     <span class="c1">; &quot;is&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">rest</span>  <span class="p">(</span><span class="nb">substring </span><span class="nv">s</span> <span class="mi">13</span><span class="p">))</span>                      <span class="c1">; &quot;you have&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">last</span>  <span class="p">(</span><span class="nb">substring </span><span class="nv">s</span> <span class="p">(</span><span class="mi">1</span><span class="nv">-</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">s</span><span class="p">))))</span>  <span class="c1">; &quot;e&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">end</span>   <span class="p">(</span><span class="nb">substring </span><span class="nv">s</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">string-length </span><span class="nv">s</span><span class="p">)</span> <span class="mi">4</span><span class="p">)))</span> <span class="c1">; &quot;have&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">piece</span> <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">s</span><span class="p">)))</span>
                <span class="p">(</span><span class="nb">substring </span><span class="nv">s</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">5</span><span class="p">))))</span>  <span class="c1">; &quot;you&quot;</span>


<span class="c1">;;; Or use the string library SRFI-13</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">s</span> <span class="s">&quot;This is what you have&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">first</span> <span class="p">(</span><span class="nf">string-take</span> <span class="nv">s</span> <span class="mi">1</span><span class="p">))</span>                     <span class="c1">; &quot;T&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">start</span> <span class="p">(</span><span class="nf">xsubstring</span> <span class="nv">s</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">))</span>                    <span class="c1">; &quot;is&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">rest</span>  <span class="p">(</span><span class="nf">xsubstring</span> <span class="nv">s</span> <span class="mi">13</span> <span class="mi">-1</span><span class="p">))</span>                  <span class="c1">; &quot;you have&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">last</span>  <span class="p">(</span><span class="nf">string-take-right</span> <span class="nv">s</span> <span class="mi">1</span><span class="p">))</span>               <span class="c1">; &quot;e&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">end</span>   <span class="p">(</span><span class="nf">string-take-right</span> <span class="nv">s</span> <span class="mi">4</span><span class="p">))</span>               <span class="c1">; &quot;have&quot;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">piece</span> <span class="p">(</span><span class="nf">xsubstring</span> <span class="nv">s</span> <span class="mi">-8</span> <span class="mi">-5</span><span class="p">))</span>                  <span class="c1">; &quot;you&quot;</span>

<span class="c1">;; Mutation of different sized strings is not allowed.  You have to</span>
<span class="c1">;; use set! to change the variable.</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">s</span> <span class="p">(</span><span class="nf">string-replace</span> <span class="nv">s</span> <span class="s">&quot;wasn&#39;t&quot;</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">))</span>
<span class="c1">;; This wasn&#39;t what you have</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">s</span> <span class="p">(</span><span class="nf">string-replace</span> <span class="nv">s</span> <span class="s">&quot;ondrous&quot;</span> <span class="mi">13</span> <span class="mi">25</span><span class="p">))</span>
<span class="c1">;; This wasn&#39;t wondrous</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">s</span> <span class="p">(</span><span class="nf">string-take-right</span> <span class="nv">s</span> <span class="p">(</span><span class="mi">1</span><span class="nv">-</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">s</span><span class="p">))))</span>
<span class="c1">;; his wasn&#39;t wondrous</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">s</span> <span class="p">(</span><span class="nf">string-take</span> <span class="nv">s</span> <span class="mi">9</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_1.2</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="k">or </span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">defined?</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nf">defined?</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_1.3</span>
<span class="c1">;; This doesn&#39;t really make sense in Scheme... temporary variables are</span>
<span class="c1">;; a natural construct and cheap.  If you want to swap variables in a</span>
<span class="c1">;; block without introducing any new variable names, you can use let:</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">b</span> <span class="nv">a</span><span class="p">))</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">alpha</span> <span class="nv">beta</span><span class="p">)</span> <span class="p">(</span><span class="nf">beta</span> <span class="nv">production</span><span class="p">)</span> <span class="p">(</span><span class="nf">production</span> <span class="nv">alpha</span><span class="p">))</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; @@PLEAC@@_1.4</span>
<span class="p">(</span><span class="k">define </span><span class="nv">num</span> <span class="p">(</span><span class="nb">char-&gt;integer </span><span class="nv">char</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">char</span> <span class="p">(</span><span class="nb">integer-&gt;char </span><span class="nv">num</span><span class="p">))</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">str</span> <span class="s">&quot;sample&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">string-join</span>
            <span class="p">(</span><span class="nb">map </span><span class="nv">number-&gt;string</span>
                 <span class="p">(</span><span class="nb">map </span><span class="nv">char-&gt;integer</span> <span class="p">(</span><span class="nb">string-&gt;list </span><span class="nv">str</span><span class="p">)))</span> <span class="s">&quot; &quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">lst</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">115</span> <span class="mi">97</span> <span class="mi">109</span> <span class="mi">112</span> <span class="mi">108</span> <span class="mi">101</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">list-&gt;string </span><span class="p">(</span><span class="nb">map </span><span class="nv">integer-&gt;char</span> <span class="nv">lst</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">next</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span><span class="p">)</span> <span class="p">(</span><span class="nb">integer-&gt;char </span><span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="p">(</span><span class="nb">char-&gt;integer </span><span class="nv">c</span><span class="p">))))))</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">hal</span> <span class="s">&quot;HAL&quot;</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">ibm</span> <span class="p">(</span><span class="nb">list-&gt;string </span><span class="p">(</span><span class="nb">map </span><span class="nv">next</span> <span class="p">(</span><span class="nb">string-&gt;list </span><span class="nv">hal</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">ibm</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">newline</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_1.5</span>
<span class="c1">;; Convert the string to a list of characters</span>
<span class="p">(</span><span class="nb">map </span><span class="nv">proc</span>
     <span class="p">(</span><span class="nb">string-&gt;list </span><span class="nv">str</span><span class="p">))</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;unique chars are: ~A\n&quot;</span>
        <span class="p">(</span><span class="nb">apply </span><span class="nv">string</span> <span class="p">(</span><span class="nf">sort</span> <span class="p">(</span><span class="nf">delete-duplicates</span>
                             <span class="p">(</span><span class="nb">string-&gt;list </span><span class="s">&quot;an apple a day&quot;</span><span class="p">))</span> <span class="nv">char&lt;?</span><span class="p">)))</span>

<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">str</span> <span class="s">&quot;an apple a day&quot;</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">+</span> <span class="p">(</span><span class="nb">map </span><span class="nv">char-&gt;integer</span> <span class="p">(</span><span class="nb">string-&gt;list </span><span class="nv">str</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;sum is ~A\n&quot;</span> <span class="nv">sum</span><span class="p">))</span>

<span class="c1">;;; or use string-fold/string-map/string-for-each from SRFI-13</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>

<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">str</span> <span class="s">&quot;an apple a day&quot;</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nf">string-fold</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span> <span class="nv">acc</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">acc</span> <span class="p">(</span><span class="nb">char-&gt;integer </span><span class="nv">c</span><span class="p">)))</span>
                         <span class="mi">0</span> <span class="nv">str</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;sum is ~A\n&quot;</span> <span class="nv">sum</span><span class="p">))</span>

<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>
<span class="c1">;; sum - compute 16-bit checksum of all input files</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">checksum</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span> <span class="ss">&#39;concat</span><span class="p">))</span> <span class="p">(</span><span class="nf">sum</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A ~A\n&quot;</span> <span class="nv">sum</span> <span class="p">(</span><span class="nf">port-filename</span> <span class="nv">p</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">line-sum</span> <span class="p">(</span><span class="nf">string-fold</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span> <span class="nv">acc</span><span class="p">)</span>
                                     <span class="p">(</span><span class="nb">+ </span><span class="nv">acc</span> <span class="p">(</span><span class="nb">char-&gt;integer </span><span class="nv">c</span><span class="p">)))</span>
                                   <span class="mi">0</span> <span class="nv">line</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span> <span class="ss">&#39;concat</span><span class="p">)</span> <span class="p">(</span><span class="nb">modulo </span><span class="p">(</span><span class="nb">+ </span><span class="nv">sum</span> <span class="nv">line-sum</span><span class="p">)</span>
                                            <span class="p">(</span><span class="mi">1</span><span class="nv">-</span> <span class="p">(</span><span class="nb">expt </span><span class="mi">2</span> <span class="mi">16</span><span class="p">))))))))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">checksum</span> <span class="p">(</span><span class="nf">current-input-port</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">call-with-input-file </span><span class="nv">f</span> <span class="nv">checksum</span><span class="p">))</span> <span class="nv">args</span><span class="p">)))</span>

<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>
<span class="c1">;; slowcat - emulate a  s l o w  line printer</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regex</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-2</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define delay </span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">and-let*</span> <span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="nb">pair? </span><span class="nv">args</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">m</span> <span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;^-([0-9]+)$&quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">set! delay </span><span class="p">(</span><span class="nb">string-&gt;number </span><span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">args</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">slowcat</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span> <span class="ss">&#39;concat</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">string-for-each</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">usleep</span> <span class="p">(</span><span class="nb">* </span><span class="mi">5</span> <span class="nv">delay</span><span class="p">)))</span> <span class="nv">line</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span> <span class="ss">&#39;concat</span><span class="p">))))))</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">slowcat</span> <span class="p">(</span><span class="nf">current-input-port</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">call-with-input-file </span><span class="nv">f</span> <span class="nv">slowcat</span><span class="p">))</span> <span class="nv">args</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_1.6</span>
<span class="p">(</span><span class="k">define </span><span class="nv">revbytes</span> <span class="p">(</span><span class="nb">list-&gt;string </span><span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nb">string-&gt;list </span><span class="nv">str</span><span class="p">))))</span>

<span class="c1">;;; Or from SRFI-13</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">revbytes</span> <span class="p">(</span><span class="nf">string-reverse</span> <span class="nv">str</span><span class="p">))</span>
<span class="p">(</span><span class="nf">string-reverse!</span> <span class="nv">str</span><span class="p">)</span> <span class="c1">; modifies in place</span>

<span class="p">(</span><span class="k">define </span><span class="nv">revwords</span> <span class="p">(</span><span class="nf">string-join</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">str</span><span class="p">))</span> <span class="s">&quot; &quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">with-input-from-file </span><span class="s">&quot;/usr/share/dict/words&quot;</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
    <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">word</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">word</span><span class="p">))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">string-length </span><span class="nv">word</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">string=? </span><span class="nv">word</span> <span class="p">(</span><span class="nf">string-reverse</span> <span class="nv">word</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">write-line</span> <span class="nv">word</span><span class="p">)))))</span>

<span class="c1">;; A little too verbose on the command line</span>
<span class="c1">;; guile --use-srfi=13 -c</span>
<span class="c1">;; &#39;(with-input-from-file &quot;/usr/share/dict/words&quot;</span>
<span class="c1">;; (lambda () (do ((word (read-line) (read-line))) ((eof-object? word))</span>
<span class="c1">;; (if (and (&gt; (string-length word) 5) (string=? word (string-reverse word)))</span>
<span class="c1">;; (write-line word)))))&#39;</span>

<span class="c1">;; @@PLEAC@@_1.7</span>
<span class="c1">;; Use regexp-substitute/global</span>
<span class="p">(</span><span class="nf">regexp-substitute/global</span>
 <span class="no">#f</span> <span class="s">&quot;([^\t]*)(\t+)&quot;</span> <span class="nv">str</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">m</span><span class="p">)</span>
   <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">pre-string</span> <span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">pre-len</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">pre-string</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">match-len</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">match:end</span> <span class="nv">m</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">match:start</span> <span class="nv">m</span> <span class="mi">2</span><span class="p">))))</span>
     <span class="p">(</span><span class="nf">string-append</span>
      <span class="nv">pre-string</span>
      <span class="p">(</span><span class="nf">make-string</span>
       <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="nv">match-len</span> <span class="mi">8</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">modulo </span><span class="nv">pre-len</span> <span class="mi">8</span><span class="p">))</span>
       <span class="sc">#\space</span><span class="p">))))</span>
 <span class="ss">&#39;post</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_1.8</span>
<span class="c1">;; just interpolate $abc in strings:</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">varsubst</span> <span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">regexp-substitute/global</span> <span class="no">#f</span> <span class="s">&quot;\\$(\\w+)&quot;</span> <span class="nv">str</span>
   <span class="ss">&#39;pre</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">))</span>
                          <span class="p">(</span><span class="nf">current-module</span><span class="p">)))</span>
   <span class="ss">&#39;post</span><span class="p">))</span>

<span class="c1">;; interpolate $abc with error messages:</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">safe-varsubst</span> <span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">regexp-substitute/global</span> <span class="no">#f</span> <span class="s">&quot;\\$(\\w+)&quot;</span> <span class="nv">str</span>
   <span class="ss">&#39;pre</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">m</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">))</span>
                             <span class="p">(</span><span class="nf">current-module</span><span class="p">)))</span>
            <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span>
              <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;[NO VARIABLE: ~A]&quot;</span> <span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)))))</span>
   <span class="ss">&#39;post</span><span class="p">))</span>

<span class="c1">;; interpolate ${(any (scheme expression))} in strings:</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">interpolate</span> <span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">regexp-substitute/global</span> <span class="no">#f</span> <span class="s">&quot;\\${([^{}]+)}&quot;</span> <span class="nv">str</span>
   <span class="ss">&#39;pre</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">eval-string</span> <span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)))</span> <span class="ss">&#39;post</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_1.9</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>

<span class="p">(</span><span class="nf">string-upcase</span> <span class="s">&quot;bo beep&quot;</span><span class="p">)</span>     <span class="c1">; BO PEEP</span>
<span class="p">(</span><span class="nf">string-downcase</span> <span class="s">&quot;JOHN&quot;</span><span class="p">)</span>      <span class="c1">; john</span>
<span class="p">(</span><span class="nf">string-titlecase</span> <span class="s">&quot;bo&quot;</span><span class="p">)</span>       <span class="c1">; Bo</span>
<span class="p">(</span><span class="nf">string-titlecase</span> <span class="s">&quot;JOHN&quot;</span><span class="p">)</span>     <span class="c1">; John</span>

<span class="p">(</span><span class="nf">string-titlecase</span> <span class="s">&quot;thIS is a loNG liNE&quot;</span><span class="p">)</span>  <span class="c1">; This Is A Long Line</span>

<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>
<span class="c1">;; randcap: filter to randomly capitalize 20% of the time</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="nf">seed-&gt;random-state</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">randcap</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span> <span class="ss">&#39;concat</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">string-map</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span><span class="p">)</span>
                                  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">random</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                                    <span class="p">(</span><span class="nb">char-upcase </span><span class="nv">c</span><span class="p">)</span>
                                    <span class="p">(</span><span class="nb">char-downcase </span><span class="nv">c</span><span class="p">)))</span>
                                <span class="nv">line</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span> <span class="ss">&#39;concat</span><span class="p">))))))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">randcap</span> <span class="p">(</span><span class="nf">current-input-port</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="p">(</span><span class="nb">call-with-input-file </span><span class="nv">f</span> <span class="nv">randcap</span><span class="p">))</span> <span class="nv">args</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_1.10</span>
<span class="c1">;; You can do this with format.  Lisp/Scheme format is a little</span>
<span class="c1">;; different from what you may be used to with C/Perl style printf</span>
<span class="c1">;; (actually far more powerful) , but if you keep in mind that we use</span>
<span class="c1">;; ~ instead of %, and , instead of . for the prefix characters, you</span>
<span class="c1">;; won&#39;t have trouble getting used to Guile&#39;s format.</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;I have ~A guanacos.&quot;</span> <span class="nv">n</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_1.11</span>
<span class="p">(</span><span class="k">define </span><span class="nv">var</span> <span class="s">&quot;</span>
<span class="s">        your text</span>
<span class="s">        goes here&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regexp</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">var</span> <span class="p">(</span><span class="nf">regexp-substitute/global</span> <span class="no">#f</span> <span class="s">&quot;\n +&quot;</span> <span class="nv">var</span> <span class="ss">&#39;pre</span> <span class="s">&quot;\n&quot;</span> <span class="ss">&#39;post</span><span class="p">))</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">var</span> <span class="p">(</span><span class="nf">string-join</span> <span class="p">(</span><span class="nb">map </span><span class="nv">string-trim</span> <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">var</span> <span class="sc">#\newline</span><span class="p">))</span> <span class="s">&quot;\n&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regexp</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-14</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dequote</span> <span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">str</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">char=? </span><span class="p">(</span><span class="nb">string-ref </span><span class="nv">str</span> <span class="mi">0</span><span class="p">)</span> <span class="sc">#\newline</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">substring </span><span class="nv">str</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">str</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">lines</span> <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">str</span> <span class="sc">#\newline</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">rx</span> <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">leader</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lines</span><span class="p">))</span> <span class="p">(</span><span class="nf">lst</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lines</span><span class="p">)))</span>
               <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">string=</span> <span class="nv">leader</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
                      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">pos</span> <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-skip</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lines</span><span class="p">)</span>
                                                  <span class="nv">char-set:whitespace</span><span class="p">)</span> <span class="mi">0</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nf">make-regexp</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;^[ \\t]{1,~A}&quot;</span> <span class="nv">pos</span><span class="p">)</span>
                                     <span class="nv">regexp/newline</span><span class="p">)))</span>
                     <span class="p">((</span><span class="nb">null? </span><span class="nv">lst</span><span class="p">)</span>
                      <span class="p">(</span><span class="nf">make-regexp</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;^[ \\t]*&quot;</span>
                                                  <span class="p">(</span><span class="nf">regexp-quote</span> <span class="nv">leader</span><span class="p">))</span>
                                   <span class="nv">regexp/newline</span><span class="p">))</span>
                     <span class="p">(</span><span class="nf">else</span>
                      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">pos</span> <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-prefix-length</span> <span class="nv">leader</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lst</span><span class="p">))</span>
                                      <span class="mi">0</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">substring </span><span class="nv">leader</span> <span class="mi">0</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lst</span><span class="p">))))))))</span>
    <span class="p">(</span><span class="nf">regexp-substitute/global</span> <span class="no">#f</span> <span class="nv">rx</span> <span class="nv">str</span> <span class="ss">&#39;pre</span> <span class="ss">&#39;post</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_1.12</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">text</span> <span class="s">&quot;Folding and splicing is the work of an editor,</span>
<span class="s">not a mere collection of silicon</span>
<span class="s">and</span>
<span class="s">mobile electrons!&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">wrap</span> <span class="nv">str</span> <span class="nv">max-col</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">words</span> <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">str</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">all</span> <span class="o">&#39;</span><span class="p">())</span>
         <span class="p">(</span><span class="nf">first</span> <span class="p">(</span><span class="nb">car </span><span class="nv">words</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">col</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">first</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">line</span> <span class="p">(</span><span class="nb">list </span><span class="nv">first</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">for-each</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">x</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">new-col</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">col</span> <span class="nv">len</span> <span class="mi">1</span><span class="p">)))</span>
         <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&gt; </span><span class="nv">new-col</span> <span class="nv">max-col</span><span class="p">)</span>
                <span class="p">(</span><span class="k">set! </span><span class="nv">all</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">string-join</span> <span class="p">(</span><span class="nf">reverse!</span> <span class="nv">line</span><span class="p">)</span> <span class="s">&quot; &quot;</span><span class="p">)</span> <span class="nv">all</span><span class="p">))</span>
                <span class="p">(</span><span class="k">set! </span><span class="nv">line</span> <span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">))</span>
                <span class="p">(</span><span class="k">set! </span><span class="nv">col</span> <span class="nv">len</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">else</span>
                <span class="p">(</span><span class="k">set! </span><span class="nv">line</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">line</span><span class="p">))</span>
                <span class="p">(</span><span class="k">set! </span><span class="nv">col</span> <span class="nv">new-col</span><span class="p">)))))</span>
     <span class="p">(</span><span class="nb">cdr </span><span class="nv">words</span><span class="p">))</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">all</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">string-join</span> <span class="p">(</span><span class="nf">reverse!</span> <span class="nv">line</span><span class="p">)</span> <span class="s">&quot; &quot;</span><span class="p">)</span> <span class="nv">all</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">string-join</span> <span class="p">(</span><span class="nf">reverse!</span> <span class="nv">all</span><span class="p">)</span> <span class="s">&quot;\n&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">wrap</span> <span class="nv">text</span> <span class="mi">20</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_1.13</span>
<span class="p">(</span><span class="k">define </span><span class="nv">str</span> <span class="s">&quot;Mom said, \&quot;Don&#39;t do that.\&quot;&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">str</span> <span class="p">(</span><span class="nf">regexp-substitute/global</span> <span class="no">#f</span> <span class="s">&quot;[&#39;\&quot;]&quot;</span> <span class="nv">str</span> <span class="ss">&#39;pre</span> <span class="s">&quot;\\&quot;</span>
                                    <span class="nv">match:substring</span> <span class="ss">&#39;post</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">str</span> <span class="p">(</span><span class="nf">regexp-substitute/global</span> <span class="no">#f</span> <span class="s">&quot;[^A-Z]&quot;</span> <span class="nv">str</span> <span class="ss">&#39;pre</span> <span class="s">&quot;\\&quot;</span>
                                    <span class="nv">match:substring</span> <span class="ss">&#39;post</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">str</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;this &quot;</span> <span class="p">(</span><span class="nf">regexp-substitute/global</span>
                                  <span class="no">#f</span> <span class="s">&quot;\W&quot;</span> <span class="s">&quot;is a test!&quot;</span> <span class="ss">&#39;pre</span> <span class="s">&quot;\\&quot;</span>
                                  <span class="nv">match:substring</span> <span class="ss">&#39;post</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_1.14</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">str</span> <span class="s">&quot;  space  &quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">string-trim</span> <span class="nv">str</span><span class="p">)</span>          <span class="c1">; &quot;space  &quot;</span>
<span class="p">(</span><span class="nf">string-trim-right</span> <span class="nv">str</span><span class="p">)</span>    <span class="c1">; &quot;  space&quot;</span>
<span class="p">(</span><span class="nf">string-trim-both</span> <span class="nv">str</span><span class="p">)</span>     <span class="c1">; &quot;space&quot;</span>

<span class="c1">;; @@PLEAC@@_1.15</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-2</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">format</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">parse-csv</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">csv-match</span> <span class="p">(</span><span class="nf">string-join</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;\&quot;([^\&quot;\\\\]*(\\\\.[^\&quot;\\\\]*)*)\&quot;,?&quot;</span>
                                   <span class="s">&quot;([^,]+),?&quot;</span>
                                   <span class="s">&quot;,&quot;</span><span class="p">)</span>
                                 <span class="s">&quot;|&quot;</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">csv-rx</span> <span class="p">(</span><span class="nf">make-regexp</span> <span class="nv">csv-match</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">text</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">start</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">result</span> <span class="o">&#39;</span><span class="p">()))</span>
        <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">start</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">and-let*</span> <span class="p">((</span><span class="nf">m</span> <span class="p">(</span><span class="nf">regexp-exec</span> <span class="nv">csv-rx</span> <span class="nv">text</span> <span class="nv">start</span><span class="p">)))</span>
            <span class="p">(</span><span class="k">set! </span><span class="nv">result</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)</span>
                                   <span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">3</span><span class="p">))</span>
                               <span class="nv">result</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">match:end</span> <span class="nv">m</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">reverse </span><span class="nv">result</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">line</span> <span class="s">&quot;XYZZY,\&quot;\&quot;,\&quot;O&#39;Reilly, Inc\&quot;,\&quot;Wall,</span>
<span class="s">             Larry\&quot;,\&quot;a \\\&quot;glug\\\&quot; bit,\&quot;,5,\&quot;Error, Core Dumped\&quot;&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">fields</span> <span class="p">(</span><span class="nf">parse-csv</span> <span class="nv">line</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">fields</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">null? </span><span class="nv">fields</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~D : ~A\n&quot;</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">car </span><span class="nv">fields</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_1.16</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-14</span><span class="p">))</span>

<span class="c1">;; Knuth&#39;s soundex algorithm from The Art of Computer Programming, Vol 3</span>
<span class="p">(</span><span class="k">define </span><span class="nv">soundex</span>
  <span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">chars</span> <span class="s">&quot;AEIOUYBFPVCGJKQSXZDTLMNR&quot;</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">nums</span> <span class="s">&quot;000000111122222222334556&quot;</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">skipchars</span> <span class="p">(</span><span class="nf">string-&gt;char-set</span> <span class="s">&quot;HW&quot;</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">trans</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span><span class="p">)</span>
                    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">i</span> <span class="p">(</span><span class="nf">string-index</span> <span class="nv">chars</span> <span class="nv">c</span><span class="p">)))</span>
                      <span class="p">(</span><span class="k">if </span><span class="nv">i</span> <span class="p">(</span><span class="nb">string-ref </span><span class="nv">nums</span> <span class="nv">i</span><span class="p">)</span> <span class="nv">c</span><span class="p">)))))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">str</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">ustr</span> <span class="p">(</span><span class="nf">string-upcase</span> <span class="nv">str</span><span class="p">))</span>
             <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">string-ref </span><span class="nv">ustr</span> <span class="mi">0</span><span class="p">))</span>
             <span class="p">(</span><span class="nf">skip</span> <span class="p">(</span><span class="nf">trans</span> <span class="nv">f</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">mstr</span> <span class="p">(</span><span class="nf">string-map</span> <span class="nv">trans</span> <span class="p">(</span><span class="nf">string-delete</span> <span class="nv">ustr</span> <span class="nv">skipchars</span> <span class="mi">1</span><span class="p">)))</span>
               <span class="p">(</span><span class="nf">dstr</span> <span class="p">(</span><span class="nf">string-map</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span><span class="p">)</span>
                                   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">c</span> <span class="nv">skip</span><span class="p">)</span> <span class="sc">#\0</span><span class="p">)</span>
                                         <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="k">set! </span><span class="nv">skip</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">c</span><span class="p">)))</span>
                                 <span class="nv">mstr</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">zstr</span> <span class="p">(</span><span class="nf">string-delete</span> <span class="nv">dstr</span> <span class="sc">#\0</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">substring </span><span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">make-string </span><span class="mi">1</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">zstr</span> <span class="s">&quot;000&quot;</span><span class="p">)</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">soundex</span> <span class="s">&quot;Knuth&quot;</span><span class="p">)</span>  <span class="c1">; K530</span>
<span class="p">(</span><span class="nf">soundex</span> <span class="s">&quot;Kant&quot;</span><span class="p">)</span>   <span class="c1">; K530</span>
<span class="p">(</span><span class="nf">soundex</span> <span class="s">&quot;Lloyd&quot;</span><span class="p">)</span>  <span class="c1">; L300</span>
<span class="p">(</span><span class="nf">soundex</span> <span class="s">&quot;Ladd&quot;</span><span class="p">)</span>   <span class="c1">; L300</span>

<span class="c1">;; @@PLEAC@@_1.17</span>
<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-14</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rw</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regex</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">data</span> <span class="s">&quot;analysed        =&gt; analyzed</span>
<span class="s">built-in        =&gt; builtin</span>
<span class="s">chastized       =&gt; chastised</span>
<span class="s">commandline     =&gt; command-line</span>
<span class="s">de-allocate     =&gt; deallocate</span>
<span class="s">dropin          =&gt; drop-in</span>
<span class="s">hardcode        =&gt; hard-code</span>
<span class="s">meta-data       =&gt; metadata</span>
<span class="s">multicharacter  =&gt; multi-character</span>
<span class="s">multiway        =&gt; multi-way</span>
<span class="s">non-empty       =&gt; nonempty</span>
<span class="s">non-profit      =&gt; nonprofit</span>
<span class="s">non-trappable   =&gt; nontrappable</span>
<span class="s">pre-define      =&gt; predefine</span>
<span class="s">preextend       =&gt; pre-extend</span>
<span class="s">re-compiling    =&gt; recompiling</span>
<span class="s">reenter         =&gt; re-enter</span>
<span class="s">turnkey         =&gt; turn-key&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">input</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
                <span class="p">(</span><span class="nf">current-input-port</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">open-input-file </span><span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">newline-char-set</span> <span class="p">(</span><span class="nf">string-&gt;char-set</span> <span class="s">&quot;\n&quot;</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">assoc-char-set</span> <span class="p">(</span><span class="nf">string-&gt;char-set</span> <span class="s">&quot; =&gt;&quot;</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">dict</span> <span class="p">(</span><span class="nf">map</span>
              <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">line</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">line</span> <span class="nv">assoc-char-set</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">data</span> <span class="nv">newline-char-set</span><span class="p">)))</span>
       <span class="p">(</span><span class="nf">dict-match</span> <span class="p">(</span><span class="nf">string-join</span> <span class="p">(</span><span class="nb">map </span><span class="nv">car</span> <span class="nv">dict</span><span class="p">)</span> <span class="s">&quot;|&quot;</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">input</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">regexp-substitute/global</span>
            <span class="p">(</span><span class="nf">current-output-port</span><span class="p">)</span> <span class="nv">dict-match</span> <span class="nv">line</span>
            <span class="ss">&#39;pre</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nb">assoc </span><span class="p">(</span><span class="nf">match:substring</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">dict</span><span class="p">)))</span>
            <span class="ss">&#39;post</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">input</span> <span class="ss">&#39;concat</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">close-port</span> <span class="nv">input</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_2.1</span>
<span class="c1">;; Strings and numbers are separate data types in Scheme, so this</span>
<span class="c1">;; isn&#39;t as important as it is in Perl.  More often you would use the</span>
<span class="c1">;; type predicates, string? and number?.</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;[^\\d]&quot;</span> <span class="nv">str</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;has nondigits&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;^\\d+$&quot;</span> <span class="nv">str</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;not a natural number&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;^-?\\d+$&quot;</span> <span class="nv">str</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;not an integer&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;^[\\-+]?\\d+$&quot;</span> <span class="nv">str</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;not an integer&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;^-?\\d+\.?\d*$&quot;</span> <span class="nv">str</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;not a decimal number&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;^-?(\d+(\.\d*)?|\.\d+)$&quot;</span> <span class="nv">str</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">&quot;not a decimal number&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;^([+-]?)(\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$&quot;</span> <span class="nv">str</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">&quot;not a C float&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">num1</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="nv">str</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">num2</span> <span class="p">(</span><span class="nf">read</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_2.2</span>
<span class="c1">;; (approx-equal? num1 num2 accuracy) : returns #t if num1 and num2 are</span>
<span class="c1">;;   equal to accuracy number of decimal places</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">approx-equal?</span> <span class="nv">num1</span> <span class="nv">num2</span> <span class="nv">accuracy</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">abs </span><span class="p">(</span><span class="nb">- </span><span class="nv">num1</span> <span class="nv">num2</span><span class="p">))</span> <span class="p">(</span><span class="nb">expt </span><span class="mf">10.0</span> <span class="p">(</span><span class="nb">- </span><span class="nv">accuracy</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">wage</span> <span class="mi">536</span><span class="p">)</span>                     <span class="c1">;; $5.36/hour</span>
<span class="p">(</span><span class="k">define </span><span class="nv">week</span> <span class="p">(</span><span class="nb">* </span><span class="mi">40</span> <span class="nv">wage</span><span class="p">))</span>             <span class="c1">;; $214.40</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;One week&#39;s wage is: $~$\n&quot;</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">week</span> <span class="mf">100.0</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_2.3</span>
<span class="p">(</span><span class="nb">round </span><span class="nv">num</span><span class="p">)</span>                           <span class="c1">;; rounds to inexact whole number</span>
<span class="p">(</span><span class="nb">inexact-&gt;exact </span><span class="nv">num</span><span class="p">)</span>                  <span class="c1">;; rounds to exact integer</span>

<span class="c1">;; You can also use format to convert numbers to more precisely</span>
<span class="c1">;; formatted strings.  Note Guile has a builtin format which is a more</span>
<span class="c1">;; limited version of that found in the (ice-9 format) module, to save</span>
<span class="c1">;; load time.  Basically, if you are doing anything you couldn&#39;t do</span>
<span class="c1">;; with a series of (display), (write) and (newline), then you&#39;ll need</span>
<span class="c1">;; to use the module.</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">format</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mf">0.255</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">round </span><span class="p">(</span><span class="nb">* </span><span class="mf">100.0</span> <span class="nv">a</span><span class="p">))</span> <span class="mf">100.0</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Unrounded: ~F\nRounded: ~F\n&quot;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Unrounded: ~F\nRounded: ~,2F\n&quot;</span> <span class="nv">a</span> <span class="nv">a</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="mf">3.3</span> <span class="mf">3.5</span> <span class="mf">3.7</span> <span class="mf">-3.3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">display </span><span class="s">&quot;number\tint\tfloor\tceil\n&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">for-each</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~,1F\t~,1F\t~,1F\t~,1F\n&quot;</span>
           <span class="nv">n</span> <span class="p">(</span><span class="nb">round </span><span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">floor </span><span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">ceiling </span><span class="nv">n</span><span class="p">)))</span>
 <span class="nv">a</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_2.4</span>
<span class="c1">;; numbers are radix independent internally, so you usually only</span>
<span class="c1">;; convert on output, however to convert strings:</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dec-&gt;bin</span> <span class="nv">num</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">number-&gt;string </span><span class="p">(</span><span class="nb">string-&gt;number </span><span class="nv">num</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">bin-&gt;dec</span> <span class="nv">num</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">number-&gt;string </span><span class="p">(</span><span class="nb">string-&gt;number </span><span class="nv">num</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">10</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">num</span> <span class="p">(</span><span class="nf">bin-&gt;dec</span> <span class="s">&quot;0110110&quot;</span><span class="p">))</span>  <span class="c1">; 54</span>
<span class="p">(</span><span class="k">define </span><span class="nv">binstr</span> <span class="p">(</span><span class="nf">dec-&gt;bin</span> <span class="s">&quot;54&quot;</span><span class="p">))</span>    <span class="c1">; 110110</span>

<span class="c1">;; @@PLEAC@@_2.5</span>
<span class="c1">;; do is the most general loop iterator</span>
<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="nv">x</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">)))</span>   <span class="c1">; var  init-value  step-value</span>
    <span class="p">((</span><span class="nb">&gt; </span><span class="nv">i</span> <span class="nv">y</span><span class="p">))</span>        <span class="c1">; end when true</span>
  <span class="c1">;; i is set to every integer from x to y, inclusive</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>

<span class="c1">;; Guile also offers a while loop</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">i</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">while</span> <span class="p">(</span><span class="nb">&lt;= </span><span class="nv">i</span> <span class="nv">y</span><span class="p">)</span>
         <span class="c1">;; i is set to every integer from x to y, inclusive</span>
         <span class="c1">; ...</span>
         <span class="p">(</span><span class="k">set! </span><span class="nv">i</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">))))</span>

<span class="c1">;; named let is another common loop</span>
<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&lt;= </span><span class="nv">i</span> <span class="nv">y</span><span class="p">)</span>
         <span class="c1">;; i is set to every integer from x to y, step-size 7</span>
         <span class="c1">;; ...</span>
         <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">7</span><span class="p">)))))</span>  <span class="c1">; tail-recursive call</span>

<span class="p">(</span><span class="nb">display </span><span class="s">&quot;Infancy is: &quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">&gt; </span><span class="nv">i</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">i</span><span class="p">))</span>
<span class="p">(</span><span class="nf">newline</span><span class="p">)</span>

<span class="p">(</span><span class="nb">display </span><span class="s">&quot;Toddling is: &quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">i</span> <span class="mi">3</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">while</span> <span class="p">(</span><span class="nb">&lt;= </span><span class="nv">i</span> <span class="mi">4</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">i</span><span class="p">)</span>
         <span class="p">(</span><span class="k">set! </span><span class="nv">i</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">newline</span><span class="p">)</span>

<span class="p">(</span><span class="nb">display </span><span class="s">&quot;Childhood is: &quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">5</span><span class="p">))</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&lt;= </span><span class="nv">i</span> <span class="mi">12</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">i</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">newline</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_2.6</span>
<span class="c1">;; format can output roman numerals - use ~:@R</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">format</span><span class="p">))</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Roman for ~R is ~:@R\n&quot;</span> <span class="mi">15</span> <span class="mi">15</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_2.7</span>
<span class="p">(</span><span class="nf">random</span> <span class="mi">5</span><span class="p">)</span>        <span class="c1">; an integer from 0 to 4</span>
<span class="p">(</span><span class="nf">random</span> <span class="mf">5.0</span><span class="p">)</span>      <span class="c1">; an inexact real in the range [0,5)</span>

<span class="c1">;; char sets from SRFI-14 and string-unfold from SRFI-13 make a quick</span>
<span class="c1">;; way to generate passwords</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-14</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">chars</span> <span class="p">(</span><span class="nf">char-set-&gt;string</span> <span class="nv">char-set:graphic</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">size</span> <span class="p">(</span><span class="nf">char-set-size</span> <span class="nv">char-set:graphic</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">password</span>
  <span class="p">(</span><span class="nf">string-unfold</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">8</span><span class="p">))</span>
                 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-ref </span><span class="nv">chars</span> <span class="p">(</span><span class="nf">random</span> <span class="nv">size</span><span class="p">)))</span>
                 <span class="mi">1</span><span class="nv">+</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_2.8</span>
<span class="c1">;; if you&#39;re working with random numbers you&#39;ll probably want to set</span>
<span class="c1">;; the random seed</span>

<span class="p">(</span><span class="nf">seed-&gt;random-state</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">;; you can also save random states and pass them to any of the above</span>
<span class="c1">;; random functions</span>

<span class="p">(</span><span class="k">define </span><span class="nv">state</span> <span class="p">(</span><span class="nf">copy-random-state</span><span class="p">))</span>
<span class="p">(</span><span class="nf">random:uniform</span><span class="p">)</span>
<span class="c1">;; 0.939377327721761</span>
<span class="p">(</span><span class="nf">random:uniform</span> <span class="nv">state</span><span class="p">)</span>
<span class="c1">;; 0.939377327721761</span>

<span class="c1">;; @@PLEAC@@_2.9</span>
<span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; very inefficient</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rw</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">make-true-random</span>
  <span class="p">(</span><span class="k">letrec </span><span class="p">((</span><span class="nf">bufsize</span> <span class="mi">8</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">accum</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span> <span class="nv">acc</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="mi">256</span> <span class="nv">acc</span><span class="p">)</span>
                                     <span class="p">(</span><span class="nb">char-&gt;integer </span><span class="nv">c</span><span class="p">))))</span>
           <span class="p">(</span><span class="nf">getbuf</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
                     <span class="p">(</span><span class="nb">call-with-input-file </span><span class="s">&quot;/dev/urandom&quot;</span>
                       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span>
                         <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">buf</span> <span class="p">(</span><span class="nb">make-string </span><span class="nv">bufsize</span><span class="p">)))</span>
                           <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buf</span> <span class="nv">p</span><span class="p">)</span>
                           <span class="nv">buf</span><span class="p">))))))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">rand-proc</span><span class="p">)</span>
      <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span>
        <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">state</span> <span class="p">(</span><span class="nf">seed-&gt;random-state</span> <span class="p">(</span><span class="nf">string-fold</span> <span class="nv">accum</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">getbuf</span><span class="p">)))))</span>
          <span class="p">(</span><span class="nb">apply </span><span class="nv">rand-proc</span> <span class="p">(</span><span class="nb">append </span><span class="nv">args</span> <span class="p">(</span><span class="nb">list </span><span class="nv">state</span><span class="p">))))))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">urandom</span> <span class="p">(</span><span class="nf">make-true-random</span> <span class="nv">random</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">urandom:exp</span> <span class="p">(</span><span class="nf">make-true-random</span> <span class="nv">random:exp</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">urandom:normal</span> <span class="p">(</span><span class="nf">make-true-random</span> <span class="nv">random:normal</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">urandom:uniform</span> <span class="p">(</span><span class="nf">make-true-random</span> <span class="nv">random:uniform</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_2.10</span>
<span class="c1">;; Guile offers a number of random distributions</span>

<span class="p">(</span><span class="nf">random:exp</span><span class="p">)</span>      <span class="c1">; an inexact real in an exponential dist with mean 1</span>
<span class="p">(</span><span class="nf">random:normal</span><span class="p">)</span>   <span class="c1">; an inexact real in a standard normal distribution</span>
<span class="p">(</span><span class="nf">random:uniform</span><span class="p">)</span>  <span class="c1">; a uniformly distributed inexact real in [0,1)</span>

<span class="c1">;; There are also functions to fill vectors with random distributions</span>

<span class="c1">;; Fills vector v with inexact real random numbers the sum of whose</span>
<span class="c1">;; squares is equal to 1.0.</span>
<span class="p">(</span><span class="nf">random:hollow-sphere!</span> <span class="nv">v</span><span class="p">)</span>

<span class="c1">;; Fills vector v with inexact real random numbers that are</span>
<span class="c1">;; independent and standard normally distributed (i.e., with mean 0</span>
<span class="c1">;; and variance 1).</span>
<span class="p">(</span><span class="nf">random:normal-vector!</span> <span class="nv">v</span><span class="p">)</span>

<span class="c1">;; Fills vector v with inexact real random numbers the sum of whose</span>
<span class="c1">;; squares is less than 1.0.</span>
<span class="p">(</span><span class="nf">random:solid-sphere!</span> <span class="nv">v</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_2.11</span>
<span class="c1">;; Guile&#39;s trigonometric functions use radians.</span>

<span class="p">(</span><span class="k">define </span><span class="nv">pi</span> <span class="mf">3.14159265358979</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">degrees-&gt;radians</span> <span class="nv">deg</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">* </span><span class="nv">pi</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">deg</span> <span class="mf">180.0</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">radians-&gt;degrees</span> <span class="nv">rad</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">* </span><span class="mf">180.0</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">rad</span> <span class="nv">pi</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">degree-sine</span> <span class="nv">deg</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">sin </span><span class="p">(</span><span class="nf">degrees-&gt;radians</span> <span class="nv">deg</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_2.12</span>

<span class="c1">;; Guile provides the following standard trigonometric functions (and</span>
<span class="c1">;; their hyperbolic equivalents), defined for all real and complex</span>
<span class="c1">;; numbers:</span>

<span class="p">(</span><span class="nb">sin </span><span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cos </span><span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="nb">tan </span><span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="nb">asin </span><span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="nb">acos </span><span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="nb">atan </span><span class="nv">z</span><span class="p">)</span>

<span class="p">(</span><span class="nb">acos </span><span class="mf">3.7</span><span class="p">)</span>  <span class="c1">; 0.0+1.9826969446812i</span>

<span class="c1">;; @@PLEAC@@_2.13</span>
<span class="c1">;; Guile provides log in base e and 10 natively, defined for any real</span>
<span class="c1">;; or complex numbers:</span>

<span class="p">(</span><span class="nb">log </span><span class="nv">z</span><span class="p">)</span>    <span class="c1">; natural logarithm</span>
<span class="p">(</span><span class="nf">log10</span> <span class="nv">z</span><span class="p">)</span>  <span class="c1">; base-10 logarithm</span>

<span class="c1">;; For other bases, divide by the log of the base:</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">log-base</span> <span class="nv">n</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">log </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">log </span><span class="nv">n</span><span class="p">)))</span>

<span class="c1">;; To avoid re-computing (log n) for a base you want to use</span>
<span class="c1">;; frequently, you can create a custom log function:</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-log-base</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">divisor</span> <span class="p">(</span><span class="nb">log </span><span class="nv">n</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">log </span><span class="nv">z</span><span class="p">)</span> <span class="nv">divisor</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">log2</span> <span class="p">(</span><span class="nf">make-log-base</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="nf">log2</span> <span class="mi">1024</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_2.14</span>
<span class="c1">;; In addition to simple vectors, Guile has builtin support for</span>
<span class="c1">;; uniform arrays of an arbitrary dimension.</span>

<span class="c1">;; a rows x cols integer matrix</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="nf">make-array</span> <span class="mi">0</span> <span class="nv">rows</span> <span class="nv">cols</span><span class="p">))</span>
<span class="p">(</span><span class="nf">array-set!</span> <span class="nv">a</span> <span class="mi">3</span> <span class="nv">row</span> <span class="nv">col</span><span class="p">)</span>
<span class="p">(</span><span class="nf">array-ref</span> <span class="nv">a</span> <span class="nv">row</span> <span class="nv">col</span><span class="p">)</span>

<span class="c1">;; a 3D matrix of reals</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nf">make-array</span> <span class="mf">0.0</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>

<span class="c1">;; a literal boolean truth table for logical and</span>
<span class="o">&#39;#</span><span class="mi">2</span><span class="p">((</span><span class="no">#f</span> <span class="no">#f</span><span class="p">)</span> <span class="p">(</span><span class="no">#f</span> <span class="no">#t</span><span class="p">))</span>

<span class="c1">;; simple matrix multiplication</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">matrix-mult</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">d1</span> <span class="p">(</span><span class="nf">array-dimensions</span> <span class="nv">m1</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">d2</span> <span class="p">(</span><span class="nf">array-dimensions</span> <span class="nv">m2</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">m1rows</span> <span class="p">(</span><span class="nb">car </span><span class="nv">d1</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">m1cols</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">d1</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">m2rows</span> <span class="p">(</span><span class="nb">car </span><span class="nv">d2</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">m2cols</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">d2</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">= </span><span class="nv">m1cols</span> <span class="nv">m2rows</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">error</span> <span class="ss">&#39;index-error</span> <span class="s">&quot;matrices don&#39;t match&quot;</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">result</span> <span class="p">(</span><span class="nf">make-array</span> <span class="mi">0</span> <span class="nv">m1rows</span> <span class="nv">m2cols</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">m1rows</span><span class="p">))</span>
        <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">j</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">j</span><span class="p">)))</span>
            <span class="p">((</span><span class="nb">= </span><span class="nv">j</span> <span class="nv">m2cols</span><span class="p">))</span>
          <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">k</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">k</span><span class="p">)))</span>
              <span class="p">((</span><span class="nb">= </span><span class="nv">k</span> <span class="nv">m1cols</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">array-set!</span> <span class="nv">result</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">array-ref</span> <span class="nv">result</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">array-ref</span> <span class="nv">m1</span> <span class="nv">i</span> <span class="nv">k</span><span class="p">)</span>
                                     <span class="p">(</span><span class="nf">array-ref</span> <span class="nv">m2</span> <span class="nv">k</span> <span class="nv">j</span><span class="p">)))</span>
                        <span class="nv">i</span> <span class="nv">j</span><span class="p">))))</span>
      <span class="nv">result</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">matrix-mult</span> <span class="o">&#39;#</span><span class="mi">2</span><span class="p">((</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">9</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&#39;#</span><span class="mi">2</span><span class="p">((</span><span class="mi">4</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">9</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_2.15</span>
<span class="c1">;; Guile has builtin support for complex numbers:</span>

<span class="p">(</span><span class="k">define </span><span class="nv">i</span> <span class="mi">0</span><span class="nv">+1i</span><span class="p">)</span>       <span class="c1">; 0.0+1.0i</span>
<span class="p">(</span><span class="k">define </span><span class="nv">i</span> <span class="p">(</span><span class="nb">sqrt </span><span class="mi">-1</span><span class="p">))</span>  <span class="c1">; 0.0+1.0i</span>

<span class="p">(</span><span class="nb">complex? </span><span class="nv">i</span><span class="p">)</span>          <span class="c1">; #t</span>
<span class="p">(</span><span class="nb">real-part </span><span class="nv">i</span><span class="p">)</span>         <span class="c1">; 0.0</span>
<span class="p">(</span><span class="nb">imag-part </span><span class="nv">i</span><span class="p">)</span>         <span class="c1">; 1.0</span>

<span class="p">(</span><span class="nb">* </span><span class="mi">3</span><span class="nv">+5i</span> <span class="mi">2-2</span><span class="nv">i</span><span class="p">)</span>         <span class="c1">; 16+4i</span>
<span class="p">(</span><span class="nb">sqrt </span><span class="mi">3</span><span class="nv">+4i</span><span class="p">)</span>           <span class="c1">; 2+i</span>

<span class="c1">;; Classic identity:  -e^(pi*i) =&gt; 1</span>
<span class="p">(</span><span class="nb">inexact-&gt;exact </span><span class="p">(</span><span class="nb">real-part </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">exp </span><span class="p">(</span><span class="nb">* </span><span class="nv">pi</span> <span class="mi">0</span><span class="nv">+1i</span><span class="p">)))))</span> <span class="c1">; 1</span>

<span class="c1">;; @@PLEAC@@_2.16</span>
<span class="c1">;; You can type in literal numbers in alternate radixes:</span>

<span class="o">#</span><span class="nv">b01101101</span>     <span class="c1">; 109 in binary</span>
<span class="o">#</span><span class="nv">o155</span>          <span class="c1">; 109 in octal</span>
<span class="o">#</span><span class="nv">d109</span>          <span class="c1">; 109 in decimal</span>
<span class="o">#</span><span class="nv">x6d</span>           <span class="c1">; 109 in hexadecimal</span>

<span class="c1">;; number-&gt;string and string-&gt;number also take an optional radix:</span>

<span class="p">(</span><span class="k">define </span><span class="nv">number</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="nv">hexadecimal</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">number</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="nv">octal</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1">;; format will also output in different radixes:</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~B ~O ~D ~X\n&quot;</span> <span class="nv">num</span> <span class="nv">num</span> <span class="nv">num</span> <span class="nv">num</span><span class="p">)</span>

<span class="c1">;; converting Unix file permissions read from stdin:</span>

<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">perm</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">perm</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;The decimal value is ~D\n&quot;</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="nv">perm</span> <span class="mi">8</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))))</span>

<span class="c1">;; @@PLEAC@@_2.17</span>
<span class="c1">;; once again, format is our friend :)</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">format</span><span class="p">))</span>

<span class="c1">;; the : prefix to the D directive causes commas to be output every</span>
<span class="c1">;; three digits.</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~:D\n&quot;</span> <span class="p">(</span><span class="nf">random</span> <span class="mi">10000000000000000</span><span class="p">))</span>
<span class="c1">; =&gt; 2,301,267,079,619,540</span>

<span class="c1">;; the third prefix arg to the D directive is the separator character</span>
<span class="c1">;; to use instead of a comma, useful for European style numbers:</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~,,&#39;.:D\n&quot;</span> <span class="p">(</span><span class="nf">random</span> <span class="mi">10000000000000000</span><span class="p">))</span>
<span class="c1">; =&gt; 6.486.470.447.356.534</span>

<span class="c1">;; the F directive, however, does not support grouping by commas.  to</span>
<span class="c1">;; achieve this, we can format the integer and fractional parts</span>
<span class="c1">;; separately:</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">commify</span> <span class="nv">num</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">int</span> <span class="p">(</span><span class="nb">inexact-&gt;exact </span><span class="p">(</span><span class="nb">truncate </span><span class="nv">num</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">num</span> <span class="nv">int</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;~:D&quot;</span> <span class="nv">int</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;~:D&quot;</span> <span class="nv">int</span><span class="p">)</span>
                     <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">str</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;~F&quot;</span> <span class="nv">num</span><span class="p">)))</span>
                       <span class="p">(</span><span class="nb">substring </span><span class="nv">str</span> <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-index</span> <span class="nv">str</span> <span class="sc">#\.</span><span class="p">)</span>
                                          <span class="p">(</span><span class="nb">string-length </span><span class="nv">str</span><span class="p">))))))))</span>

<span class="c1">;; @@PLEAC@@_2.18</span>
<span class="c1">;; format can handle simple &#39;s&#39; plurals with ~p, and &#39;y/ies&#39; plurals</span>
<span class="c1">;; with the @ prefix:</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;It took ~D hour~P\n&quot;</span> <span class="nv">hours</span> <span class="nv">hours</span><span class="p">)</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;It took ~D centur~@P\n&quot;</span> <span class="nv">centuries</span> <span class="nv">centuries</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">noun-plural</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">suffixes</span> <span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;ss&quot;</span>  <span class="o">.</span> <span class="s">&quot;sses&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;ph&quot;</span>  <span class="o">.</span> <span class="s">&quot;phes&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;sh&quot;</span>  <span class="o">.</span> <span class="s">&quot;shes&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;ch&quot;</span>  <span class="o">.</span> <span class="s">&quot;ches&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;z&quot;</span>   <span class="o">.</span> <span class="s">&quot;zes&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;ff&quot;</span>  <span class="o">.</span> <span class="s">&quot;ffs&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;f&quot;</span>   <span class="o">.</span> <span class="s">&quot;ves&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;ey&quot;</span>  <span class="o">.</span> <span class="s">&quot;eys&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;y&quot;</span>   <span class="o">.</span> <span class="s">&quot;ies&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;ix&quot;</span>  <span class="o">.</span> <span class="s">&quot;ices&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;s&quot;</span>   <span class="o">.</span> <span class="s">&quot;ses&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;x&quot;</span>   <span class="o">.</span> <span class="s">&quot;xes&quot;</span><span class="p">)</span>
                     <span class="p">(</span><span class="s">&quot;ius&quot;</span> <span class="o">.</span> <span class="s">&quot;ii&quot;</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">suffix-match</span>
         <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;(&quot;</span> <span class="p">(</span><span class="nf">string-join</span> <span class="p">(</span><span class="nb">map </span><span class="nv">car</span> <span class="nv">suffixes</span><span class="p">)</span> <span class="s">&quot;|&quot;</span><span class="p">)</span> <span class="s">&quot;)$&quot;</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">suffix-rx</span> <span class="p">(</span><span class="nf">make-regexp</span> <span class="nv">suffix-match</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">noun</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">m</span> <span class="p">(</span><span class="nf">regexp-exec</span> <span class="nv">suffix-rx</span> <span class="nv">noun</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if </span><span class="nv">m</span>
          <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nf">regexp-substitute</span> <span class="no">#f</span> <span class="nv">m</span> <span class="ss">&#39;pre</span><span class="p">)</span>
                         <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assoc </span><span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">suffixes</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">string-append </span><span class="nv">noun</span> <span class="s">&quot;s&quot;</span><span class="p">))))))</span>

<span class="c1">;; @@PLEAC@@_2.19</span>
<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>

<span class="c1">;; very naive factoring algorithm</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">factor</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">factors</span> <span class="o">&#39;</span><span class="p">())</span>
        <span class="p">(</span><span class="nf">limit</span> <span class="p">(</span><span class="nb">inexact-&gt;exact </span><span class="p">(</span><span class="nb">round </span><span class="p">(</span><span class="nb">sqrt </span><span class="nv">n</span><span class="p">))))</span>
        <span class="p">(</span><span class="nf">twos</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1">;; factor out 2&#39;s</span>
    <span class="p">(</span><span class="nf">while</span> <span class="p">(</span><span class="nb">even? </span><span class="nv">n</span><span class="p">)</span>
           <span class="p">(</span><span class="k">set! </span><span class="nv">n</span> <span class="p">(</span><span class="nf">ash</span> <span class="nv">n</span> <span class="mi">-1</span><span class="p">))</span>
           <span class="p">(</span><span class="k">set! </span><span class="nv">twos</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">twos</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">twos</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">factors</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="nv">twos</span><span class="p">))))</span>
    <span class="c1">;; factor out odd primes</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">3</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">r</span> <span class="p">(</span><span class="nb">remainder </span><span class="nv">n</span> <span class="nv">i</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">r</span> <span class="mi">0</span><span class="p">)</span>
               <span class="p">(</span><span class="k">set! </span><span class="nv">n</span> <span class="p">(</span><span class="nb">quotient </span><span class="nv">n</span> <span class="nv">i</span><span class="p">))</span>
               <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">old-val</span> <span class="p">(</span><span class="nb">assv </span><span class="nv">i</span> <span class="nv">factors</span><span class="p">))</span>
                      <span class="p">(</span><span class="nf">new-val</span> <span class="p">(</span><span class="k">if </span><span class="nv">old-val</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">old-val</span><span class="p">))</span> <span class="mi">1</span><span class="p">)))</span>
                 <span class="p">(</span><span class="k">set! </span><span class="nv">factors</span> <span class="p">(</span><span class="nf">assv-set!</span> <span class="nv">factors</span> <span class="nv">i</span> <span class="nv">new-val</span><span class="p">)))</span>
               <span class="p">(</span><span class="nf">loop</span> <span class="nv">i</span><span class="p">))</span>
              <span class="p">((</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="nv">limit</span><span class="p">)</span>
               <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="nv">i</span><span class="p">))))))</span>
    <span class="c1">;; remainder</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">factors</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">factors</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">reverse!</span> <span class="nv">factors</span><span class="p">)))</span>

<span class="c1">;; pretty print a term of a factor</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pp-term</span> <span class="nv">pair</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">number-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;~A^~A&quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">))))</span>

<span class="c1">;; factor each number given on the command line</span>
<span class="p">(</span><span class="nf">for-each</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">factors</span> <span class="p">(</span><span class="nf">factor</span> <span class="nv">n</span><span class="p">)))</span>
     <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A = ~A&quot;</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">pp-term</span> <span class="p">(</span><span class="nb">car </span><span class="nv">factors</span><span class="p">)))</span>
     <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot; * ~A&quot;</span> <span class="p">(</span><span class="nf">pp-term</span> <span class="nv">x</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">cdr </span><span class="nv">factors</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">newline</span><span class="p">)))</span>
 <span class="p">(</span><span class="nb">map </span><span class="nv">string-&gt;number</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_3.0</span>
<span class="c1">;; Use the builtin POSIX time functions</span>

<span class="c1">;; get the current time</span>
<span class="p">(</span><span class="nf">current-time</span><span class="p">)</span>   <span class="c1">; number of seconds since the epoch</span>
<span class="p">(</span><span class="nf">gettimeofday</span><span class="p">)</span>   <span class="c1">; pair of seconds and microseconds since the epoch</span>

<span class="c1">;; create a time object from an integer (e.g. returned by current-time)</span>
<span class="p">(</span><span class="nf">localtime</span> <span class="nv">time</span><span class="p">)</span> <span class="c1">; in localtime</span>
<span class="p">(</span><span class="nf">gmtime</span> <span class="nv">time</span><span class="p">)</span>    <span class="c1">; in UTC</span>

<span class="c1">;; get/set broken down components of a time object</span>

<span class="p">(</span><span class="nf">tm:sec</span> <span class="nv">time</span><span class="p">)</span>    <span class="p">(</span><span class="nf">set-tm:sec</span> <span class="nv">time</span> <span class="nv">secs</span><span class="p">)</span>    <span class="c1">; seconds (0-59)</span>
<span class="p">(</span><span class="nf">tm:min</span> <span class="nv">time</span><span class="p">)</span>    <span class="p">(</span><span class="nf">set-tm:min</span> <span class="nv">time</span> <span class="nv">mins</span><span class="p">)</span>    <span class="c1">; minutes (0-59)</span>
<span class="p">(</span><span class="nf">tm:hour</span> <span class="nv">time</span><span class="p">)</span>   <span class="p">(</span><span class="nf">set-tm:hour</span> <span class="nv">time</span> <span class="nv">hours</span><span class="p">)</span>  <span class="c1">; hours (0-23)</span>
<span class="p">(</span><span class="nf">tm:mday</span> <span class="nv">time</span><span class="p">)</span>   <span class="p">(</span><span class="nf">set-tm:mday</span> <span class="nv">time</span> <span class="nv">mday</span><span class="p">)</span>   <span class="c1">; day of the month (1-31)</span>
<span class="p">(</span><span class="nf">tm:mon</span> <span class="nv">time</span><span class="p">)</span>    <span class="p">(</span><span class="nf">set-tm:mon</span> <span class="nv">time</span> <span class="nv">month</span><span class="p">)</span>   <span class="c1">; month (0-11)</span>
<span class="p">(</span><span class="nf">tm:year</span> <span class="nv">time</span><span class="p">)</span>   <span class="p">(</span><span class="nf">set-tm:year</span> <span class="nv">time</span> <span class="nv">year</span><span class="p">)</span>   <span class="c1">; year minus 1900 (70-)</span>
<span class="p">(</span><span class="nf">tm:wday</span> <span class="nv">time</span><span class="p">)</span>   <span class="p">(</span><span class="nf">set-tm:wday</span> <span class="nv">time</span> <span class="nv">wday</span><span class="p">)</span>   <span class="c1">; day of the week (0-6)</span>
                                           <span class="c1">; where Sunday is 0</span>
<span class="p">(</span><span class="nf">tm:yday</span> <span class="nv">time</span><span class="p">)</span>   <span class="p">(</span><span class="nf">set-tm:yday</span> <span class="nv">time</span> <span class="nv">yday</span><span class="p">)</span>   <span class="c1">; day of year (0-365)</span>
<span class="p">(</span><span class="nf">tm:isdst</span> <span class="nv">time</span><span class="p">)</span>  <span class="p">(</span><span class="nf">set-tm:isdst</span> <span class="nv">time</span> <span class="nv">isdst</span><span class="p">)</span> <span class="c1">; daylight saving indicator</span>
                                           <span class="c1">; 0 for &quot;no&quot;, &gt; 0 for &quot;yes&quot;,</span>
                                           <span class="c1">; &lt; 0 for &quot;unknown&quot;</span>
<span class="p">(</span><span class="nf">tm:gmtoff</span> <span class="nv">time</span><span class="p">)</span> <span class="p">(</span><span class="nf">set-tm:gmtoff</span> <span class="nv">time</span> <span class="nv">off</span><span class="p">)</span>  <span class="c1">; time zone offset in seconds</span>
                                           <span class="c1">; west of UTC (-46800 to 43200)</span>
<span class="p">(</span><span class="nf">tm:zone</span> <span class="nv">time</span><span class="p">)</span>   <span class="p">(</span><span class="nf">set-tm:zone</span> <span class="nv">time</span> <span class="nv">zone</span><span class="p">)</span>   <span class="c1">; Time zone label (a string),</span>
                                           <span class="c1">; not necessarily unique.</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Today is day ~A of the current year.\n&quot;</span>
        <span class="p">(</span><span class="nf">tm:yday</span> <span class="p">(</span><span class="nf">localtime</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))))</span>

<span class="c1">;; Or use SRFI-19 - Time and Date Procedures</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-19</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">now</span> <span class="p">(</span><span class="nf">current-date</span><span class="p">))</span>  <span class="c1">; immutable once created</span>

<span class="p">(</span><span class="nf">date-nanosecond</span> <span class="nv">now</span><span class="p">)</span>        <span class="c1">; 0-9,999,999</span>
<span class="p">(</span><span class="nf">date-second</span> <span class="nv">now</span><span class="p">)</span>            <span class="c1">; 0-60 (60 represents a leap second)</span>
<span class="p">(</span><span class="nf">date-minute</span> <span class="nv">now</span><span class="p">)</span>            <span class="c1">; 0-59</span>
<span class="p">(</span><span class="nf">date-hour</span> <span class="nv">now</span><span class="p">)</span>              <span class="c1">; 0-23</span>
<span class="p">(</span><span class="nf">date-day</span> <span class="nv">now</span><span class="p">)</span>               <span class="c1">; 0-31</span>
<span class="p">(</span><span class="nf">date-month</span> <span class="nv">now</span><span class="p">)</span>             <span class="c1">; 1-12</span>
<span class="p">(</span><span class="nf">date-year</span> <span class="nv">now</span><span class="p">)</span>              <span class="c1">; integer representing the year</span>
<span class="p">(</span><span class="nf">date-year-day</span> <span class="nv">now</span><span class="p">)</span>          <span class="c1">; day of year (Jan 1 is 1, etc.)</span>
<span class="p">(</span><span class="nf">date-week-day</span> <span class="nv">now</span><span class="p">)</span>          <span class="c1">; day of week (Sunday is 0, etc.)</span>
<span class="p">(</span><span class="nf">date-week-number</span> <span class="nv">now</span> <span class="nv">start</span><span class="p">)</span> <span class="c1">; week of year, ignoring a first partial week</span>
                             <span class="c1">; start is the first day of week as above</span>
<span class="p">(</span><span class="nf">date-zone-offset</span> <span class="nv">now</span><span class="p">)</span>       <span class="c1">; integer number of seconds east of GMT</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Today is day ~A of the current year.\n&quot;</span>
        <span class="p">(</span><span class="nf">date-year-day</span> <span class="p">(</span><span class="nf">current-date</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_3.1</span>
<span class="c1">;; using format and POSIX time components</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">format</span><span class="p">))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">now</span> <span class="p">(</span><span class="nf">localtime</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;The current date is ~4&#39;0D ~2&#39;0D ~2&#39;0D\n&quot;</span>
          <span class="p">(</span><span class="nb">+ </span><span class="mi">1900</span> <span class="p">(</span><span class="nf">tm:year</span> <span class="nv">now</span><span class="p">))</span> <span class="p">(</span><span class="nf">tm:mon</span> <span class="nv">now</span><span class="p">)</span> <span class="p">(</span><span class="nf">tm:mday</span> <span class="nv">now</span><span class="p">)))</span>

<span class="c1">;; using format and SRFI-19 time components</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-19</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">format</span><span class="p">))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">now</span> <span class="p">(</span><span class="nf">current-date</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;The current date is ~4&#39;0d-~2&#39;0D-~2&#39;0D\n&quot;</span>
          <span class="p">(</span><span class="nf">date-year</span> <span class="nv">now</span><span class="p">)</span> <span class="p">(</span><span class="nf">date-month</span> <span class="nv">now</span><span class="p">)</span> <span class="p">(</span><span class="nf">date-day</span> <span class="nv">now</span><span class="p">)))</span>

<span class="c1">;; using POSIX strftime with a libc time format string</span>
<span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">strftime</span> <span class="s">&quot;%Y-%m-%d\n&quot;</span> <span class="p">(</span><span class="nf">localtime</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_3.2</span>
<span class="c1">;; set the individual components of a time struct and use mktime</span>
<span class="p">(</span><span class="k">define </span><span class="nv">time</span> <span class="p">(</span><span class="nf">localtime</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">set-tm:mday</span> <span class="nv">time</span> <span class="nv">mday</span><span class="p">)</span>
<span class="p">(</span><span class="nf">set-tm:mon</span> <span class="nv">time</span> <span class="nv">mon</span><span class="p">)</span>
<span class="p">(</span><span class="nf">set-tm:year</span> <span class="nv">time</span> <span class="nv">year</span><span class="p">)</span>
<span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">mktime</span> <span class="nv">time</span><span class="p">))</span>  <span class="c1">; mktime returns a (epoch-seconds . time) pair</span>

<span class="c1">;; or use SRFI-19&#39;s make-date and date-&gt;time-monotonic</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-19</span><span class="p">))</span>
<span class="p">(</span><span class="nf">date-&gt;time-monotonic</span>
 <span class="p">(</span><span class="nf">make-date</span> <span class="nv">nanosecond</span> <span class="nv">second</span> <span class="nv">minute</span> <span class="nv">hour</span> <span class="nv">day</span> <span class="nv">month</span> <span class="nv">year</span> <span class="nv">zone-offset</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_3.3</span>
<span class="c1">;; use localtime or gmtime with the accessors mentioned in the</span>
<span class="c1">;; introduction to this chapter</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">time</span> <span class="p">(</span><span class="nf">localtime</span> <span class="nv">seconds</span><span class="p">)))</span>  <span class="c1">; or gmtime</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Dateline: ~2&#39;0d:~2&#39;0d:~2&#39;0d-~4&#39;0d/~2&#39;0d/~2&#39;0d\n&quot;</span>
          <span class="p">(</span><span class="nf">tm:hour</span> <span class="nv">time</span><span class="p">)</span> <span class="p">(</span><span class="nf">tm:min</span> <span class="nv">time</span><span class="p">)</span> <span class="p">(</span><span class="nf">tm:sec</span> <span class="nv">time</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">+ </span><span class="mi">1900</span> <span class="p">(</span><span class="nf">tm:year</span> <span class="nv">time</span><span class="p">))</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="p">(</span><span class="nf">tm:mon</span> <span class="nv">time</span><span class="p">))</span> <span class="p">(</span><span class="nf">tm:mday</span> <span class="nv">time</span><span class="p">)))</span>

<span class="c1">;; or use SRFI-19</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-19</span><span class="p">))</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">time</span> <span class="p">(</span><span class="nf">make-time</span> <span class="nv">time-monotonic</span> <span class="nv">nanosecond</span> <span class="nv">second</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">date-&gt;string</span> <span class="p">(</span><span class="nf">time-monotonic-&gt;date</span> <span class="nv">time</span><span class="p">)</span> <span class="s">&quot;~T-~1\n&quot;</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_3.4</span>
<span class="c1">;; just add or subtract epoch seconds</span>
<span class="p">(</span><span class="k">define </span><span class="nv">when</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">now</span> <span class="nv">difference</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">then</span> <span class="p">(</span><span class="nb">- </span><span class="nv">now</span> <span class="nv">difference</span><span class="p">))</span>

<span class="c1">;; if you have DMYHMS values, you can convert them to times or add</span>
<span class="c1">;; them as seconds:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">birthtime</span> <span class="mi">96176750</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">interval</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">5</span>                  <span class="c1">; 5 seconds</span>
                    <span class="p">(</span><span class="nb">* </span><span class="mi">17</span> <span class="mi">60</span><span class="p">)</span>          <span class="c1">; 17 minutes</span>
                    <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">60</span> <span class="mi">60</span><span class="p">)</span>        <span class="c1">; 2 hours</span>
                    <span class="p">(</span><span class="nb">* </span><span class="mi">55</span> <span class="mi">60</span> <span class="mi">60</span> <span class="mi">24</span><span class="p">)))</span>  <span class="c1">; and 55 days</span>
<span class="p">(</span><span class="k">define </span><span class="nv">then</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">birthtime</span> <span class="nv">interval</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Then is ~A\n&quot;</span> <span class="p">(</span><span class="nf">strftime</span> <span class="s">&quot;%a %b %d %T %Y&quot;</span> <span class="p">(</span><span class="nf">localtime</span> <span class="nv">then</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_3.5</span>
<span class="c1">;; subtract the epoch seconds:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">bree</span> <span class="mi">361535725</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">nat</span> <span class="mi">96201950</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">difference</span> <span class="p">(</span><span class="nb">- </span><span class="nv">bree</span> <span class="nv">nat</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;There were ~A seconds between Nat and Bree\n&quot;</span> <span class="nv">difference</span><span class="p">)</span>

<span class="c1">;; or use SRFI-19&#39;s time arithmetic procedures:</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-19</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">time1</span> <span class="p">(</span><span class="nf">make-time</span> <span class="nv">time-monotonic</span> <span class="nv">nano1</span> <span class="nv">sec1</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">time2</span> <span class="p">(</span><span class="nf">make-time</span> <span class="nv">time-monotonic</span> <span class="nv">nano2</span> <span class="nv">sec2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">duration</span> <span class="p">(</span><span class="nf">time-difference</span> <span class="nv">time1</span> <span class="nv">time2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">time=?</span> <span class="p">(</span><span class="nf">subtract-duration</span> <span class="nv">time1</span> <span class="nv">duration</span><span class="p">)</span> <span class="nv">time2</span><span class="p">)</span> <span class="c1">; #t</span>
<span class="p">(</span><span class="nf">time=?</span> <span class="p">(</span><span class="nf">add-duration</span> <span class="nv">time2</span> <span class="nv">duration</span><span class="p">)</span> <span class="nv">time1</span><span class="p">)</span>      <span class="c1">; #t</span>

<span class="c1">;; @@PLEAC@@_3.6</span>
<span class="c1">;; convert to a SRFI-19 date and use the accessors</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-19</span><span class="p">))</span>
<span class="p">(</span><span class="nf">date-day</span> <span class="nv">date</span><span class="p">)</span>
<span class="p">(</span><span class="nf">date-year-day</span> <span class="nv">date</span><span class="p">)</span>
<span class="p">(</span><span class="nf">date-week-day</span> <span class="nv">date</span><span class="p">)</span>
<span class="p">(</span><span class="nf">date-week-number</span> <span class="nv">date</span> <span class="nv">start-day-of-week</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_3.7</span>
<span class="c1">;; use the strptime function:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">time-pair</span> <span class="p">(</span><span class="nf">strptime</span> <span class="s">&quot;%Y-%m-%d&quot;</span> <span class="s">&quot;1998-06-03&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Time is ~A\n.&quot;</span> <span class="p">(</span><span class="nf">strftime</span> <span class="s">&quot;%b %d, %Y&quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">time-pair</span><span class="p">)))</span>

<span class="c1">;; or use SRFI-19&#39;s string-&gt;date:</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-19</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">date</span> <span class="p">(</span><span class="nf">string-&gt;date</span> <span class="s">&quot;1998-06-03&quot;</span> <span class="s">&quot;~Y-~m-~d&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Time is ~A.\n&quot;</span> <span class="p">(</span><span class="nf">date-&gt;string</span> <span class="nv">date</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_3.8</span>
<span class="c1">;; use the already seen strftime:</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;strftime gives: ~A\n&quot;</span>
        <span class="p">(</span><span class="nf">strftime</span> <span class="s">&quot;%A %D&quot;</span> <span class="p">(</span><span class="nf">localtime</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))))</span>

<span class="c1">;; or SRFI-19&#39;s date-&gt;string:</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-19</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;default date-&gt;string gives: ~A\n&quot;</span> <span class="p">(</span><span class="nf">date-&gt;string</span> <span class="p">(</span><span class="nf">current-date</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;date-&gt;string gives: ~A\n&quot;</span>
        <span class="p">(</span><span class="nf">date-&gt;string</span> <span class="p">(</span><span class="nf">current-date</span><span class="p">)</span> <span class="s">&quot;~a ~b ~e ~H:~M:~S ~z ~Y&quot;</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_3.9</span>
<span class="c1">;; gettimeofday will return seconds and microseconds:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">t0</span> <span class="p">(</span><span class="nf">gettimeofday</span><span class="p">))</span>
<span class="c1">;; do your work here</span>
<span class="p">(</span><span class="k">define </span><span class="nv">t1</span> <span class="p">(</span><span class="nf">gettimeofday</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;You took ~A seconds and ~A microseconds\n&quot;</span>
        <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">car </span><span class="nv">t1</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">t0</span><span class="p">))</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">t1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">t0</span><span class="p">)))</span>

<span class="c1">;; you can also get more detailed info about the real and processor</span>
<span class="c1">;; times:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">runtime</span> <span class="p">(</span><span class="nf">times</span><span class="p">))</span>
<span class="p">(</span><span class="nf">tms:clock</span> <span class="nv">runtime</span><span class="p">)</span>  <span class="c1">; the current real time</span>
<span class="p">(</span><span class="nf">tms:utime</span> <span class="nv">runtime</span><span class="p">)</span>  <span class="c1">; the CPU time units used by the calling process</span>
<span class="p">(</span><span class="nf">tms:stime</span> <span class="nv">runtime</span><span class="p">)</span>  <span class="c1">; the CPU time units used by the system on behalf</span>
                     <span class="c1">; of the calling process.</span>
<span class="p">(</span><span class="nf">tms:cutime</span> <span class="nv">runtime</span><span class="p">)</span> <span class="c1">; the CPU time units used by terminated child</span>
                     <span class="c1">; processes of the calling process, whose status</span>
                     <span class="c1">; has been collected (e.g., using `waitpid&#39;).</span>
<span class="p">(</span><span class="nf">tms:cstime</span> <span class="nv">runtime</span><span class="p">)</span> <span class="c1">; the CPU times units used by the system on</span>
		     <span class="c1">; behalf of terminated child processes</span>

<span class="c1">;; you can also use the time module to time execution:</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">time</span><span class="p">))</span>
<span class="p">(</span><span class="nf">time</span> <span class="p">(</span><span class="nf">sleep</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;; clock utime stime cutime cstime gctime</span>
<span class="c1">;; 3.01  0.00  0.00   0.00   0.00   0.00</span>
<span class="c1">;; 0</span>

<span class="c1">;; @@PLEAC@@_3.10</span>
<span class="p">(</span><span class="nf">sleep</span> <span class="nv">i</span><span class="p">)</span>   <span class="c1">; sleep for i seconds</span>
<span class="p">(</span><span class="nf">usleep</span> <span class="nv">i</span><span class="p">)</span>  <span class="c1">; sleep for i microseconds (not available on all platforms)</span>

<span class="c1">;; @@PLEAC@@_4.0</span>
<span class="p">(</span><span class="k">define </span><span class="nv">nested</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;this&quot;</span> <span class="s">&quot;that&quot;</span> <span class="s">&quot;the&quot;</span> <span class="s">&quot;other&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">nested</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;this&quot;</span> <span class="s">&quot;that&quot;</span> <span class="p">(</span><span class="s">&quot;the&quot;</span> <span class="s">&quot;other&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">tune</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;The&quot;</span> <span class="s">&quot;Star-Spangled&quot;</span> <span class="s">&quot;Banner&quot;</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_4.1</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;quick&quot;</span> <span class="s">&quot;brown&quot;</span> <span class="s">&quot;fox&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Why&quot;</span> <span class="s">&quot;are&quot;</span> <span class="s">&quot;you&quot;</span> <span class="s">&quot;teasing&quot;</span> <span class="s">&quot;me?&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">lines</span>
  <span class="p">(</span><span class="nb">map </span><span class="nv">string-trim</span>
       <span class="p">(</span><span class="nf">string-tokenize</span> <span class="s">&quot;\</span>
<span class="s">    The boy stood on the burning deck,</span>
<span class="s">    It was as hot as glass.&quot;</span>
			<span class="sc">#\newline</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">bigarray</span>
  <span class="p">(</span><span class="nb">with-input-from-file </span><span class="s">&quot;mydatafile&quot;</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
      <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">lines</span> <span class="o">&#39;</span><span class="p">())</span>
		 <span class="p">(</span><span class="nf">next-line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">next-line</span><span class="p">)</span>
	    <span class="p">(</span><span class="nb">reverse </span><span class="nv">lines</span><span class="p">)</span>
	    <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">next-line</span> <span class="nv">lines</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">read-line</span><span class="p">)))))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">banner</span> <span class="s">&quot;The Mines of Moria&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">name</span> <span class="s">&quot;Gandalf&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">banner</span>
  <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;Speak, &quot;</span> <span class="nv">name</span> <span class="s">&quot;, and enter!&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">banner</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;Speak, ~A, and welcome!&quot;</span> <span class="nv">name</span><span class="p">))</span>

<span class="c1">;; Advanced shell-like function is provided by guile-scsh, the Guile</span>
<span class="c1">;; port of SCSH, the Scheme shell.  Here we roll our own using the</span>
<span class="c1">;; pipe primitives that come with core Guile.</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">popen</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">drain-output</span> <span class="nv">port</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">chars</span> <span class="o">&#39;</span><span class="p">())</span>
             <span class="p">(</span><span class="nf">next</span> <span class="p">(</span><span class="nb">read-char </span><span class="nv">port</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">next</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">list-&gt;string </span><span class="p">(</span><span class="nf">reverse!</span> <span class="nv">chars</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">next</span> <span class="nv">chars</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">read-char </span><span class="nv">port</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">qx</span> <span class="nv">pipeline</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">pipe</span> <span class="p">(</span><span class="nf">open-input-pipe</span> <span class="nv">pipeline</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">output</span> <span class="p">(</span><span class="nf">drain-output</span> <span class="nv">pipe</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">close-pipe</span> <span class="nv">pipe</span><span class="p">)</span>
    <span class="nv">output</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">his-host</span> <span class="s">&quot;www.perl.com&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">host-info</span> <span class="p">(</span><span class="nf">qx</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;nslookup ~A&quot;</span> <span class="nv">his-host</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">perl-info</span> <span class="p">(</span><span class="nf">qx</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;ps ~A&quot;</span> <span class="p">(</span><span class="nf">getpid</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">shell-info</span> <span class="p">(</span><span class="nf">qx</span> <span class="s">&quot;ps $$&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">banner</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Costs&quot;</span> <span class="s">&quot;only&quot;</span> <span class="s">&quot;$4.95&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">brax</span>    <span class="p">(</span><span class="nb">map </span><span class="nv">string</span> <span class="p">(</span><span class="nb">string-&gt;list </span><span class="s">&quot;()&lt;&gt;{}[]&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">rings</span>   <span class="p">(</span><span class="nf">string-tokenize</span> <span class="s">&quot;Nenya Narya Vilya&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">tags</span>    <span class="p">(</span><span class="nf">string-tokenize</span> <span class="s">&quot;LI TABLE TR TD A IMG H1 P&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">sample</span>
  <span class="p">(</span><span class="nf">string-tokenize</span> <span class="s">&quot;The vertical bar (|) looks and behaves like a pipe.&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">ships</span>  <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Nińa&quot;</span> <span class="s">&quot;Pinta&quot;</span> <span class="s">&quot;Santa María&quot;</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_4.2</span>
<span class="p">(</span><span class="k">define </span><span class="nv">array</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;red&quot;</span> <span class="s">&quot;yellow&quot;</span> <span class="s">&quot;green&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">begin</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;I have &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">for-each </span><span class="nv">display</span> <span class="nv">array</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot; marbles.\n&quot;</span><span class="p">))</span>
<span class="c1">;; I have redyellowgreen marbles.</span>

<span class="p">(</span><span class="nf">begin</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;I have &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">colour</span><span class="p">)</span>
	      <span class="p">(</span><span class="nb">display </span><span class="nv">colour</span><span class="p">)</span>
	      <span class="p">(</span><span class="nb">display </span><span class="s">&quot; &quot;</span><span class="p">))</span>
	    <span class="nv">array</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;marbles.\n&quot;</span><span class="p">))</span>
<span class="c1">;; I have red yellow green marbles.</span>

<span class="c1">;; commify - insertion of commas into list output</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">commify</span> <span class="nv">strings</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nb">length </span><span class="nv">strings</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">case </span><span class="nv">len</span>
      <span class="p">((</span><span class="mi">0</span><span class="p">)</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
      <span class="p">((</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">strings</span><span class="p">))</span>
      <span class="p">((</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">strings</span><span class="p">)</span> <span class="s">&quot; and &quot;</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">strings</span><span class="p">)))</span>
      <span class="p">((</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">strings</span><span class="p">)</span> <span class="s">&quot;, &quot;</span>
                          <span class="p">(</span><span class="nb">cadr </span><span class="nv">strings</span><span class="p">)</span> <span class="s">&quot;, and &quot;</span>
                          <span class="p">(</span><span class="nb">caddr </span><span class="nv">strings</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">else</span>
       <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">strings</span><span class="p">)</span> <span class="s">&quot;, &quot;</span>
                      <span class="p">(</span><span class="nf">commify</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">strings</span><span class="p">)))))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">lists</span> <span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;just one thing&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;Mutt&quot;</span> <span class="s">&quot;Jeff&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;Peter&quot;</span> <span class="s">&quot;Paul&quot;</span> <span class="s">&quot;Mary&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;To our parents&quot;</span> <span class="s">&quot;Mother Theresa&quot;</span> <span class="s">&quot;God&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;pastrami&quot;</span> <span class="s">&quot;ham and cheese&quot;</span> <span class="s">&quot;peanut butter and jelly&quot;</span> <span class="s">&quot;tuna&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;recycle tired, old phrases&quot;</span> <span class="s">&quot;ponder big, happy thoughts&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;recycle tired, old phrases&quot;</span>
                 <span class="s">&quot;ponder big, happy thoughts&quot;</span>
                 <span class="s">&quot;sleep and dream peacefully&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">list</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">display </span><span class="s">&quot;The list is: &quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">commify</span> <span class="nv">list</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">display </span><span class="s">&quot;.\n&quot;</span><span class="p">))</span>
          <span class="nv">lists</span><span class="p">)</span>

<span class="c1">;; The list is: just one thing.</span>
<span class="c1">;; The list is: Mutt and Jeff.</span>
<span class="c1">;; The list is: Peter, Paul, and Mary.</span>
<span class="c1">;; The list is: To our parents, Mother Theresa, and God.</span>
<span class="c1">;; The list is: pastrami, ham and cheese, peanut butter and jelly, and tuna.</span>
<span class="c1">;; The list is: recycle tired, old phrases and ponder big, happy thoughts.</span>
<span class="c1">;; The list is: recycle tired, old phrases, ponder big, happy thoughts, and</span>
<span class="c1">;; sleep and dream peacefully.</span>

<span class="c1">;; @@PLEAC@@_4.3</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; Scheme does not normally grow and shrink arrays in the way that</span>
<span class="c1">;; Perl can.  The more usual operations are adding and removing from</span>
<span class="c1">;; the head of a list using the `cons&#39; and `cdr&#39; procedures.</span>
<span class="c1">;; However ...</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">grow/shrink</span> <span class="nv">list</span> <span class="nv">new-size</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">size</span> <span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&lt; </span><span class="nv">size</span> <span class="nv">new-size</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">grow/shrink</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;&quot;</span> <span class="nv">list</span><span class="p">)</span> <span class="nv">new-size</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">&gt; </span><span class="nv">size</span> <span class="nv">new-size</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">grow/shrink</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">list</span><span class="p">)</span> <span class="nv">new-size</span><span class="p">))</span>
          <span class="p">(</span><span class="k">else </span><span class="nv">list</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">element</span> <span class="nv">list</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list-ref </span><span class="nv">list</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">)</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">set-element</span> <span class="nv">list</span> <span class="nv">i</span> <span class="nv">value</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">i</span> <span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">list</span> <span class="p">(</span><span class="nf">grow/shrink</span> <span class="nv">list</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">set-car! </span><span class="p">(</span><span class="nf">list-cdr-ref</span> <span class="nv">list</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">)</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="nv">list</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">what-about</span> <span class="nv">list</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;The array now has ~A elements.\n&quot;</span> <span class="nv">len</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;The index of the last element is ~A.\n&quot;</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Element #3 is `~A&#39;.\n&quot;</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">len</span> <span class="mi">3</span><span class="p">)</span>
                                           <span class="p">(</span><span class="nf">element</span> <span class="nv">list</span> <span class="mi">3</span><span class="p">)</span>
                                           <span class="s">&quot;&quot;</span><span class="p">))))</span>

<span class="c1">;; In the emulation of Perl arrays implemented here, the elements are</span>
<span class="c1">;; in reverse order when compared to normal Scheme lists.</span>
<span class="p">(</span><span class="k">define </span><span class="nv">people</span> <span class="p">(</span><span class="nb">reverse </span><span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Crosby&quot;</span> <span class="s">&quot;Stills&quot;</span> <span class="s">&quot;Nash&quot;</span> <span class="s">&quot;Young&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">what-about</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The array now has 4 elements.</span>
<span class="c1">;; The index of the last element is 3.</span>
<span class="c1">;; Element #3 is `Young&#39;.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">people</span> <span class="p">(</span><span class="nf">grow/shrink</span> <span class="nv">people</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nf">what-about</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The array now has 3 elements.</span>
<span class="c1">;; The index of the last element is 2.</span>
<span class="c1">;; Element #3 is `&#39;.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">people</span> <span class="p">(</span><span class="nf">grow/shrink</span> <span class="nv">people</span> <span class="mi">10001</span><span class="p">))</span>
<span class="p">(</span><span class="nf">what-about</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The array now has 10001 elements.</span>
<span class="c1">;; The index of the last element is 10000.</span>
<span class="c1">;; Element #3 is `&#39;.</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_4.4</span>
<span class="c1">; Using a &#39;list&#39; i.e. chain of pairs</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*mylist*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">; Apply procedure to each member of &#39;mylist&#39;</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">item</span><span class="p">))</span>
  <span class="nv">*mylist*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Using a &#39;vector&#39; i.e. one-dimensional array</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*bad-users*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot;lou&quot;</span> <span class="s">&quot;mo&quot;</span> <span class="s">&quot;sterling&quot;</span> <span class="s">&quot;john&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;You&#39;re a *bad user*,&quot;</span> <span class="nv">user</span><span class="p">))</span>

<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span> <span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">))</span>
  <span class="nv">*bad-users*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Could probably get away with sorting a list of strings ...</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*sorted-environ*</span>
  <span class="p">(</span><span class="nf">sort</span> <span class="p">(</span><span class="nf">environ</span><span class="p">)</span> <span class="nv">string&lt;?</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">var</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>
  <span class="nv">*sorted-environ*</span><span class="p">)</span>

<span class="c1">;; ----</span>

<span class="c1">; ... but the intent here is to sort a hash table, so we&#39;ll use</span>
<span class="c1">; an &#39;assoc&#39;, Scheme&#39;s native dictionary type, which is really</span>
<span class="c1">; nothing more than a list of conses / dotted pairs [hash tables</span>
<span class="c1">; will be used in later examples]</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cons-&gt;env-string</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">a</span><span class="p">)</span> <span class="s">&quot;=&quot;</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">a</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">env-string-&gt;cons</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">key-value</span> <span class="p">(</span><span class="nf">string-split</span> <span class="nv">s</span> <span class="sc">#\=</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">key-value</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">key-value</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*sorted-environ-assoc*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="p">(</span><span class="nf">map</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">var</span><span class="p">)</span> <span class="p">(</span><span class="nf">env-string-&gt;cons</span> <span class="nv">var</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">environ</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span> <span class="p">(</span><span class="nb">string&lt;? </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">)))</span> <span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">var</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">var</span><span class="p">)</span> <span class="s">&quot;=&quot;</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">var</span><span class="p">)))</span>
  <span class="nv">*sorted-environ-assoc*</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*MAX-QUOTA*</span> <span class="mi">100</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-all-users</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-usage</span> <span class="nv">user</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">disk-usage</span> <span class="p">(</span><span class="nf">get-usage</span> <span class="nv">user</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">disk-usage</span> <span class="nv">*MAX-QUOTA*</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">get-all-users</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">string=? </span><span class="nv">user</span> <span class="s">&quot;tchrist&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">user</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">string-split</span> <span class="p">(</span><span class="nf">qx</span> <span class="s">&quot;who|cut -d&#39; &#39; -f1|uniq&quot;</span><span class="p">)</span> <span class="sc">#\newline</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-14</span><span class="p">))</span>

<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">for-each</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">word</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">string-reverse</span> <span class="nv">word</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">line</span> <span class="nv">char-set:graphic</span><span class="p">)))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Updates vector in-place [accepts variable number of vectors]</span>
<span class="c1">; See also the library function, &#39;array-map-in-order!&#39; and its</span>
<span class="c1">; brethren</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-map-in-order!</span> <span class="nv">proc</span> <span class="nv">vec</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">all-vec</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">vec</span> <span class="nv">rest</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">vec</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">end</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">idx</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">cond</span>
              <span class="p">((</span><span class="nb">= </span><span class="nv">idx</span> <span class="nv">end</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
              <span class="p">(</span><span class="nf">else</span>
                <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="nv">idx</span>
                  <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">idx</span><span class="p">))))</span>
                <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">idx</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">)))</span>
      <span class="nv">all-vec</span><span class="p">)))</span>

<span class="c1">;; ----</span>

<span class="c1">; A non-mutating version - illustration only, as library routines</span>
<span class="c1">; [SRFI-43 and built-ins] should be preferred</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-map-in-order</span> <span class="nv">proc</span> <span class="nv">vec</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">all-vec</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">vec</span> <span class="nv">rest</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec-len</span> <span class="p">(</span><span class="nf">reduce</span> <span class="nv">+</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">map </span><span class="nv">vector-length</span> <span class="nv">all-vec</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">new-vec-len</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec-idx</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">all-vec</span> <span class="nv">all-vec</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">new-vec-idx</span> <span class="nv">new-vec-len</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="nf">array-for-each</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">list </span><span class="nv">element</span><span class="p">)))</span>
              <span class="p">(</span><span class="k">set! </span><span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-vec-idx</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">car </span><span class="nv">all-vec</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">all-vec</span><span class="p">))</span> <span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;i =&quot;</span> <span class="nv">item</span><span class="p">))</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;i =&quot;</span> <span class="nv">item</span><span class="p">))</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">; Since a &#39;vector&#39; is mutable, in-place updates allowed</span>
<span class="p">(</span><span class="nf">vector-map-in-order!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">item</span> <span class="mi">1</span><span class="p">))</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mf">0.5</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="nf">vector-map-in-order!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">item</span> <span class="mi">7</span><span class="p">))</span>
  <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Using &#39;for-each&#39; to iterate over several container items is a</span>
<span class="c1">; simple matter of passing a list of those items e.g. a list of</span>
<span class="c1">; strings, or of arrays etc.</span>
<span class="c1">;</span>
<span class="c1">; However, complications arise when:</span>
<span class="c1">; * Heterogenous list of items e.g. list contains all of arrays,</span>
<span class="c1">;   hashes, strings, etc. Necesitates different handling based on type</span>
<span class="c1">; * Item needs updating. It is not possible to alter the item reference</span>
<span class="c1">;   and updating an item&#39;s internals is only possible if the relevant</span>
<span class="c1">;   mutating procedures are implemented e.g. specified string characters</span>
<span class="c1">;   may be altered in-place, but character deletion requires a new be</span>
<span class="c1">;   created [i.e. altering the item reference], so is not possible</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*scalar*</span> <span class="s">&quot;123 &quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot; 123 &quot;</span> <span class="s">&quot;456 &quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*hash*</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="s">&quot;key1&quot;</span> <span class="s">&quot;123 &quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;key2&quot;</span> <span class="s">&quot; 456&quot;</span><span class="p">)))</span>

<span class="c1">; Illustrates iteration / handling of heterogenous types</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">string? </span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nf">do-stuff-with-string</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">((</span><span class="nb">vector? </span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nf">do-stuff-with-vector</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">((</span><span class="nb">pair? </span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nf">do-stuff-with-hash</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">print</span> <span class="s">&quot;unknown type&quot;</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">list </span><span class="nv">*scalar*</span> <span class="nv">*array*</span> <span class="nv">*hash*</span><span class="p">))</span>

<span class="c1">; So, for item-replacement-based updating you need to use explicit</span>
<span class="c1">; iteration e.g. &#39;do&#39; loop, or recursion [as is done in the code for</span>
<span class="c1">; &#39;vector-map-in-order!&#39;] - examples in next section. Or, you could</span>
<span class="c1">; create a new &#39;for-each&#39; type control structure using Scheme&#39;s</span>
<span class="c1">; macro facility [example not shown]</span>

<span class="c1">;; @@PLEAC@@_4.5</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; Whilst a &#39;vector&#39; is mutable, &#39;array-for-each&#39; passes only a copy</span>
<span class="c1">; of each cell, thus there is no way to perform updates</span>
<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="c1">;; ... do some non-array-mutating task with &#39;item&#39;...</span>
    <span class="o">&#39;</span><span class="p">())</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; For mutating operations, use one of the mutating &#39;array-map-...&#39;</span>
<span class="c1">; routines or the custom, &#39;vector-map-in-order!&#39;</span>
<span class="p">(</span><span class="nf">vector-map-in-order!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="c1">;; ... do some array-mutating task with &#39;item&#39;...</span>
    <span class="o">&#39;</span><span class="p">())</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Alternatively, use &#39;do&#39; to iterate over the array and directly</span>
<span class="c1">; update</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">*array*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">vector-length</span><span class="p">))</span>
    <span class="c1">;; ... do some array-mutating task with current element ...</span>
    <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Alternatively, use a &#39;named let&#39; to iterate over array and</span>
<span class="c1">; directly update</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">*array*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">vector-length</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="c1">;; ... do some array-mutating task with current element ...</span>
        <span class="o">&#39;</span><span class="p">()</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*fruits*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot;Apple&quot;</span> <span class="s">&quot;Blackberry&quot;</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">fruit</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">fruit</span> <span class="s">&quot;tastes good in a pie.&quot;</span><span class="p">))</span>
  <span class="nv">*fruits*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">*fruits*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">vector-length</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">*fruits*</span> <span class="nv">i</span><span class="p">)</span> <span class="s">&quot;tastes good in a pie.&quot;</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*rogue-cats*</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Blacky&quot;</span> <span class="s">&quot;Ginger&quot;</span> <span class="s">&quot;Puss&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*name-list*</span> <span class="p">(</span><span class="nf">acons</span> <span class="ss">&#39;felines</span> <span class="nv">*rogue-cats*</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">cat</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">cat</span> <span class="s">&quot;purrs hypnotically..&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">&#39;felines</span> <span class="nv">*name-list*</span><span class="p">)))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">felines</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">&#39;felines</span> <span class="nv">*name-list*</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nb">null? </span><span class="nv">felines</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
    <span class="p">(</span><span class="nf">else</span>
      <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">felines</span><span class="p">)</span> <span class="s">&quot;purrs hypnotically..&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">felines</span><span class="p">)))))</span>

<span class="c1">;; @@PLEAC@@_4.6</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="c1">; Simplest [read: least code] means of removing duplicates is to</span>
<span class="c1">; use SRFI-1&#39;s &#39;delete-duplicates&#39; routine</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*non-uniq-num-list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span> <span class="p">(</span><span class="nf">delete-duplicates</span> <span class="nv">*my-non-uniq-num-list*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="c1">; Another simple alternative is to use SRFI-1&#39;s &#39;lset-union&#39; routine.</span>
<span class="c1">; In general, the &#39;lset-...&#39; routines:</span>
<span class="c1">; - convenient, but not fast; probably best avoided for &#39;large&#39; sets</span>
<span class="c1">; - operate on standard lists, so simple matter of type-converting</span>
<span class="c1">;   arrays and such</span>
<span class="c1">; - care needs to be taken in choosing the needed equality function</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*non-uniq-string-list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;abc&quot;</span> <span class="s">&quot;def&quot;</span> <span class="s">&quot;ghi&quot;</span> <span class="s">&quot;abc&quot;</span> <span class="s">&quot;def&quot;</span> <span class="s">&quot;ghi&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span>
  <span class="p">(</span><span class="nf">lset-union</span> <span class="nv">string=?</span> <span class="nv">*non-uniq-string-list*</span> <span class="nv">*non-uniq-string-list*</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*non-uniq-sym-list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span>
  <span class="p">(</span><span class="nf">lset-union</span> <span class="nv">equal?</span> <span class="nv">*my-non-uniq-sym-list*</span> <span class="nv">*my-non-uniq-sym-list*</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*non-uniq-num-list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span>
  <span class="p">(</span><span class="nf">lset-union</span> <span class="nv">=</span> <span class="nv">*my-non-uniq-num-list*</span> <span class="nv">*my-non-uniq-num-list*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">;; Perl Cookbook-based examples - illustrative only, *not*</span>
<span class="c1">;; recommended approaches</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">1</span> <span class="mi">8</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*seen*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; Use hash to filter out unique items</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*seen*</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*seen*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*seen*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">))))</span>
  <span class="nv">*list*</span><span class="p">)</span>

<span class="c1">; Generate list of unique items</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span>
  <span class="p">(</span><span class="nf">fold-right</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="nv">*seen*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">1</span> <span class="mi">8</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*seen*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; Build list of unique items by checking set membership</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">member </span><span class="nv">item</span> <span class="nv">*seen*</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*seen*</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">*seen*</span><span class="p">))))</span>
  <span class="nv">*list*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*users*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="p">(</span><span class="nf">string-split</span> <span class="p">(</span><span class="nf">qx</span> <span class="s">&quot;who|cut -d&#39; &#39; -f1&quot;</span><span class="p">)</span> <span class="sc">#\newline</span><span class="p">)</span>
    <span class="nv">string&lt;?</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*seen*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; Build list of unique users by checking set membership</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">member </span><span class="nv">user</span> <span class="nv">*seen*</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*seen*</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">*seen*</span><span class="p">))))</span>
  <span class="nv">*list*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_4.7</span>
<span class="c1">; All problems in this section involve, at core, set difference</span>
<span class="c1">; operations. Thus, the most compact and straightforward approach</span>
<span class="c1">; is to utilise SRFI-1&#39;s &#39;lset-difference&#39; routine</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">))</span>

<span class="c1">; *difference* contains elements in *a* but not in *b*: 1 6 8</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*difference*</span> <span class="p">(</span><span class="nf">lset-difference</span> <span class="nv">=</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="c1">; *difference* contains elements in *b* but not in *a*: 2 9</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*difference*</span> <span class="p">(</span><span class="nf">lset-difference</span> <span class="nv">=</span> <span class="nv">*b*</span> <span class="nv">*a*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">;; Perl Cookbook-based example - illustrative only, *not*</span>
<span class="c1">;; recommended approaches</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a-only*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; Build list of items in *a* but not in *b*</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">member </span><span class="nv">item</span> <span class="nv">*b*</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*a-only*</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">*a-only*</span><span class="p">))))</span>
  <span class="nv">*a*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_4.8</span>
<span class="c1">; The SRFI-1 &#39;lset-xxx&#39; routines are appropriate here</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">))</span>

<span class="c1">; Combined elements of *a* and *b* sans duplicates: 1 2 3 5 6 7 8 9</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*union*</span> <span class="p">(</span><span class="nf">lset-union</span> <span class="nv">=</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="c1">; Elements common to both *a* and *b*: 3 5 7</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*intersection*</span> <span class="p">(</span><span class="nf">lset-intersection</span> <span class="nv">=</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="c1">; Elements in *a* but not in *b*: 1 6 8</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*difference*</span> <span class="p">(</span><span class="nf">lset-difference</span> <span class="nv">=</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">;; Perl Cookbook-based example - illustrative only, *not*</span>
<span class="c1">;; recommended approaches</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*union*</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*isect*</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*diff*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ------------</span>

<span class="c1">; Union and intersection</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">*union*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*union*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">)))</span>
  <span class="nv">*a*</span><span class="p">)</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*union*</span> <span class="nv">item</span><span class="p">)</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*isect*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*isect*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">*union*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*union*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">)))</span>
  <span class="nv">*b*</span><span class="p">)</span>

<span class="c1">; Difference *a* and *b*</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*isect*</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*diff*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*diff*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">))))</span>
  <span class="nv">*a*</span><span class="p">)</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*union*</span>
  <span class="p">(</span><span class="nf">fold</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="nv">*union*</span><span class="p">))</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*isect*</span>
  <span class="p">(</span><span class="nf">fold</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="nv">*isect*</span><span class="p">))</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*diff*</span>
  <span class="p">(</span><span class="nf">fold</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="nv">*diff*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Union count:       &quot;</span> <span class="p">(</span><span class="nb">length </span><span class="nv">*union*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Intersection count:&quot;</span> <span class="p">(</span><span class="nb">length </span><span class="nv">*isect*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Difference count:  &quot;</span> <span class="p">(</span><span class="nb">length </span><span class="nv">*diff*</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_4.9</span>
<span class="c1">; Arrays, specifically vectors in the current context, are fixed-size</span>
<span class="c1">; entities; joining several such together requires copying of their</span>
<span class="c1">; contents into a new, appropriately-sized, array. This task may be</span>
<span class="c1">; performed:</span>

<span class="c1">; * Directly: loop through existing arrays copying elements into a</span>
<span class="c1">;   newly-created array</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-join</span> <span class="nv">vec</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">all-vec</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">vec</span> <span class="nv">rest</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec-len</span> <span class="p">(</span><span class="nf">reduce</span> <span class="nv">+</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">map </span><span class="nv">vector-length</span> <span class="nv">all-vec</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">new-vec-len</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec-idx</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">all-vec</span> <span class="nv">all-vec</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">new-vec-idx</span> <span class="nv">new-vec-len</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="nf">array-for-each</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">new-vec-idx</span> <span class="nv">element</span><span class="p">)</span>
              <span class="p">(</span><span class="k">set! </span><span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-vec-idx</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">car </span><span class="nv">all-vec</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">all-vec</span><span class="p">))</span> <span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array1*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*array2*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*newarray*</span>
  <span class="p">(</span><span class="nf">vector-join</span> <span class="nv">*array1*</span> <span class="nv">*array2*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; * Indirectly; convert arrays to lists, append the lists, convert</span>
<span class="c1">;   resulting list back into an array</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array1*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*array2*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*newarray*</span>
  <span class="p">(</span><span class="nb">list-&gt;vector </span><span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">vector-&gt;list </span><span class="nv">*array1*</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-&gt;list </span><span class="nv">*array2*</span><span class="p">))</span> <span class="p">))</span>

<span class="c1">; Of course if random access is not required, it is probably best to simply</span>
<span class="c1">; use lists since a wealth of list manipulation routines are available</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; While Perl offers an all-purpose &#39;splice&#39; routine, a cleaner approach is</span>
<span class="c1">; to separate out such functionality; here three routines are implemented</span>
<span class="c1">; together offering an equivalent to &#39;splice&#39;. The routines are:</span>
<span class="c1">; * vector-replace! [use with &#39;vector-copy&#39; to avoid changing original]</span>
<span class="c1">;   e.g. (vector-replace! vec ...)</span>
<span class="c1">;        (set! new-vec (vector-replace! (vector-copy vec) ...))</span>
<span class="c1">; * vector-delete</span>
<span class="c1">; * vector-insert</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-replace!</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">item</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">all-items</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">rest</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">pos</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">pos</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">in-bounds</span>
           <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">+ </span><span class="nv">pos</span> <span class="p">(</span><span class="nb">length </span><span class="nv">all-items</span><span class="p">))</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)))))</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">in-bounds</span>
      <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="nf">all-items</span> <span class="nv">all-items</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">cond</span>
          <span class="p">((</span><span class="nb">null? </span><span class="nv">all-items</span><span class="p">)</span> <span class="nv">vec</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">else</span>
            <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">car </span><span class="nv">all-items</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">all-items</span><span class="p">)))</span> <span class="p">))</span>
    <span class="c1">;else</span>
      <span class="nv">vec</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-delete</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">len</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">new-vec-len</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="nv">len</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="no">#f</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">pos</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">&lt; </span><span class="nv">new-vec-len</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">vec</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">new-vec-len</span><span class="p">))</span>
        <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">vec-idx</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">new-vec-idx</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">cond</span>
            <span class="p">((</span><span class="nb">= </span><span class="nv">new-vec-idx</span> <span class="nv">new-vec-len</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">else</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">vec-idx</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">vec-idx</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">vec-idx</span> <span class="nv">len</span><span class="p">)))</span>
              <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">vec-idx</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">vec-idx</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-vec-idx</span> <span class="mi">1</span><span class="p">))</span> <span class="p">)))</span> <span class="p">))</span> <span class="p">))</span>

<span class="c1">; This routine would probably benefit from having &#39;cmd&#39; implemented as</span>
<span class="c1">; a keyword argument. However, &#39;cmd&#39; implemented as a positional to keep</span>
<span class="c1">; example simple</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-insert</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">cmd</span> <span class="nv">item</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">all-item-vec</span> <span class="p">(</span><span class="nf">list-&gt;array</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">rest</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">all-item-vec-len</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">all-item-vec</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">vec-len</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="p">(</span><span class="nb">+ </span><span class="nv">vec-len</span> <span class="nv">all-item-vec-len</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">pos</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="nv">cmd</span> <span class="ss">&#39;after</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">pos</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">pos</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">vector-move-left!</span> <span class="nv">vec</span> <span class="mi">0</span> <span class="nv">pos</span> <span class="nv">new-vec</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">vector-move-left!</span> <span class="nv">all-item-vec</span> <span class="mi">0</span> <span class="nv">all-item-vec-len</span> <span class="nv">new-vec</span> <span class="nv">pos</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">vector-move-left!</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">vec-len</span> <span class="nv">new-vec</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">pos</span> <span class="nv">all-item-vec-len</span><span class="p">))</span>
    <span class="nv">new-vec</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*members*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot;Time&quot;</span> <span class="s">&quot;Flies&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*initiates*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot;An&quot;</span> <span class="s">&quot;Arrow&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*members*</span> <span class="p">(</span><span class="nf">vector-join</span> <span class="nv">*members*</span> <span class="nv">*initiates*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*members*</span> <span class="p">(</span><span class="nf">vector-insert</span> <span class="nv">*members*</span> <span class="mi">1</span> <span class="ss">&#39;after</span> <span class="s">&quot;Like&quot;</span> <span class="nv">*initiates*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">*members*</span><span class="p">)</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*members*</span> <span class="p">(</span><span class="nf">vector-replace</span> <span class="nv">*members*</span> <span class="mi">0</span> <span class="s">&quot;Fruit&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*members*</span> <span class="p">(</span><span class="nf">vector-replace</span> <span class="nv">*members*</span> <span class="mi">-2</span> <span class="s">&quot;A&quot;</span> <span class="s">&quot;Banana&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">*members*</span><span class="p">)</span>

<span class="c1">; was: &#39;#(&quot;Time&quot; &quot;Flies&quot; &quot;An&quot; &quot;Arrow&quot;)</span>
<span class="c1">; now: &#39;#(&quot;Fruit&quot; &quot;Flies&quot; &quot;Like&quot; &quot;A&quot; &quot;Banana&quot;)</span>

<span class="c1">;; @@PLEAC@@_4.10</span>
<span class="c1">; As for appending arrays, there is the choice of iterating through</span>
<span class="c1">; the array:</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-reverse!</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">j</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">&gt;= </span><span class="nv">i</span> <span class="nv">j</span><span class="p">)</span> <span class="nv">vec</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="nf">vector-ref-swap!</span> <span class="nv">vec</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nf">vector-reverse!</span> <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">*array*</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="mi">0</span><span class="p">))</span>
  <span class="c1">;; ... do something with *array* ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; or of converting to / from a list, performing any manipulation using</span>
<span class="c1">; the list routines</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*newarray*</span>
  <span class="p">(</span><span class="nb">list-&gt;vector </span><span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nf">sort</span> <span class="p">(</span><span class="nb">vector-&gt;list </span><span class="nv">*array*</span><span class="p">)</span> <span class="nv">&lt;</span><span class="p">))</span> <span class="p">))</span>

<span class="c1">;; @@PLEAC@@_4.11</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Remove first 3 elements</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*front*</span> <span class="p">(</span><span class="nf">vector-delete</span> <span class="nv">*array*</span> <span class="mi">0</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">; Remove last 3 elements</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*end*</span> <span class="p">(</span><span class="nf">vector-delete</span> <span class="nv">*array*</span> <span class="mi">-1</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Another helper routine</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-slice</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">len</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">vec-len</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">pos</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">vec-len</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">pos</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">in-bounds</span>
           <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">+ </span><span class="nv">pos</span> <span class="nv">len</span><span class="p">)</span> <span class="nv">vec-len</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">in-bounds</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">len</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">vec-idx</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="nf">new-vec-idx</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">cond</span>
            <span class="p">((</span><span class="nb">= </span><span class="nv">new-vec-idx</span> <span class="nv">len</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">else</span>
              <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">vec-idx</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">vec-idx</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-vec-idx</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">)))</span>
    <span class="c1">;else</span>
      <span class="nv">vec</span><span class="p">)))</span>

<span class="c1">; Both the following use, &#39;values&#39;, to return two values; this approach</span>
<span class="c1">; is quite contrived and is taken to mimic the Perl examples, not</span>
<span class="c1">; because it is a recommended one [returning a single list would probably</span>
<span class="c1">; be more sensible]</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">shift2</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">vector-slice</span> <span class="nv">vec</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="mi">1</span><span class="p">))</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pop2</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">vector-slice</span> <span class="nv">vec</span> <span class="mi">-1</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="mi">1</span><span class="p">))</span> <span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*friends*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="ss">&#39;Peter</span> <span class="ss">&#39;Paul</span> <span class="ss">&#39;Mary</span> <span class="ss">&#39;Jim</span> <span class="ss">&#39;Tim</span><span class="p">))</span>

<span class="p">(</span><span class="nf">let-values</span> <span class="p">(</span> <span class="p">((</span><span class="nf">this</span> <span class="nv">that</span><span class="p">)</span> <span class="p">(</span><span class="nf">shift2</span> <span class="nv">*friends*</span><span class="p">))</span> <span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">this</span> <span class="s">&quot;:&quot;</span> <span class="nv">that</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*beverages*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="ss">&#39;Dew</span> <span class="ss">&#39;Jolt</span> <span class="ss">&#39;Cola</span> <span class="ss">&#39;Sprite</span> <span class="ss">&#39;Fresca</span><span class="p">))</span>

<span class="p">(</span><span class="nf">let-values</span> <span class="p">(</span> <span class="p">((</span><span class="nf">d1</span> <span class="nv">d2</span><span class="p">)</span> <span class="p">(</span><span class="nf">pop2</span> <span class="nv">*beverages*</span><span class="p">))</span> <span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">d1</span> <span class="s">&quot;:&quot;</span> <span class="nv">d2</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_4.12</span>
<span class="c1">; SRFI-1 [list manipulation] routines are ideal for the types of task</span>
<span class="c1">; in this and the next section, in particular, &#39;for-each&#39; and &#39;find&#39;,</span>
<span class="c1">; &#39;list-index&#39;, and many others for more specialist functions. The same</span>
<span class="c1">; applies to vectors with the SRFI-43 routines, &#39;vector-index&#39; and</span>
<span class="c1">; &#39;vector-skip&#39;, though the approach taken in this chapter has been to</span>
<span class="c1">; implement functionally similar vector manipulation routines to more</span>
<span class="c1">; closely mimic the Perl examples</span>

<span class="c1">; Return #f, or first index for which &#39;pred&#39; returns true</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-first-idx</span> <span class="nv">pred</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">vec-len</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">idx</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">idx</span> <span class="nv">vec-len</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">pred</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">idx</span><span class="p">))</span>
            <span class="nv">idx</span>
          <span class="c1">;else</span>
            <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">idx</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">)))))</span>

<span class="c1">; Return #f, or first index for which &#39;pred&#39; returns true</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">list-first-idx</span> <span class="nv">pred</span> <span class="nv">list</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">idx</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">list</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">null? </span><span class="nv">list</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">pred</span> <span class="p">(</span><span class="nb">car </span><span class="nv">list</span><span class="p">))</span>
          <span class="nv">idx</span>
        <span class="c1">;else</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">idx</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">list</span><span class="p">)))</span> <span class="p">))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nf">vector-first-idx</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">9</span><span class="p">))</span>
    <span class="nv">*array*</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nf">list-first-idx</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">4</span><span class="p">))</span>
    <span class="nv">*list*</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nf">list-index</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">4</span><span class="p">))</span>
    <span class="nv">*list*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; The Perl &#39;highest paid engineer&#39; example isn&#39;t really a &#39;first match&#39;</span>
<span class="c1">; type of problem - the routines shown earlier really aren&#39;t suited to</span>
<span class="c1">; this. Better suited, instead, are the SRFI-1 routines like &#39;fold&#39;,</span>
<span class="c1">; &#39;fold-right&#39; and &#39;reduce&#39;, even old standbys like &#39;filter&#39; and &#39;for-each&#39;</span>

<span class="p">(</span><span class="k">define </span><span class="nv">+null-salary-rec+</span>
  <span class="p">(</span><span class="nb">list </span><span class="o">&#39;</span><span class="p">()</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*salaries*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">43000</span> <span class="ss">&#39;Bob</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;programmer</span> <span class="mi">48000</span> <span class="ss">&#39;Andy</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">35000</span> <span class="ss">&#39;Champ</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">49000</span> <span class="ss">&#39;Bubbles</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;programmer</span> <span class="mi">47000</span> <span class="ss">&#39;Twig</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">34000</span> <span class="ss">&#39;Axel</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*highest-paid-engineer*</span>
  <span class="p">(</span><span class="nf">reduce</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span> <span class="nv">acc</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">if</span>
        <span class="p">(</span><span class="nf">and</span>
          <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="ss">&#39;engineer</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">acc</span><span class="p">)))</span>
        <span class="nv">salary-rec</span>
      <span class="c1">;else</span>
        <span class="nv">acc</span><span class="p">))</span>
    <span class="nv">+null-salary-rec+</span>
    <span class="nv">*salaries*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*highest-paid-engineer*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*highest-paid-engineer*</span>
  <span class="p">(</span><span class="nf">fold-right</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span> <span class="nv">acc</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">acc</span><span class="p">))</span>
        <span class="nv">salary-rec</span>
      <span class="c1">;else</span>
        <span class="nv">acc</span><span class="p">))</span>
    <span class="nv">+null-salary-rec+</span>
    <span class="p">(</span><span class="nf">filter</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="ss">&#39;engineer</span><span class="p">))</span>
      <span class="nv">*salaries*</span><span class="p">))</span> <span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*highest-paid-engineer*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*highest-paid-engineer*</span> <span class="nv">+null-salary-rec+</span><span class="p">)</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">if</span>
      <span class="p">(</span><span class="nf">and</span>
        <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="ss">&#39;engineer</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">*highest-paid-engineer*</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*highest-paid-engineer*</span> <span class="nv">salary-rec</span><span class="p">)))</span>
  <span class="nv">*salaries*</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*highest-paid-engineer*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_4.13</span>
<span class="c1">; All tasks in this section consist of either generating a collection,</span>
<span class="c1">; or filtering a larger collection, of elements matching some criteria;</span>
<span class="c1">; obvious candidates are the &#39;filter&#39; and &#39;array-filter&#39; routines, though</span>
<span class="c1">; others like &#39;for-each&#39; can also be applied</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*list-matching*</span> <span class="p">(</span><span class="nf">filter</span> <span class="nv">PRED</span> <span class="nv">LIST</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*vector-matching*</span> <span class="p">(</span><span class="nf">array-filter</span> <span class="nv">PRED</span> <span class="nv">ARRAY</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*nums*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="nv">e7</span> <span class="mi">3</span><span class="nv">e7</span> <span class="mi">2</span><span class="nv">e7</span> <span class="mi">4</span><span class="nv">e7</span> <span class="mi">1</span><span class="nv">e7</span> <span class="mi">3</span><span class="nv">e7</span> <span class="mi">2</span><span class="nv">e7</span> <span class="mi">4</span><span class="nv">e7</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*bigs*</span>
  <span class="p">(</span><span class="nf">filter</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">num</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">num</span> <span class="mi">1000000</span><span class="p">))</span>
    <span class="nv">*nums*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*users*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">u1</span> <span class="o">.</span> <span class="mi">2</span><span class="nv">e7</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">u2</span> <span class="o">.</span> <span class="mi">1</span><span class="nv">e7</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">u3</span> <span class="o">.</span> <span class="mi">4</span><span class="nv">e7</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">u4</span> <span class="o">.</span> <span class="mi">3</span><span class="nv">e7</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*pigs*</span>
  <span class="p">(</span><span class="nf">fold-right</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="p">(</span><span class="nf">filter</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)</span> <span class="mi">1</span><span class="nv">e7</span><span class="p">))</span>
      <span class="nv">*users*</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*pigs*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*salaries*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">43000</span> <span class="ss">&#39;Bob</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;programmer</span> <span class="mi">48000</span> <span class="ss">&#39;Andy</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">35000</span> <span class="ss">&#39;Champ</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">49000</span> <span class="ss">&#39;Bubbles</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;programmer</span> <span class="mi">47000</span> <span class="ss">&#39;Twig</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">34000</span> <span class="ss">&#39;Axel</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*engineers*</span>
  <span class="p">(</span><span class="nf">filter</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="ss">&#39;engineer</span><span class="p">))</span>
    <span class="nv">*salaries*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*engineers*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*applicants*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a1</span> <span class="mi">26000</span> <span class="ss">&#39;Bob</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a2</span> <span class="mi">28000</span> <span class="ss">&#39;Andy</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a3</span> <span class="mi">24000</span> <span class="ss">&#39;Candy</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*secondary-assistance*</span>
  <span class="p">(</span><span class="nf">filter</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">and</span>
        <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="mi">26000</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="mi">30000</span><span class="p">)))</span>
    <span class="nv">*applicants*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*secondary-assistance*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_4.14</span>
<span class="c1">; Sorting numeric data in Scheme is very straightforward ...</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*unsorted*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span> <span class="mi">8</span> <span class="mi">1</span> <span class="mi">7</span> <span class="mi">4</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Ascending sort - use &#39;&lt;&#39; as comparator</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*sorted*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*unsorted*</span>
    <span class="nv">&lt;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*sorted*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Descending sort - use &#39;&gt;&#39; as comparator</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*sorted*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*unsorted*</span>
    <span class="nv">&gt;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*sorted*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_4.15</span>
<span class="c1">; A customised lambda may be passed as comparator to &#39;sort&#39;, so</span>
<span class="c1">; sorting on one or more &#39;fields&#39; is quite straightforward</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*unordered*</span> <span class="o">&#39;</span><span class="p">(</span> <span class="o">...</span> <span class="p">))</span>

<span class="c1">; COMPARE is some comparator suited for the element type being</span>
<span class="c1">; sorted</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*ordered*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*unordered*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">COMPARE</span> <span class="nv">left</span> <span class="nv">right</span><span class="p">))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*unordered*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;s</span> <span class="mi">34</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;e</span> <span class="mi">12</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;c</span> <span class="mi">45</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;q</span> <span class="mi">11</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;g</span> <span class="mi">24</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*pre-computed*</span>
  <span class="p">(</span><span class="nf">map</span>
    <span class="c1">; Here element is returned unaltered, but it would normally be</span>
    <span class="c1">; transformed in som way</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span> <span class="nv">element</span><span class="p">)</span>
    <span class="nv">*unordered*</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*ordered-pre-computed*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*pre-computed*</span>
    <span class="c1">; Sort on the first field [assume it is the &#39;key&#39;]</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))))</span>

<span class="c1">; Extract the second field [assume it is the &#39;value&#39;]</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*ordered*</span>
  <span class="p">(</span><span class="nf">map</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">element</span><span class="p">))</span>
    <span class="nv">*ordered-pre-computed*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*employees*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Bob</span> <span class="mi">43000</span> <span class="mi">123</span> <span class="mi">42</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Andy</span> <span class="mi">48000</span> <span class="mi">124</span> <span class="mi">35</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Champ</span> <span class="mi">35000</span> <span class="mi">125</span> <span class="mi">37</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Bubbles</span> <span class="mi">49000</span> <span class="mi">126</span> <span class="mi">34</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Twig</span> <span class="mi">47000</span> <span class="mi">127</span> <span class="mi">36</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Axel</span> <span class="mi">34000</span> <span class="mi">128</span> <span class="mi">31</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*ordered*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*employees*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">employee</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">employee</span><span class="p">)</span> <span class="s">&quot;earns $&quot;</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">employee</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*employees*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*bonus*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">125</span> <span class="o">.</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">127</span> <span class="o">.</span> <span class="mi">1500</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">employee</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">bonus</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*bonus*</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">employee</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">bonus</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">()</span>
      <span class="c1">;else</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">employee</span><span class="p">)</span> <span class="s">&quot;earned bonus&quot;</span> <span class="nv">bonus</span><span class="p">)</span> <span class="p">)))</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*employees*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rdelim</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regex</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*filename*</span> <span class="s">&quot;/etc/passwd&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*users*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">port</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">*filename*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line&amp;terminator</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">line&amp;terminator</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">*users*</span>
          <span class="p">(</span><span class="nf">assoc-set!</span>
            <span class="nv">*users*</span>
            <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">string-split</span> <span class="p">(</span><span class="nb">car </span><span class="nv">line&amp;terminator</span><span class="p">)</span> <span class="o">#</span><span class="err">\</span><span class="nv">:</span><span class="p">))</span>
            <span class="no">#t</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">))</span> <span class="p">)))</span>
  <span class="p">(</span><span class="nb">close-input-port </span><span class="nv">port</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">user</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*users*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">)))))</span>

<span class="c1">;; @@PLEAC@@_4.16</span>
<span class="c1">; Use SRFI-1&#39;s &#39;circular-list&#39; routine to build a circular list</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*processes*</span> <span class="p">(</span><span class="nf">circular-list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">processes</span> <span class="nv">*processes*</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Handling process&quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">processes</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">sleep</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">processes</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_4.17</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="c1">; Implements Fischer-Yates shuffle algorithm</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-shuffle!</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="nv">vector-length</span><span class="p">)</span> <span class="p">(</span><span class="nf">j</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">random</span> <span class="nv">vector-length</span><span class="p">))))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
        <span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">j</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">vector-ref-swap!</span> <span class="nv">vec</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))))</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))))</span> <span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-ref-swap!</span> <span class="nv">vec</span> <span class="nv">idx1</span> <span class="nv">idx2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">tmp</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">idx1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="nv">idx1</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">idx2</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="nv">idx2</span> <span class="nv">tmp</span><span class="p">)))</span>

<span class="c1">; Generate vector of values 1 .. 10</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*irange*</span> <span class="p">(</span><span class="nb">list-&gt;vector </span><span class="p">(</span><span class="nf">iota</span> <span class="mi">10</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1">; Shuffle array values</span>
<span class="p">(</span><span class="nf">vector-shuffle!</span> <span class="nv">*irange*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_4.18</span>
<span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; @@INCOMPLETE@@</span>

<span class="c1">;; @@PLEAC@@_4.19</span>
<span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; @@INCOMPLETE@@</span>

<span class="c1">;; @@PLEAC@@_5.0</span>
<span class="c1">;; ---------------------------------------------------------------------</span>
<span class="c1">;; Scheme offers two dictionary types:</span>
<span class="c1">;;</span>
<span class="c1">;; * Association list [list of pairs e.g. &#39;((k1 . v1) (k2 . v2) ...)]</span>
<span class="c1">;; * Hash table [vector of pairs plus hash algorithm]</span>
<span class="c1">;;</span>
<span class="c1">;; Implementation differences aside, they are remarkably similar in that</span>
<span class="c1">;; the functions operating on them are similar named, and offer the same</span>
<span class="c1">;; interface. Examples:</span>
<span class="c1">;;</span>
<span class="c1">;; * Retrieve an item: (assoc-ref hash key)</span>
<span class="c1">;;                     (hash-ref hash key)</span>
<span class="c1">;;</span>
<span class="c1">;; * Update an item:   (assoc-set! hash key value)</span>
<span class="c1">;;                     (hash-set! hash key value)</span>
<span class="c1">;;</span>
<span class="c1">;; Hash tables would tend to be used where performance was critical e.g.</span>
<span class="c1">;; near constant-time lookups, or where entry updates are frequent,</span>
<span class="c1">;; whilst association lists would be used where table-level traversals</span>
<span class="c1">;; and manipulations require maximum flexibility</span>
<span class="c1">;;</span>
<span class="c1">;; Many of the sections include examples using both association lists</span>
<span class="c1">;; and hash tables. However, where only one of these is shown,</span>
<span class="c1">;; implementing the other is usually a trivial exercise. Finally, any</span>
<span class="c1">;; helper functions will be included in the Appendix</span>
<span class="c1">;; ---------------------------------------------------------------------</span>

<span class="c1">; Association lists</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*age*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;Nat</span> <span class="mi">24</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;Jules</span> <span class="mi">25</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;Josh</span> <span class="mi">17</span><span class="p">)))</span>

<span class="c1">;; or, perhaps more compactly:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*age*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Nat</span> <span class="o">.</span> <span class="mi">24</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Jules</span> <span class="o">.</span> <span class="mi">25</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Josh</span> <span class="o">.</span> <span class="mi">17</span><span class="p">)))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Guile built-in association list support</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*age*</span> <span class="p">(</span><span class="nf">acons</span> <span class="ss">&#39;Nat</span> <span class="mi">24</span> <span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*age*</span> <span class="p">(</span><span class="nf">acons</span> <span class="ss">&#39;Jules</span> <span class="mi">25</span> <span class="nv">*age*</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*age*</span> <span class="p">(</span><span class="nf">acons</span> <span class="ss">&#39;Josh</span> <span class="mi">17</span> <span class="nv">*age*</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; SRFI-1 association list support</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*age*</span> <span class="p">(</span><span class="nf">alist-cons</span> <span class="ss">&#39;Nat</span> <span class="mi">24</span> <span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*age*</span> <span class="p">(</span><span class="nf">alist-cons</span> <span class="ss">&#39;Jules</span> <span class="mi">25</span> <span class="nv">*age*</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*age*</span> <span class="p">(</span><span class="nf">alist-cons</span> <span class="ss">&#39;Josh</span> <span class="mi">17</span> <span class="nv">*age*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*food-colour*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Apple</span> <span class="o">.</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Banana</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Lemon</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Carrot</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Hash tables. Guile offers an implementation, and it is also</span>
<span class="c1">; possible to use SRFI-69 hash tables; only the former will be</span>
<span class="c1">; illustrated here</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*age*</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">20</span><span class="p">))</span>
<span class="c1">; or</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*age*</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">20</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*age*</span> <span class="ss">&#39;Nat</span> <span class="mi">24</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*age*</span> <span class="ss">&#39;Jules</span> <span class="mi">25</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*age*</span> <span class="ss">&#39;Josh</span> <span class="mi">17</span><span class="p">)</span>

<span class="p">(</span><span class="nf">hash-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">key</span><span class="p">))</span>
  <span class="nv">*age*</span><span class="p">)</span>

<span class="c1">; or, if vector used as hash table, can also use:</span>

<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="nv">pair</span><span class="p">))</span> <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))))</span>
  <span class="nv">*age*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*food-colour*</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">20</span><span class="p">))</span>

<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*food-colour*</span> <span class="ss">&#39;Apple</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*food-colour*</span> <span class="ss">&#39;Banana</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*food-colour*</span> <span class="ss">&#39;Lemon</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*food-colour*</span> <span class="ss">&#39;Carrot</span> <span class="s">&quot;orange&quot;</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_5.1</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*hash*</span> <span class="p">(</span><span class="nf">acons</span> <span class="nv">key</span> <span class="nv">value</span> <span class="nv">*hash*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*food-colour*</span> <span class="p">(</span><span class="nf">acons</span> <span class="ss">&#39;Raspberry</span> <span class="s">&quot;pink&quot;</span> <span class="nv">*food-colour*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Known foods:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)))</span>
  <span class="nv">*food-colour*</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*hash*</span> <span class="nv">key</span> <span class="nv">value</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*food-colour*</span> <span class="ss">&#39;Raspberry</span> <span class="s">&quot;pink&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Known foods:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">key</span><span class="p">))</span>
  <span class="nv">*food-colour*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_5.2</span>
<span class="c1">; &#39;assoc&#39; returns the pair, (key . value)</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="nv">hash</span><span class="p">)</span>
  <span class="c1">;; ... found ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="c1">;else</span>
  <span class="c1">;; ... not found ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; &#39;assoc-ref&#39; returns the value only</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">hash</span> <span class="nv">key</span><span class="p">)</span>
  <span class="c1">;; ... found ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="c1">;else</span>
  <span class="c1">;; ... not found ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ------------</span>

<span class="c1">; *food-colour* association list from an earlier section</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">name</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">pair</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">name</span> <span class="nv">*food-colour*</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="nv">pair</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span> <span class="s">&quot;is a food&quot;</span><span class="p">)</span>
      <span class="c1">;else</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">name</span><span class="p">)</span> <span class="s">&quot;is a drink&quot;</span><span class="p">)</span> <span class="p">)))</span>
  <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Banana</span> <span class="ss">&#39;Martini</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; &#39;hash-get-handle&#39; returns the pair, (key . value)</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">hash-get-handle</span> <span class="nv">hash</span> <span class="nv">key</span><span class="p">)</span>
  <span class="c1">;; ... found ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="c1">;else</span>
  <span class="c1">;; ... not found ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; &#39;hash-ref&#39; returns the value only</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">hash</span> <span class="nv">key</span><span class="p">)</span>
  <span class="c1">;; ... found ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="c1">;else</span>
  <span class="c1">;; ... not found ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ------------</span>

<span class="c1">; *food-colour* hash table from an earlier section</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">name</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">value</span> <span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">*food-colour*</span> <span class="nv">name</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="nv">value</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">name</span><span class="p">)</span> <span class="s">&quot;is a food&quot;</span><span class="p">)</span>
      <span class="c1">;else</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">name</span><span class="p">)</span> <span class="s">&quot;is a drink&quot;</span><span class="p">)</span> <span class="p">)))</span>
  <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Banana</span> <span class="ss">&#39;Martini</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*age*</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">20</span><span class="p">))</span>

<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*age*</span> <span class="ss">&#39;Toddler</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*age*</span> <span class="ss">&#39;Unborn</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*age*</span> <span class="ss">&#39;Phantasm</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">thing</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">value</span> <span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">*age*</span> <span class="nv">thing</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">display </span><span class="nv">thing</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="nv">value</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot; Exists&quot;</span><span class="p">))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">and </span><span class="nv">value</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">string-null?</span> <span class="nv">value</span><span class="p">)))</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot; Defined&quot;</span><span class="p">))</span>
      <span class="c1">; Testing for non-zero as true is not applicable, so testing</span>
      <span class="c1">; for non-equality with zero</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">and </span><span class="nv">value</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">eq? </span><span class="nv">value</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot; True&quot;</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">))</span>
  <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Toddler</span> <span class="ss">&#39;Unborn</span> <span class="ss">&#39;Phantasm</span> <span class="ss">&#39;Relic</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_5.3</span>
<span class="p">(</span><span class="nf">assoc-remove!</span> <span class="nv">hash</span> <span class="nv">key</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="c1">; *food-colour* association list from an earlier section</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">foods</span>
          <span class="p">(</span><span class="nf">fold-right</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
            <span class="o">&#39;</span><span class="p">()</span>
            <span class="nv">*food-colour*</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">&quot;Keys: &quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">foods</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Values:&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">food</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">colour</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*food-colour*</span> <span class="nv">food</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">cond</span>
            <span class="p">((</span><span class="nf">string-null?</span> <span class="nv">colour</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;(undef) &quot;</span><span class="p">))</span>
            <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">string-append </span><span class="nv">colour</span> <span class="s">&quot; &quot;</span><span class="p">)))</span> <span class="p">)))</span>
      <span class="nv">foods</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Initially:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;\nWith Banana undef&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*food-colour*</span> <span class="ss">&#39;Banana</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;\nWith Banana deleted&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">assoc-remove!</span> <span class="nv">*food-colour*</span> <span class="ss">&#39;Banana</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">hash-remove!</span> <span class="nv">hash</span> <span class="nv">key</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="c1">; *food-colour* hash table from an earlier section</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">foods</span>
          <span class="p">(</span><span class="nf">hash-fold</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="nv">value</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">key</span> <span class="nv">accum</span><span class="p">))</span>
            <span class="o">&#39;</span><span class="p">()</span>
            <span class="nv">*food-colour*</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">&quot;Keys: &quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">foods</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Values:&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">food</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">colour</span> <span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">*food-colour*</span> <span class="nv">food</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">cond</span>
            <span class="p">((</span><span class="nf">string-null?</span> <span class="nv">colour</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;(undef) &quot;</span><span class="p">))</span>
            <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">string-append </span><span class="nv">colour</span> <span class="s">&quot; &quot;</span><span class="p">)))</span> <span class="p">)))</span>
      <span class="nv">foods</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Initially:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;\nWith Banana undef&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*food-colour*</span> <span class="ss">&#39;Banana</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;\nWith Banana deleted&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">hash-remove!</span> <span class="nv">*food-colour*</span> <span class="ss">&#39;Banana</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print-foods</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_5.4</span>
<span class="c1">; Since an association list is nothing more than a list of pairs, it</span>
<span class="c1">; may be traversed using &#39;for-each&#39;</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">key</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">value</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)))</span>
      <span class="c1">;; ... do something with key / value ...</span>
      <span class="o">&#39;</span><span class="p">()))</span>
  <span class="nv">hash</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; A &#39;for-each&#39;-like function is available for hash table traversal</span>
<span class="p">(</span><span class="nf">hash-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="nv">value</span><span class="p">)</span>
    <span class="c1">;; ... do something with key / value ...</span>
    <span class="o">&#39;</span><span class="p">())</span>
  <span class="nv">hash</span><span class="p">)</span>

<span class="c1">; If the hash table is directly implemented as a vector, then it is</span>
<span class="c1">; also possible to traverse it using, &#39;array-for-each&#39;, though a</span>
<span class="c1">; check for empty slots is needed</span>
<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="nv">pair</span><span class="p">))</span> <span class="o">...</span> <span class="k">do </span><span class="nv">something</span> <span class="nv">with</span> <span class="nv">key</span> <span class="nv">/</span> <span class="nv">value</span> <span class="o">...</span><span class="p">))</span>
  <span class="nv">hash</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; *food-colour* association list from an earlier section</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">food</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">colour</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">food</span><span class="p">)</span> <span class="s">&quot;is&quot;</span> <span class="nv">colour</span><span class="p">)</span> <span class="p">))</span>
  <span class="nv">*food-colour*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; *food-colour* association list from an earlier section</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">food</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">food</span><span class="p">)</span> <span class="s">&quot;is&quot;</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*food-colour*</span> <span class="nv">food</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="p">(</span><span class="nf">fold-right</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="nv">*food-colour*</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">string&lt;? </span><span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">right</span><span class="p">)))))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rdelim</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regex</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*filename*</span> <span class="s">&quot;from.txt&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*from*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">port</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">*filename*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line&amp;terminator</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">line&amp;terminator</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">key</span> <span class="p">(</span><span class="nf">string-&gt;symbol</span>
                      <span class="p">(</span><span class="nf">match:substring</span>
                        <span class="p">(</span><span class="nf">string-match</span>
                          <span class="s">&quot;^From: (.*)&quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">line&amp;terminator</span><span class="p">))</span>
                        <span class="mi">1</span><span class="p">)</span> <span class="p">))</span>
               <span class="p">(</span><span class="nf">value</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*from*</span> <span class="nv">key</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">value</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="k">set! </span><span class="nv">*from*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*from*</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">value</span><span class="p">))))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">))</span> <span class="p">)))</span>
  <span class="p">(</span><span class="nb">close-input-port </span><span class="nv">port</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">person</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">person</span><span class="p">)</span> <span class="s">&quot;:&quot;</span>
           <span class="p">(</span><span class="nb">number-&gt;string </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*from*</span> <span class="nv">person</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="p">(</span><span class="nf">fold-right</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="nv">*from*</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">string&lt;? </span><span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">right</span><span class="p">)))))</span>

<span class="c1">;; @@PLEAC@@_5.5</span>
<span class="c1">; All approaches shown in the previous section apply here also, so</span>
<span class="c1">; there is little to be gained by repeating those examples [i.e. the</span>
<span class="c1">; use of &#39;for-each&#39; and similar]. It is always possible, of course,</span>
<span class="c1">; to directly recurse over an association list:</span>

<span class="c1">; *food-colour* association list from an earlier section</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*sorted-food-colour*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*food-colour*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))</span> <span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">hash</span> <span class="nv">*sorted-food-colour*</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nb">null? </span><span class="nv">hash</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
    <span class="p">(</span><span class="nf">else</span>
      <span class="p">(</span><span class="nf">print</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">car </span><span class="nv">hash</span><span class="p">)))</span> <span class="s">&quot;=&gt;&quot;</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">car </span><span class="nv">hash</span><span class="p">))</span> <span class="p">)</span>
      <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">hash</span><span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; @@PLEAC@@_5.6</span>
<span class="c1">; AFAIK, Scheme doesn&#39;t offer a facility similar to Perl&#39;s &#39;Tie::IxHash&#39;.</span>
<span class="c1">; Therefore, use an association list if retrieval [from a dictionary</span>
<span class="c1">; type container] in insertion order is required.</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*food-colour*</span> <span class="p">(</span><span class="nf">acons</span> <span class="ss">&#39;Banana</span> <span class="s">&quot;Yellow&quot;</span> <span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*food-colour*</span> <span class="p">(</span><span class="nf">acons</span> <span class="ss">&#39;Apple</span> <span class="s">&quot;Green&quot;</span> <span class="nv">*food-colour*</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*food-colour*</span> <span class="p">(</span><span class="nf">acons</span> <span class="ss">&#39;Lemon</span> <span class="s">&quot;yellow&quot;</span> <span class="nv">*food-colour*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;In insertion order, the foods are:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">food</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">colour</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;  &quot;</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">food</span><span class="p">))</span> <span class="p">))</span>
  <span class="nv">*food-colour*</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Still in insertion order, the food&#39;s colours are:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">food</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">colour</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">food</span><span class="p">)</span> <span class="s">&quot;is coloured&quot;</span> <span class="nv">colour</span><span class="p">)</span> <span class="p">))</span>
  <span class="nv">*food-colour*</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Of course, insertion order is lost if the association list is sorted,</span>
<span class="c1">; or elements removed, so if maintaining insertion order is vital, it</span>
<span class="c1">; might pay to associate data with a timestamp [e.g. create a timestamped</span>
<span class="c1">; record / structure], and manipulate those entities [no example given]</span>

<span class="c1">;; @@PLEAC@@_5.7</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*ttys*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user-tty-pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">user-tty-pair</span> <span class="p">(</span><span class="nf">string-split</span> <span class="nv">user-tty-pair</span> <span class="sc">#\space</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">user</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nb">car </span><span class="nv">user-tty-pair</span><span class="p">)))</span>
           <span class="p">(</span><span class="nf">newtty</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">user-tty-pair</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">current-ttys</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*ttys*</span> <span class="nv">user</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*ttys*</span>
        <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*ttys*</span> <span class="nv">user</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">current-ttys</span><span class="p">)</span>
            <span class="nv">newtty</span>
            <span class="p">(</span><span class="nb">string-append </span><span class="nv">current-ttys</span> <span class="s">&quot; &quot;</span> <span class="nv">newtty</span><span class="p">))</span> <span class="p">))))</span>
  <span class="p">(</span><span class="nf">string-split</span> <span class="p">(</span><span class="nf">qx</span> <span class="s">&quot;who|cut -d&#39; &#39; -f1,2&quot;</span><span class="p">)</span> <span class="sc">#\newline</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user-ttys</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">user-ttys</span><span class="p">))</span> <span class="s">&quot;:&quot;</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">user-ttys</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*ttys*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">)))))</span> <span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regex</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multi-hash-delete</span> <span class="nv">hash</span> <span class="nv">key</span> <span class="nv">value</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">value-found</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">hash</span> <span class="nv">key</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">value-found</span>
      <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">hash</span> <span class="nv">key</span>
        <span class="p">(</span><span class="nf">regexp-substitute/global</span>
          <span class="no">#f</span> <span class="p">(</span><span class="nf">string-match</span> <span class="nv">value</span> <span class="nv">value-found</span><span class="p">)</span> <span class="ss">&#39;pre</span> <span class="s">&quot;&quot;</span> <span class="ss">&#39;post</span> <span class="s">&quot;&quot;</span><span class="p">)))))</span>

<span class="c1">;; @@PLEAC@@_5.8</span>
<span class="c1">; Alternate implementatons of a hash inversion function; both assume</span>
<span class="c1">; key is a symbol, value is a string</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">assoc-invert</span> <span class="nv">assoc</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">map</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">cons</span>
        <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))))</span>
    <span class="nv">assoc</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">assoc-invert</span> <span class="nv">assoc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nb">assoc </span><span class="nv">assoc</span><span class="p">)</span> <span class="p">(</span><span class="nf">new-assoc</span> <span class="o">&#39;</span><span class="p">()))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">null? </span><span class="nv">assoc</span><span class="p">)</span> <span class="nv">new-assoc</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">assoc</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">acons</span>
                <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nb">cdar </span><span class="nv">assoc</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">caar </span><span class="nv">assoc</span><span class="p">))</span> <span class="nv">new-assoc</span><span class="p">))</span> <span class="p">))</span> <span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*surname*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Mickey</span> <span class="o">.</span> <span class="s">&quot;Mantle&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Babe</span> <span class="o">.</span> <span class="s">&quot;Ruth&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*first-name*</span> <span class="p">(</span><span class="nf">assoc-invert</span> <span class="nv">*surname*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*first-name*</span> <span class="ss">&#39;Mantle</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; foodfind</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*given*</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*colour*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Apple</span> <span class="o">.</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Lemon</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Carrot</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*food*</span> <span class="p">(</span><span class="nf">assoc-invert</span> <span class="nv">*colour*</span><span class="p">))</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*colour*</span> <span class="nv">*given*</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span>
    <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">*given*</span><span class="p">)</span>
    <span class="s">&quot;is a food with colour&quot;</span>
    <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*colour*</span> <span class="nv">*given*</span><span class="p">)))</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*food*</span> <span class="nv">*given*</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span>
    <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*food*</span> <span class="nv">*given*</span><span class="p">)</span>
    <span class="s">&quot;is a food with colour&quot;</span>
    <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">*given*</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_5.9</span>
<span class="c1">; *food-colour* association list from an earlier section</span>

<span class="c1">; Use &#39;sort&#39; to sort the entire hash, on key or on value, ascending or</span>
<span class="c1">; descending order</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*sorted-on-key:food-colour*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*food-colour*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*sorted-on-value:food-colour*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*food-colour*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">cdr </span><span class="nv">left</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">cdr </span><span class="nv">right</span><span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">food</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">colour</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">print</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">food</span><span class="p">)</span>
        <span class="s">&quot;is&quot;</span>
        <span class="nv">colour</span><span class="p">)))</span>
  <span class="nv">*sorted-on-key:food-colour*</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Alternatively, generate a list of keys or values, sort as required,</span>
<span class="c1">; and use list to guide the hash traversal</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*sorted-food-colour-keys*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="p">(</span><span class="nf">fold-right</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="nv">*food-colour*</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">left</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">right</span><span class="p">)))</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*sorted-food-colour-values*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="p">(</span><span class="nf">fold-right</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="nv">*food-colour*</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">string&lt;? </span><span class="nv">left</span> <span class="nv">right</span><span class="p">))</span> <span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">food</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">food</span><span class="p">)</span> <span class="s">&quot;is&quot;</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*food-colour*</span> <span class="nv">food</span><span class="p">)))</span>
  <span class="nv">*sorted-food-colour-keys*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_5.10</span>
<span class="c1">; If merging is defined as the combining of the contents of two or more</span>
<span class="c1">; hashes, then it is simply a matter of copying the contents of each</span>
<span class="c1">; into a new hash</span>

<span class="c1">; Association lists can simply be appended together</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*food-colour*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Apple</span> <span class="o">.</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Banana</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Lemon</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Carrot</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*drink-colour*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Galliano</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Mai</span> <span class="nv">Tai</span> <span class="o">.</span> <span class="s">&quot;blue&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*ingested-colour*</span> <span class="p">(</span><span class="nb">append </span><span class="nv">*food-colour*</span> <span class="nv">*drink-colour*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Hash tables built from vectors can be copied element by element into</span>
<span class="c1">; a new vector, or spliced together using &#39;vector-join&#39; [see Chapter 4]</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*food-colour*</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">20</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="c1">; ...</span>
  <span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*drink-colour*</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">20</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="c1">; ...</span>
  <span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*ingested-colour*</span>
  <span class="p">(</span><span class="nf">vector-join</span> <span class="nv">*food-colour*</span> <span class="nv">*drink-colour*</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_5.11</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*common*</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*this-not-that*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*dict1*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Apple</span> <span class="o">.</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Lemon</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Carrot</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*dict2*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Apple</span> <span class="o">.</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Carrot</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Find items common to &#39;*dict1*&#39; and &#39;*dict2*&#39;</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">key</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">value</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*dict2*</span> <span class="nv">key</span><span class="p">)</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">*common*</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">key</span> <span class="nv">*common*</span><span class="p">)))</span> <span class="p">))</span>
  <span class="nv">*dict1*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Find items in &#39;*dict1*&#39; but not &#39;*dict2*&#39;</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">key</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">value</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*dict2*</span> <span class="nv">key</span><span class="p">))</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">*this-not-that*</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">key</span> <span class="nv">*this-not-that*</span><span class="p">)))</span> <span class="p">))</span>
  <span class="nv">*dict1*</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*non-citrus*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*citrus-colour*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Lemon</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Orange</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Lime</span> <span class="o">.</span> <span class="s">&quot;green&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*food-colour*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Apple</span> <span class="o">.</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Banana</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Lemon</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Carrot</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">key</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">value</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*citrus-colour*</span> <span class="nv">key</span><span class="p">))</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">*non-citrus*</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">key</span> <span class="nv">*non-citrus*</span><span class="p">)))</span> <span class="p">))</span>
  <span class="nv">*food-colour*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_5.12</span>
<span class="c1">; All objects [including functions] are first class entities, so there</span>
<span class="c1">; is no problem / special treatment needed to use any object, including</span>
<span class="c1">; those classed as &#39;references&#39; [e.g. file handles or ports] as keys</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*ports*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">filename</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">port</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">filename</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*ports*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*ports*</span> <span class="nv">port</span> <span class="nv">filename</span><span class="p">))</span> <span class="p">))</span>
  <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;/etc/termcap&quot;</span> <span class="s">&quot;/vmlinux&quot;</span> <span class="s">&quot;/bin/cat&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;open files: &quot;</span>
    <span class="p">(</span><span class="nf">string-drop</span>
      <span class="p">(</span><span class="nf">fold-right</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;, &quot;</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
        <span class="s">&quot;&quot;</span>
        <span class="nv">*ports*</span><span class="p">)</span>
      <span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">port</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">filename</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">seek</span> <span class="nv">port</span> <span class="mi">0</span> <span class="nv">SEEK_END</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">print</span> <span class="nv">filename</span> <span class="s">&quot;is&quot;</span> <span class="p">(</span><span class="nb">number-&gt;string </span><span class="p">(</span><span class="nf">ftell</span> <span class="nv">port</span><span class="p">))</span> <span class="s">&quot;bytes long.&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">close-input-port </span><span class="nv">port</span><span class="p">)</span> <span class="p">))</span>
  <span class="nv">*ports*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_5.13</span>
<span class="c1">; An association list takes on the size of the number of elements with</span>
<span class="c1">; which it is initialised, so presizing is implicit</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*hash*</span> <span class="o">&#39;</span><span class="p">())</span>         <span class="c1">; zero elements</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*hash*</span>              <span class="c1">; three elements</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Apple</span> <span class="o">.</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Lemon</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Carrot</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; A size [i.e. number of entries] must be specified when a hash table</span>
<span class="c1">; is created, so presizing is implicit</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*hash*</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">100</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*hash*</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">100</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">;; @@PLEAC@@_5.14</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span>
  <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span> <span class="ss">&#39;d</span> <span class="ss">&#39;d</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span> <span class="ss">&#39;c</span> <span class="ss">&#39;d</span> <span class="ss">&#39;d</span> <span class="ss">&#39;e</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*count*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">value</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*count*</span> <span class="nv">element</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">value</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*count*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*count*</span> <span class="nv">element</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">value</span><span class="p">)))))</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*count*</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">20</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">value</span> <span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">*count*</span> <span class="nv">element</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">value</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">*count*</span> <span class="nv">element</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">value</span><span class="p">))))</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_5.15</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*father*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Cain</span> <span class="o">.</span> <span class="nv">Adam</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Abel</span> <span class="o">.</span> <span class="nv">Adam</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Seth</span> <span class="o">.</span> <span class="nv">Adam</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Enoch</span> <span class="o">.</span> <span class="nv">Cain</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Irad</span> <span class="o">.</span> <span class="nv">Enoch</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Mehujael</span> <span class="o">.</span> <span class="nv">Irad</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Methusael</span> <span class="o">.</span> <span class="nv">Mehujael</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Lamech</span> <span class="o">.</span> <span class="nv">Methusael</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Jabal</span> <span class="o">.</span> <span class="nv">Lamech</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Jubal</span> <span class="o">.</span> <span class="nv">Lamech</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Tubalcain</span> <span class="o">.</span> <span class="nv">Lamech</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">Enos</span> <span class="o">.</span> <span class="nv">Seth</span><span class="p">)))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rdelim</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">port</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">*filename*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line&amp;terminator</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">line&amp;terminator</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">person</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nb">car </span><span class="nv">line&amp;terminator</span><span class="p">))))</span>
          <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">father</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*father*</span> <span class="nv">person</span><span class="p">)))</span>
            <span class="p">(</span><span class="k">if </span><span class="nv">father</span>
            <span class="p">(</span><span class="nf">begin</span>
              <span class="p">(</span><span class="nf">print</span> <span class="nv">father</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*father*</span> <span class="nv">father</span><span class="p">))</span> <span class="p">)))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">))</span> <span class="p">))))</span>
  <span class="p">(</span><span class="nb">close-input-port </span><span class="nv">port</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rdelim</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">assoc-invert-N:M</span> <span class="nv">assoc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">new-assoc</span> <span class="o">&#39;</span><span class="p">()))</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">old-key</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">new-key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">new-key-found</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">new-assoc</span> <span class="nv">new-key</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">new-key-found</span><span class="p">)</span>
            <span class="p">(</span><span class="k">set! </span><span class="nv">new-assoc</span> <span class="p">(</span><span class="nf">acons</span> <span class="nv">new-key</span> <span class="p">(</span><span class="nb">list </span><span class="nv">old-key</span><span class="p">)</span> <span class="nv">new-assoc</span><span class="p">))</span>
          <span class="c1">;else</span>
            <span class="p">(</span><span class="k">set! </span><span class="nv">new-assoc</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">new-assoc</span> <span class="nv">new-key</span>
                            <span class="p">(</span><span class="nb">cons </span><span class="nv">old-key</span> <span class="nv">new-key-found</span><span class="p">)))</span> <span class="p">)))</span>
      <span class="nv">assoc</span><span class="p">)</span>
  <span class="nv">new-assoc</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*children*</span> <span class="p">(</span><span class="nf">assoc-invert-N:M</span> <span class="nv">*father*</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">port</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">*filename*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line&amp;terminator</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">line&amp;terminator</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">person</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nb">car </span><span class="nv">line&amp;terminator</span><span class="p">)))</span>
               <span class="p">(</span><span class="nf">children-found</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*children*</span> <span class="nv">person</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">person</span><span class="p">)</span> <span class="s">&quot;begat:&quot;</span><span class="p">)</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">children-found</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;nobody&quot;</span><span class="p">)</span>
          <span class="c1">;else</span>
            <span class="p">(</span><span class="nf">for-each</span>
              <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">child</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">child</span><span class="p">)</span> <span class="s">&quot;,&quot;</span><span class="p">))</span>
              <span class="nv">children-found</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">))</span> <span class="p">))))</span>
  <span class="p">(</span><span class="nb">close-input-port </span><span class="nv">port</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_5.16</span>
<span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; @@INCOMPLETE@@</span>

<span class="c1">;; @@PLEAC@@_7.0</span>
<span class="c1">;; use (open-input-file filename) or (open filename O_RDONLY)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">input</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="s">&quot;/usr/local/widgets/data&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">input</span> <span class="ss">&#39;concat</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;blue&quot;</span> <span class="nv">line</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">display </span><span class="nv">line</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">input</span> <span class="ss">&#39;concat</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">close</span> <span class="nv">input</span><span class="p">)</span>

<span class="c1">;; Many I/O functions default to the logical STDIN/OUT</span>

<span class="c1">;; You can also explicitly get the standard ports with</span>
<span class="c1">;; [set-]current-{input,output,error}-port.</span>

<span class="c1">;; format takes a port as the first argument.  If #t is given, format</span>
<span class="c1">;; writes to stdout, if #f is given, format returns a string.</span>

<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>     <span class="c1">; reads from stdin</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;[0-9]&quot;</span> <span class="nv">line</span><span class="p">))</span>
           <span class="c1">;; writes to stderr</span>
           <span class="p">(</span><span class="nb">display </span><span class="s">&quot;No digit found.\n&quot;</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">))</span>
           <span class="c1">;; writes to stdout</span>
           <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Read: ~A\n&quot;</span> <span class="nv">line</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))))</span>

<span class="c1">;; use open-output-file</span>

<span class="p">(</span><span class="k">define </span><span class="nv">logfile</span> <span class="p">(</span><span class="nb">open-output-file </span><span class="s">&quot;/tmp/log&quot;</span><span class="p">))</span>

<span class="c1">;; increasingly specific ways of closing ports (it&#39;s safe to close a</span>
<span class="c1">;; closed port)</span>

<span class="p">(</span><span class="nf">close</span> <span class="nv">logfile</span><span class="p">)</span>                <span class="c1">; #t</span>
<span class="p">(</span><span class="nf">close-port</span> <span class="nv">logfile</span><span class="p">)</span>           <span class="c1">; #f (already closed)</span>
<span class="p">(</span><span class="nb">close-output-port </span><span class="nv">logfile</span><span class="p">)</span>    <span class="c1">; unspecified</span>

<span class="c1">;; you can rebind standard ports with set-current-&lt;foo&gt;-port:</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">old-out</span> <span class="p">(</span><span class="nf">current-output-port</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">set-current-output-port</span> <span class="nv">logfile</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;Countdown initiated ...\n&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">set-current-output-port</span> <span class="nv">old-out</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;You have 30 seconds to reach minimum safety distance.\n&quot;</span><span class="p">))</span>

<span class="c1">;; or</span>

<span class="p">(</span><span class="nb">with-output-to-file </span><span class="nv">logfile</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;Countdown initiated ...\n&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">display </span><span class="s">&quot;You have 30 seconds to reach minimum safety distance.\n&quot;</span><span class="p">)</span>


<span class="c1">;; @@PLEAC@@_7.1</span>
<span class="p">(</span><span class="k">define </span><span class="nv">source</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">path</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">sink</span> <span class="p">(</span><span class="nb">open-output-file </span><span class="nv">path</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">source</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="nv">O_RDONLY</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">sink</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="nv">O_WRONLY</span><span class="p">))</span>

<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">path</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open-file</span> <span class="nv">path</span> <span class="s">&quot;r&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="nv">O_RDONLY</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nb">open-output-file </span><span class="nv">path</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open-file</span> <span class="nv">path</span> <span class="s">&quot;w&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">O_WRONLY</span> <span class="nv">O_TRUNC</span> <span class="nv">O_CREAT</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">O_WRONLY</span> <span class="nv">O_EXCL</span> <span class="nv">O_CREAT</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open-file</span> <span class="nv">path</span> <span class="s">&quot;a&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">O_WRONLY</span> <span class="nv">O_APPEND</span> <span class="nv">O_CREAT</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">O_WRONLY</span> <span class="nv">O_APPEND</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="nv">O_RDWR</span><span class="p">))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open-file</span> <span class="nv">path</span> <span class="s">&quot;r+&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">O_RDWR</span> <span class="nv">O_CREAT</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">path</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">O_RDWR</span> <span class="nv">O_EXCL</span> <span class="nv">O_CREAT</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>

<span class="c1">;; @@PLEAC@@_7.2</span>
<span class="c1">;; Nothing different needs to be done with Guile</span>

<span class="c1">;; @@PLEAC@@_7.3</span>
<span class="p">(</span><span class="k">define </span><span class="nv">expand-user</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">rx</span> <span class="p">(</span><span class="nf">make-regexp</span> <span class="s">&quot;^\\~([^/]+)?&quot;</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">filename</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">m</span> <span class="p">(</span><span class="nf">regexp-exec</span> <span class="nv">rx</span> <span class="nv">filename</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if </span><span class="nv">m</span>
          <span class="p">(</span><span class="nf">string-append</span>
           <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">passwd:dir</span> <span class="p">(</span><span class="nf">getpwnam</span> <span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)))</span>
             <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">getenv</span> <span class="s">&quot;HOME&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">getenv</span> <span class="s">&quot;LOGDIR&quot;</span><span class="p">)</span>
                 <span class="p">(</span><span class="nf">passwd:dir</span> <span class="p">(</span><span class="nf">getpwuid</span> <span class="p">(</span><span class="nf">cuserid</span><span class="p">)))</span> <span class="s">&quot;&quot;</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">substring </span><span class="nv">filename</span> <span class="p">(</span><span class="nf">match:end</span> <span class="nv">m</span><span class="p">)))</span>
          <span class="nv">filename</span><span class="p">)))))</span>

<span class="c1">;; @@PLEAC@@_7.4</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open-file</span> <span class="nv">filename</span> <span class="nv">mode</span><span class="p">))</span>  <span class="c1">; raise an exception on error</span>

<span class="c1">;; use catch to trap errors</span>
<span class="p">(</span><span class="nf">catch</span> <span class="ss">&#39;system-error</span> <span class="c1">; the type of error thrown</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">port</span> <span class="p">(</span><span class="nf">open-file</span> <span class="nv">filename</span> <span class="nv">mode</span><span class="p">)))</span> <span class="c1">; thunk to try</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>  <span class="c1">; exception handler</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">fmt</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">args</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">msg&amp;path</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">args</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">format</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">)</span> <span class="nv">fmt</span> <span class="p">(</span><span class="nb">car </span><span class="nv">msg&amp;path</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">msg&amp;path</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">newline</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_7.5</span>
<span class="c1">;; use the POSIX tmpnam</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">name</span> <span class="p">(</span><span class="nf">tmpnam</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">call-with-output-file </span><span class="nv">name</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">port</span><span class="p">)</span>
      <span class="c1">;; ... output to port</span>
      <span class="o">&#39;</span><span class="p">())))</span>

<span class="c1">;; better to test and be sure you have exclusive access to the file</span>
<span class="c1">;; (temp file name will be available as (port-filename port))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">open-temp-file</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">name</span> <span class="p">(</span><span class="nf">tmpnam</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">catch</span> <span class="ss">&#39;system-error</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">open</span> <span class="nv">name</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">O_RDWR</span> <span class="nv">O_CREAT</span> <span class="nv">O_EXCL</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">tmpnam</span><span class="p">))))))</span>

<span class="c1">;; or let mkstemp! do the work for you:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">port</span> <span class="p">(</span><span class="nf">mkstemp!</span> <span class="nv">template-string-ending-in-XXXXXX</span><span class="p">))</span>

<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">tmpl</span> <span class="s">&quot;/tmp/programXXXXXX&quot;</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">port</span> <span class="p">(</span><span class="nf">mkstemp!</span> <span class="nv">tmpl</span><span class="p">)))</span>
  <span class="c1">;; tmpl now contains the name of the temp file,</span>
  <span class="c1">;; e.g. &quot;/tmp/programhVoEzw&quot;</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="mi">10</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">format</span> <span class="nv">port</span> <span class="s">&quot;~A\n&quot;</span> <span class="nv">i</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">seek</span> <span class="nv">port</span> <span class="mi">0</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;Tmp file has:\n&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;concat</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;concat</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">line</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">close</span> <span class="nv">port</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_7.6</span>
<span class="c1">;; string ports are ideal for this</span>

<span class="p">(</span><span class="k">define </span><span class="nv">DATA</span> <span class="s">&quot;</span>
<span class="s">your data goes here</span>
<span class="s">&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">call-with-input-string</span>
 <span class="nv">DATA</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">port</span><span class="p">)</span>
   <span class="c1">;; ... process input from port</span>
   <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">;; or</span>

<span class="p">(</span><span class="nf">with-input-from-string</span> <span class="nv">DATA</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
    <span class="c1">;; ... stdin now comes from DATA</span>
    <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">;; @@PLEAC@@_7.7</span>
<span class="c1">;; to process lines of current-input-port:</span>
<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
  <span class="c1">;; ... do something with line</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; a general filter template:</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">line</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">newline</span><span class="p">)))</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span>
  <span class="c1">;; ... handle options here</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">body</span><span class="p">)</span>     <span class="c1">; no args, just call body on stdin</span>
    <span class="p">(</span><span class="nb">for-each </span> <span class="c1">; otherwise, call body with stdin set to each arg in turn</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">file</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">catch</span> <span class="ss">&#39;system-error</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
           <span class="p">(</span><span class="nb">with-input-from-file </span><span class="nv">file</span>
             <span class="nv">body</span><span class="p">))</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">format</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">caaddr </span><span class="nv">args</span><span class="p">)</span>
                   <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdaddr </span><span class="nv">args</span><span class="p">)))</span>
           <span class="p">(</span><span class="nb">newline </span><span class="p">(</span><span class="nf">current-error-port</span><span class="p">)))))</span>
     <span class="nv">args</span><span class="p">)))</span>

<span class="c1">;; example: count-chunks:</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">format</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regex</span><span class="p">))</span>

<span class="c1">;; also use directory-files from 9.5 and globbing functions from 9.6</span>

<span class="c1">;; can use (ice-9 getopt-long) described in chapter 15, or process</span>
<span class="c1">;; options by hand</span>
<span class="p">(</span><span class="k">define </span><span class="nv">opt-append</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">opt-ignore-ints</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">opt-nostdout</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">opt-unbuffer</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>

<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">opts</span> <span class="nv">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">opts</span><span class="p">)))</span>
    <span class="p">((</span><span class="k">or </span><span class="p">(</span><span class="nb">null? </span><span class="nv">opts</span><span class="p">)</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">string-ref </span><span class="p">(</span><span class="nb">car </span><span class="nv">opts</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="sc">#\-</span><span class="p">)))</span>
     <span class="p">(</span><span class="k">set! </span><span class="nv">args</span> <span class="nv">opts</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">opt</span> <span class="p">(</span><span class="nb">car </span><span class="nv">opts</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">string=? </span><span class="nv">opt</span> <span class="s">&quot;-a&quot;</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">opt-append</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">opt-append</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">string=? </span><span class="nv">opt</span> <span class="s">&quot;-i&quot;</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">opt-ignore-ints</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">opt-ignore-ints</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">string=? </span><span class="nv">opt</span> <span class="s">&quot;-n&quot;</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">opt-nostdout</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">opt-nostdout</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">string=? </span><span class="nv">opt</span> <span class="s">&quot;-u&quot;</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">opt-unbuffer</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">opt-unbuffer</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">throw</span> <span class="ss">&#39;usage-error</span> <span class="s">&quot;Unexpected argument: ~A&quot;</span> <span class="nv">opt</span><span class="p">)))))</span>

<span class="c1">;; default to all C source files</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">args</span> <span class="p">(</span><span class="nf">glob</span> <span class="s">&quot;*.[Cch]&quot;</span> <span class="s">&quot;.&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">find-login</span><span class="p">)</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">string-match</span> <span class="s">&quot;login&quot;</span> <span class="nv">line</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">display </span><span class="nv">line</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">newline</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lowercase</span><span class="p">)</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">string-downcase</span> <span class="nv">line</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">newline</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">count-chunks</span><span class="p">)</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">chunks</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">((</span><span class="k">or </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">string=? </span><span class="nv">line</span> <span class="s">&quot;__DATA__&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">string=? </span><span class="nv">line</span> <span class="s">&quot;__END__&quot;</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Found ~A chunks\n&quot;</span> <span class="nv">chunks</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">tokens</span>
           <span class="p">(</span><span class="nf">string-tokenize</span> <span class="p">(</span><span class="nf">string-take</span> <span class="nv">line</span> <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-index</span> <span class="nv">line</span> <span class="o">#</span><span class="err">\</span><span class="o">#</span><span class="p">)</span>
                                                  <span class="p">(</span><span class="nb">string-length </span><span class="nv">line</span><span class="p">))))))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">chunks</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">chunks</span> <span class="p">(</span><span class="nb">length </span><span class="nv">tokens</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">count-chunks</span><span class="p">)</span>     <span class="c1">; or find-login, lowercase, etc.</span>
  <span class="p">(</span><span class="nf">for-each</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">file</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">catch</span> <span class="ss">&#39;system-error</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
         <span class="p">(</span><span class="nb">with-input-from-file </span><span class="nv">file</span>
           <span class="nv">count-chunks</span><span class="p">))</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">format</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">caaddr </span><span class="nv">args</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdaddr </span><span class="nv">args</span><span class="p">)))</span>
         <span class="p">(</span><span class="nb">newline </span><span class="p">(</span><span class="nf">current-error-port</span><span class="p">)))))</span>
   <span class="nv">args</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_7.8</span>
<span class="c1">;; write changes to a temporary file then rename it</span>
<span class="p">(</span><span class="nb">with-input-from-file </span><span class="nv">old</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
    <span class="p">(</span><span class="nb">with-output-to-file </span><span class="nv">new</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
        <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
            <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
          <span class="c1">;; change line, then...</span>
          <span class="p">(</span><span class="nf">write-line</span> <span class="nv">line</span><span class="p">))))))</span>
<span class="p">(</span><span class="nf">rename-file</span> <span class="nv">old</span> <span class="p">(</span><span class="nb">string-append </span><span class="nv">old</span> <span class="s">&quot;.orig&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">rename-file</span> <span class="nv">new</span> <span class="nv">old</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_7.9</span>
<span class="c1">;; no -i switch</span>

<span class="c1">;; @@PLEAC@@_7.10</span>
<span class="c1">;; open the file in read/write mode, slurp up the contents, modify it,</span>
<span class="c1">;; then write it back out:</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="nf">open-file</span> <span class="nv">file</span> <span class="s">&quot;r+&quot;</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">lines</span> <span class="o">&#39;</span><span class="p">()))</span>
  <span class="c1">;; read in lines</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">lines</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">line</span> <span class="nv">lines</span><span class="p">)))</span>
  <span class="c1">;; modify (reverse lines)</span>
  <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="mi">0</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
  <span class="c1">;; write out lines</span>
  <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">write-line</span> <span class="nv">x</span> <span class="nv">p</span><span class="p">))</span> <span class="nv">lines</span><span class="p">)</span>
  <span class="c1">;; truncate the file</span>
  <span class="p">(</span><span class="nf">truncate-file</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">close</span> <span class="nv">p</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="nf">open-file</span> <span class="s">&quot;foo&quot;</span> <span class="s">&quot;r+&quot;</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">lines</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">date</span> <span class="p">(</span><span class="nf">date-&gt;string</span> <span class="p">(</span><span class="nf">current-date</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span> <span class="ss">&#39;concat</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span> <span class="ss">&#39;concat</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">lines</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">line</span> <span class="nv">lines</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="mi">0</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">for-each</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">regexp-substitute/global</span> <span class="nv">p</span> <span class="s">&quot;DATE&quot;</span> <span class="nv">x</span> <span class="ss">&#39;pre</span> <span class="nv">date</span> <span class="ss">&#39;post</span><span class="p">))</span>
   <span class="p">(</span><span class="nb">reverse </span><span class="nv">lines</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">truncate-file</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">close</span> <span class="nv">p</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_7.11</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nf">open-file</span> <span class="nv">path</span> <span class="s">&quot;r+&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">flock</span> <span class="nv">p</span> <span class="nv">LOCK_EX</span><span class="p">)</span>
<span class="c1">;; update the file, then...</span>
<span class="p">(</span><span class="nf">close</span> <span class="nv">p</span><span class="p">)</span>

<span class="c1">;; to increment a number in a file</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nf">open</span> <span class="s">&quot;numfile&quot;</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">O_RDWR</span> <span class="nv">O_CREAT</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">flock</span> <span class="nv">p</span> <span class="nv">LOCK_EX</span><span class="p">)</span>
<span class="c1">;; Now we have acquired the lock, it&#39;s safe for I/O</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">obj</span> <span class="p">(</span><span class="nb">read </span><span class="nv">p</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">num</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">obj</span><span class="p">)</span> <span class="mi">0</span> <span class="nv">obj</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="mi">0</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">truncate-file</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">write </span><span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">num</span><span class="p">)</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">newline </span><span class="nv">p</span><span class="p">))</span>
<span class="p">(</span><span class="nf">close</span> <span class="nv">p</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_7.12</span>
<span class="c1">;; use force-output</span>
<span class="p">(</span><span class="nf">force-output</span> <span class="nv">p</span><span class="p">)</span>

<span class="c1">;; flush all open ports</span>
<span class="p">(</span><span class="nf">flush-all-ports</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_7.13</span>
<span class="c1">;; use select</span>
<span class="p">(</span><span class="nf">select</span> <span class="nv">inputs</span> <span class="nv">outputs</span> <span class="nv">exceptions</span> <span class="nv">seconds</span><span class="p">)</span>
<span class="p">(</span><span class="nf">select</span> <span class="p">(</span><span class="nb">list </span><span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">nfound</span> <span class="p">(</span><span class="nf">select</span> <span class="p">(</span><span class="nb">list </span><span class="nv">inport</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">()))</span>
       <span class="p">(</span><span class="nf">inputs</span> <span class="p">(</span><span class="nb">car </span><span class="nv">nfound</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="nv">inputs</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">inport</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;I read ~A\n&quot;</span> <span class="nv">line</span><span class="p">))))</span>

<span class="c1">;; or use char-ready? if you only need a single character</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">char-ready? </span><span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;I read ~A\n&quot;</span> <span class="p">(</span><span class="nb">read-char </span><span class="nv">p</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_7.14</span>
<span class="c1">;; use the O_NONBLOCK option with open</span>
<span class="p">(</span><span class="k">define </span><span class="nv">modem</span> <span class="p">(</span><span class="nf">open</span> <span class="s">&quot;/dev/cua0&quot;</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">O_RDWR</span> <span class="nv">O_NONBLOCK</span><span class="p">)))</span>

<span class="c1">;; or use fcntl if you already have a port</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">flags</span> <span class="p">(</span><span class="nf">fcntl</span> <span class="nv">p</span> <span class="nv">F_GETFD</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">fcntl</span> <span class="nv">p</span> <span class="nv">F_SETFD</span> <span class="p">(</span><span class="nf">logior</span> <span class="nv">flags</span> <span class="nv">O_NONBLOCK</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_7.15</span>
<span class="c1">;; use stat</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">buf</span> <span class="p">(</span><span class="nb">make-string </span><span class="p">(</span><span class="nf">stat:size</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">p</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buf</span> <span class="nv">input</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_7.16</span>
<span class="c1">;; not needed - ports are first class objects</span>

<span class="c1">;; @@PLEAC@@_7.18</span>
<span class="c1">;; use for-each on the list of ports:</span>
<span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="nv">stuff-to-print</span> <span class="nv">p</span><span class="p">))</span> <span class="nv">port-list</span><span class="p">)</span>

<span class="c1">;; or, if you don&#39;t want to keep track of the port list and know you</span>
<span class="c1">;; want to print to all open output ports, you can use port-for-each:</span>
<span class="p">(</span><span class="nf">port-for-each</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">output-port? </span><span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="nv">stuff</span> <span class="nv">p</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_7.19</span>
<span class="c1">;; use fdopen:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nf">fdopen</span> <span class="nv">num</span> <span class="nv">mode</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nf">fdopen</span> <span class="mi">3</span> <span class="s">&quot;r&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nf">fdopen</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="p">(</span><span class="nf">getenv</span> <span class="s">&quot;MHCONTEXTFD&quot;</span><span class="p">))</span> <span class="s">&quot;r&quot;</span><span class="p">))</span>
<span class="c1">;; after processing</span>
<span class="p">(</span><span class="nf">close</span> <span class="nv">p</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_7.20</span>
<span class="c1">;; ports are first class objects and can be aliased and passed around</span>
<span class="c1">;; like any other non-immediate variables:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">alias</span> <span class="nv">original</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">old-in</span> <span class="p">(</span><span class="nf">current-input-port</span><span class="p">))</span>

<span class="c1">;; or you can open two separate ports on the same file:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">path</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p2</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">path</span><span class="p">))</span>

<span class="c1">;; or use fdopen:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">copy-of-p</span> <span class="p">(</span><span class="nf">fdopen</span> <span class="p">(</span><span class="nf">fileno</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">mode</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">old-out</span> <span class="p">(</span><span class="nf">current-output-port</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">old-err</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">new-out</span> <span class="p">(</span><span class="nb">open-output-file </span><span class="s">&quot;/tmp/program.out&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">set-current-output-port</span> <span class="nv">new-out</span><span class="p">)</span>
<span class="p">(</span><span class="nf">set-current-error-port</span> <span class="nv">new-out</span><span class="p">)</span>

<span class="p">(</span><span class="nf">system</span> <span class="nv">joe-random-program</span><span class="p">)</span>

<span class="p">(</span><span class="nf">close</span> <span class="nv">new-out</span><span class="p">)</span>

<span class="p">(</span><span class="nf">set-current-output-port</span> <span class="nv">old-out</span><span class="p">)</span>
<span class="p">(</span><span class="nf">set-current-error-port</span> <span class="nv">old-out</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_8.0</span>
<span class="c1">;; open the file and loop through the port with read-line:</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">file</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A\n&quot;</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">line</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">close</span> <span class="nv">p</span><span class="p">))</span>

<span class="c1">;; you can use with-input-from-file to temporarily rebind stdin:</span>
<span class="p">(</span><span class="nb">with-input-from-file </span><span class="nv">file</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
    <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A\n&quot;</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">line</span><span class="p">)))))</span>

<span class="c1">;; or define a utility procedure to do this</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">for-each-line</span> <span class="nv">proc</span> <span class="nv">file</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-input-from-file </span><span class="nv">file</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
      <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">proc</span> <span class="nv">line</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">for-each-line</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A\n&quot;</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">line</span><span class="p">)))</span> <span class="nv">file</span><span class="p">)</span>

<span class="c1">;; read in the file as a list of lines</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">read-lines</span> <span class="nv">file</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">ls</span> <span class="o">&#39;</span><span class="p">()))</span>
    <span class="p">(</span><span class="nb">with-input-from-file </span><span class="nv">file</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
        <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
            <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
          <span class="p">(</span><span class="k">set! </span><span class="nv">ls</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">line</span> <span class="nv">ls</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">reverse </span><span class="nv">ls</span><span class="p">)))))</span>

<span class="c1">;; read in the file as a single string</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">file-contents</span> <span class="nv">file</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">call-with-input-file </span><span class="nv">file</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">size</span> <span class="p">(</span><span class="nf">stat:size</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">p</span><span class="p">)))</span>
             <span class="p">(</span><span class="nf">buf</span> <span class="p">(</span><span class="nb">make-string </span><span class="nv">size</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buf</span> <span class="nv">p</span><span class="p">)</span>
        <span class="nv">buf</span><span class="p">))))</span>

<span class="c1">;; use display to print human readable output</span>
<span class="p">(</span><span class="nb">display </span><span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;One&quot;</span> <span class="s">&quot;two&quot;</span> <span class="s">&quot;three&quot;</span><span class="p">)</span> <span class="nv">port</span><span class="p">)</span>  <span class="c1">; (One two three)</span>
<span class="p">(</span><span class="nb">display </span><span class="s">&quot;Baa baa black sheep.\n&quot;</span><span class="p">)</span>     <span class="c1">; Sent to default output port</span>

<span class="c1">;; use write to print machine readable output</span>
<span class="p">(</span><span class="nb">write </span><span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;One&quot;</span> <span class="s">&quot;two&quot;</span> <span class="s">&quot;three&quot;</span><span class="p">)</span> <span class="nv">port</span><span class="p">)</span>    <span class="c1">; (&quot;One&quot; &quot;two&quot; &quot;three&quot;)</span>

<span class="c1">;; use (ice-9 rw) to read/write fixed-length blocks of data:</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rw</span><span class="p">))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">buffer</span> <span class="p">(</span><span class="nb">make-string </span><span class="mi">4096</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buffer</span> <span class="nv">port</span> <span class="mi">4096</span><span class="p">))</span>

<span class="c1">;; truncate-file</span>
<span class="p">(</span><span class="nf">truncate-file</span> <span class="nv">port</span> <span class="nv">length</span><span class="p">)</span>  <span class="c1">; truncate to length</span>
<span class="p">(</span><span class="nf">truncate-file</span> <span class="nv">port</span><span class="p">)</span>         <span class="c1">; truncate to current pos</span>

<span class="c1">;; ftell</span>
<span class="p">(</span><span class="k">define </span><span class="nv">pos</span> <span class="p">(</span><span class="nf">ftell</span> <span class="nv">port</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;I&#39;m ~A bytes from the start of DATAFILE.\n&quot;</span> <span class="nv">pos</span><span class="p">)</span>

<span class="c1">;; seek</span>
<span class="p">(</span><span class="nf">seek</span> <span class="nv">log-port</span> <span class="mi">0</span> <span class="nv">SEEK_END</span><span class="p">)</span>      <span class="c1">; seek to end</span>
<span class="p">(</span><span class="nf">seek</span> <span class="nv">data-port</span> <span class="nv">pos</span> <span class="nv">SEEK_SET</span><span class="p">)</span>   <span class="c1">; seek to pos</span>
<span class="p">(</span><span class="nf">seek</span> <span class="nv">out-port</span> <span class="mi">-20</span> <span class="nv">SEEK_CUR</span><span class="p">)</span>    <span class="c1">; seek back 20 bytes</span>

<span class="c1">;; block read/write</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rw</span><span class="p">))</span>
<span class="p">(</span><span class="nf">write-string/partial</span> <span class="nv">mystring</span> <span class="nv">data-port</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">mystring</span><span class="p">))</span>
<span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">block</span> <span class="mi">256</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_8.1</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">rx</span> <span class="p">(</span><span class="nf">make-regexp</span> <span class="s">&quot;(.*)\\\\$&quot;</span><span class="p">)))</span> <span class="c1">; or &quot;(.*)\\\\\\s*$&quot;</span>
  <span class="p">(</span><span class="nb">with-input-from-file </span><span class="nv">file</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
      <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
          <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">m</span> <span class="p">(</span><span class="nf">regexp-exec</span> <span class="nv">rx</span> <span class="nv">line</span><span class="p">))</span>
                <span class="p">(</span><span class="nf">next</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
            <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="k">and </span><span class="nv">m</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">next</span><span class="p">)))</span>
                   <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">next</span><span class="p">)))</span>
                  <span class="p">(</span><span class="nf">else</span>
                   <span class="c1">;; else process line here, then recurse</span>
                   <span class="p">(</span><span class="nf">loop</span> <span class="nv">next</span><span class="p">)))))))))</span>

<span class="c1">;; @@PLEAC@@_8.2</span>
<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>

<span class="c1">;; fastest way if your terminator is a single newline</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rw</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">buf</span> <span class="p">(</span><span class="nb">make-string </span><span class="p">(</span><span class="nb">expt </span><span class="mi">2</span> <span class="mi">16</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">count</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buf</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buf</span> <span class="nv">p</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">not </span><span class="nv">len</span><span class="p">)</span> <span class="nv">count</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">count</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">count</span> <span class="p">(</span><span class="nf">string-count</span> <span class="nv">buf</span> <span class="sc">#\newline</span> <span class="mi">0</span> <span class="nv">len</span><span class="p">)))))</span>

<span class="c1">;; or use port-line</span>
<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">)</span> <span class="p">(</span><span class="nf">port-line</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_8.3</span>
<span class="c1">;; default behaviour of string-tokenize is to split on whitespace:</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="nv">eof-object?</span> <span class="nv">line</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">for-each </span><span class="nv">some-function-of-word</span> <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">line</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">table</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">31</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">for-each</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">w</span><span class="p">)</span> <span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">table</span> <span class="nv">w</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">table</span> <span class="nv">w</span> <span class="mi">0</span><span class="p">))))</span>
            <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">line</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">hash-fold</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">k</span> <span class="nv">v</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~5D ~A\n&quot;</span> <span class="nv">v</span> <span class="nv">k</span><span class="p">))</span> <span class="no">#f</span> <span class="nv">table</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_8.4</span>
<span class="c1">;; build up the list the reverse it or fold over it:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">lines</span> <span class="p">(</span><span class="nf">read-lines</span> <span class="nv">file</span><span class="p">))</span>
<span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">word</span><span class="p">)</span> <span class="nv">do-something-with-word</span><span class="p">)</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">lines</span><span class="p">))</span>
<span class="p">(</span><span class="nf">fold</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">word</span> <span class="nv">acc</span><span class="p">)</span> <span class="nv">do-something-with-word</span><span class="p">)</span> <span class="no">#f</span> <span class="nv">lines</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_8.5</span>
<span class="c1">;; save the current position and reseek to it</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tail</span> <span class="nv">file</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">call-with-input-file </span><span class="nv">file</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">)</span>
               <span class="p">(</span><span class="nf">sleep</span> <span class="nv">sometime</span><span class="p">)</span>
               <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">pos</span> <span class="p">(</span><span class="nf">ftell</span> <span class="nv">p</span><span class="p">)))</span>
                 <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="mi">0</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
                 <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="nv">pos</span> <span class="nv">SEEK_SET</span><span class="p">)))</span>
              <span class="p">(</span><span class="nf">else</span>
               <span class="c1">;; process line</span>
               <span class="p">))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">))))))</span>

<span class="c1">;; @@PLEAC@@_8.6</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">rand-line</span> <span class="no">#f</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
           <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nf">port-line</span> <span class="nv">p</span><span class="p">)))</span>
             <span class="p">(</span><span class="k">set! </span><span class="nv">rand-line</span> <span class="nv">line</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))))</span>
  <span class="c1">;; rand-line is the random line</span>
  <span class="p">)</span>

<span class="c1">;; @@PLEAC@@_8.7</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">shuffle</span> <span class="nv">list</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">v</span> <span class="p">(</span><span class="nb">list-&gt;vector </span><span class="nv">list</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="p">(</span><span class="mi">1</span><span class="nv">-</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">v</span><span class="p">))</span> <span class="p">(</span><span class="mi">1</span><span class="nv">-</span> <span class="nv">i</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-&gt;list </span><span class="nv">v</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">j</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">))))</span>
        <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">j</span><span class="p">))</span>
               <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">v</span> <span class="nv">i</span><span class="p">)))</span>
                 <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">v</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">v</span> <span class="nv">j</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">v</span> <span class="nv">j</span> <span class="nv">temp</span><span class="p">))))))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">rand-lines</span> <span class="p">(</span><span class="nf">shuffle</span> <span class="p">(</span><span class="nf">read-lines</span> <span class="nv">file</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_8.8</span>
<span class="c1">;; looking for line number desired-line-number</span>
<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">= </span><span class="p">((</span><span class="nf">port-line</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">desired-line-number</span><span class="p">)</span> <span class="nv">line</span><span class="p">)))</span>
<span class="c1">;; or read into a list</span>
<span class="p">(</span><span class="k">define </span><span class="nv">lines</span> <span class="p">(</span><span class="nf">read-lines</span> <span class="nv">file</span><span class="p">))</span>
<span class="p">(</span><span class="nb">list-ref </span><span class="nv">lines</span> <span class="nv">desired-line-number</span><span class="p">)</span>

<span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">; (define (build-index data-file index-file)</span>
<span class="c1">;   )</span>

<span class="c1">; (define (line-with-index data-file index-file line-number)</span>
<span class="c1">;   )</span>

<span class="c1">;; @@PLEAC@@_8.9</span>
<span class="c1">;; use string-tokenize with an appropriate character set</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-14</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">fields</span> <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">line</span> <span class="p">(</span><span class="nf">string-&gt;charset</span> <span class="s">&quot;+-&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">fields</span> <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">line</span> <span class="p">(</span><span class="nf">string-&gt;charset</span> <span class="s">&quot;:&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">fields</span> <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">line</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_8.10</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="nf">open-file</span> <span class="nv">file</span> <span class="s">&quot;r+&quot;</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">pos</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eof-object? </span><span class="p">(</span><span class="nb">peek-char </span><span class="nv">p</span><span class="p">))</span>
             <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="mi">0</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">truncate-file</span> <span class="nv">p</span> <span class="nv">pos</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">close</span> <span class="nv">p</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">else</span>
             <span class="p">(</span><span class="k">set! </span><span class="nv">pos</span> <span class="p">(</span><span class="nf">ftell</span> <span class="nv">p</span><span class="p">))</span>
             <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">p</span><span class="p">)))))))</span>

<span class="c1">;; @@PLEAC@@_8.11</span>
<span class="c1">;; no equivalent - don&#39;t know how Guile under windows handles this</span>

<span class="c1">;; @@PLEAC@@_8.12</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">address</span> <span class="p">(</span><span class="nb">* </span><span class="nv">recsize</span> <span class="nv">recno</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">buf</span> <span class="p">(</span><span class="nb">make-string </span><span class="nv">recsize</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="nv">address</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buf</span> <span class="nv">p</span><span class="p">)</span>
  <span class="nv">buf</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_8.13</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">address</span> <span class="p">(</span><span class="nb">* </span><span class="nv">recsize</span> <span class="nv">recno</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">buf</span> <span class="p">(</span><span class="nb">make-string </span><span class="nv">recsize</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="nv">address</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buf</span> <span class="nv">p</span><span class="p">)</span>
  <span class="c1">;; modify buf, then write back with</span>
  <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="nv">address</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">write-string/partial</span> <span class="nv">buf</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">close</span> <span class="nv">p</span><span class="p">))</span>

<span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; weekearly</span>

<span class="c1">;; @@PLEAC@@_8.14</span>
<span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="nv">addr</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">str</span> <span class="p">(</span><span class="nf">read-delimited</span> <span class="p">(</span><span class="nb">make-string </span><span class="mi">1</span> <span class="sc">#\nul</span><span class="p">)</span> <span class="nv">p</span><span class="p">))</span>

<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>
<span class="c1">;; bgets -- get a string from an address in a binary file</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">format</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">file</span> <span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">addrs</span> <span class="p">(</span><span class="nb">map </span><span class="nv">string-&gt;number</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">args</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">delims</span> <span class="p">(</span><span class="nb">make-string </span><span class="mi">1</span> <span class="sc">#\nul</span><span class="p">))</span>

<span class="p">(</span><span class="nb">call-with-input-file </span><span class="nv">file</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">for-each</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">addr</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">seek</span> <span class="nv">p</span> <span class="nv">addr</span> <span class="nv">SEEK_SET</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~X ~O ~D ~S\n&quot;</span> <span class="nv">addr</span> <span class="nv">addr</span> <span class="nv">addr</span>
               <span class="p">(</span><span class="nf">read-delimited</span> <span class="nv">delims</span> <span class="nv">p</span><span class="p">)))</span>
     <span class="nv">addrs</span><span class="p">)))</span>

<span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; strings</span>

<span class="c1">;; @@PLEAC@@_9.0</span>
<span class="p">(</span><span class="k">define </span><span class="nv">entry</span> <span class="p">(</span><span class="nf">stat</span> <span class="s">&quot;/usr/bin/vi&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">entry</span> <span class="p">(</span><span class="nf">stat</span> <span class="s">&quot;/usr/bin&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">entry</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">port</span><span class="p">))</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">posix</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">inode</span> <span class="p">(</span><span class="nf">stat</span> <span class="s">&quot;/usr/bin/vi&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">ctime</span> <span class="p">(</span><span class="nf">stat:ctime</span> <span class="nv">inode</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">size</span> <span class="p">(</span><span class="nf">stat:size</span> <span class="nv">inode</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">F</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">filename</span><span class="p">))</span>
<span class="c1">;; no equivalent - what defines -T?</span>
<span class="c1">; unless (-s F &amp;&amp; -T _) {</span>
<span class="c1">;     die &quot;$filename doesn&#39;t have text in it.\n&quot;;</span>
<span class="c1">; }</span>

<span class="p">(</span><span class="k">define </span><span class="nv">dir</span> <span class="p">(</span><span class="nf">opendir</span> <span class="s">&quot;/usr/bin&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">filename</span> <span class="p">(</span><span class="nf">readdir</span> <span class="nv">dir</span><span class="p">)</span> <span class="p">(</span><span class="nf">readdir</span> <span class="nv">dir</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">filename</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Inside /usr/bin is something called ~A\n&quot;</span> <span class="nv">filename</span><span class="p">))</span>
<span class="p">(</span><span class="nf">closedir</span> <span class="nv">dir</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_9.1</span>
<span class="p">(</span><span class="k">define </span><span class="nv">inode</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">filename</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">readtime</span> <span class="p">(</span><span class="nf">stat:atime</span> <span class="nv">inode</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">writetime</span> <span class="p">(</span><span class="nf">stat:mtime</span> <span class="nv">inode</span><span class="p">))</span>

<span class="p">(</span><span class="nf">utime</span> <span class="nv">newreadtime</span> <span class="nv">newwritetime</span> <span class="nv">filename</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">seconds-per-day</span> <span class="p">(</span><span class="nb">* </span><span class="mi">60</span> <span class="mi">60</span> <span class="mi">24</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">inode</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">file</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">atime</span> <span class="p">(</span><span class="nf">stat:atime</span> <span class="nv">inode</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">mtime</span> <span class="p">(</span><span class="nf">stat:mtime</span> <span class="nv">inode</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">atime</span> <span class="p">(</span><span class="nb">- </span><span class="nv">atime</span> <span class="p">(</span><span class="nb">* </span><span class="mi">7</span> <span class="nv">seconds-per-day</span><span class="p">)))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">mtime</span> <span class="p">(</span><span class="nb">- </span><span class="nv">mtime</span> <span class="p">(</span><span class="nb">* </span><span class="mi">7</span> <span class="nv">seconds-per-day</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">utime</span> <span class="nv">file</span> <span class="nv">atime</span> <span class="nv">mtime</span><span class="p">)</span>

<span class="c1">;; mtime is optional</span>
<span class="p">(</span><span class="nf">utime</span> <span class="nv">file</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>
<span class="p">(</span><span class="nf">utime</span> <span class="nv">file</span> <span class="p">(</span><span class="nf">stat:atime</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">file</span><span class="p">))</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>
<span class="c1">;; uvi - vi a file without changing its access times</span>

<span class="p">(</span><span class="k">define </span><span class="nv">file</span> <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">inode</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">file</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">atime</span> <span class="p">(</span><span class="nf">stat:atime</span> <span class="nv">inode</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">mtime</span> <span class="p">(</span><span class="nf">stat:mtime</span> <span class="nv">inode</span><span class="p">))</span>
<span class="p">(</span><span class="nf">system</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">getenv</span> <span class="s">&quot;EDITOR&quot;</span><span class="p">)</span>  <span class="s">&quot;vi&quot;</span><span class="p">)</span> <span class="s">&quot; &quot;</span> <span class="nv">file</span><span class="p">))</span>
<span class="p">(</span><span class="nf">utime</span> <span class="nv">file</span> <span class="nv">atime</span> <span class="nv">mtime</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_9.2</span>
<span class="p">(</span><span class="nf">delete-file</span> <span class="nv">file</span><span class="p">)</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">count</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">for-each</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">delete-file</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">count</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">count</span><span class="p">)))</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">err</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="no">#f</span><span class="p">)))</span>
   <span class="nv">file-list</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">= </span><span class="nv">count</span> <span class="p">(</span><span class="nb">length </span><span class="nv">file-list</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">format</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">)</span> <span class="s">&quot;could only delete ~A of ~A files&quot;</span>
            <span class="nv">count</span> <span class="p">(</span><span class="nb">length </span><span class="nv">file-list</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_9.3</span>
<span class="c1">;; use builtin copy-file</span>
<span class="p">(</span><span class="nf">copy-file</span> <span class="nv">oldfile</span> <span class="nv">newfile</span><span class="p">)</span>
<span class="p">(</span><span class="nf">rename-file</span> <span class="nv">oldfile</span> <span class="nv">newfile</span><span class="p">)</span>

<span class="c1">;; or do it by hand (clumsy, error-prone)</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rw</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">posix</span><span class="p">))</span>
<span class="p">(</span><span class="nb">with-input-from-file </span><span class="nv">oldfile</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
    <span class="p">(</span><span class="nb">call-with-output-file </span><span class="nv">newfile</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">inode</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">oldfile</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">blksize</span> <span class="p">(</span><span class="k">if </span><span class="nv">inode</span> <span class="p">(</span><span class="nf">stat:size</span> <span class="nv">inode</span><span class="p">)</span> <span class="mi">16384</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">buf</span> <span class="p">(</span><span class="nb">make-string </span><span class="nv">blksize</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buf</span><span class="p">)))</span>
            <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="k">and </span><span class="nv">len</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">len</span> <span class="mi">0</span><span class="p">))</span>
                   <span class="p">(</span><span class="nf">write-string/partial</span> <span class="nv">buf</span> <span class="nv">p</span> <span class="mi">0</span> <span class="nv">len</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-string!/partial</span> <span class="nv">buf</span><span class="p">))))))))))</span>

<span class="c1">;; or call out to the system (non-portable, insecure)</span>
<span class="p">(</span><span class="nf">system</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;cp &quot;</span> <span class="nv">oldfile</span> <span class="s">&quot; &quot;</span> <span class="nv">newfile</span><span class="p">))</span>    <span class="c1">; unix</span>
<span class="p">(</span><span class="nf">system</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;copy &quot;</span> <span class="nv">oldfile</span> <span class="s">&quot; &quot;</span> <span class="nv">newfile</span><span class="p">))</span>  <span class="c1">; dos, vms</span>

<span class="c1">;; @@PLEAC@@_9.4</span>
<span class="c1">;; use a hash lookup of inodes</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">posix</span><span class="p">))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">seen</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">31</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">for-each</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">file</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">stats</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">file</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">key</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">stat:dev</span> <span class="nv">stats</span><span class="p">)</span> <span class="p">(</span><span class="nf">stat:ino</span> <span class="nv">stats</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">val</span> <span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">seen</span> <span class="nv">key</span> <span class="mi">0</span><span class="p">)))</span>
       <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">val</span> <span class="mi">0</span><span class="p">)</span>
              <span class="c1">;; do something with new file</span>
              <span class="p">))</span>
       <span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">seen</span> <span class="nv">key</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">val</span><span class="p">))))</span>
   <span class="nv">file-names</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">seen</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">31</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">for-each</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">file</span><span class="p">)</span>
     <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">stats</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">file</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">key</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">stat:dev</span> <span class="nv">stats</span><span class="p">)</span> <span class="p">(</span><span class="nf">stat:ino</span> <span class="nv">stats</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">val</span> <span class="p">(</span><span class="nf">hash-ref</span> <span class="nv">seen</span> <span class="nv">key</span> <span class="o">&#39;</span><span class="p">())))</span>
       <span class="p">(</span><span class="nf">hash-set!</span> <span class="nv">seen</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">file</span> <span class="nv">val</span><span class="p">))))</span>
   <span class="nv">file-names</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">hash-fold</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="nv">value</span> <span class="nv">prior</span><span class="p">)</span>
     <span class="c1">;; process key == (dev . inode), value == list of filenames</span>
     <span class="p">)</span>
   <span class="o">&#39;</span><span class="p">()</span> <span class="nv">seen</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_9.5</span>
<span class="c1">;; use opendir, readdir, closedir</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="nf">opendir</span> <span class="nv">dir</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">file</span> <span class="p">(</span><span class="nf">readdir</span> <span class="nv">p</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">file</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">close</span> <span class="nv">p</span><span class="p">)</span>
      <span class="c1">;; do something with file</span>
      <span class="p">)))</span>

<span class="c1">;; or define a utility function for this</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">directory-files</span> <span class="nv">dir</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">access?</span> <span class="nv">dir</span> <span class="nv">R_OK</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="nf">opendir</span> <span class="nv">dir</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">file</span> <span class="p">(</span><span class="nf">readdir</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">readdir</span> <span class="nv">p</span><span class="p">))</span>
           <span class="p">(</span><span class="nf">ls</span> <span class="o">&#39;</span><span class="p">()))</span>
          <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">file</span><span class="p">)</span> <span class="p">(</span><span class="nf">closedir</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">reverse!</span> <span class="nv">ls</span><span class="p">))</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">ls</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">file</span> <span class="nv">ls</span><span class="p">))))))</span>

<span class="c1">;; to skip . and ..</span>
<span class="p">(</span><span class="nb">cddr </span><span class="p">(</span><span class="nf">directory-files</span> <span class="nv">dir</span><span class="p">))</span>

<span class="c1">;; probably better to implement full Emacs style directory-files</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">posix</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">plain-files</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">rx</span> <span class="p">(</span><span class="nf">make-regexp</span> <span class="s">&quot;^\\.&quot;</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">dir</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">sort</span> <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="ss">&#39;regular</span> <span class="p">(</span><span class="nf">stat:type</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">x</span><span class="p">))))</span>
                    <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="nv">dir</span> <span class="s">&quot;/&quot;</span> <span class="nv">x</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">remove</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">regexp-exec</span> <span class="nv">rx</span> <span class="nv">x</span><span class="p">))</span>
                                 <span class="p">(</span><span class="nb">cddr </span><span class="p">(</span><span class="nf">directory-files</span> <span class="nv">dir</span><span class="p">)))))</span>
            <span class="nv">string&lt;</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_9.6</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">glob-&gt;regexp</span> <span class="nv">pat</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nb">string-length </span><span class="nv">pat</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">ls</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;^&quot;</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">in-brace?</span> <span class="no">#f</span><span class="p">))</span>
    <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">len</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">char</span> <span class="p">(</span><span class="nb">string-ref </span><span class="nv">pat</span> <span class="nv">i</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">case </span><span class="nv">char</span>
          <span class="p">((</span><span class="o">#</span><span class="err">\</span><span class="nv">*</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">ls</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;[^.]*&quot;</span> <span class="nv">ls</span><span class="p">)))</span>
          <span class="p">((</span><span class="sc">#\?</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">ls</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;[^.]&quot;</span> <span class="nv">ls</span><span class="p">)))</span>
          <span class="p">((</span><span class="o">#</span><span class="err">\</span><span class="p">[)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">ls</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;[&quot;</span> <span class="nv">ls</span><span class="p">)))</span>
          <span class="p">((</span><span class="o">#</span><span class="err">\</span><span class="p">])</span> <span class="p">(</span><span class="k">set! </span><span class="nv">ls</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;]&quot;</span> <span class="nv">ls</span><span class="p">)))</span>
          <span class="p">((</span><span class="o">#</span><span class="err">\\</span><span class="p">)</span>
           <span class="p">(</span><span class="k">set! </span><span class="nv">i</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">))</span>
           <span class="p">(</span><span class="k">set! </span><span class="nv">ls</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">make-string </span><span class="mi">1</span> <span class="p">(</span><span class="nb">string-ref </span><span class="nv">pat</span> <span class="nv">i</span><span class="p">))</span> <span class="nv">ls</span><span class="p">))</span>
           <span class="p">(</span><span class="k">set! </span><span class="nv">ls</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;\\&quot;</span> <span class="nv">ls</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">else</span>
           <span class="p">(</span><span class="k">set! </span><span class="nv">ls</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">regexp-quote</span> <span class="p">(</span><span class="nb">make-string </span><span class="mi">1</span> <span class="nv">char</span><span class="p">))</span> <span class="nv">ls</span><span class="p">))))))</span>
    <span class="p">(</span><span class="nf">string-concatenate</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nb">cons </span><span class="s">&quot;$&quot;</span> <span class="nv">ls</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">glob</span> <span class="nv">pat</span> <span class="nv">dir</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">rx</span> <span class="p">(</span><span class="nf">make-regexp</span> <span class="p">(</span><span class="nf">glob-&gt;regexp</span> <span class="nv">pat</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">regexp-exec</span> <span class="nv">rx</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">directory-files</span> <span class="nv">dir</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">files</span> <span class="p">(</span><span class="nf">glob</span> <span class="s">&quot;*.c&quot;</span> <span class="s">&quot;.&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">files</span> <span class="p">(</span><span class="nf">glob</span> <span class="s">&quot;*.[ch]&quot;</span> <span class="s">&quot;.&quot;</span><span class="p">))</span>

<span class="c1">;; Not sure if the Schwartzian Transform would really be more</span>
<span class="c1">;; efficient here... perhaps with a much larger directory where very</span>
<span class="c1">;; few files matched.</span>
<span class="p">(</span><span class="k">define </span><span class="nv">dirs</span> <span class="p">(</span><span class="nf">filter</span>
              <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="ss">&#39;directory</span> <span class="p">(</span><span class="nf">stat:type</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">x</span><span class="p">))))</span>
              <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="nv">dir</span> <span class="s">&quot;/&quot;</span> <span class="nv">x</span><span class="p">))</span>
                   <span class="p">(</span><span class="nf">sort</span> <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;^[0-9]+$&quot;</span> <span class="nv">x</span><span class="p">))</span>
                                 <span class="p">(</span><span class="nf">directory-files</span> <span class="nv">dir</span><span class="p">))</span>
                         <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span>
                           <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">string-&gt;number </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="nv">b</span><span class="p">)))))))</span>

<span class="c1">;; @@PLEAC@@_9.7</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">find</span> <span class="nv">proc</span> <span class="o">.</span> <span class="nv">dirs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">pair? </span><span class="nv">dirs</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">for-each </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">dirs</span><span class="p">)</span> <span class="s">&quot;/&quot;</span> <span class="nv">x</span><span class="p">))</span>
                             <span class="p">(</span><span class="nf">directory-files</span> <span class="p">(</span><span class="nb">car </span><span class="nv">dirs</span><span class="p">))))</span>
         <span class="p">(</span><span class="nb">apply </span><span class="nv">find</span> <span class="nv">proc</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">dirs</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">find</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A~A\n&quot;</span> <span class="nv">x</span>
                          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nf">stat:type</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">x</span><span class="p">))</span> <span class="ss">&#39;directory</span><span class="p">)</span>
                            <span class="s">&quot;/&quot;</span> <span class="s">&quot;&quot;</span><span class="p">)))</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">saved-size</span> <span class="mi">-1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">saved-name</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">biggest</span> <span class="nv">file</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">stats</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">file</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nf">stat:type</span> <span class="nv">stats</span><span class="p">)</span> <span class="ss">&#39;regular</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">size</span> <span class="p">(</span><span class="nf">stat:size</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">file</span><span class="p">))))</span>
        <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&gt; </span><span class="nv">size</span> <span class="nv">saved-size</span><span class="p">)</span>
               <span class="p">(</span><span class="k">set! </span><span class="nv">saved-size</span> <span class="nv">size</span><span class="p">)</span>
               <span class="p">(</span><span class="k">set! </span><span class="nv">saved-name</span> <span class="nv">file</span><span class="p">)))))))</span>
<span class="p">(</span><span class="nb">apply </span><span class="nv">find</span> <span class="nv">biggest</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Biggest file ~A in ~A is ~A bytes long.\n&quot;</span>
        <span class="nv">saved-name</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))</span> <span class="nv">saved-size</span><span class="p">)</span>

<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>
<span class="c1">;; fdirs - find all directories</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print-dirs</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nf">stat:type</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">f</span><span class="p">))</span> <span class="ss">&#39;directory</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">write-line</span> <span class="nv">f</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">apply </span><span class="nv">find</span> <span class="nv">print-dirs</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_9.8</span>
<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>
<span class="c1">;; rmtree - remove whole directory trees like rm -f</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">finddepth</span> <span class="nv">proc</span> <span class="o">.</span> <span class="nv">dirs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">pair? </span><span class="nv">dirs</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">apply </span><span class="nv">finddepth</span> <span class="nv">proc</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">dirs</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">for-each </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">dirs</span><span class="p">)</span> <span class="s">&quot;/&quot;</span> <span class="nv">x</span><span class="p">))</span>
                             <span class="p">(</span><span class="nf">directory-files</span> <span class="p">(</span><span class="nb">car </span><span class="nv">dirs</span><span class="p">)))))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">zap</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">rm</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nf">stat:type</span> <span class="p">(</span><span class="nf">stat</span> <span class="nv">f</span><span class="p">))</span> <span class="ss">&#39;directory</span><span class="p">)</span> <span class="nv">rmdir</span> <span class="nv">delete-file</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;deleting ~A\n&quot;</span> <span class="nv">f</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">rm</span> <span class="nv">f</span><span class="p">))</span>
      <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;couldn&#39;t delete ~A\n&quot;</span> <span class="nv">f</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">error</span> <span class="s">&quot;usage: rmtree dir ..\n&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">apply </span><span class="nv">finddepth</span> <span class="nv">zap</span> <span class="nv">args</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_9.9</span>
<span class="p">(</span><span class="nf">for-each</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">file</span><span class="p">)</span>
   <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">newname</span> <span class="p">(</span><span class="nf">function-of</span> <span class="nv">file</span><span class="p">)))</span>
     <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">rename-file</span> <span class="nv">file</span> <span class="nv">newname</span><span class="p">))</span>
       <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span> <span class="p">(</span><span class="nf">format</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">)</span>
                            <span class="s">&quot;couldn&#39;t rename ~A to ~A\n&quot;</span> <span class="nv">file</span> <span class="nv">newname</span><span class="p">)))))</span>
 <span class="nv">names</span><span class="p">)</span>

<span class="o">#</span><span class="nv">!/usr/local/bin/guile</span> <span class="nv">-s</span>
<span class="nv">!</span><span class="o">#</span>
<span class="c1">;; rename - Guile&#39;s filename fixer</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regex</span><span class="p">))</span> <span class="c1">; not needed, but often useful here</span>
<span class="p">(</span><span class="k">define </span><span class="nv">args</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">&quot;usage: rename expr [files]\n&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">proc</span> <span class="p">(</span><span class="nf">eval-string</span> <span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">for-each</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">old</span><span class="p">)</span>
   <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">new</span> <span class="p">(</span><span class="nf">proc</span> <span class="nv">old</span><span class="p">)))</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">string=? </span><span class="nv">old</span> <span class="nv">new</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">rename-file</span> <span class="nv">old</span> <span class="nv">new</span><span class="p">))</span>
         <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span> <span class="p">(</span><span class="nf">format</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">)</span>
                              <span class="s">&quot;couldn&#39;t rename ~A to ~A\n&quot;</span> <span class="nv">old</span> <span class="nv">new</span><span class="p">))))))</span>
 <span class="p">(</span><span class="nb">cdr </span><span class="nv">args</span><span class="p">))</span>

<span class="c1">;; command-line examples:</span>
<span class="c1">;; rename &#39;(lambda (x) (regexp-substitute/global #f &quot;\\.orig\$&quot; x (quote pre)))&#39; *.orig</span>
<span class="c1">;; rename string-downcase *</span>
<span class="c1">;; rename &#39;(lambda (x) (if (string-match &quot;^Make&quot; x) x (string-downcase x)))&#39; *</span>
<span class="c1">;; rename &#39;(lambda (x) (string-append x &quot;.bad&quot;))&#39; *.pl</span>
<span class="c1">;; rename &#39;(lambda (x) (format #t &quot;~a: &quot;) (read-line))&#39; *</span>

<span class="c1">;; @@PLEAC@@_9.10</span>
<span class="p">(</span><span class="k">define </span><span class="nv">base</span> <span class="p">(</span><span class="nf">basename</span> <span class="nv">path</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">base</span> <span class="p">(</span><span class="nf">dirname</span> <span class="nv">path</span> <span class="nv">ext</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">dir</span> <span class="p">(</span><span class="nf">dirname</span> <span class="nv">path</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">path</span> <span class="s">&quot;/usr/lib/libc.a&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">file</span> <span class="p">(</span><span class="nf">basename</span> <span class="nv">path</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">dir</span> <span class="p">(</span><span class="nf">dirname</span> <span class="nv">path</span><span class="p">))</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;dir is ~A, file is ~A\n&quot;</span> <span class="nv">dir</span> <span class="nv">file</span><span class="p">)</span>

<span class="p">(</span><span class="nf">basename</span> <span class="nv">path</span> <span class="s">&quot;.a&quot;</span><span class="p">)</span> <span class="c1">; libc</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regex</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">file-parse</span> <span class="nv">path</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">ext</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span> <span class="s">&quot;\\..*&quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">rx1</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;^((.*)/)?(.*)?(&quot;</span> <span class="nv">ext</span> <span class="s">&quot;)$&quot;</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">rx2</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;^((.*)/)?(.*)?()$&quot;</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">m</span> <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">string-match</span> <span class="nv">rx1</span> <span class="nv">path</span><span class="p">)</span> <span class="p">(</span><span class="nf">string-match</span> <span class="nv">rx2</span> <span class="nv">path</span><span class="p">))))</span>
      <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">3</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">match:substring</span> <span class="nv">m</span> <span class="mi">4</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">extension</span> <span class="nv">path</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">caddr </span><span class="p">(</span><span class="nb">apply </span><span class="nv">file-parse</span> <span class="nv">path</span> <span class="nv">args</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_10.0</span>
<span class="c1">; Note: Some of the examples will show code blocks in this style:</span>
<span class="c1">;</span>
<span class="c1">;  (define</span>
<span class="c1">;    ... code here ...</span>
<span class="c1">;  )</span>
<span class="c1">;</span>
<span class="c1">; This is not generally considered good style, and is not recommended;</span>
<span class="c1">; it is only used here to more clearly highlight block scope</span>

<span class="c1">; By convention a &#39;global variable&#39; i.e. a variable that is defined at</span>
<span class="c1">; the top-level, and as such, visible within any scope, is named with</span>
<span class="c1">; beginning and ending asterisks [and one to be used as a constant</span>
<span class="c1">; with beginning and ending plus signs]</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*greeted*</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hello</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">*greeted*</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">*greeted*</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;hi there!, this procedure has been called&quot;</span> <span class="nv">*greeted*</span> <span class="s">&quot;times&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">how-many-greetings</span><span class="p">)</span> <span class="nv">*greeted*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">hello</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*greetings*</span> <span class="p">(</span><span class="nf">how-many-greetings</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;bye there!, there have been&quot;</span> <span class="nv">*greetings*</span> <span class="s">&quot;greetings so far&quot;</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_10.1</span>
<span class="c1">; Subroutine parameters are named [whether directly, or indirectly in</span>
<span class="c1">; the case of variable arguments - see next example]; this is the only</span>
<span class="c1">; means of access [This contrasts with languages like Perl and REXX which</span>
<span class="c1">; allow access to arguments via array subscripting, and function calls,</span>
<span class="c1">; respectively]</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hypotenuse</span> <span class="nv">side1</span> <span class="nv">side2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">* </span><span class="nv">side1</span> <span class="nv">side1</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">side2</span> <span class="nv">side2</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*diag*</span> <span class="p">(</span><span class="nf">hypotenuse</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; &#39;other-sides&#39; is the name of a list of containing any additional</span>
<span class="c1">; parameters. Note that a name is still used to access values</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hypotenuse</span> <span class="nv">side1</span> <span class="o">.</span> <span class="nv">other-sides</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">all-sides</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">side1</span> <span class="nv">other-sides</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">side</span><span class="p">)</span>
        <span class="c1">;; ...</span>
        <span class="o">&#39;</span><span class="p">())</span>
      <span class="nv">all-sides</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*diag*</span> <span class="p">(</span><span class="nf">hypotenuse</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; Possible to pack parameters into a single structure [e.g. list or</span>
<span class="c1">; array], and access values contained therein</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hypotenuse</span> <span class="nv">sides</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">side1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">sides</span><span class="p">))</span> <span class="p">(</span><span class="nf">side2</span> <span class="p">(</span><span class="nb">caar </span><span class="nv">sides</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">* </span><span class="nv">side1</span> <span class="nv">side1</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">side2</span> <span class="nv">side2</span><span class="p">)))))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*args*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*diag*</span> <span class="p">(</span><span class="nf">hypotenuse</span> <span class="nv">*args*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Parameters passed by reference, however, whether original object is</span>
<span class="c1">; modified depends on choice of functions used to manipulate them</span>
<span class="c1">; [most functions create copies and return these; mutating versions of</span>
<span class="c1">; same functions may also exist [see next example]</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*nums*</span> <span class="p">(</span><span class="nb">vector </span><span class="mf">1.4</span> <span class="mf">3.5</span> <span class="mf">6.7</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">int-all</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">vector-map-in-order</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span> <span class="p">(</span><span class="nb">inexact-&gt;exact </span><span class="p">(</span><span class="nb">round </span><span class="nv">element</span><span class="p">)))</span>
    <span class="nv">vec</span><span class="p">))</span>

<span class="c1">; Copy created</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*ints*</span> <span class="p">(</span><span class="nf">int-all</span> <span class="nv">*nums*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*nums*</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">*ints*</span><span class="p">)</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*nums*</span> <span class="p">(</span><span class="nb">vector </span><span class="mf">1.4</span> <span class="mf">3.5</span> <span class="mf">6.7</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">trunc-all</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">array-map-in-order!</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span> <span class="p">(</span><span class="nb">inexact-&gt;exact </span><span class="p">(</span><span class="nb">round </span><span class="nv">element</span><span class="p">)))</span>
    <span class="nv">vec</span><span class="p">))</span>

<span class="c1">; Original modified</span>
<span class="p">(</span><span class="nf">trunc-all</span> <span class="nv">*nums*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_10.2</span>
<span class="c1">; Scheme is lexically-scoped; variables defined within a block are</span>
<span class="c1">; visible only within that block. Whilst nested / subordinate blocks</span>
<span class="c1">; have access to those variables, neither the caller, nor any called</span>
<span class="c1">; procedures have direct access to those same variables</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">some-func</span> <span class="nv">parm1</span> <span class="nv">parm2</span> <span class="nv">parm3</span><span class="p">)</span>
  <span class="c1">;; ... paramaters visible here ...</span>

  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">var1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">var2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">var3</span> <span class="mi">3</span><span class="p">))</span>
    <span class="c1">;; ... parameters also visible here, but variables, &#39;var1&#39; etc</span>
    <span class="c1">;;     only visible within this block ...</span>
  <span class="p">)</span>
  <span class="c1">;; ... paramaters also visible here, but still within procedure body ...</span>
<span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Top-level definitions - accessable globally</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*name*</span> <span class="p">(</span><span class="nb">caar </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*age*</span> <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*start*</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; Lexical binding - accessable only within this block</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">name</span> <span class="p">(</span><span class="nb">caar </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">age</span> <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">start</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">)))</span>
   <span class="c1">;; ... variables only visible here ...</span>
   <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*pair*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="o">.</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1">; &#39;a&#39; and &#39;b&#39; need to be dereferenced and separately defined [Also,</span>
<span class="c1">; since globally defined, should really be named, &#39;*a*&#39;, &#39;*b*&#39;, etc]</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="nb">car </span><span class="nv">*pair*</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">*pair*</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">run-check</span><span class="p">)</span>
  <span class="c1">;; ... do something with &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">check-x</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">run-check</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;got&quot;</span> <span class="nv">x</span><span class="p">)))</span>

<span class="c1">; Calling &#39;check-x&#39;; &#39;run-check&#39; has access to &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;</span>
<span class="p">(</span><span class="nf">check-x</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">;; ----</span>

<span class="c1">; If defined within a block, variables &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; are no longer</span>
<span class="c1">; accessable anywhere except that scope. Therefore, &#39;run-check&#39; as</span>
<span class="c1">; defined above can no longer access these variables [in fact, the code</span>
<span class="c1">; will fail because variables &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; do not exist when</span>
<span class="c1">; &#39;run-check&#39; is defined]</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">car </span><span class="nv">*pair*</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">*pair*</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">)))</span>
   <span class="c1">;; ...</span>
   <span class="p">(</span><span class="nf">check-x</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
   <span class="c1">;; ...</span>
   <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">;; ----</span>

<span class="c1">; The procedures, &#39;run-check&#39; and &#39;check-x&#39; are defined within the</span>
<span class="c1">; same block as variables, &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;, so have direct access to</span>
<span class="c1">; them</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">car </span><span class="nv">*pair*</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">*pair*</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">))</span>

       <span class="p">(</span><span class="nf">run-check</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
           <span class="c1">;; ... do something with &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; ...</span>
           <span class="o">&#39;</span><span class="p">()))</span>

       <span class="p">(</span><span class="nf">check-x</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
           <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">run-check</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;got&quot;</span> <span class="nv">x</span><span class="p">))))</span> <span class="p">)</span>
   <span class="c1">;; ...</span>
   <span class="p">(</span><span class="nf">check-x</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
   <span class="c1">;; ...</span>
   <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">;; @@PLEAC@@_10.3</span>
<span class="c1">; Ordinarily, a variable must be initialised when it is defined,</span>
<span class="c1">; whether at the top-level:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*variable*</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">; ... or within a &#39;let&#39; binding</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">variable</span> <span class="mi">1</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">mysub</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
           <span class="c1">;; ... accessing &#39;variable&#39; ...</span>
         <span class="o">&#39;</span><span class="p">())))</span>
  <span class="c1">;; ... do stuff ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">; However, since Scheme allows syntactic extensions via &#39;macros&#39; [of</span>
<span class="c1">; which there are two varieties: hygenic and LISP-based], it is</span>
<span class="c1">; possible to create new forms which alter this behaviour. For example,</span>
<span class="c1">; in this tutorial: http://home.comcast.net/~prunesquallor/macro.txt</span>
<span class="c1">; there is a macro implementation equivalent to &#39;let, &#39;called,</span>
<span class="c1">; &#39;bind-values&#39;, which allows variables to be defined without initial</span>
<span class="c1">; values; an example follows:</span>

<span class="c1">; Initialisation values for &#39;a&#39; and &#39;b&#39; not specified</span>
<span class="p">(</span><span class="nf">bind-values</span> <span class="p">((</span><span class="nf">a</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">*global*</span> <span class="mi">5</span><span class="p">)))</span>
  <span class="c1">;; ... do stuff ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">; In Scheme many things are possible, but not all those things are</span>
<span class="c1">; offered as standard features :) !</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">counter</span> <span class="mi">42</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">next-counter</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">counter</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">counter</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">counter</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">prev-counter</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">counter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">counter</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">counter</span><span class="p">)))</span>

  <span class="c1">;; ... do stuff with &#39;next-counter&#39; and &#39;prev-counter&#39; ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">;; ----</span>

<span class="c1">; A more complete, and practical, variation of the above code:</span>

<span class="c1">; &#39;counter&#39; constructor</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-counter</span> <span class="nv">start</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">counter</span> <span class="mi">42</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">next-counter</span>
           <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">counter</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">counter</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">counter</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">prev-counter</span>
           <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">counter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">counter</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">counter</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">op</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">&#39;prev</span><span class="p">)</span> <span class="nv">prev-counter</span><span class="p">)</span>
      <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">&#39;next</span><span class="p">)</span> <span class="nv">next-counter</span><span class="p">)</span>
      <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;error:counter&quot;</span><span class="p">)))</span> <span class="p">))))</span>

<span class="c1">; Interface functions to &#39;counter&#39; functionality</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">prev-counter</span> <span class="nv">counter</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nf">counter</span> <span class="ss">&#39;prev</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">next-counter</span> <span class="nv">counter</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nf">counter</span> <span class="ss">&#39;next</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">; Create a &#39;counter&#39;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*counter*</span> <span class="p">(</span><span class="nf">make-counter</span> <span class="mi">42</span><span class="p">))</span>

<span class="c1">; Use the &#39;counter&#39; ...</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">prev-counter</span> <span class="nv">*counter*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">prev-counter</span> <span class="nv">*counter*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">next-counter</span> <span class="nv">*counter*</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_10.4</span>
<span class="c1">; Scheme interpreters generally provide a rich collection of procedure</span>
<span class="c1">; metadata, as well as easy access to a program&#39;s current &#39;execution</span>
<span class="c1">; state&#39;. Put simply, provision of a powerful, highly customisable</span>
<span class="c1">; debugging / tracing facility is almost taken for granted. However, using</span>
<span class="c1">; it to perform as trivial a task as obtaining the current function name</span>
<span class="c1">; is less than trivial [at least it seems so in Guile] as it appears to</span>
<span class="c1">; require quite some setup work. Additionally, the documentation talks</span>
<span class="c1">; about facilities e.g. trap installation, that don&#39;t appear to be</span>
<span class="c1">; available [at least, I couldn&#39;t find them].</span>
<span class="c1">;</span>
<span class="c1">; Example below uses in-built debugging facilities to dump a backtrace</span>
<span class="c1">; to a string port and extract the caller&#39;s name from the resulting</span>
<span class="c1">; string. Not exactly elegant ...</span>

<span class="c1">; Execute using: guile --debug ... else no useful output seen</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">debug</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">child</span> <span class="nv">num</span><span class="p">)</span>
  <span class="c1">; Create stack [i.e. activation record] object, discarding</span>
  <span class="c1">; irrelevant frames</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">s</span> <span class="p">(</span><span class="nf">make-stack</span> <span class="no">#t</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">trace-string-port</span> <span class="p">(</span><span class="nf">open-output-string</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">parent-name</span> <span class="s">&quot;&quot;</span><span class="p">))</span>

    <span class="c1">; Dump backtrace to string port</span>
    <span class="p">(</span><span class="nf">display-backtrace</span> <span class="nv">s</span> <span class="nv">trace-string-port</span><span class="p">)</span>

    <span class="c1">; Extract caller&#39;s name from backtrace data</span>
    <span class="c1">; [shamefully crude - don&#39;t do this at home !]</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">parent-name</span>
      <span class="p">(</span><span class="nb">caddr </span><span class="p">(</span><span class="nf">string-tokenize</span>
               <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">string-split</span>
                       <span class="p">(</span><span class="nf">get-output-string</span> <span class="nv">trace-string-port</span><span class="p">)</span>
                       <span class="sc">#\newline</span><span class="p">))</span>
               <span class="nv">char-set:graphic</span><span class="p">)))</span>

    <span class="c1">; Who&#39;s your daddy ?</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">parent-name</span><span class="p">)))</span>

<span class="c1">; Each invocation of &#39;child&#39; should see &#39;parent&#39; displayed as</span>
<span class="c1">; the caller</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">parent</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">child</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">child</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">child</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nf">parent</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_10.5</span>
<span class="c1">; Procedure parameters are references to entities, so there is no special</span>
<span class="c1">; treatment required. If an argument represents a mutable object such</span>
<span class="c1">; as an array, then care should be taken to not mutate the object within</span>
<span class="c1">; the procedure, or a copy of the object be made and used</span>

<span class="p">(</span><span class="nf">array-diff</span> <span class="nv">*array1*</span> <span class="nv">*array2*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-vector-pair</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">x</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">vector-length</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">vector-length</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">x</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">y</span> <span class="nv">i</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))</span> <span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">5</span> <span class="mi">8</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*c*</span> <span class="p">(</span><span class="nf">add-vector-pair</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*c*</span><span class="p">)</span>

<span class="c1">;; ----</span>

  <span class="c1">;; ...</span>

  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">vector? </span><span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector? </span><span class="nv">a2</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">add-vector-pair</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">))</span>
  <span class="c1">;else</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;usage: add-vector-pair a1 a2&quot;</span><span class="p">))</span>

  <span class="c1">;; ...</span>

<span class="c1">;; @@PLEAC@@_10.6</span>
<span class="c1">; AFAIK there is no Scheme equivalent to Perl&#39;s &#39;return context&#39; where</span>
<span class="c1">; it is possible to use language primitives [e.g. &#39;wantarray&#39;] to</span>
<span class="c1">; dynamically specify the return type of a procedure. It is, however,</span>
<span class="c1">; possible to:</span>
<span class="c1">; * Return one of several types from a procedure, whether based on</span>
<span class="c1">;   processing results [e.g. &#39;false&#39; on error, numeric on success], or</span>
<span class="c1">;   perhaps specified via control argument</span>
<span class="c1">; * Check procedure return type and take appropriate action</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">my-sub</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">datatype</span> <span class="p">(</span><span class="nb">vector </span><span class="o">&#39;</span><span class="p">()</span> <span class="mi">7</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="s">&quot;abc&quot;</span> <span class="ss">&#39;sym</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">datatype</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">datatype</span><span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; &#39;*result*&#39; is bound to a randomly chosen datatype</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*result*</span> <span class="p">(</span><span class="nf">my-sub</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cond</span>
  <span class="c1">; It is common to return an empty list to represent &#39;void&#39;</span>
  <span class="p">((</span><span class="nb">null? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;void context&quot;</span><span class="p">))</span>

  <span class="p">((</span><span class="nb">list? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;list context&quot;</span><span class="p">))</span>
  <span class="p">((</span><span class="nb">number? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;scalar context&quot;</span><span class="p">))</span>
  <span class="p">((</span><span class="nb">string? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;string context&quot;</span><span class="p">))</span>
  <span class="p">((</span><span class="nb">symbol? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;atom context&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Unknown type&quot;</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_10.7</span>
<span class="c1">; Keyword parameters are fully supported. Note that pairs have</span>
<span class="c1">; replaced Perl strings in the examples since they are easier to</span>
<span class="c1">; manipulate</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">optargs</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define*</span> <span class="p">(</span><span class="nf">the-func</span> <span class="o">#</span><span class="nv">:key</span> <span class="p">(</span><span class="nf">increment</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">10</span> <span class="ss">&#39;s</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">finish</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="ss">&#39;m</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">start</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="ss">&#39;m</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">increment</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">finish</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">start</span><span class="p">))</span>

<span class="p">(</span><span class="nf">the-func</span><span class="p">)</span>
<span class="p">(</span><span class="nf">the-func</span>
  <span class="o">#</span><span class="nv">:increment</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">20</span> <span class="ss">&#39;s</span><span class="p">)</span> <span class="o">#</span><span class="nv">:start</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">5</span> <span class="ss">&#39;m</span><span class="p">)</span> <span class="o">#</span><span class="nv">:finish</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">30</span> <span class="ss">&#39;m</span><span class="p">))</span>
<span class="p">(</span><span class="nf">the-func</span> <span class="o">#</span><span class="nv">:start</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">5</span> <span class="ss">&#39;m</span><span class="p">)</span> <span class="o">#</span><span class="nv">:finish</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">30</span> <span class="ss">&#39;m</span><span class="p">))</span>
<span class="p">(</span><span class="nf">the-func</span> <span class="o">#</span><span class="nv">:finish</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">30</span> <span class="ss">&#39;m</span><span class="p">))</span>
<span class="p">(</span><span class="nf">the-func</span> <span class="o">#</span><span class="nv">:start</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">5</span> <span class="ss">&#39;m</span><span class="p">)</span> <span class="o">#</span><span class="nv">:increment</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">20</span> <span class="ss">&#39;s</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_10.8</span>
<span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; @@INCOMPLETE@@</span>

<span class="c1">;; @@PLEAC@@_10.9</span>
<span class="c1">; The return of multiple values, whether arrays or other items, may be</span>
<span class="c1">; achieved via:</span>
<span class="c1">; * Packaging return items as a single list, structure or array, an</span>
<span class="c1">;   approach which is usable across many languages, though can be</span>
<span class="c1">;   clunky because the procedure caller must manually extract all</span>
<span class="c1">;   items</span>
<span class="c1">; * The &#39;values&#39; procedure, a more Schemish idiom, is usually used in</span>
<span class="c1">;   conjunction with the &#39;call-with-values&#39; procedure [the former combines</span>
<span class="c1">;   multiple values, the latter captures and cleanly extracts them]. It</span>
<span class="c1">;   comes into its own, however, when used to create a &#39;macro&#39; [an</span>
<span class="c1">;   extension to the Scheme language] like &#39;let-values&#39;, a variation of</span>
<span class="c1">;   the &#39;let&#39; form that allows multiple return values to be placed directly</span>
<span class="c1">;   into separate variables. Implementation shown here is from &#39;The</span>
<span class="c1">;   Scheme Programming Language, 3rd Edition&#39; by R. Kent Dybvig, though</span>
<span class="c1">;   there exists a more standard implementation in SRFI-11. There is also</span>
<span class="c1">;   the &#39;receive&#39; functionality accessable via: (use-modules (ice-9 receive))</span>

<span class="c1">; [1] Implementation of &#39;somefunc&#39; returning muliple values via packaging</span>
<span class="c1">; items within a list that is returned</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">somefunc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">5</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">h</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">5</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">list </span><span class="nv">a</span> <span class="nv">h</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">; Retrieving procedure values requires that the return list be captured</span>
<span class="c1">; and each contained item separately extracted [&#39;let*&#39; used in place of</span>
<span class="c1">; &#39;let&#39; to ensure correct retrieval order]</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">return-list</span> <span class="p">(</span><span class="nf">somefunc</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">a</span> <span class="p">(</span><span class="nb">car </span><span class="nv">return-list</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">return-list</span><span class="p">)))</span>

  <span class="c1">;; ... do something with &#39;a&#39; and &#39;b&#39; ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; [2] Implementation of &#39;somefunc&#39; returning muliple values using the</span>
<span class="c1">; &#39;values&#39; procedure</span>

<span class="p">(</span><span class="nf">use-syntax</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">syncase</span><span class="p">))</span>

<span class="c1">; &#39;let-values&#39; from: http://www.scheme.com/tspl3/syntax.html#fullletvalues</span>
<span class="p">(</span><span class="k">define-syntax </span><span class="nv">let-values</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">()</span> <span class="nv">f1</span> <span class="nv">f2</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="k">let </span><span class="p">()</span> <span class="nv">f1</span> <span class="nv">f2</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">((</span><span class="nf">fmls1</span> <span class="nv">expr1</span><span class="p">)</span> <span class="p">(</span><span class="nf">fmls2</span> <span class="nv">expr2</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="nv">f1</span> <span class="nv">f2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">lvhelp</span> <span class="nv">fmls1</span> <span class="p">()</span> <span class="p">()</span> <span class="nv">expr1</span> <span class="p">((</span><span class="nf">fmls2</span> <span class="nv">expr2</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nf">f1</span> <span class="nv">f2</span> <span class="o">...</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">lvhelp</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">(</span><span class="nf">x1</span> <span class="o">.</span> <span class="nv">fmls</span><span class="p">)</span> <span class="p">(</span><span class="nf">x</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="o">...</span><span class="p">)</span> <span class="nv">e</span> <span class="nv">m</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">lvhelp</span> <span class="nv">fmls</span> <span class="p">(</span><span class="nf">x</span> <span class="o">...</span> <span class="nv">x1</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="o">...</span> <span class="nv">tmp</span><span class="p">)</span> <span class="nv">e</span> <span class="nv">m</span> <span class="nv">b</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">()</span> <span class="p">(</span><span class="nf">x</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="o">...</span><span class="p">)</span> <span class="nv">e</span> <span class="nv">m</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">call-with-values</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">e</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">t</span> <span class="o">...</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">let-values</span> <span class="nv">m</span> <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="nv">t</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)))))</span>
    <span class="p">((</span><span class="nf">_</span> <span class="nv">xr</span> <span class="p">(</span><span class="nf">x</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="o">...</span><span class="p">)</span> <span class="nv">e</span> <span class="nv">m</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">call-with-values</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">e</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">t</span> <span class="o">...</span> <span class="o">.</span> <span class="nv">tmpr</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">let-values</span> <span class="nv">m</span> <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="nv">t</span><span class="p">)</span> <span class="o">...</span> <span class="p">(</span><span class="nf">xr</span> <span class="nv">tmpr</span><span class="p">))</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)))))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">somefunc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">5</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">h</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">5</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values </span><span class="nv">a</span> <span class="nv">h</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">; Multiple return items placed directly into separate variables</span>
<span class="p">(</span><span class="nf">let-values</span> <span class="p">(</span> <span class="p">((</span><span class="nf">a</span> <span class="nv">h</span><span class="p">)</span> <span class="p">(</span><span class="nf">somefunc</span><span class="p">))</span> <span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">array?</span> <span class="nv">a</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">hash-table?</span> <span class="nv">h</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_10.10</span>
<span class="c1">; Like most modern languages, Scheme supports exceptions for handling</span>
<span class="c1">; failure, something that will be illustrated in another section. However,</span>
<span class="c1">; conventions exist as to the choice of value used to indicate failure:</span>
<span class="c1">; * Empty list i.e. &#39;() is often used for this task, as is it&#39;s string</span>
<span class="c1">;   counterpart, &quot;&quot;, the empty string</span>
<span class="c1">; * Return false i.e. #f to indicate failed / not found etc, and a valid</span>
<span class="c1">;   value otherwise [e.g. testing set membership: if not a member, return</span>
<span class="c1">;   #f, but if a member, return the item itself rather than #t]</span>

<span class="c1">; Return empty list as indicating &#39;failure&#39;</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-failed</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">look-for-something</span><span class="p">)</span>
  <span class="o">...</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">something-found</span><span class="p">)</span>
    <span class="c1">; Item found, return the item</span>
    <span class="nv">something</span>
  <span class="c1">;else</span>
    <span class="c1">; Not found, indicate failure</span>
    <span class="no">#f</span>
  <span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">look-for-something</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Item could not be found ...&quot;</span><span class="p">)</span>
<span class="c1">;else</span>
  <span class="c1">;; do something with item ...</span>
  <span class="c1">;; ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
  <span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; An interesting variation on returning #f as a failure indicator is</span>
<span class="c1">; in using the, &#39;false-if-exception&#39; procedure whereby a procedure is</span>
<span class="c1">; executed, any exceptions it may throw caught, and handled by simply</span>
<span class="c1">; returning #f. See example in section on Exception Handling below.</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">ioctl</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="no">#f</span><span class="p">)</span>

<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nf">print</span> <span class="s">&quot;can&#39;t ioctl&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">exit</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_10.11</span>
<span class="c1">; Whether Scheme is seen to support prototyping depends on the definition</span>
<span class="c1">; of this term used:</span>
<span class="c1">; * Prototyping along the lines used in Ada, Modula X, and even C / C++,</span>
<span class="c1">;   in which a procedure&#39;s interface is declared separately from its</span>
<span class="c1">;   implementation, is *not* supported</span>
<span class="c1">; * Prototyping in which, as part of the procedure definition, parameter</span>
<span class="c1">;   information must be supplied. This is a requirement in Scheme in that</span>
<span class="c1">;   parameter number and names must be given, though there is no need to</span>
<span class="c1">;   supply type information [optional and keyword parameters muddy the</span>
<span class="c1">;   waters somewhat, but the general principle applies]</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func-with-no-arg</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func-with-one-arg</span> <span class="nv">arg1</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func-with-two-arg</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func-with-three-arg</span> <span class="nv">arg1</span> <span class="nv">arg2</span> <span class="nv">arg3</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_10.12</span>
<span class="c1">; Not exactly like the Perl example, but a way of immediately</span>
<span class="c1">; exiting from an application</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">die</span> <span class="nv">msg</span> <span class="o">.</span> <span class="nv">error-code</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">string-append </span><span class="nv">msg</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">exit</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">error-code</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">error-code</span><span class="p">))))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="nf">die</span> <span class="s">&quot;some message&quot;</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; An exception is thrown via &#39;throw&#39;; argument must be a symbol</span>
<span class="p">(</span><span class="nf">throw</span> <span class="ss">&#39;some-exception</span><span class="p">)</span>

<span class="c1">; Invalid attempts - these, themselves force a &#39;wrong-type-arg</span>
<span class="c1">; exception to be thrown</span>
<span class="p">(</span><span class="nf">throw</span> <span class="no">#t</span><span class="p">)</span>
<span class="p">(</span><span class="nf">throw</span> <span class="s">&quot;my message&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">throw</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Example of a &#39;catch all&#39; handler - &#39;proc&#39; is executed, and any</span>
<span class="c1">; exception thrown is handled, in this case by simply returning false</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">false-if-exception</span> <span class="nv">proc</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
    <span class="nv">proc</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="no">#f</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Starting &#39;func&#39; ...&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">throw</span> <span class="ss">&#39;myexception</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Leaving &#39;func&#39; ...&quot;</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">false-if-exception</span> <span class="nv">main</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;&#39;func&#39; raised an exception&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;&#39;func&#39; executed normally&quot;</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; More typical exception handling example in which:</span>
<span class="c1">; * &#39;func&#39; is executed</span>
<span class="c1">; * &#39;catch&#39; either:</span>
<span class="c1">;   - returns return value of &#39;func&#39; [if successful]</span>
<span class="c1">;   - executes handler(s)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">full-moon-exception-handler</span> <span class="nv">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;I&#39;m executing after stack unwound !&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">full-moon-exception-prewind-handler</span> <span class="nv">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;I&#39;m executing with the stack still intact !&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Starting &#39;func&#39; ...&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">throw</span> <span class="ss">&#39;full-moon-exception</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Leaving &#39;func&#39; ...&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">catch</span> <span class="ss">&#39;full-moon-exception</span>
   <span class="nv">func</span>
   <span class="nv">full-moon-exception-handler</span>
   <span class="nv">full-moon-exception-prewind-handler</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_10.13</span>
<span class="c1">; Scheme is lexically-scoped, so same-name, higher-level variables</span>
<span class="c1">; are merely shadowed in lower-level blocks. Upon exit from those</span>
<span class="c1">; blocks the higher-level values are again available. Therefore, the</span>
<span class="c1">; saving of global variables, as required by Perl, is not necessary</span>

<span class="c1">; Global variable</span>
<span class="p">(</span><span class="k">define </span><span class="nv">age</span> <span class="mi">18</span><span class="p">)</span>

<span class="c1">; Procedure definition creates a closure - it captures the earlier</span>
<span class="c1">; version of, age&#39;, and will retain it</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">age</span><span class="p">))</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">condition</span><span class="p">)</span>
  <span class="c1">; New &#39;local&#39; variable created which acts to shadow the global</span>
  <span class="c1">; version</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">age</span> <span class="mi">23</span><span class="p">))</span>

    <span class="c1">; Prints 23 because the global variable is shadowed within</span>
    <span class="c1">; this block</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">age</span><span class="p">)</span>

    <span class="c1">; However, lexical-scoping ensures &#39;func&#39; still accesses the</span>
    <span class="c1">; &#39;age&#39; which was active when it was defined</span>
    <span class="p">(</span><span class="nf">func</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">; The use of &#39;fluid-let&#39; allows for similar behaviour to Perl&#39;s i.e.</span>
<span class="c1">; it mimics dynamic scope, but it does so cleanly in that once its</span>
<span class="c1">; scope ends any affected global variables are restored to previous</span>
<span class="c1">; values</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">condition</span><span class="p">)</span>

  <span class="c1">; This does not create a new &#39;local&#39; variables but temporarily</span>
  <span class="c1">; sets the global variable, &#39;age&#39; to 23</span>
  <span class="p">(</span><span class="nf">fluid-let</span> <span class="p">((</span><span class="nf">age</span> <span class="mi">23</span><span class="p">))</span>

    <span class="c1">; Prints 23 because it is accessing the global version of &#39;age&#39;</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">age</span><span class="p">)</span>

    <span class="c1">; Prints 23 because it is its lexically-scoped version of &#39;age&#39;</span>
    <span class="c1">; that has its value altered, albeit temporarily</span>
    <span class="p">(</span><span class="nf">func</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">;; @@PLEAC@@_10.14</span>
<span class="c1">; Define two procedures, bind them to identifiers</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">grow</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;grow&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">shrink</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;shrink&quot;</span><span class="p">))</span>

<span class="c1">; Separate procedures executed</span>
<span class="p">(</span><span class="nf">grow</span><span class="p">)</span>
<span class="p">(</span><span class="nf">shrink</span><span class="p">)</span>

<span class="c1">; Rebind identifier; now acts as alias for latter</span>
<span class="p">(</span><span class="k">define </span><span class="nv">grow</span> <span class="nv">shrink</span><span class="p">)</span>

<span class="c1">; Same procedure executed in both cases</span>
<span class="p">(</span><span class="nf">grow</span><span class="p">)</span>
<span class="p">(</span><span class="nf">shrink</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; As for previous except that rebinding is localised and</span>
<span class="c1">; ends once local scope exited</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">grow</span> <span class="nv">shrink</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">grow</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">shrink</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Example of dynamically creating [from text data] and binding</span>
<span class="c1">; procedures. The example here is conceptually similar to the Perl</span>
<span class="c1">; example in that it makes use of an &#39;eval&#39; type of facility to</span>
<span class="c1">; generate code from text. In Scheme such tasks are generally better</span>
<span class="c1">; dealt with using macros</span>

<span class="c1">; List of procedure name / first argument pairs</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*colours*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;red&quot;</span> <span class="o">.</span> <span class="s">&quot;baron&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;blue&quot;</span> <span class="o">.</span> <span class="s">&quot;zephyr&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;green&quot;</span> <span class="o">.</span> <span class="s">&quot;beret&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;yellow&quot;</span> <span class="o">.</span> <span class="s">&quot;ribbon&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;orange&quot;</span> <span class="o">.</span> <span class="s">&quot;county&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;purple&quot;</span> <span class="o">.</span> <span class="s">&quot;haze&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;violet&quot;</span> <span class="o">.</span> <span class="s">&quot;temper&quot;</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">; Build a series of procedures dynamically by traversing the</span>
<span class="c1">; *colours* list and obtaining:</span>
<span class="c1">; * Procedure name from first item of pair</span>
<span class="c1">; * Procedure argument from second item of pair</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">colour</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc-string</span>
            <span class="p">(</span><span class="nf">string-append</span>
              <span class="s">&quot;(define &quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">colour</span><span class="p">)</span> <span class="s">&quot; (lambda () &quot;</span>
              <span class="s">&quot;\&quot;&lt;FONT COLOR=&quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">colour</span><span class="p">)</span> <span class="s">&quot;&gt;&quot;</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">colour</span><span class="p">)</span>
              <span class="s">&quot;&lt;/FONT&gt;\&quot;))&quot;</span> <span class="p">)))</span>
      <span class="p">(</span><span class="nf">eval-string</span> <span class="nv">proc-string</span><span class="p">)))</span>
   <span class="nv">*colours*</span><span class="p">)</span>

<span class="c1">; Apply each of the dynamically-built procedures</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">colour</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nf">string-&gt;procedure</span> <span class="p">(</span><span class="nb">car </span><span class="nv">colour</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())))</span>
  <span class="nv">*colours*</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_10.15</span>
<span class="c1">; AFAICT Guile doesn&#39;t implement an AUTOLOAD facility in which a</span>
<span class="c1">; &#39;replacement&#39; function is available should another one fail to</span>
<span class="c1">; load [though there is an autoload feature available with modules</span>
<span class="c1">; which is a load-on-demand facility aimed at conserving memory and</span>
<span class="c1">; speeding up initial program load time].</span>
<span class="c1">;</span>
<span class="c1">; One might think it would be feasable, however, to use exception</span>
<span class="c1">; handling to provide roughly similar functionality:</span>

<span class="c1">; Catch all exceptions</span>
<span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
  <span class="c1">; Undefined procedure, &#39;x&#39;</span>
  <span class="nv">x</span>
  <span class="c1">; Exception handler could load missing code ?</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="o">...</span> <span class="p">))</span>

<span class="c1">; However, an undefined function call is reported as:</span>
<span class="c1">;</span>
<span class="c1">;    ERROR: Unbound variable: ...</span>
<span class="c1">;</span>
<span class="c1">; and this situation doesn&#39;t appear to be user-trappable.</span>
<span class="c1">;</span>

<span class="c1">;; @@PLEAC@@_10.16</span>
<span class="c1">; Both implementations below  are correct, and exhibit identical</span>
<span class="c1">; behaviour</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">outer</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">arg</span> <span class="mi">35</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">inner</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">19</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="p">(</span><span class="nf">inner</span><span class="p">))))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">outer</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">arg</span> <span class="mi">35</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">inner</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">19</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="p">(</span><span class="nf">inner</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_10.17</span>
<span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; @@INCOMPLETE@@</span>

<span class="c1">;; @@PLEAC@@_12.0</span>
<span class="c1">; Modules searched for by name in pre-configured paths [refer documentation</span>
<span class="c1">; for details]. For testing it is probably easiest to place them, and</span>
<span class="c1">; all other source files, in the current directory, and specify search</span>
<span class="c1">; path on command-line:</span>
<span class="c1">;</span>
<span class="c1">;     guile -L ./ -s testprog.scm</span>
<span class="c1">;</span>
<span class="c1">; Here, &#39;testprog.scm&#39; [see example] and modules reside in current the</span>
<span class="c1">; directory</span>

<span class="c1">; Load modules</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">alpha</span><span class="p">)</span>
              <span class="c1">; Optionally specify item(s) to use</span>
              <span class="nv">:select</span> <span class="p">(</span><span class="nf">name</span><span class="p">)</span>
              <span class="c1">; Optionally attach a &#39;module alias&#39; to distinguish items</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;alpha:</span><span class="p">))</span> <span class="p">)</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">omega</span><span class="p">)</span>
              <span class="nv">:select</span> <span class="p">(</span><span class="nf">name</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;omega:</span><span class="p">))</span> <span class="p">)</span>

<span class="c1">; Access module members</span>
<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;Alpha is &quot;</span> <span class="nv">alpha:name</span> <span class="s">&quot;, Omega is &quot;</span> <span class="nv">omega:name</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Module name and source file names match -&gt; alpha.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">alpha</span><span class="p">))</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">name</span> <span class="s">&quot;first&quot;</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Module name and source file names match -&gt; omega.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">omega</span><span class="p">))</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">name</span> <span class="s">&quot;last&quot;</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Guile doesn&#39;t distinguish between compile-time and run-time as far</span>
<span class="c1">; as module handling is concerned. A module is loaded when:</span>

<span class="c1">; * A (use-modules ...) is encountered</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">omega</span><span class="p">))</span>
             <span class="o">...</span>
             <span class="p">)</span>

<span class="c1">; * A reference is made to an item in a module specified as being</span>
<span class="c1">; autoloaded</span>

<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">new-module</span><span class="p">)</span>
               <span class="o">#</span><span class="nv">:autoload</span> <span class="p">(</span><span class="nf">mod-x</span><span class="p">)</span> <span class="p">(</span><span class="nf">mod-y</span><span class="p">))</span>
               <span class="c1">;; ...</span>

<span class="c1">; Module code loaded at this point</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">item-from-mod-x</span> <span class="nv">item</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="no">#t</span>
  <span class="c1">; else</span>
  <span class="c1">;; ...</span>
  <span class="no">#f</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_12.1</span>
<span class="c1">; All bindings within a module are private to it unless specifically</span>
<span class="c1">; exported, something which is accomplished via:</span>
<span class="c1">;</span>
<span class="c1">; * Use of (define-public ...) in place of (define ...) for each export</span>
<span class="c1">;   item</span>
<span class="c1">;</span>

<span class="c1">; Module name and source file names match -&gt; your-module.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">your-module</span><span class="p">))</span>

<span class="c1">; Module&#39;s &#39;interface&#39; - set of exported / publically-accessable items</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">version</span> <span class="s">&quot;1.2&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nf">a-public-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="s">&quot;a-public-proc&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nf">another-public-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="s">&quot;another-public-proc&quot;</span><span class="p">)</span>

<span class="c1">; Module&#39;s &#39;implementation&#39;, its internals</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a-private-var</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">a-private-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;</span>
<span class="c1">; or via:</span>
<span class="c1">;</span>
<span class="c1">; * Create an export list via: (export item1 item2 ...)</span>
<span class="c1">;</span>

<span class="c1">; Module name and source file names match -&gt; your-module.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">your-module</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">version</span> <span class="s">&quot;1.2&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">a-public-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="s">&quot;a-public-proc&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">another-public-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="s">&quot;another-public-proc&quot;</span><span class="p">)</span>

<span class="c1">; Module&#39;s &#39;interface&#39; - set of exported / publically-accessable items</span>
<span class="p">(</span><span class="nf">export</span> <span class="nv">version</span> <span class="nv">a-public-proc</span> <span class="nv">another-public-proc</span><span class="p">)</span>

<span class="c1">; Module&#39;s &#39;implementation&#39;, its internals</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a-private-var</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">a-private-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Load module, allowing access to all exported items, and uses</span>
<span class="c1">; specified prefix, &#39;ym:, to refer to module items</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">your-module</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;ym:</span><span class="p">))</span> <span class="p">)</span>

<span class="c1">; Access module members</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">ym:version</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">ym:a-public-proc</span> <span class="ss">&#39;x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">ym:another-public-proc</span> <span class="ss">&#39;x</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Load module, allowing access to all exported items, and uses no</span>
<span class="c1">; prefix for module items - they are identified as named within the</span>
<span class="c1">; module, something which may cause name-clash problems</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">your-module</span><span class="p">))</span>

<span class="c1">; Access module members</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">version</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">a-public-proc</span> <span class="ss">&#39;x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">another-public-proc</span> <span class="ss">&#39;x</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_12.2</span>
<span class="c1">; The module-handling procedures offer some reflective capabilities,</span>
<span class="c1">; including the ability to obtain a module&#39;s export list, and</span>
<span class="c1">; dynamically load / create a module. Here, a custom function is used</span>
<span class="c1">; to obtain a module&#39;s export list; since success indicates said module</span>
<span class="c1">; exists, it may be used to check module availability without the module</span>
<span class="c1">; being loaded. Note: this approach works, but since the documentation</span>
<span class="c1">; is rather sparse, I&#39;m not sure whether this is *the* best approach to</span>
<span class="c1">; this problem</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">module-available?</span> <span class="nv">module-name</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">resolve-interface</span> <span class="nv">module-name</span><span class="p">)</span> <span class="no">#t</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="no">#f</span><span class="p">)))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Is module available ?</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">module-available?</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">alpha</span><span class="p">))</span>
  <span class="c1">; Yes ? Load it for use, else report the problem</span>
  <span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">alpha</span><span class="p">)</span>
                <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;alpha:</span><span class="p">))</span> <span class="p">)</span>
<span class="c1">;else</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Module does not exist / not in load path&quot;</span><span class="p">))</span>

<span class="c1">;; ...</span>

<span class="c1">; Use module item(s) [assuming load was successful]</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">alpha:aa</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_12.3</span>
<span class="c1">; Guile doesn&#39;t distinguish between compile-time and run-time as far</span>
<span class="c1">; as module handling is concerned. A module is loaded when:</span>

<span class="c1">; * A (use-modules ...) is encountered</span>

<span class="c1">; (use-modules ((...))</span>

<span class="c1">; * A reference is made to an item in a module specified as being</span>
<span class="c1">; autoloaded</span>

<span class="c1">; (define-module (...)</span>
<span class="c1">;               #:autoload (mod-x) (...))</span>
<span class="c1">;               ...</span>

<span class="c1">; Module code loaded at this point</span>
<span class="c1">; (if (item-from-mod-x ...) ...)</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">num1</span> <span class="no">#f</span><span class="p">)</span> <span class="p">(</span><span class="nf">num2</span> <span class="no">#f</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nf">and</span>
      <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))</span> <span class="mi">3</span><span class="p">)</span>
      <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">num1</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span> <span class="nv">num1</span><span class="p">)</span>
      <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">num2</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="p">(</span><span class="nb">caddr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span> <span class="nv">num2</span><span class="p">))</span>

      <span class="c1">; Command-line processing successful - load modules to do some</span>
      <span class="c1">; real work</span>
      <span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">some-module</span><span class="p">)</span>
                    <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;some:</span><span class="p">))</span> <span class="p">)</span>

      <span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">another-module</span><span class="p">)</span>
                    <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;another:</span><span class="p">))</span> <span class="p">)</span>

      <span class="o">...</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">else</span>
      <span class="p">(</span><span class="nf">die</span>
        <span class="p">(</span><span class="nf">string-append</span>
          <span class="s">&quot;usage: guile -s &quot;</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))</span> <span class="s">&quot; num1 num2&quot;</span><span class="p">))</span> <span class="p">)))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">cond</span>
  <span class="p">(</span><span class="nf">opt-b</span>
    <span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">bigmath</span><span class="p">)</span>
                  <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;bigmath:</span><span class="p">))</span> <span class="p">)</span>
  <span class="c1">;; ...</span>
    <span class="c1">; use module</span>
  <span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">else</span>
    <span class="c1">;; ...</span>
    <span class="c1">; work without module</span>
   <span class="o">...</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_12.4</span>
<span class="c1">; Variables are private to a module unless exported</span>

<span class="c1">; Module name and source file names match -&gt; alpha.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">alpha</span><span class="p">))</span>

<span class="c1">; If &#39;define&#39; instead of &#39;define-public&#39; used, then items remain</span>
<span class="c1">; private</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">aa</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">x</span> <span class="s">&quot;azure&quot;</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Module name and source file names match -&gt; beta.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">beta</span><span class="p">))</span>

<span class="c1">; If &#39;define&#39; instead of &#39;define-public&#39; used, then items remain</span>
<span class="c1">; private</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">bb</span> <span class="mi">20</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">x</span> <span class="s">&quot;blue&quot;</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Load modules</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">alpha</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;alpha:</span><span class="p">))</span> <span class="p">)</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">beta</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;beta:</span><span class="p">))</span> <span class="p">)</span>

<span class="c1">; Access module items</span>
<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nf">string-append</span>
    <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">alpha:aa</span><span class="p">)</span> <span class="s">&quot;, &quot;</span>
    <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">beta:bb</span><span class="p">)</span> <span class="s">&quot;, &quot;</span>
    <span class="nv">alpha:x</span> <span class="s">&quot;, &quot;</span>
    <span class="nv">beta:x</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_12.5</span>
<span class="c1">; caller&#39;s package</span>
<span class="c1">; ??? backtrace trap</span>
<span class="nv">@@INCOMPLETE@@</span>
<span class="nv">@@INCOMPLETE@@</span>

<span class="c1">;; @@PLEAC@@_12.6</span>
<span class="c1">; automating module cleanup</span>
<span class="c1">; ??? hooks, guardians</span>
<span class="nv">@@INCOMPLETE@@</span>
<span class="nv">@@INCOMPLETE@@</span>

<span class="c1">;; @@PLEAC@@_12.7</span>
<span class="c1">; The directories Guile should search for modules are available in the</span>
<span class="c1">; global variable, &#39;%load-path&#39; based on configuration data supplied</span>
<span class="c1">; at installation time. Additional search directories may be specified</span>
<span class="c1">; using:</span>
<span class="c1">;</span>
<span class="c1">; * Command-line Option:   -L DIRNAME</span>
<span class="c1">; * Environment Variable:  GUILE_LOAD_PATH</span>
<span class="c1">;</span>
<span class="c1">; which act to prepend search data to the %load-path variable so that</span>
<span class="c1">; user modules will be processed before non-core system modules</span>
<span class="c1">;</span>
<span class="c1">; Following standalone code could be loaded in several ways - probably</span>
<span class="c1">; easiest to place it in a file and execute via: guile -s FILENAME</span>
<span class="c1">; Use &#39;guile --help&#39; for more execution options</span>
<span class="c1">;</span>

<span class="o">#</span><span class="nv">!</span>
<span class="nv">!</span><span class="o">#</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print</span> <span class="nv">item</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">all-item</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">rest</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot; &quot;</span><span class="p">))</span>
      <span class="nv">all-item</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">for-each-idx</span> <span class="nv">proc</span> <span class="nv">list</span> <span class="o">.</span> <span class="nv">start-idx</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">start-idx</span><span class="p">)</span>
                  <span class="mi">0</span>
                  <span class="p">(</span><span class="nb">car </span><span class="nv">start-idx</span><span class="p">)))</span>
             <span class="p">(</span><span class="nb">list </span><span class="nv">list</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">null? </span><span class="nv">list</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="nf">proc</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">car </span><span class="nv">list</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">list</span><span class="p">))))</span> <span class="p">))</span>

<span class="p">(</span><span class="nf">for-each-idx</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">i</span> <span class="nv">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">i</span> <span class="nv">item</span><span class="p">))</span>
  <span class="nv">%load-path</span><span class="p">)</span>

<span class="c1">; Output:</span>
<span class="c1">;</span>
<span class="c1">; 0 /usr/local/share/guile/site</span>
<span class="c1">; 1 /usr/local/share/guile/1.8</span>
<span class="c1">; 2 /usr/local/share/guile</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; To specify the location of user modules from outside the execution</span>
<span class="c1">; environment use any of the earlier mentioned approaches</span>

<span class="c1">; guile -L /projects/spectre/lib/ -s SCRIPTNAME ...</span>

<span class="c1">; Append:</span>
<span class="c1">;   set GUILE_LOAD_PATH=$GUILE_LOAD_PATH:/projects/spectre/lib/</span>
<span class="c1">; or prepend:</span>
<span class="c1">;   set GUILE_LOAD_PATH=/projects/spectre/lib/:$GUILE_LOAD_PATH</span>
<span class="c1">; export GUILE_LOAD_PATH</span>

<span class="c1">;; @@PLEAC@@_12.8</span>
<span class="c1">; Module distribution can be:</span>
<span class="c1">;</span>
<span class="c1">; * Informal, consisting of nothing more than copying all</span>
<span class="c1">;   relevant [.scm] files somewhere into the load path [see</span>
<span class="c1">;   previous section]. This task could be performed manually,</span>
<span class="c1">;   or automated using a custom installation script.</span>
<span class="c1">;</span>
<span class="c1">;   This approach would appear reasonable for very small one</span>
<span class="c1">;   or two [.scm] file systems, or where no additional libraries</span>
<span class="c1">;   [e.g. C static and dynamic libraries] are needed, but probably</span>
<span class="c1">;   not suitable for larger system distribution</span>
<span class="c1">;</span>
<span class="c1">; * Formal, using some published distribution means. AFAIK there</span>
<span class="c1">;   are no utilities such as Perl&#39;s &#39;h2xs&#39; to automate this process.</span>
<span class="c1">;   However, major Guile packages appear to use the GNU Build System</span>
<span class="c1">;   [i.e. autoconf, automake et al] for distribution. Since this</span>
<span class="c1">;   system is well known it is recommended that a suitable tutorial</span>
<span class="c1">;   be consulted. A later section will include a simple example</span>
<span class="c1">;</span>

<span class="c1">;; @@PLEAC@@_12.9</span>
<span class="c1">; Guile has no equivalent to Perl&#39;s &#39;selfloader&#39; facility, thus this</span>
<span class="c1">; section could not be implemented</span>

<span class="c1">;; @@PLEAC@@_12.10</span>
<span class="c1">; Guile has no equivalent to Perl&#39;s &#39;autoloader&#39; facility. The use</span>
<span class="c1">; of the &#39;autoload&#39; keyword with modules serves to ensure a module</span>
<span class="c1">; is loaded [if not already in memory] if specified module items</span>
<span class="c1">; are accessed. In other words, a &#39;load-on-demand&#39; facility which</span>
<span class="c1">; is, I believe, a somewhat different mechanism to Perl&#39;s, therefore,</span>
<span class="c1">; the examples in this section could not be implemented</span>
<span class="c1">;</span>

<span class="c1">;; @@PLEAC@@_12.11</span>
<span class="c1">; In Scheme, a built-in function [BIF] is no more than an object</span>
<span class="c1">; encapsulating a block of code [a &#39;lambda&#39;] that is bound to an</span>
<span class="c1">; identifier. Since identifier bindings can be readily altered, simply</span>
<span class="c1">; rebinding the identifier to a replacement lambda overrides the</span>
<span class="c1">; built-in version</span>

<span class="c1">; Show current time using built-in, &#39;current-time&#39;</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">; Override built-in by rebinding identifier with new lambda</span>
<span class="p">(</span><span class="k">define </span><span class="nv">current-time</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="s">&quot;This isn&#39;t the current time !&quot;</span><span class="p">))</span>

<span class="c1">; Does this show the current time ?</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; However, if overriding of built-ins occurs within a module:</span>
<span class="c1">;</span>
<span class="c1">; * All module code will see overidden code [assuming it occurs</span>
<span class="c1">;   early in the module]; this is as expected</span>
<span class="c1">; * Override will only affect module users if the same identifier</span>
<span class="c1">;   is exported [i.e. no module prefix is used]</span>

<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">override</span><span class="p">))</span>

<span class="c1">; Override &#39;current-time&#39;</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">current-time</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="s">&quot;This isn&#39;t the current time !&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nf">return-current-time</span><span class="p">)</span>
  <span class="c1">; Uses overriden version of, &#39;current-time&#39;</span>
  <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Import module using prefix</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">override</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;override:</span><span class="p">))</span> <span class="p">)</span>

<span class="c1">; Use overidden version</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">override:current-time</span><span class="p">))</span>

<span class="c1">; Top-level binding retained</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Import module - no prefix</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">override</span><span class="p">))</span>

<span class="c1">; Top-level binding overidden</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_12.12</span>
<span class="c1">; Simple custom error reporter mimicing Perl&#39;s &#39;die&#39;</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">die</span> <span class="nv">msg</span> <span class="o">.</span> <span class="nv">error-code</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">string-append </span><span class="nv">msg</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">exit</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">error-code</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">error-code</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">even-only</span> <span class="nv">num</span><span class="p">)</span>
  <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">modulo </span><span class="nv">num</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">die</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">num</span><span class="p">)</span> <span class="s">&quot; is not even&quot;</span><span class="p">))))</span>

<span class="c1">; Ok for the following:</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1">; ==&gt; #t</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1">; ==&gt; exits with error message and return code, 1</span>

<span class="c1">; However, the following applications:</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="ss">&#39;$</span><span class="p">)</span>     <span class="c1">; ==&gt; wrong type arg exception thrown</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="s">&quot;34&quot;</span><span class="p">)</span>   <span class="c1">; ==&gt; ditto</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Built-ins use the exception handling mechanism to trap and</span>
<span class="c1">; handle errors</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">even-only</span> <span class="nv">num</span><span class="p">)</span>
  <span class="c1">; Catch all exceptions</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
    <span class="c1">; Execute our &#39;work code&#39;</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">modulo </span><span class="nv">num</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1">; Make sure our error handler doesn&#39;t, itself, fail :) !</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">snum</span>
        <span class="p">(</span><span class="nf">cond</span>
          <span class="p">((</span><span class="nb">number? </span><span class="nv">num</span><span class="p">)</span> <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">num</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">symbol? </span><span class="nv">num</span><span class="p">)</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">num</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">string? </span><span class="nv">num</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;\&quot;&quot;</span> <span class="nv">num</span> <span class="s">&quot;\&quot;&quot;</span><span class="p">))</span>
          <span class="p">(</span><span class="k">else </span><span class="s">&quot;???&quot;</span><span class="p">)</span> <span class="p">)))</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">string-append </span><span class="nv">snum</span> <span class="s">&quot; is not even&quot;</span><span class="p">))</span>
        <span class="no">#f</span><span class="p">))))</span>

<span class="c1">; Ok for all the following:</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1">; ==&gt; #t</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1">; ==&gt; #f</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="ss">&#39;$</span><span class="p">)</span>     <span class="c1">; ==&gt; #f</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="s">&quot;34&quot;</span><span class="p">)</span>   <span class="c1">; ==&gt; #f</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Shorter, but coarser-grained version of the above</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">false-if-exception</span> <span class="nv">proc</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
    <span class="nv">proc</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="no">#f</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">even-only</span> <span class="nv">num</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">false-if-exception</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">modulo </span><span class="nv">num</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span> <span class="p">))</span>

<span class="c1">; Ok for all the following:</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1">; ==&gt; #t</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1">; ==&gt; #f</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="ss">&#39;$</span><span class="p">)</span>     <span class="c1">; ==&gt; #f</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="s">&quot;34&quot;</span><span class="p">)</span>   <span class="c1">; ==&gt; #f</span>

<span class="c1">;; @@PLEAC@@_12.13</span>
<span class="c1">; It is, of course, possible to dynamically generate module names</span>
<span class="c1">; and procedures, and gain access to those items indirectly; this is</span>
<span class="c1">; done via macros and &#39;eval&#39;</span>

<span class="c1">; Some helper procedures</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">load-module</span> <span class="nv">module-name</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">name</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="nv">module-name</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">prefix</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nb">string-append </span><span class="nv">module-name</span> <span class="s">&quot;:&quot;</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">primitive-eval</span>
      <span class="o">`</span><span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="o">,</span><span class="nv">name</span><span class="p">)</span> <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;,prefix</span><span class="p">))))</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">string-&gt;procedure</span> <span class="nv">proc-name</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">primitive-eval</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="nv">proc-name</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-prefixed-proc</span> <span class="nv">prefix</span> <span class="nv">proc-name</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">string-&gt;procedure</span> <span class="p">(</span><span class="nb">string-append </span><span class="nv">prefix</span> <span class="s">&quot;:&quot;</span> <span class="nv">proc-name</span><span class="p">)))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Example from earlier using &#39;indirect&#39; module loading and module</span>
<span class="c1">; procedure access</span>

<span class="c1">; Load a module &#39;indirectly&#39; i.e. name could be a string obtained</span>
<span class="c1">; from the user at runtime</span>
<span class="p">(</span><span class="nf">load-module</span> <span class="s">&quot;override&quot;</span><span class="p">)</span>

<span class="c1">; Execute module procedure using runtime-generated names</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nf">make-prefixed-proc</span> <span class="s">&quot;override&quot;</span> <span class="s">&quot;current-time&quot;</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">; This approach:</span>

<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">override:current-time</span><span class="p">))</span>

<span class="c1">; cannot be used because neither the module name nor the module</span>
<span class="c1">; procedure are known until runtime</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Module &#39;main&#39;</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">main</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nb">log </span><span class="nv">n</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Module name</span>
<span class="p">(</span><span class="k">define </span><span class="nv">module-name</span> <span class="s">&quot;main&quot;</span><span class="p">)</span>

<span class="c1">; Load the module</span>
<span class="p">(</span><span class="nf">load-module</span> <span class="nv">module-name</span><span class="p">)</span>

<span class="c1">; Conveneience procedure - alias for module procedure</span>
<span class="p">(</span><span class="k">define </span><span class="nv">log-proc</span> <span class="p">(</span><span class="nf">make-prefixed-proc</span> <span class="nv">module-name</span> <span class="s">&quot;log&quot;</span><span class="p">))</span>

<span class="c1">; Apply module procedure ...</span>
<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
    <span class="p">(</span><span class="nf">else</span>
      <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">log-proc</span> <span class="p">(</span><span class="nb">list </span><span class="nv">i</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Bind module items to top-level identifiers</span>
<span class="p">(</span><span class="k">define </span><span class="nv">blue</span> <span class="nv">colours:blue</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">main-blue</span> <span class="nv">colours:azure</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_12.14</span>
<span class="c1">; This section appears to illustrate access to shared library code</span>
<span class="c1">; from Perl. Guile offers several methods of doing the same,</span>
<span class="c1">; including:</span>
<span class="c1">;</span>
<span class="c1">; * The &#39;dynamic-link&#39;, &#39;dynamic-unlink&#39;, &#39;dynamic-call&#39;, and</span>
<span class="c1">;   &#39;dynamic-call-with-args&#39; primitives which, together, provide</span>
<span class="c1">;   a simple [if crude] means of accessing functions in shared</span>
<span class="c1">;   libraries [&#39;.so&#39; files]</span>
<span class="c1">;</span>
<span class="c1">; * The &#39;libffi&#39; facility, a cross-language facility for accessing</span>
<span class="c1">;   &#39;foreign&#39; [i.e. non-Scheme] functions. A Guile implementation is</span>
<span class="c1">;   available, though it does need some fine-tuning when installing</span>
<span class="c1">;   [see: http://www.mail-archive.com/guile-devel@gnu.org/msg00951.html</span>
<span class="c1">;   for more details]</span>
<span class="c1">;</span>
<span class="c1">; * Creating and installing new Guile compiled C primitives. This</span>
<span class="c1">;   process boils down to:</span>
<span class="c1">;</span>
<span class="c1">;   - Writing C worker function(s) to perform whatever is required</span>
<span class="c1">;   - Writing C wrapper function(s) for the workers i.e. glue code</span>
<span class="c1">;     that packs / unpacks and conerts arguments and return values</span>
<span class="c1">;   - Compiling using: #include &lt;libguile.h&gt;, and placing code into a</span>
<span class="c1">;     shared library [&#39;.so&#39;]</span>
<span class="c1">;   - Loading shared library in Guile via the &#39;load-extension&#39; primitive</span>
<span class="c1">;</span>

<span class="c1">; !!! dynamic-link example goes here</span>
<span class="nv">@@INCOMPLETE@@</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; !!! libffi example goes here</span>
<span class="c1">; ./configure --disable-deprecated --disable-discouraged</span>
<span class="nv">@@INCOMPLETE@@</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; !!! libguile.h example goes here</span>
<span class="nv">@@INCOMPLETE@@</span>

<span class="c1">;; @@PLEAC@@_12.15</span>
<span class="c1">; !!!</span>
<span class="c1">; This section appears to illustrate how a Perl module, in particular,</span>
<span class="c1">; one using C code, is built, ready for distribution. The Guile example</span>
<span class="c1">; will use the GNU Build system ...</span>
<span class="nv">@@INCOMPLETE@@</span>
<span class="nv">@@INCOMPLETE@@</span>

<span class="c1">;; @@PLEAC@@_12.16</span>
<span class="c1">; Possibly the simplest means of documenting Guile code,</span>
<span class="c1">; aside, of course, from manually inserting commentary, is</span>
<span class="c1">; via the use of &quot;docstrings&quot; in procedure definitions:</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sample-proc</span><span class="p">)</span>
    <span class="s">&quot;This procedure does this, that, and the other ...&quot;</span>
      <span class="o">...</span> <span class="nv">procedure</span> <span class="nv">code</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">; With the code loaded, the docstring for a procedure may be</span>
<span class="c1">; accessed via:</span>

    <span class="p">(</span><span class="nf">procedure-documentation</span> <span class="nv">sample-proc</span><span class="p">)</span>

<span class="c1">; Several packages for documenting Scheme / Guile code are</span>
<span class="c1">; available, and which may be roughly catergorised as:</span>
<span class="c1">;</span>
<span class="c1">; * Producing HTML-based documention [ala JavaDoc]</span>
<span class="c1">;   http://www.cs.auc.dk/~normark/schemedoc/</span>
<span class="c1">;</span>
<span class="c1">; * Generating TexInfo source for subsequent processing</span>
<span class="c1">;   http://swissnet.ai.mit.edu/~jaffer/Docupage/schmooz.html</span>
<span class="c1">;</span>
<span class="c1">; Both varieties rely on processing specially-formatted comment</span>
<span class="c1">; blocks, or other commen-embedded tags</span>
<span class="c1">;</span>

<span class="c1">;; @@PLEAC@@_12.17</span>
<span class="c1">; The Guile website hosts a libraries / projects page:</span>
<span class="c1">;</span>
<span class="c1">; http://www.gnu.org/software/guile/gnu-guile-projects.html#Libraries</span>
<span class="c1">;</span>
<span class="c1">; General installation procedure [assumes *NIX-based system and</span>
<span class="c1">; superuser privelages]:</span>
<span class="c1">;</span>
<span class="c1">; 1. Click on a link, follow download instructions</span>
<span class="c1">; 2. tar -zxvf newlibrary-x.y.z.tar.gz</span>
<span class="c1">; 3. cd newlibrary-x.y.z</span>
<span class="c1">; 4. ./configure</span>
<span class="c1">; 5. make</span>
<span class="c1">; 6. make check</span>
<span class="c1">; 7. make install</span>
<span class="c1">;</span>
<span class="c1">; A simple, Guile source-only library would simply see source files</span>
<span class="c1">; copied to the default Guile modules directory, and any relevant</span>
<span class="c1">; documentation installed, whilst a more complex library would also</span>
<span class="c1">; see native code libraries built and installed</span>
<span class="c1">;</span>
<span class="c1">; Notes:</span>
<span class="c1">;</span>
<span class="c1">; * Libraries may be available in other forms e.g. RPM&#39;s, Debian</span>
<span class="c1">;   packages, Window&#39;s installers or .zips - follow relevant</span>
<span class="c1">;   instructions</span>
<span class="c1">;</span>
<span class="c1">; * A simple, Guile source-only library may be manually copied</span>
<span class="c1">;   into the default modules directory or placed into an arbitrary</span>
<span class="c1">;   directory and location information passed to the interpreter</span>
<span class="c1">;   via environment variables or command-line. For example, for a</span>
<span class="c1">;   quick look one could copy relevant module .scm files into</span>
<span class="c1">;   the current directory and load them via:</span>
<span class="c1">;</span>
<span class="c1">;       guile -L ./ -s tester.scm</span>
<span class="c1">;</span>

<span class="c1">;; @@PLEAC@@_12.18</span>
<span class="c1">; The format of a Guile module really is quite simple; it is a</span>
<span class="c1">; source file:</span>
<span class="c1">;</span>
<span class="c1">; * Containing a &#39;define-module&#39; definition which serves to</span>
<span class="c1">;   name the module [the name would match the source file</span>
<span class="c1">;   basename (if a single name is used), or the last name</span>
<span class="c1">;   in a name list (preceding names are subdirectory names)]</span>
<span class="c1">;</span>
<span class="c1">; * A list of bindings to be exported, either via individual</span>
<span class="c1">;   &#39;define-public&#39; definitions, or via an &#39;export&#39; list</span>
<span class="c1">;</span>
<span class="c1">; Documentation is optional [but useful :)], as is any runtime</span>
<span class="c1">; accessable data such as version number or author name, or any</span>
<span class="c1">; special routines such as a module cleanup routine [just</span>
<span class="c1">; &#39;define-public&#39; whatever variable or procedure you want, and</span>
<span class="c1">; adopt a convention for its use]</span>
<span class="c1">;</span>

<span class="c1">; module.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">module</span><span class="p">))</span>

<span class="c1">; ---</span>

<span class="c1">; Module implementation</span>
<span class="p">(</span><span class="k">define </span><span class="nv">private-variable</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">private-procedure</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; ---</span>

<span class="c1">; Module interface</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">exported-variable</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nf">exported-procedure</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; @@PLEAC@@_13.0</span>
<span class="c1">;; Guile OOP is in the (oop goops) module (based on CLOS).  All</span>
<span class="c1">;; following sections assume you have (oop goops loaded).</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">oop</span> <span class="nv">goops</span><span class="p">))</span>
<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;data-encoder&gt;</span> <span class="p">())</span>
<span class="p">(</span><span class="k">define </span><span class="nv">obj</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;data-encoder&gt;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">obj</span> <span class="o">#</span><span class="p">(</span><span class="mi">3</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A ~A\n&quot;</span> <span class="p">(</span><span class="nf">class-of</span> <span class="nv">obj</span><span class="p">)</span> <span class="p">(</span><span class="nf">array-ref</span> <span class="nv">obj</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nf">change-class</span> <span class="nv">v</span> <span class="nv">&lt;human-cannibal&gt;</span><span class="p">)</span> <span class="c1">; has to be defined</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A ~A\n&quot;</span> <span class="p">(</span><span class="nf">slot-ref</span> <span class="nv">obj</span> <span class="nv">stomach</span><span class="p">)</span> <span class="p">(</span><span class="nf">slot-ref</span> <span class="nv">obj</span> <span class="nv">name</span><span class="p">))</span>

<span class="p">(</span><span class="nf">slot-ref</span> <span class="nv">obj</span> <span class="ss">&#39;stomach</span><span class="p">)</span>
<span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">obj</span> <span class="ss">&#39;stomach</span> <span class="s">&quot;Empty&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">name</span> <span class="nv">obj</span><span class="p">)</span>
<span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">name</span> <span class="nv">obj</span><span class="p">)</span> <span class="s">&quot;Thag&quot;</span><span class="p">)</span>

<span class="c1">;; inheritance</span>
<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;lawyer&gt;</span> <span class="p">(</span><span class="nf">&lt;human-cannibal&gt;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">lector</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;human-cannibal&gt;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">feed</span> <span class="nv">lector</span> <span class="s">&quot;Zak&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">move</span> <span class="nv">lector</span> <span class="s">&quot;New York&quot;</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_13.1</span>
<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;my-class&gt;</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">start</span> <span class="o">#</span><span class="nv">:init-form</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">age</span> <span class="o">#</span><span class="nv">:init-value</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">;; classes must have predefined slots, but you could use one as a</span>
<span class="c1">;; dictionary:</span>
<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;my-class&gt;</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">start</span> <span class="o">#</span><span class="nv">:init-form</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">age</span> <span class="o">#</span><span class="nv">:init-value</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">properties</span> <span class="o">#</span><span class="nv">:init-value</span> <span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">initialize</span> <span class="p">(</span><span class="nf">m</span> <span class="nv">&lt;my-class&gt;</span><span class="p">)</span> <span class="nv">initargs</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">and-let*</span> <span class="p">((</span><span class="nf">extra</span> <span class="p">(</span><span class="nb">memq </span><span class="o">#</span><span class="nv">:extra</span> <span class="nv">initargs</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">m</span> <span class="ss">&#39;properties</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">extra</span><span class="p">))))</span>

<span class="c1">;; @@PLEAC@@_13.2</span>
<span class="c1">;; For smobs (external C objects), you can specify a callback to be</span>
<span class="c1">;; performed when the object is garbage collected with the C API</span>
<span class="c1">;; function `scm_set_smob_free&#39;.  This solves the problem of cleaning up</span>
<span class="c1">;; after external objects and connections.  Guile doesn&#39;t use reference</span>
<span class="c1">;; count garbage collection, so circular data structures aren&#39;t a</span>
<span class="c1">;; problem.</span>

<span class="c1">;; @@PLEAC@@_13.3</span>
<span class="c1">;; either use slot-ref/set!</span>
<span class="p">(</span><span class="nf">slot-ref</span> <span class="nv">obj</span> <span class="ss">&#39;name</span><span class="p">)</span>
<span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">obj</span> <span class="ss">&#39;name</span> <span class="nv">value</span><span class="p">)</span>

<span class="c1">;; or define the class with accessors</span>
<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;my-class&gt;</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">name</span> <span class="o">#</span><span class="nv">:accessor</span> <span class="nv">name</span><span class="p">))</span>
<span class="p">(</span><span class="nf">name</span> <span class="nv">obj</span><span class="p">)</span>
<span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">name</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">value</span><span class="p">)</span>

<span class="c1">;; or use getters/setters to implement read/write-only slots</span>
<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;my-class&gt;</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">name</span> <span class="o">#</span><span class="nv">:getter</span> <span class="nv">name</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">age</span> <span class="o">#</span><span class="nv">:setter</span> <span class="nv">age</span><span class="p">))</span>
<span class="p">(</span><span class="nf">name</span> <span class="nv">obj</span><span class="p">)</span>
<span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">age</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">value</span><span class="p">)</span>

<span class="c1">;; or implement getters/setters manually</span>
<span class="p">(</span><span class="nf">define-method</span> <span class="p">((</span><span class="nf">setter</span> <span class="nv">name</span><span class="p">)</span> <span class="p">(</span><span class="nf">obj</span> <span class="nv">&lt;my-class&gt;</span><span class="p">)</span> <span class="nv">value</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">string-match</span> <span class="s">&quot;[^-\\w0-9&#39;]&quot;</span> <span class="nv">value</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">warn</span> <span class="s">&quot;funny characters in name&quot;</span><span class="p">))</span>
        <span class="p">((</span><span class="nf">string-match</span> <span class="s">&quot;[0-9]&quot;</span> <span class="nv">value</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">warn</span> <span class="s">&quot;numbers in name&quot;</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;\\w+\\W+\\w+&quot;</span> <span class="nv">value</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">warn</span> <span class="s">&quot;prefer multiword names&quot;</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nf">string-match</span> <span class="s">&quot;\\w&quot;</span> <span class="nv">value</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">warn</span> <span class="s">&quot;name is blank&quot;</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">obj</span> <span class="ss">&#39;name</span> <span class="p">(</span><span class="nf">string-downcase</span> <span class="nv">value</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_13.4</span>
<span class="c1">;; override the initialize method</span>
<span class="p">(</span><span class="k">define </span><span class="nv">body-count</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="nf">define-method</span> <span class="p">(</span><span class="nf">initialize</span> <span class="p">(</span><span class="nf">obj</span> <span class="nv">&lt;person&gt;</span><span class="p">)</span> <span class="nv">initargs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">body-count</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">body-count</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">next-method</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">people</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">1</span><span class="nv">+</span> <span class="nv">i</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">&gt; </span><span class="nv">i</span> <span class="mi">10</span><span class="p">))</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">people</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;person&gt;</span><span class="p">)</span> <span class="nv">people</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;There are ~A people alive.\n&quot;</span> <span class="nv">body-count</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">him</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;person&gt;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">him</span> <span class="ss">&#39;gender</span> <span class="s">&quot;male&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">her</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;person&gt;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">her</span> <span class="ss">&#39;gender</span> <span class="s">&quot;female&quot;</span><span class="p">)</span>

<span class="c1">;; use the :class allocation method</span>
<span class="p">(</span><span class="nf">slot-set!</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;fixed-array&gt;</span><span class="p">)</span> <span class="ss">&#39;max-bounds</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">; set for whole class</span>
<span class="p">(</span><span class="k">define </span><span class="nv">alpha</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;fixed-array&gt;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Bound on alpha is ~D\n&quot;</span> <span class="p">(</span><span class="nf">slot-ref</span> <span class="nv">alpha</span> <span class="ss">&#39;max-bounds</span><span class="p">))</span>
<span class="c1">;; 100</span>

<span class="p">(</span><span class="k">define </span><span class="nv">beta</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;fixed-array&gt;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">beta</span> <span class="ss">&#39;max-bounds</span> <span class="mi">50</span><span class="p">)</span>          <span class="c1">; still sets for whole class</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Bound on alpha is ~D\n&quot;</span> <span class="p">(</span><span class="nf">slot-ref</span> <span class="nv">alpha</span> <span class="ss">&#39;max-bounds</span><span class="p">))</span>
<span class="c1">;; 50</span>

<span class="c1">;; defined simply as</span>
<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;fixed-array&gt;</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">max-bounds</span> <span class="o">#</span><span class="nv">:init-value</span> <span class="mi">7</span> <span class="o">#</span><span class="nv">:allocation</span> <span class="o">#</span><span class="nv">:class</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_13.5</span>
<span class="c1">;; Guile classes are basically structs by definition.  If you don&#39;t care</span>
<span class="c1">;; about OO programming at all, you can use records, which are portable</span>
<span class="c1">;; across most Schemes.  This is, however, an OO chapter so I&#39;ll stick</span>
<span class="c1">;; to classes.</span>
<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;person&gt;</span> <span class="p">()</span> <span class="nv">name</span> <span class="nv">age</span> <span class="nv">peers</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;person&gt;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">p</span> <span class="ss">&#39;name</span> <span class="s">&quot;Jason Smythe&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">p</span> <span class="ss">&#39;age</span> <span class="mi">13</span><span class="p">)</span>
<span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">p</span> <span class="ss">&#39;peers</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Wilbur&quot;</span> <span class="s">&quot;Ralph&quot;</span> <span class="s">&quot;Fred&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;At age ~D, ~A&#39;s first friend is ~A.\n&quot;</span>
        <span class="p">(</span><span class="nf">slot-ref</span> <span class="nv">p</span> <span class="ss">&#39;age</span><span class="p">)</span> <span class="p">(</span><span class="nf">slot-ref</span> <span class="nv">p</span> <span class="ss">&#39;name</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">slot-ref</span> <span class="nv">p</span> <span class="ss">&#39;peers</span><span class="p">)))</span>

<span class="c1">;; For type-checking and field validation, define the setters</span>
<span class="c1">;; accordingly.</span>
<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;person&gt;</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">name</span> <span class="o">#</span><span class="nv">:accessor</span> <span class="nv">name</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">age</span> <span class="o">#</span><span class="nv">:accessor</span> <span class="nv">age</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define-method</span> <span class="p">((</span><span class="nf">setter</span> <span class="nv">age</span><span class="p">)</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">&lt;person&gt;</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">number? </span><span class="nv">a</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">warn</span> <span class="s">&quot;age&quot;</span> <span class="nv">a</span> <span class="s">&quot;isn&#39;t numeric&quot;</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="mi">150</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">warn</span> <span class="s">&quot;age&quot;</span> <span class="nv">a</span> <span class="s">&quot;is unreasonable&quot;</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">slot-set!</span> <span class="nv">p</span> <span class="ss">&#39;age</span> <span class="nv">a</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define-class</span> <span class="nv">&lt;family&gt;</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">head</span> <span class="o">#</span><span class="nv">:init-form</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;person&gt;</span><span class="p">)</span> <span class="o">#</span><span class="nv">:accessor</span> <span class="nv">head</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">address</span> <span class="o">#</span><span class="nv">:init-value</span> <span class="s">&quot;&quot;</span> <span class="o">#</span><span class="nv">:accessor</span> <span class="nv">address</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">members</span> <span class="o">#</span><span class="nv">:init-value</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">#</span><span class="nv">:accessor</span> <span class="nv">members</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">folks</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;family&gt;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">dad</span> <span class="p">(</span><span class="nf">head</span> <span class="nv">folks</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">name</span> <span class="nv">dad</span><span class="p">)</span> <span class="s">&quot;John&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">age</span> <span class="nv">dad</span><span class="p">)</span> <span class="mi">34</span><span class="p">)</span>

<span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;~A&#39;s age is ~D\n&quot;</span> <span class="p">(</span><span class="nf">name</span> <span class="nv">dad</span><span class="p">)</span> <span class="p">(</span><span class="nf">age</span> <span class="nv">dad</span><span class="p">))</span>

<span class="c1">;; Macros are the usual way to add syntactic sugar</span>

<span class="c1">;; For all fields of the same type, let&#39;s use _ to mean the slot name in</span>
<span class="c1">;; the options expansion.</span>
<span class="p">(</span><span class="nf">define-macro</span> <span class="p">(</span><span class="nf">define-uniform-class</span> <span class="nv">name</span> <span class="nv">supers</span> <span class="nv">slots</span> <span class="o">.</span> <span class="nv">options</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nf">define-class</span> <span class="o">,</span><span class="nv">name</span> <span class="o">,</span><span class="nv">supers</span>
     <span class="o">,@</span><span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">s</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">o</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="nv">o</span> <span class="ss">&#39;_</span><span class="p">)</span> <span class="nv">s</span> <span class="nv">o</span><span class="p">))</span> <span class="nv">options</span><span class="p">)))</span>
            <span class="nv">slots</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">define-uniform-class</span> <span class="nv">&lt;card&gt;</span> <span class="p">(</span><span class="nf">name</span> <span class="nv">color</span> <span class="nv">cost</span> <span class="nv">type</span> <span class="nv">release</span> <span class="nv">text</span><span class="p">)</span>
  <span class="o">#</span><span class="nv">:accessor</span> <span class="nv">_</span> <span class="o">#</span><span class="nv">:init-value</span> <span class="s">&quot;&quot;</span><span class="p">)</span>

<span class="c1">;; If you *really* wanted to enforce slot types you could use something</span>
<span class="c1">;; like the above with the custom setter.  To illustrate reversing</span>
<span class="c1">;; normal slot definition args, we&#39;ll reverse an init-value:</span>
<span class="p">(</span><span class="nf">define-macro</span> <span class="p">(</span><span class="nf">define-default-class</span> <span class="nv">name</span> <span class="nv">supers</span> <span class="o">.</span> <span class="nv">default&amp;slots</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nf">define-class</span> <span class="o">,</span><span class="nv">name</span> <span class="o">,</span><span class="nv">supers</span>
     <span class="o">,@</span><span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">d&amp;s</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">d&amp;s</span><span class="p">)</span>
                                <span class="o">#</span><span class="nv">:init-value</span> <span class="p">(</span><span class="nb">car </span><span class="nv">d&amp;s</span><span class="p">)</span>
                                <span class="o">#</span><span class="nv">:accessor</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">d&amp;s</span><span class="p">)))</span>
            <span class="nv">default&amp;slots</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">define-default-class</span> <span class="nv">hostent</span> <span class="p">()</span>
  <span class="p">(</span><span class="s">&quot;&quot;</span> <span class="nv">name</span><span class="p">)</span>
  <span class="p">(</span><span class="o">&#39;</span><span class="p">()</span> <span class="nv">aliases</span><span class="p">)</span>
  <span class="p">(</span><span class="s">&quot;&quot;</span> <span class="nv">addrtype</span><span class="p">)</span>
  <span class="p">(</span><span class="mi">0</span>  <span class="nv">length</span><span class="p">)</span>
  <span class="p">(</span><span class="o">&#39;</span><span class="p">()</span> <span class="nv">addr-list</span><span class="p">))</span>

<span class="c1">;; Nothing special needed for Aliases - all names are equal</span>
<span class="p">(</span><span class="k">define </span><span class="nv">type</span> <span class="nv">addrtype</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-method</span> <span class="p">(</span><span class="nf">addr</span> <span class="p">(</span><span class="nf">h</span> <span class="nv">&lt;hostent&gt;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">addr-list</span> <span class="nv">h</span><span class="p">)))</span>

<span class="c1">;; @@PLEAC@@_13.6</span>
<span class="c1">;; A little more clear than the Perl, but not very useful.</span>
<span class="p">(</span><span class="k">define </span><span class="nv">obj1</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;some-class&gt;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">obj2</span> <span class="p">(</span><span class="nf">make</span> <span class="p">(</span><span class="nf">class-of</span> <span class="nv">obj1</span><span class="p">)))</span>

<span class="c1">;; Use the shallow-clone or deep-clone methods to initialize from</span>
<span class="c1">;; another instance.</span>
<span class="p">(</span><span class="k">define </span><span class="nv">obj1</span> <span class="p">(</span><span class="nf">make</span> <span class="nv">&lt;widget&gt;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">obj2</span> <span class="p">(</span><span class="nf">deep-clone</span> <span class="nv">obj1</span><span class="p">))</span>

<span class="c1">;; @@PLEAC@@_13.7</span>
<span class="c1">;; Use eval or a variant to convert from a symbol or string to the</span>
<span class="c1">;; actual method.  As shown in 13.5 above, methods are first class and</span>
<span class="c1">;; you&#39;d be more likely to store the actual method than the name in a</span>
<span class="c1">;; real Scheme program.</span>
<span class="p">(</span><span class="k">define </span><span class="nv">methname</span> <span class="s">&quot;flicker&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">apply-generic</span> <span class="p">(</span><span class="nf">eval-string</span> <span class="nv">methname</span><span class="p">)</span> <span class="nv">obj</span> <span class="mi">10</span><span class="p">)</span>

<span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="nv">obj</span> <span class="p">(</span><span class="nf">eval-string</span> <span class="nv">m</span><span class="p">)))</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;start&quot;</span> <span class="s">&quot;run&quot;</span> <span class="s">&quot;stop&quot;</span><span class="p">))</span>

<span class="c1">;; really, don&#39;t do this...</span>
<span class="p">(</span><span class="k">define </span><span class="nv">methods</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;name&quot;</span> <span class="s">&quot;rank&quot;</span> <span class="s">&quot;serno&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">his-info</span>
  <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">m</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">m</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="p">(</span><span class="nf">eval-string</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)))</span>
       <span class="nv">methods</span><span class="p">))</span>

<span class="c1">;; same as this:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">his-info</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="s">&quot;name&quot;</span> <span class="p">(</span><span class="nf">name</span> <span class="nv">obj</span><span class="p">))</span>
                       <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;rank&quot;</span> <span class="p">(</span><span class="nf">rank</span> <span class="nv">obj</span><span class="p">))</span>
                       <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;serno&quot;</span> <span class="p">(</span><span class="nf">serno</span> <span class="nv">obj</span><span class="p">))))</span>

<span class="c1">;; a closure works</span>
<span class="p">(</span><span class="k">define </span><span class="nv">fnref</span> <span class="p">(</span><span class="k">lambda </span><span class="nv">args</span> <span class="p">(</span><span class="nf">method</span> <span class="nv">obj</span> <span class="nv">args</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">fnref</span> <span class="mi">10</span> <span class="s">&quot;fred&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">method</span> <span class="nv">obj</span> <span class="mi">10</span> <span class="nv">fred</span><span class="p">)</span>

<span class="c1">;; @@PLEAC@@_13.8</span>
<span class="c1">;; use is-a?</span>
<span class="p">(</span><span class="nf">is-a?</span> <span class="nv">obj</span> <span class="nv">&lt;http-message&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">is-a?</span> <span class="nv">&lt;http-response&gt;</span> <span class="nv">&lt;http-message&gt;</span><span class="p">)</span>
</pre></div>
</body>
</html>
