<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=latin1">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre> <span class="c"># -*- tcl -*-</span>


<span class="c"># @@PLEAC@@_NAME</span>
<span class="c"># @@SKIP@@ Tcl</span>

<span class="c"># @@PLEAC@@_WEB</span>
<span class="c"># @@SKIP@@ http://tcl.tk/</span>

<span class="c"># @@PLEAC@@_INTRO</span>
<span class="c"># @@SKIP@@ Version: Tcl 8.4</span>

<span class="c"># @@PLEAC@@_APPENDIX</span>
<span class="c"># @@SKIP@@ General-purpose, custom functions that might be used in several sections, appear here</span>

<span class="c"># coroutines.</span>
<span class="c"># recursion messes with the uplevel stuff. so using this imperative</span>
<span class="c"># version instead.</span>
<span class="c"># what we have here is an eqivalent of ruby&#39;s str.gsub! &amp;block mechanism,</span>
<span class="c"># where each matched string is passed into the block and the results are</span>
<span class="c"># used for substitution.</span>

<span class="k">proc</span> gregsub <span class="k">{</span><span class="nv">re</span> txt block<span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> res <span class="k">{}</span>
    <span class="k">while</span> <span class="mi">1</span> <span class="k">{</span>
        <span class="c">#fetch the regexp first</span>
        <span class="k">set</span> part <span class="k">[</span><span class="nb">lindex</span> <span class="k">[</span><span class="nb">regexp</span> <span class="o">-</span>inline <span class="nv">$re</span> <span class="nv">$txt</span><span class="k">]</span> <span class="mi">1</span><span class="k">]</span>
        <span class="k">if</span> <span class="k">{</span><span class="o">!</span><span class="k">[</span><span class="nb">string</span> length <span class="nv">$part</span><span class="k">]}</span> <span class="k">{</span>
                <span class="nb">append</span> res <span class="nv">$txt</span>
                <span class="k">break</span>
        <span class="k">}</span>

        <span class="c">#now substitute with original</span>
        <span class="k">set</span> lst <span class="k">[</span><span class="nb">split</span> <span class="k">[</span><span class="nb">regsub</span> <span class="o">--</span> <span class="nv">$re</span> <span class="nv">$txt</span> <span class="s2">&quot;\0&quot;</span><span class="k">]</span> <span class="s2">&quot;\0&quot;</span><span class="k">]</span>
        <span class="nb">append</span> res <span class="k">[</span><span class="nb">lindex</span> <span class="nv">$lst</span> <span class="mi">0</span><span class="k">]</span> <span class="k">[apply</span> <span class="nv">$block</span> <span class="nv">$part</span><span class="k">]</span>
        <span class="k">set</span> txt <span class="k">[</span><span class="nb">lindex</span> <span class="nv">$lst</span> <span class="mi">1</span><span class="k">]</span>
    <span class="k">}</span>
    <span class="k">return</span> <span class="nv">$res</span>
<span class="k">}</span>

<span class="k">proc</span> regrange <span class="k">{</span><span class="nv">p1</span> sep p2 data block<span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> on <span class="mi">0</span>
    <span class="k">set</span> delay <span class="mi">0</span>
    <span class="k">if</span> <span class="k">{</span><span class="o">!</span><span class="k">[</span><span class="nb">string</span> compare <span class="nv">$sep</span> <span class="s2">&quot;...&quot;</span><span class="k">]}</span> <span class="k">{</span>
        <span class="k">set</span> delay <span class="mi">1</span>
    <span class="k">}</span>
    <span class="k">if</span> <span class="o">!</span><span class="k">[</span><span class="nb">llength</span> <span class="nv">$p1</span><span class="k">]</span> <span class="k">{</span> <span class="err">;</span><span class="c"># {} for start from begining.</span>
        <span class="k">set</span> on <span class="mi">1</span>
        <span class="k">set</span> p1 <span class="k">{</span><span class="nv">$-</span><span class="o">^</span><span class="k">}</span> <span class="k">;</span><span class="c"># never match any thing more.</span>
    <span class="k">}</span>

    <span class="k">foreach</span> line <span class="nv">$data</span> <span class="k">{</span>
        <span class="k">switch</span> <span class="o">-</span>exact <span class="o">--</span> <span class="nv">$sep</span> <span class="k">{</span>
            <span class="k">{</span><span class="nv">..</span><span class="k">}</span>  <span class="k">{</span>
                <span class="k">if</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="o">--</span> <span class="nv">$p1</span> <span class="nv">$line</span><span class="k">]}</span> <span class="k">{set</span> on <span class="mi">1</span><span class="k">}</span> <span class="k">elseif</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="o">--</span> <span class="nv">$p2</span> <span class="nv">$line</span><span class="k">]}</span> <span class="k">{set</span> delay <span class="mi">1</span><span class="k">}</span>
                <span class="k">if</span> <span class="k">{</span><span class="nv">$on</span><span class="k">}</span> <span class="k">{</span>
                    <span class="c">#do thingies.</span>
                    <span class="k">apply</span> <span class="nv">$block</span> <span class="nv">$line</span>
                <span class="k">}</span>
                <span class="k">if</span> <span class="k">{</span><span class="nv">$delay</span><span class="k">}</span> <span class="k">{</span>
                    <span class="k">set</span> on <span class="mi">0</span>
                    <span class="k">set</span> delay <span class="mi">0</span>
                <span class="k">}</span>
            <span class="k">}</span>
            <span class="k">{</span><span class="nv">...</span><span class="k">}</span> <span class="k">{</span>
                <span class="k">if</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="o">--</span> <span class="nv">$p1</span> <span class="nv">$line</span><span class="k">]}</span> <span class="k">{set</span> delay <span class="mi">0</span><span class="k">}</span> <span class="k">elseif</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="o">--</span> <span class="nv">$p2</span> <span class="nv">$line</span><span class="k">]}</span> <span class="k">{set</span> on <span class="mi">0</span><span class="k">}</span>
                <span class="k">if</span> <span class="k">{</span><span class="nv">$on</span><span class="k">}</span> <span class="k">{</span>
                    <span class="c">#do thingies.</span>
                    <span class="k">apply</span> <span class="nv">$block</span> <span class="nv">$line</span>
                <span class="k">}</span>
                <span class="k">if</span> <span class="k">{</span><span class="o">!</span><span class="nv">$delay</span><span class="k">}</span> <span class="k">{</span>
                    <span class="k">set</span> on <span class="mi">1</span>
                    <span class="k">set</span> delay <span class="mi">1</span>
                <span class="k">}</span>
            <span class="k">}</span>
            <span class="nv">default</span> <span class="k">{</span>
                <span class="k">error</span> <span class="s2">&quot;wrong range operator $sep&quot;</span>
            <span class="k">}</span>
        <span class="k">}</span>
    <span class="k">}</span>
<span class="k">}</span>

<span class="k">proc</span> with-file <span class="k">{</span><span class="nb">file</span> block<span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> fd <span class="k">[</span><span class="nb">open</span> <span class="nv">$file</span><span class="k">]</span>
    <span class="k">uplevel</span> <span class="mi">1</span> <span class="k">[</span><span class="nb">list</span> apply <span class="nv">$block</span> <span class="nv">$fd</span><span class="k">]</span>
    <span class="nb">close</span> <span class="nv">$fd</span>
<span class="k">}</span>

<span class="k">proc</span> read-lines <span class="k">{</span><span class="nv">fd</span> block<span class="k">}</span> <span class="k">{</span>
    <span class="k">while</span> <span class="k">{[</span><span class="nb">gets</span> <span class="nv">$fd</span> line<span class="k">]</span> <span class="o">&gt;=</span> <span class="nv">0</span><span class="k">}</span> <span class="k">{</span>
        <span class="k">uplevel</span> <span class="mi">1</span> <span class="k">[</span><span class="nb">list</span> apply <span class="nv">$block</span> <span class="nv">$line</span><span class="k">]</span>
    <span class="k">}</span>
<span class="k">}</span>

<span class="k">proc</span> readlines <span class="k">{</span><span class="nv">fd</span> block<span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> data <span class="k">[</span><span class="nb">read</span> <span class="o">-</span>nonewline <span class="nv">$fd</span><span class="k">]</span>
    <span class="k">set</span> variable options
    <span class="k">set</span> cr <span class="s2">&quot;\n&quot;</span>
    <span class="k">if</span> <span class="k">[</span><span class="nb">info</span> exist options<span class="k">(</span><span class="nv">CR</span><span class="k">)]</span> <span class="k">{</span>
        <span class="k">set</span> cr <span class="nv">$options</span><span class="k">(</span><span class="nv">CR</span><span class="k">)</span>
    <span class="k">}</span>
    <span class="k">foreach</span> line <span class="k">[</span><span class="nb">split</span> <span class="k">[</span><span class="nb">regsub</span> <span class="o">-</span>all <span class="o">--</span> <span class="nv">$cr</span> <span class="nv">$data</span> <span class="s2">&quot;\0&quot;</span> <span class="k">]</span> <span class="s2">&quot;\0&quot;</span> <span class="k">]</span> <span class="k">{</span>
        <span class="k">uplevel</span> <span class="mi">1</span> <span class="k">[</span><span class="nb">list</span> apply <span class="nv">$block</span> <span class="nv">$line</span><span class="k">]</span>
        <span class="nb">puts</span> <span class="o">-</span>nonewline <span class="nv">$cr</span>
    <span class="k">}</span>
<span class="k">}</span>

<span class="k">proc</span> argf-iter <span class="k">{</span><span class="nv">block</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">variable</span> options
    <span class="k">foreach</span> file <span class="nv">$::argv</span> <span class="k">{</span>
        <span class="nv">with-file</span> <span class="nv">$file</span> <span class="k">[</span><span class="nb">list</span> fd <span class="s2">&quot;return \[readlines \$fd {$block}\]&quot;</span><span class="k">]</span>
    <span class="k">}</span>
<span class="k">}</span>

<span class="c"># @@PLEAC@@_1.0</span>


<span class="c"># Tcl&#39;s &quot;...&quot; corresponds to Perl&#39;s &quot;...&quot;, while the other</span>
<span class="c"># quoting construct {...} is more similar to Perl&#39;s q{...}</span>
<span class="c"># operator.</span>

<span class="c"># It&#39;s not necessary to quote text data in Tcl as long as</span>
<span class="c"># it doesn&#39;t contain whitespace.</span>



<span class="k">set</span> string <span class="k">{</span><span class="err">\</span><span class="nv">n</span><span class="k">}</span>                     <span class="k">;</span><span class="c"># two characters, \ and n</span>

<span class="k">set</span> string <span class="s2">&quot;jon &#39;maddog&#39; orwant&quot;</span>    <span class="k">;</span><span class="c"># literal single quotes</span>

<span class="k">set</span> string <span class="err">\</span>n                       <span class="k">;</span><span class="c"># a &quot;newline&quot; character</span>

<span class="k">set</span> string <span class="s2">&quot;jon \&quot;crosby\&quot; orwant&quot;</span>  <span class="k">;</span><span class="c"># literal double quotes</span>

<span class="k">set</span> string <span class="k">{</span><span class="nv">jon</span> <span class="s2">&quot;stills&quot;</span> orwant<span class="k">}</span>    <span class="k">;</span><span class="c"># literal double quotes</span>

<span class="k">set</span> string <span class="s2">&quot;jon {nash} orwant&quot;</span>      <span class="k">;</span><span class="c"># literal braces</span>

<span class="k">set</span> string <span class="k">{</span><span class="nv">jon</span> <span class="k">{</span><span class="nv">young</span><span class="k">}</span> orwant<span class="k">}</span>     <span class="k">;</span><span class="c"># literal braces</span>

<span class="k">set</span> a <span class="k">{</span>
<span class="nv">this</span> is a multiline string
<span class="nv">terminated</span> by an unescaped and
<span class="k">{</span><span class="nv">unnested</span><span class="k">}</span> <span class="nv">right</span> brace <span class="k">(</span><span class="err">\}</span><span class="k">)</span>
<span class="k">}</span>

<span class="c"># @@PLEAC@@_1.1</span>


<span class="k">set</span> value <span class="k">[</span><span class="nb">string</span> range <span class="nv">$string</span> <span class="nv">$first</span> <span class="nv">$last</span><span class="k">]</span>

<span class="k">set</span> value <span class="k">[</span><span class="nb">string</span> range <span class="nv">$string</span> <span class="nv">$first</span> <span class="k">[expr</span> <span class="k">{</span><span class="nv">$first</span><span class="o">+</span><span class="nv">$count-1</span><span class="k">}]]</span>

<span class="k">set</span> value <span class="k">[</span><span class="nb">string</span> range <span class="nv">$string</span> <span class="nv">$first</span> end<span class="k">]</span>


<span class="k">set</span> string <span class="k">[</span><span class="nb">string</span> replace <span class="nv">$string</span> <span class="nv">$first</span> <span class="nv">$last</span> <span class="nv">$newstring</span><span class="k">]</span>

<span class="k">set</span> string <span class="k">[</span><span class="nb">string</span> replace <span class="nv">$string</span> <span class="nv">$first</span> <span class="k">[expr</span> <span class="k">{</span><span class="nv">$first</span><span class="o">+</span><span class="nv">$count-1</span><span class="k">}]</span> <span class="nv">$newstring</span><span class="k">]</span>

<span class="k">set</span> string <span class="k">[</span><span class="nb">string</span> replace <span class="nv">$string</span> <span class="nv">$first</span> end <span class="nv">$newtail</span><span class="k">]</span>


<span class="c"># get a 5-byte string, skip 3, then grab 2 8-byte strings, then the rest</span>
<span class="nb">binary</span> scan <span class="nv">$data</span> <span class="s2">&quot;A5 x3 A8 A8 A*&quot;</span> leading s1 s2 trailing


<span class="c"># Important note: the above was all well and good when the Cookbook was </span>
<span class="c"># written and a character and a byte were the same size.  They still</span>
<span class="c"># are for some programming languages, but Tcl for one uses 16-bit</span>
<span class="c"># Unicode characters to encode strings.</span>

<span class="c">#   The above unpack/scan works for strings containing only character</span>
<span class="c"># codes in the range 0--255, but distorts other strings by truncating</span>
<span class="c"># all codes to 8 bits.</span>

<span class="c">#   To avoid this, the input string can be converted to an 8-bit</span>
<span class="c"># encoding before scanning:</span>


<span class="nb">encoding</span> convertto utf-8 <span class="s2">&quot;H\u2082O is the chemical formula for water&quot;</span>
<span class="c"># =&gt; Hв??O is the chemical formula for water</span>


<span class="c"># split at five-byte boundaries (16-bit safe)</span>
<span class="k">set</span> fivers <span class="k">[</span><span class="nb">list</span><span class="k">]</span>
<span class="k">set</span> temp <span class="k">[</span><span class="nb">encoding</span> convertto utf-8 <span class="nv">$string</span><span class="k">]</span>
<span class="k">while</span> <span class="k">{[</span><span class="nb">binary</span> scan <span class="nv">$temp</span> a5a<span class="o">*</span> group tail<span class="k">]}</span> <span class="k">{</span>
    <span class="nb">lappend</span> fivers <span class="nv">$group</span>
    <span class="k">set</span> temp <span class="nv">$tail</span>
<span class="k">}</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">string</span> length <span class="nv">$tail</span><span class="k">]}</span> <span class="k">{</span> <span class="nb">lappend</span> fivers <span class="nv">$tail</span> <span class="k">}</span>
<span class="k">set</span> fivers


<span class="c"># split at five-char boundaries (16-bit safe)</span>
<span class="k">set</span> fivers <span class="k">[</span><span class="nb">regexp</span> <span class="o">-</span>all <span class="o">-</span>inline <span class="k">{</span><span class="nv">.</span><span class="k">{</span><span class="nv">1</span><span class="err">,</span><span class="mi">5</span><span class="k">}}</span> <span class="nv">$data</span><span class="k">]</span>


<span class="c"># chop string into individual characters:</span>
<span class="k">set</span> chars <span class="k">[</span><span class="nb">split</span> <span class="nv">$data</span> <span class="k">{}]</span>


<span class="c"># &quot;This is what you have&quot;</span>
<span class="c"># +012345678901234567890  Indexing forwards (left to right)</span>
<span class="c">#  098765432109876543210- Indexing from end (right to left)</span>
<span class="c"># note that 0 means 10 or 20, etc. above</span>

<span class="c"># end is a special value that is available in list and string </span>
<span class="c"># commands.  It is defined as the index of the last element (in </span>
<span class="c"># lists), or character (in strings).</span>
<span class="c">#   Likewise, end-1 is defined as the element/character</span>
<span class="c"># preceding the last, and so on.</span>


<span class="k">set</span> first <span class="k">[</span><span class="nb">string</span> index <span class="s2">&quot;This is what you have&quot;</span> <span class="mi">0</span><span class="k">]</span>
<span class="c"># =&gt; T</span>

 
<span class="k">set</span> start <span class="k">[</span><span class="nb">string</span> range <span class="s2">&quot;This is what you have&quot;</span> <span class="mi">5</span> <span class="mi">6</span><span class="k">]</span>
<span class="c"># =&gt; is</span>

 
<span class="k">set</span> rest <span class="k">[</span><span class="nb">string</span> range <span class="s2">&quot;This is what you have&quot;</span> <span class="mi">13</span> end<span class="k">]</span>
<span class="c"># =&gt; you have</span>

 
<span class="k">set</span> last <span class="k">[</span><span class="nb">string</span> index <span class="s2">&quot;This is what you have&quot;</span> end<span class="k">]</span>
<span class="c"># =&gt; e</span>

 
<span class="k">set</span> end <span class="k">[</span><span class="nb">string</span> range <span class="s2">&quot;This is what you have&quot;</span> end-3 end<span class="k">]</span>
<span class="c"># =&gt; have</span>

 
<span class="k">set</span> piece <span class="k">[</span><span class="nb">string</span> range <span class="s2">&quot;This is what you have&quot;</span> end-7 end-5<span class="k">]</span>
<span class="c"># =&gt; you</span>


<span class="c"># The general technique here is to mutate a string and then assign</span>
<span class="c"># it back to the variable.  One can [replace] a segment of the string</span>
<span class="c"># with another string or with an empty string (deleting the segment)</span>
<span class="c"># or simply select a segment using [range].</span>


 
<span class="k">set</span> string <span class="k">[</span><span class="nb">string</span> replace <span class="s2">&quot;This is what you have&quot;</span> <span class="mi">5</span> <span class="mi">6</span> wasn<span class="err">&#39;</span>t<span class="k">]</span>
<span class="c"># =&gt; This wasn&#39;t what you have</span>

 
<span class="k">set</span> string <span class="k">[</span><span class="nb">string</span> replace <span class="s2">&quot;This wasn&#39;t what you have&quot;</span> end-11 end ondrous<span class="k">]</span>
<span class="c"># =&gt; This wasn&#39;t wondrous</span>

 
<span class="k">set</span> string <span class="k">[</span><span class="nb">string</span> range <span class="s2">&quot;This wasn&#39;t wondrous&quot;</span> <span class="mi">1</span> end<span class="k">]</span>
<span class="c"># =&gt; his wasn&#39;t wondrous</span>

 
<span class="k">set</span> string <span class="k">[</span><span class="nb">string</span> range <span class="s2">&quot;his wasn&#39;t wondrous&quot;</span> <span class="mi">0</span> end-10<span class="k">]</span>
<span class="c"># =&gt; his wasn&#39;</span>


<span class="k">if</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="nv">$pattern</span> <span class="k">[</span><span class="nb">string</span> range <span class="nv">$string</span> end-9 end<span class="k">]]}</span> <span class="k">{</span>
    <span class="k">return</span> <span class="s2">&quot;Pattern matches in last 10 characters&quot;</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">return</span> <span class="s2">&quot;Match failed&quot;</span>
<span class="k">}</span>


<span class="c"># substitute &quot;at&quot; for &quot;is&quot;, restricted to first five characters</span>
<span class="nb">regsub</span> <span class="o">-</span>all is <span class="k">[</span><span class="nb">string</span> range <span class="nv">$string</span> <span class="mi">0</span> <span class="mi">4</span><span class="k">]</span> at newstring
<span class="k">set</span> string <span class="k">[</span><span class="nb">string</span> replace <span class="nv">$string</span> <span class="mi">0</span> <span class="mi">4</span> <span class="nv">$newstring</span><span class="k">]</span>


<span class="nb">regsub</span> <span class="k">{(</span><span class="nv">.</span><span class="k">)(</span><span class="nv">.</span><span class="o">*</span><span class="k">)(</span><span class="nv">.</span><span class="k">)}</span> <span class="s2">&quot;make a hat&quot;</span> <span class="k">{</span><span class="err">\</span><span class="nv">3</span><span class="err">\</span><span class="mi">2</span><span class="err">\</span><span class="mi">1</span><span class="k">}</span> a
<span class="nb">puts</span> <span class="nv">$a</span>
<span class="c"># =&gt; take a ham</span>


<span class="k">set</span> b <span class="k">[</span><span class="nb">string</span> range <span class="s2">&quot;To be or not to be&quot;</span> <span class="mi">6</span> <span class="mi">11</span><span class="k">]</span>
<span class="c"># =&gt; or not</span>

 
<span class="k">set</span> a <span class="s2">&quot;To be or not to be&quot;</span>
<span class="k">set</span> b <span class="k">[</span><span class="nb">string</span> range <span class="nv">$a</span> <span class="mi">6</span> <span class="mi">7</span><span class="k">]</span>
<span class="nb">append</span> b <span class="o">:</span> <span class="k">[</span><span class="nb">string</span> range <span class="nv">$a</span> <span class="mi">3</span> <span class="mi">4</span><span class="k">]</span>
<span class="c"># =&gt; or:be</span>


<span class="k">proc</span> cut2fmt <span class="k">{</span><span class="nv">args</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> positions <span class="nv">$args</span>
    <span class="k">set</span> template  <span class="k">{}</span>
    <span class="k">set</span> lastpos   <span class="mi">1</span>
    <span class="k">foreach</span> <span class="k">{</span><span class="nv">place</span><span class="k">}</span> <span class="nv">$positions</span> <span class="k">{</span>
        <span class="nb">append</span> template <span class="s2">&quot;A[expr {$place-$lastpos}] &quot;</span>
        <span class="k">set</span> lastpos <span class="nv">$place</span>
    <span class="k">}</span>
    <span class="nb">append</span> template A<span class="o">*</span>
    <span class="k">return</span> <span class="nv">$template</span>
<span class="k">}</span>
    
<span class="k">set</span> fmt <span class="k">[</span><span class="nv">cut2fmt</span> <span class="mi">8</span> <span class="mi">14</span> <span class="mi">20</span> <span class="mi">26</span> <span class="mi">30</span><span class="k">]</span>
<span class="c"># =&gt; A7 A6 A6 A6 A4 A*</span>

<span class="c"># @@PLEAC@@_1.2</span>


<span class="c"># In Tcl, commands such as if or while require the value of the</span>
<span class="c"># condition expression to be a proper boolean value.  If the </span>
<span class="c"># value is numeric, 0 is false and anything else is true.  For</span>
<span class="c"># non-numeric strings, &quot;true&quot;, &quot;on&quot;, or &quot;yes&quot; is true and </span>
<span class="c"># &quot;false&quot;, &quot;off&quot;, or &quot;no&quot; is false.  Any other value for the</span>
<span class="c"># condition expression raises an error.</span>
<span class="c">#   The `boolean operators&#39; return either &quot;1&quot; or &quot;0&quot;.</span>



<span class="c"># use $b if b has characters, else $c</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">string</span> length <span class="nv">$b</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> a <span class="nv">$b</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> a <span class="nv">$c</span>
<span class="k">}</span>

 
<span class="c"># use $b if b is non-zero, else $c</span>
<span class="k">if</span> <span class="k">{</span><span class="nv">$b</span> <span class="o">!=</span> <span class="nv">0</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> a <span class="nv">$b</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> a <span class="nv">$c</span>
<span class="k">}</span>


<span class="c"># set x to $y if $x has no characters</span>
<span class="k">if</span> <span class="k">{</span><span class="o">!</span><span class="k">[</span><span class="nb">string</span> length <span class="nv">$x</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> x <span class="nv">$y</span>
<span class="k">}</span>

 
<span class="c"># set x to $y if $x is zero</span>
<span class="k">if</span> <span class="k">{</span><span class="nv">$x</span> <span class="o">==</span> <span class="nv">0</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> x <span class="nv">$y</span>
<span class="k">}</span>


<span class="c"># set a to $b if b exists, else to $c</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">info</span> exists b<span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> a <span class="nv">$b</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> a <span class="nv">$c</span>
<span class="k">}</span>


<span class="c"># Perl: $dir = shift(@ARGV) || &quot;/tmp&quot;;</span>
<span class="k">set</span> arg <span class="k">[</span><span class="nb">lindex</span> <span class="nv">$argv</span> <span class="mi">0</span><span class="k">]</span>
<span class="k">set</span> argv <span class="k">[</span><span class="nb">lrange</span> <span class="nv">$argv</span> <span class="mi">1</span> end<span class="k">]</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">string</span> length <span class="nv">$arg</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> dir <span class="nv">$arg</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> dir <span class="o">/</span>tmp
<span class="k">}</span>


<span class="c"># Perl: $dir = $ARGV[0] || &quot;/tmp&quot;;</span>
<span class="k">set</span> arg <span class="k">[</span><span class="nb">lindex</span> <span class="nv">$argv</span> <span class="mi">0</span><span class="k">]</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">string</span> length <span class="nv">$arg</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> dir <span class="nv">$arg</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> dir <span class="o">/</span>tmp
<span class="k">}</span>


<span class="c"># Perl: $dir = defined($ARGV[0]) ? shift(@ARGV) : &quot;/tmp&quot;;</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">info</span> exists argv<span class="k">]</span> <span class="o">&amp;&amp;</span> <span class="k">[</span><span class="nb">llength</span> <span class="nv">$argv</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> dir <span class="k">[</span><span class="nb">lindex</span> <span class="nv">$argv</span> <span class="mi">0</span><span class="k">]</span>
    <span class="k">set</span> argv <span class="k">[</span><span class="nb">lrange</span> <span class="nv">$argv</span> <span class="mi">1</span> end<span class="k">]</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> dir <span class="o">/</span>tmp
<span class="k">}</span>

 
<span class="c"># Perl: $dir = @ARGV ? $ARGV[0] : &quot;/tmp&quot;;</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">llength</span> <span class="nv">$argv</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> dir <span class="k">[</span><span class="nb">lindex</span> <span class="nv">$argv</span> <span class="mi">0</span><span class="k">]</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> dir <span class="o">/</span>tmp
<span class="k">}</span>


<span class="c"># Perl: $count{ $shell || &quot;/bin/sh&quot; }++;</span>
<span class="k">if</span> <span class="k">{</span><span class="o">!</span><span class="k">[</span><span class="nb">string</span> length <span class="nv">$shell</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> shell <span class="o">/</span>bin<span class="o">/</span>sh
<span class="k">}</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">info</span> exist count<span class="k">(</span><span class="nv">$shell</span><span class="k">)]}</span> <span class="k">{</span>
    <span class="nb">incr</span> count<span class="k">(</span><span class="nv">$shell</span><span class="k">)</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> count<span class="k">(</span><span class="nv">$shell</span><span class="k">)</span> <span class="mi">1</span>
<span class="k">}</span>


<span class="c"># The catch command intercepts errors raised.  In this</span>
<span class="c"># case catch is used as an alternative idiom to </span>
<span class="c"># [info exists var].</span>
<span class="c"># The pros and cons of the different idioms is </span>
<span class="c"># discussed at &lt;URL: http://mini.net/tcl/1322.html&gt;.</span>



<span class="c"># find the user name on Unix systems; needs extension to</span>
<span class="c"># check getlogin() and getpwuid()</span>
<span class="k">if</span> <span class="k">{</span><span class="o">!</span><span class="k">[catch</span> <span class="k">{</span><span class="nb">string</span> length <span class="nv">$env</span><span class="k">(</span><span class="nv">USER</span><span class="k">)}]}</span> <span class="k">{</span>
    <span class="k">set</span> user <span class="nv">$env</span><span class="k">(</span><span class="nv">USER</span><span class="k">)</span>
<span class="k">}</span> <span class="k">elseif</span> <span class="k">{</span><span class="o">!</span><span class="k">[catch</span> <span class="k">{</span><span class="nb">string</span> length <span class="nv">$env</span><span class="k">(</span><span class="nv">LOGIN</span><span class="k">)}]}</span> <span class="k">{</span>
    <span class="k">set</span> user <span class="nv">$env</span><span class="k">(</span><span class="nv">LOGIN</span><span class="k">)</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> user <span class="s2">&quot;Unknown user&quot;</span>
<span class="k">}</span>

<span class="c"># The most obvious way to do the above in Tcl is</span>
<span class="k">set</span> <span class="o">::</span>tcl_platform<span class="k">(</span><span class="nv">user</span><span class="k">)</span>

<span class="k">if</span> <span class="k">{</span><span class="o">!</span><span class="k">[</span><span class="nb">string</span> length <span class="nv">$startingPoint</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> startingPoint Greenwich
<span class="k">}</span>


<span class="c"># if x has no elements, assign $y to it</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">llength</span> <span class="nv">$x</span><span class="k">]</span> <span class="o">==</span> <span class="nv">0</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> x <span class="nv">$y</span>
<span class="k">}</span>

<span class="c"># if y has elements, assign it to x, otherwise assign $z to x</span>
<span class="k">if</span> <span class="k">{[</span><span class="nb">llength</span> <span class="nv">$y</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">set</span> x <span class="nv">$y</span>
<span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
    <span class="k">set</span> x <span class="nv">$z</span>
<span class="k">}</span>

<span class="c"># @@PLEAC@@_1.3</span>


<span class="c"># cross-assignment</span>
<span class="k">foreach</span> <span class="k">{</span><span class="nv">b</span> a<span class="k">}</span> <span class="nv">$args</span> break


<span class="c"># cross-assignment with temp</span>
<span class="k">set</span> temp <span class="nv">$a</span>
<span class="k">set</span> a <span class="nv">$b</span>
<span class="k">set</span> b <span class="nv">$temp</span>
<span class="k">unset</span> temp


<span class="k">foreach</span> <span class="k">{</span><span class="nv">alpha</span> beta production<span class="k">}</span> <span class="k">[</span><span class="nb">list</span> January March August<span class="k">]</span> break
<span class="c"># move beta       to alpha,</span>
<span class="c"># move production to beta,</span>
<span class="c"># move alpha      to production</span>
<span class="k">foreach</span> <span class="k">{</span><span class="nv">alpha</span> beta production<span class="k">}</span> <span class="k">[</span><span class="nb">list</span> <span class="nv">$beta</span> <span class="nv">$production</span> <span class="nv">$alpha</span><span class="k">]</span> break

<span class="c"># @@PLEAC@@_1.4</span>


<span class="k">set</span> num <span class="k">[</span><span class="nb">scan</span> <span class="nv">$char</span> <span class="o">%</span>c<span class="k">]</span>


<span class="k">set</span> char <span class="k">[</span><span class="nb">format</span> <span class="o">%</span>c <span class="nv">$num</span><span class="k">]</span>

<span class="nb">format</span> <span class="s2">&quot;Number %d is character %c&quot;</span> <span class="mi">101</span> <span class="mi">101</span>
<span class="c"># =&gt; Number 101 is character e</span>


<span class="k">set</span> utf8data <span class="k">[</span><span class="nb">encoding</span> convertto utf-8 <span class="nv">$string</span><span class="k">]</span>
<span class="nb">binary</span> scan <span class="nv">$utf8data</span> c<span class="o">*</span> codelist


<span class="k">set</span> utf8data <span class="k">[</span><span class="nb">binary</span> format c<span class="o">*</span> <span class="nv">$codelist</span><span class="k">]</span>
<span class="k">set</span> string <span class="k">[</span><span class="nb">encoding</span> convertfrom utf-8 <span class="nv">$utf8data</span><span class="k">]</span>


<span class="k">proc</span> hal2ibm <span class="k">{}</span> <span class="k">{</span>
    <span class="k">set</span> hal HAL
    <span class="nb">binary</span> scan <span class="nv">$hal</span> c<span class="o">*</span> codes
    <span class="k">foreach</span> <span class="k">{</span><span class="nv">num</span><span class="k">}</span> <span class="nv">$codes</span> <span class="k">{</span>
        <span class="nb">lappend</span> newcodes <span class="k">[</span><span class="nb">incr</span> num<span class="k">]</span>
    <span class="k">}</span>
    <span class="k">set</span> ibm <span class="k">[</span><span class="nb">binary</span> format c<span class="o">*</span> <span class="nv">$newcodes</span><span class="k">]</span>
<span class="k">}</span>
<span class="nv">hal2ibm</span>
<span class="c"># =&gt; IBM</span>

<span class="c"># @@PLEAC@@_1.5</span>


<span class="k">set</span> a <span class="k">[</span><span class="nb">split</span> <span class="nv">$string</span> <span class="k">{}]</span>


<span class="k">set</span> utf8data <span class="k">[</span><span class="nb">encoding</span> convertto utf-8 <span class="nv">$string</span><span class="k">]</span>
<span class="nb">binary</span> scan <span class="nv">$utf8data</span> c<span class="o">*</span> a


<span class="c"># with -line, . never matches newline</span>
<span class="k">foreach</span> <span class="mi">1</span> <span class="k">[</span><span class="nb">regexp</span> <span class="o">-</span>inline <span class="o">-</span>all <span class="o">-</span>line . <span class="nv">$string</span><span class="k">]</span> <span class="k">{</span>
    <span class="c"># do something with $1</span>
<span class="k">}</span>


<span class="k">proc</span> indChars-1 <span class="k">{</span><span class="nv">s</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">array</span> set seen <span class="k">[</span><span class="nb">list</span><span class="k">]</span>
    <span class="k">set</span> string <span class="nv">$s</span>
    <span class="k">foreach</span> <span class="k">{</span><span class="nv">char</span><span class="k">}</span> <span class="k">[</span><span class="nb">split</span> <span class="nv">$string</span> <span class="k">{}]</span> <span class="k">{</span>
        <span class="k">if</span> <span class="k">{[</span><span class="nb">info</span> exists seen<span class="k">(</span><span class="nv">$char</span><span class="k">)]}</span> <span class="k">{</span>
            <span class="nb">incr</span> seen<span class="k">(</span><span class="nv">$char</span><span class="k">)</span>
        <span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
            <span class="k">set</span> seen<span class="k">(</span><span class="nv">$char</span><span class="k">)</span> <span class="mi">1</span>
        <span class="k">}</span>
    <span class="k">}</span>
    <span class="nb">puts</span> <span class="s2">&quot;unique chars are: {[join [lsort [array names seen]] {}]}&quot;</span>
<span class="k">}</span>
<span class="nv">indChars-1</span> <span class="s2">&quot;an apple a day&quot;</span>
<span class="c"># =&gt; unique chars are: { adelnpy}</span>


<span class="c"># Of course, if all you care about are which unique </span>
<span class="c"># characters appear, it&#39;s much easier:</span>



<span class="k">proc</span> uniqueChars-1 <span class="k">{</span><span class="nv">s</span><span class="k">}</span> <span class="k">{</span>
    <span class="nb">puts</span> <span class="s2">&quot;unique chars are: {[join [lsort -unique [split $s {}]] {}]}&quot;</span>
<span class="k">}</span>
<span class="nv">uniqueChars-1</span> <span class="s2">&quot;an apple a day&quot;</span>
<span class="c"># =&gt; unique chars are: { adelnpy}</span>


<span class="c"># simplistic checksum calculation</span>
<span class="k">proc</span> simpleChecksum <span class="k">{</span><span class="nb">string</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> sum <span class="mi">0</span>
    <span class="nb">binary</span> scan <span class="nv">$string</span> c<span class="o">*</span> codes
    <span class="k">foreach</span> <span class="k">{</span><span class="nv">code</span><span class="k">}</span> <span class="nv">$codes</span> <span class="k">{</span>
        <span class="nb">incr</span> sum <span class="nv">$code</span>
    <span class="k">}</span>
    <span class="k">return</span> <span class="nv">$sum</span>
<span class="k">}</span>
<span class="nv">simpleChecksum</span> <span class="s2">&quot;an apple a day&quot;</span>
<span class="c"># =&gt; 1248</span>


<span class="c"># The Trf package, which is available at</span>
<span class="c"># &lt;URL: http://www.oche.de/~akupries/soft/trf/&gt;,</span>
<span class="c"># has several utilities for transforming data,</span>
<span class="c"># including message digests such as CRC and MD5.</span>



<span class="nb">package</span> require Trf
<span class="nb">binary</span> scan <span class="k">[</span><span class="nv">crc</span> <span class="k">{</span><span class="nv">an</span> apple a day<span class="k">}]</span> H<span class="o">*</span> checksum
<span class="k">set</span> checksum
<span class="c"># =&gt; 325295</span>


<span class="c"># slowcat - emulate a   s l o w   line printer</span>
<span class="c"># usage: slowcat [-DELAY] [files ...]</span>
<span class="k">proc</span> slowcat <span class="k">{</span><span class="nv">args</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> delay <span class="mi">1</span>
    <span class="k">if</span> <span class="k">{[</span><span class="nb">llength</span> <span class="nv">$args</span><span class="k">]}</span> <span class="k">{</span>
        <span class="k">if</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="k">{</span><span class="o">^</span><span class="nv">-</span><span class="k">([</span><span class="nv">.</span><span class="err">\</span>d<span class="k">]</span><span class="o">+</span><span class="k">)}</span> <span class="k">[</span><span class="nb">lindex</span> <span class="nv">$args</span> <span class="mi">0</span><span class="k">]</span> match delay<span class="k">]}</span> <span class="k">{</span>
            <span class="k">set</span> args <span class="k">[</span><span class="nb">lrange</span> <span class="nv">$args</span> <span class="mi">1</span> end<span class="k">]</span>
        <span class="k">}</span>
    <span class="k">}</span>
    <span class="nb">fconfigure</span> stdout <span class="o">-</span>buffering no
    <span class="k">if</span> <span class="k">{[</span><span class="nb">llength</span> <span class="nv">$args</span><span class="k">]}</span> <span class="k">{</span>
        <span class="k">foreach</span> <span class="k">{</span><span class="nv">arg</span><span class="k">}</span> <span class="nv">$args</span> <span class="k">{</span>
            <span class="k">set</span> f <span class="k">[</span><span class="nb">open</span> <span class="nv">$arg</span><span class="k">]</span>
            <span class="nb">lappend</span> channels <span class="nv">$f</span>
        <span class="k">}</span>
    <span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
        <span class="k">set</span> channels stdin
    <span class="k">}</span>
    <span class="k">foreach</span> <span class="k">{</span><span class="nb">chan</span><span class="k">}</span> <span class="nv">$channels</span> <span class="k">{</span>
        <span class="k">while</span> <span class="k">{[</span><span class="nb">gets</span> <span class="nv">$chan</span> line<span class="k">]</span> <span class="o">&gt;</span> <span class="nv">-1</span><span class="k">}</span> <span class="k">{</span>
            <span class="k">foreach</span> <span class="k">{</span><span class="nv">ch</span><span class="k">}</span> <span class="k">[</span><span class="nb">split</span> <span class="nv">$line</span> <span class="k">{}]</span> <span class="k">{</span>
                <span class="nb">puts</span> <span class="o">-</span>nonewline <span class="nv">$ch</span>
                <span class="k">after</span> <span class="k">[expr</span> <span class="k">{</span><span class="nv">int</span><span class="k">(</span><span class="nv">5</span> <span class="o">*</span> <span class="nv">$delay</span><span class="k">)}]</span>
            <span class="k">}</span>
            <span class="nb">puts</span> <span class="k">{}</span>
        <span class="k">}</span>
    <span class="k">}</span>
<span class="k">}</span>

<span class="c"># @@PLEAC@@_1.6</span>


<span class="k">proc</span> reverse <span class="k">{</span><span class="nv">args</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> res <span class="k">[</span><span class="nb">list</span><span class="k">]</span>
    <span class="k">if</span> <span class="k">{[</span><span class="nb">llength</span> <span class="nv">$args</span><span class="k">]</span> <span class="o">==</span> <span class="nv">1</span><span class="k">}</span> <span class="k">{</span>
        <span class="k">set</span> args <span class="k">[</span><span class="nb">lindex</span> <span class="nv">$args</span> <span class="mi">0</span><span class="k">]</span>
    <span class="k">}</span>
    <span class="k">foreach</span> elem <span class="nv">$args</span> <span class="k">{</span>
        <span class="k">set</span> res <span class="k">[</span><span class="nb">linsert</span> <span class="nv">$res</span> <span class="mi">0</span> <span class="nv">$elem</span><span class="k">]</span>
    <span class="k">}</span>
    <span class="k">return</span> <span class="nv">$res</span>
<span class="k">}</span>


<span class="c"># reverse characters</span>
<span class="nb">join</span> <span class="k">[</span><span class="nv">reverse</span> <span class="k">[</span><span class="nb">split</span> <span class="nv">$string</span> <span class="k">{}]]</span> <span class="k">{}</span>


<span class="c"># reverse words</span>
<span class="nb">join</span> <span class="k">[</span><span class="nv">reverse</span> <span class="k">[</span><span class="nb">split</span> <span class="nv">$string</span><span class="k">]]</span>

<span class="c"># reverse quoted words</span>
<span class="nb">join</span> <span class="k">[</span><span class="nv">reverse</span> <span class="k">[</span><span class="nb">split</span> <span class="k">{</span><span class="nv">Yoda</span> said<span class="err">,</span> <span class="s2">&quot;can you see this?&quot;</span><span class="k">}]]</span>
<span class="c"># =&gt; this?&quot; see you &quot;can said, Yoda</span>


<span class="k">set</span> word reviver
<span class="k">set</span> is_palindrome <span class="k">[</span><span class="nb">string</span> equal <span class="nv">$word</span> <span class="k">[</span><span class="nb">join</span> <span class="k">[</span><span class="nv">reverse</span> <span class="k">[</span><span class="nb">split</span> <span class="nv">$word</span><span class="k">]]]]</span>
<span class="c"># =&gt; 1</span>

<span class="c"># @@PLEAC@@_1.7</span>


<span class="nb">package</span> require textutil
<span class="k">namespace</span> import <span class="o">::</span>textutil::tabify::<span class="o">*</span>
<span class="nv">tabify</span> <span class="s2">&quot;...     zzz        xxx&quot;</span>
<span class="c"># =&gt; ...     zzz	xxx</span>


<span class="nv">untabify</span> <span class="s2">&quot;...\tzzz\txxx&quot;</span>
<span class="c"># =&gt; ...        zzz        xxx</span>


<span class="nv">tabify2</span> <span class="s2">&quot;...     zzz     xxx&quot;</span>
<span class="c"># =&gt; ...	zzz	xxx</span>


<span class="nv">untabify2</span> <span class="s2">&quot;...\tzzz\txxx&quot;</span>
<span class="c"># =&gt; ...     zzz     xxx</span>

<span class="c"># @@PLEAC@@_1.8</span>


<span class="k">set</span> debt <span class="mi">100</span>
<span class="nb">subst</span> <span class="s2">&quot;You owe $debt to me.&quot;</span>
<span class="c"># =&gt; You owe 100 to me.</span>


<span class="k">set</span> debt <span class="mi">100</span>
<span class="k">proc</span> writeIt <span class="k">{</span><span class="nb">string</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">uplevel</span> subst <span class="k">[</span><span class="nb">list</span> <span class="nv">$string</span><span class="k">]</span>
<span class="k">}</span>
<span class="c"># braces prevent immediate substitution</span>
<span class="nv">writeIt</span> <span class="k">{</span><span class="nv">You</span> owe <span class="nv">$debt</span> to me.<span class="k">}</span>
<span class="c"># =&gt; You owe 100 to me.</span>


<span class="k">foreach</span> <span class="k">{</span><span class="nv">rows</span> cols<span class="k">}</span> <span class="k">{</span><span class="nv">24</span> <span class="mi">80</span><span class="k">}</span> break
<span class="k">set</span> text <span class="k">{</span><span class="nv">I</span> am <span class="nv">$rows</span> high and <span class="nv">$cols</span> long<span class="k">}</span>
<span class="nb">subst</span> <span class="nv">$text</span>
<span class="c"># =&gt; I am 24 high and 80 long</span>


<span class="k">set</span> string <span class="s2">&quot;I am 17 years old&quot;</span>
<span class="nb">regsub</span> <span class="o">-</span>all <span class="k">{(</span><span class="err">\</span><span class="nv">d</span><span class="o">+</span><span class="k">)}</span> <span class="nv">$string</span> <span class="k">{[expr</span> <span class="k">{</span><span class="err">\</span><span class="nv">1</span><span class="o">*</span><span class="mi">2</span><span class="k">}]}</span> string
<span class="nb">subst</span> <span class="nv">$string</span>
<span class="c"># =&gt; I am 34 years old</span>


<span class="c"># expand variables in $text, but put an error message in</span>
<span class="c"># if the variable isn&#39;t defined.</span>
<span class="k">proc</span> expandOrError-1 <span class="k">{</span><span class="err">@</span><span class="nv">text</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">upvar</span> <span class="err">$</span><span class="k">{</span><span class="err">@</span><span class="nv">text</span><span class="k">}</span> text
    <span class="k">while</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="k">{</span><span class="err">\$</span><span class="k">(</span><span class="err">\</span><span class="nv">w</span><span class="o">+</span><span class="k">)}</span> <span class="nv">$text</span> match var<span class="k">]}</span> <span class="k">{</span>
        <span class="k">if</span> <span class="k">{[uplevel</span> info exists <span class="nv">$var</span><span class="k">]}</span> <span class="k">{</span>
            <span class="nb">regsub</span> <span class="err">\\</span><span class="nv">$match</span> <span class="nv">$text</span> <span class="k">[uplevel</span> set <span class="nv">$var</span><span class="k">]</span> text
        <span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
            <span class="nb">regsub</span> <span class="err">\\</span><span class="nv">$match</span> <span class="nv">$text</span> <span class="s2">&quot;\[NO VARIABLE: $var\]&quot;</span> text
        <span class="k">}</span>
    <span class="k">}</span>
    <span class="k">set</span> text
<span class="k">}</span>


<span class="c"># Tcl allows commands to embedded in text data as well as variables. </span>
<span class="c"># If the string is taken from user input, this may be a security</span>
<span class="c"># hazard.  The solution is to let a &quot;safe interpreter&quot; (which has a</span>
<span class="c"># reduced set of commands by default) interpret the text data.  In</span>
<span class="c"># case the interpreted script text contains illegal commands the</span>
<span class="c"># interpreter raises an error.</span>



<span class="k">proc</span> safeExpand-1 <span class="k">{</span><span class="nb">string</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">set</span> si <span class="k">[</span><span class="nb">interp</span> create <span class="o">-</span>safe<span class="k">]</span>
    <span class="k">set</span> res <span class="k">[uplevel</span> <span class="nv">$si</span> eval <span class="k">[</span><span class="nb">list</span> subst <span class="k">[</span><span class="nb">list</span> <span class="nv">$string</span><span class="k">]]]</span>
    <span class="nb">interp</span> delete <span class="nv">$si</span>
    <span class="k">set</span> res
<span class="k">}</span>
<span class="nv">safeExpand-1</span> <span class="k">{[</span><span class="nb">exec</span> rm foo.bar<span class="k">]}</span>
<span class="c"># =&gt; invalid command name &quot;exec&quot;</span>


<span class="c"># It is also possible to further reduce the command set of an</span>
<span class="c"># interpreter, or to add new commands, or to change the meaning</span>
<span class="c"># of commands (i.e. exec would perform *some* system commands</span>
<span class="c"># but not all, etc).</span>

<span class="c"># But I digress...</span>


<span class="c"># @@PLEAC@@_1.9</span>


<span class="k">set</span> little <span class="s2">&quot;bo peep&quot;</span>
<span class="k">set</span> big <span class="k">[</span><span class="nb">string</span> toupper <span class="nv">$little</span><span class="k">]</span>
<span class="c"># =&gt; BO PEEP</span>


<span class="k">set</span> big <span class="s2">&quot;BO PEEP&quot;</span>
<span class="k">set</span> little <span class="k">[</span><span class="nb">string</span> tolower <span class="nv">$big</span><span class="k">]</span>
<span class="c"># =&gt; bo peep</span>


<span class="k">set</span> little <span class="s2">&quot;bo peep&quot;</span>
<span class="k">set</span> title <span class="k">[</span><span class="nb">string</span> totitle <span class="nv">$little</span><span class="k">]</span>
<span class="c"># =&gt; Bo peep</span>


<span class="k">set</span> little <span class="s2">&quot;bo peep&quot;</span>
<span class="k">set</span> big <span class="k">[</span><span class="nb">string</span> toupper <span class="nv">$little</span> <span class="mi">0</span><span class="k">]</span>
<span class="c"># =&gt; Bo peep</span>


<span class="k">set</span> big <span class="s2">&quot;BO PEEP&quot;</span>
<span class="k">set</span> little <span class="k">[</span><span class="nb">string</span> tolower <span class="nv">$big</span> <span class="mi">0</span><span class="k">]</span>
<span class="c"># =&gt; bO PEEP</span>


<span class="c"># convert case within a string</span>
<span class="k">set</span> name <span class="k">{</span><span class="nv">kirk</span><span class="k">}</span>
<span class="k">set</span> string <span class="s2">&quot;Ship&#39;s Captain: [string totitle $name].&quot;</span>
<span class="c"># =&gt; Ship&#39;s Captain: Kirk.</span>


<span class="c"># capitalize each word&#39;s first character, downcase the rest</span>
<span class="k">set</span> text <span class="s2">&quot;thIS is a loNG liNE&quot;</span>
<span class="k">set</span> pos <span class="mi">0</span>
<span class="k">while</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="o">-</span>indices <span class="o">-</span>start <span class="nv">$pos</span> <span class="k">{(</span><span class="err">\</span><span class="nv">w</span><span class="o">+</span><span class="k">)}</span> <span class="nv">$text</span> where<span class="k">]}</span> <span class="k">{</span>
    <span class="k">foreach</span> <span class="k">{</span><span class="nv">first</span> last<span class="k">}</span> <span class="nv">$where</span> break
    <span class="k">set</span> text <span class="k">[</span><span class="nb">string</span> totitle <span class="nv">$text</span> <span class="nv">$first</span> <span class="nv">$last</span><span class="k">]</span>
    <span class="k">set</span> pos <span class="nv">$last</span>
    <span class="nb">incr</span> pos
<span class="k">}</span>
<span class="nb">puts</span> <span class="nv">$text</span>
<span class="c"># =&gt; This Is A Long Line</span>

<span class="c"># capitalize each word&#39;s first character, downcase the rest</span>
<span class="c"># (another solution)</span>
<span class="k">foreach</span> word <span class="s2">&quot;thIS is a loNG liNE&quot;</span> <span class="k">{</span>
    <span class="nb">lappend</span> words <span class="k">[</span><span class="nb">string</span> totitle <span class="nv">$word</span><span class="k">]</span>
<span class="k">}</span>
<span class="nb">puts</span> <span class="nv">$words</span>
<span class="c"># =&gt; This Is A Long Line</span>


<span class="c"># case insensitive string comparison</span>
<span class="nb">string</span> equal <span class="o">-</span>nocase foo Foo
<span class="c"># =&gt; 1</span>


<span class="c"># randcap: filter to randomly capitalize 20% of the letters</span>
<span class="k">set</span> text <span class="k">{</span>
<span class="nv">001</span><span class="o">:</span><span class="mo">001</span> In the beginning God created the heaven and the earth.
<span class="nv">001</span><span class="o">:</span><span class="mo">002</span> And the earth was without form<span class="err">,</span> and void<span class="k">;</span> <span class="nv">and</span> darkness was
        <span class="nv">upon</span> the face of the deep. And the spirit of God moved upon
        <span class="nv">the</span> face of the waters.
<span class="nv">001</span><span class="o">:</span><span class="mo">003</span> And God said<span class="err">,</span> let there be light: and there was light.
<span class="k">}</span>
<span class="k">set</span> pos <span class="mi">0</span>
<span class="k">while</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="o">-</span>indices <span class="o">-</span>start <span class="nv">$pos</span> <span class="k">{(</span><span class="err">\</span><span class="nv">w</span><span class="k">)}</span> <span class="nv">$text</span> where<span class="k">]}</span> <span class="k">{</span>
    <span class="k">foreach</span> <span class="k">{</span><span class="nv">first</span> last<span class="k">}</span> <span class="nv">$where</span> break
    <span class="k">if</span> <span class="k">{</span><span class="nv">rand</span><span class="k">()</span><span class="o">&lt;=</span><span class="mf">0.2</span><span class="k">}</span> <span class="k">{</span>
        <span class="k">set</span> text <span class="k">[</span><span class="nb">string</span> toupper <span class="nv">$text</span> <span class="nv">$first</span><span class="k">]</span>
    <span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
        <span class="k">set</span> text <span class="k">[</span><span class="nb">string</span> tolower <span class="nv">$text</span> <span class="nv">$first</span><span class="k">]</span>
    <span class="k">}</span>
    <span class="k">set</span> pos <span class="nv">$last</span>
    <span class="nb">incr</span> pos
<span class="k">}</span>
<span class="nb">puts</span> <span class="nv">$text</span>
<span class="c"># =&gt; </span>
<span class="c"># =&gt;         001:001 iN The begInNing god crEaTed tHe HeAven And thE earTh.</span>
<span class="c"># =&gt; </span>
<span class="c"># =&gt;         001:002 and tHe earth was wiThout form, aNd void; and darknESs Was</span>
<span class="c"># =&gt;                 upOn tHe faCe OF the deep. and the sPirIt Of goD moved upOn</span>
<span class="c"># =&gt;                 the fACE oF the wATers.</span>
<span class="c"># =&gt; </span>
<span class="c"># =&gt;         001:003 AnD goD said, lEt there be light: aND there wAs LighT.</span>
<span class="c"># =&gt;         </span>

<span class="c"># @@PLEAC@@_1.10</span>


<span class="c"># Interpolating functions and expressions within strings</span>
<span class="k">set</span> var1 Tool
<span class="k">proc</span> func <span class="k">{</span><span class="nv">s</span><span class="k">}</span> <span class="k">{</span><span class="nb">string</span> totitle <span class="nv">$s</span><span class="k">}</span>
<span class="k">set</span> var2 Language
<span class="k">set</span> answer <span class="s2">&quot;$var1 [func command] $var2&quot;</span>
<span class="c"># =&gt; Tool Command Language</span>


<span class="k">set</span> n <span class="mi">5</span>
<span class="k">set</span> phrase <span class="s2">&quot;I have [expr {$n + 1}] guanacos.&quot;</span>
<span class="c"># =&gt; I have 6 guanacos.</span>


<span class="k">set</span> rec foo:bar:baz
<span class="nb">interp</span> alias <span class="k">{}</span> some_cmd <span class="k">{}</span> join
<span class="nv">some_cmd</span> <span class="s2">&quot;What you want is [llength [split $rec :]] items&quot;</span>
<span class="c"># =&gt; What you want is 3 items</span>


<span class="k">set</span> text <span class="k">{</span>
<span class="nv">To</span><span class="o">:</span> <span class="nv">$naughty</span>
<span class="nv">From</span><span class="o">:</span> Your Bank
<span class="nv">Cc</span><span class="o">:</span> <span class="k">[</span><span class="nv">getManagerList</span> <span class="nv">$naughty</span><span class="k">]</span>
<span class="nv">Date</span><span class="o">:</span> <span class="k">[</span><span class="nb">clock</span> format <span class="k">[</span><span class="nb">clock</span> seconds<span class="k">]]</span> <span class="k">(</span><span class="nv">today</span><span class="k">)</span>
<span class="nv">Dear</span> <span class="nv">$naughty</span><span class="err">,</span>
<span class="nv">Today</span><span class="err">,</span> you bounced check number <span class="k">[expr</span> <span class="k">{</span><span class="nv">500</span> <span class="o">+</span> int<span class="k">(</span><span class="nv">rand</span><span class="k">()</span><span class="o">*</span><span class="mi">100</span><span class="k">)}]</span> to us.
<span class="nv">Your</span> account is now closed.
<span class="nv">Sincerely</span><span class="err">,</span>
<span class="nv">the</span> management
<span class="k">}</span>
<span class="k">if</span> <span class="k">{</span><span class="o">!</span><span class="k">[</span><span class="nv">sendMail</span> <span class="nv">$text</span> <span class="nv">$target</span><span class="k">]}</span> <span class="k">{</span>
    <span class="k">error</span> <span class="s2">&quot;Couldn&#39;t send mail&quot;</span>
<span class="k">}</span>

<span class="c"># @@PLEAC@@_1.11</span>


<span class="c"># all in one</span>
<span class="nb">regsub</span> <span class="o">-</span>line <span class="o">-</span>all <span class="k">{</span><span class="o">^</span><span class="err">\</span><span class="nv">s</span><span class="o">+</span><span class="k">}</span> <span class="k">{</span>
    <span class="nv">your</span> text
    <span class="nv">goes</span> here
<span class="k">}</span> <span class="k">{}</span> var
<span class="nb">format</span> <span class="o">%</span>s <span class="err">\</span>n<span class="nv">$var</span>
<span class="c"># =&gt; </span>
<span class="c"># =&gt; your text</span>
<span class="c"># =&gt; goes here</span>


<span class="c"># or with two steps</span>
<span class="k">set</span> var <span class="k">{</span>
    <span class="nv">your</span> text
    <span class="nv">goes</span> here
<span class="k">}</span>
<span class="nb">regsub</span> <span class="o">-</span>line <span class="o">-</span>all <span class="k">{</span><span class="o">^</span><span class="err">\</span><span class="nv">s</span><span class="o">+</span><span class="k">}</span> <span class="nv">$var</span> <span class="k">{}</span> var
<span class="nb">format</span> <span class="o">%</span>s <span class="err">\</span>n<span class="nv">$var</span>
<span class="c"># =&gt; </span>
<span class="c"># =&gt; your text</span>
<span class="c"># =&gt; goes here</span>

<span class="c"># one more time</span>
<span class="nb">regsub</span> <span class="o">-</span>line <span class="o">-</span>all <span class="k">{</span><span class="o">^</span><span class="err">\</span><span class="nv">s</span><span class="o">+</span><span class="k">}</span> <span class="k">{</span>
    <span class="nv">The</span> five varieties of camelids
    <span class="nv">are</span> the familiar camel<span class="err">,</span> his friends
    <span class="nv">the</span> llama and the alpaca<span class="err">,</span> and the
    <span class="nv">rather</span> less well-known guanaco
    <span class="nv">and</span> vicu<span class="err">с</span>a.
<span class="k">}</span> <span class="k">{}</span> definition
<span class="c"># =&gt; 6</span>


<span class="k">proc</span> fix <span class="k">{</span><span class="nb">string</span><span class="k">}</span> <span class="k">{</span>
    <span class="nb">regsub</span> <span class="o">-</span>line <span class="o">-</span>all <span class="k">{</span><span class="o">^</span><span class="err">\</span><span class="nv">s</span><span class="o">+</span><span class="k">}</span> <span class="nv">$string</span> <span class="k">{}</span> string
    <span class="k">return</span> <span class="nv">$string</span>
<span class="k">}</span>

<span class="nv">fix</span> <span class="k">{</span>
    <span class="nv">My</span> stuff goes here
<span class="k">}</span>
<span class="c"># =&gt; My stuff goes here</span>


<span class="c"># the end-of-string right brace doesn&#39;t have to be flush left</span>
<span class="nb">regsub</span> <span class="o">-</span>line <span class="o">-</span>all <span class="k">{</span><span class="o">^</span><span class="err">\</span><span class="nv">s</span><span class="o">+</span><span class="k">}</span> <span class="k">{</span>
    <span class="nv">...we</span> will have peace<span class="err">,</span> when you and all your works have
    <span class="nv">perished--and</span> the works of your dark master to whom you would
    <span class="nv">deliver</span> us. You are a liar<span class="err">,</span> Saruman<span class="err">,</span> and a corrupter of men<span class="err">&#39;</span>s
    <span class="nv">hearts.</span>  <span class="o">--</span>Theoden <span class="ow">in</span> <span class="o">/</span>usr<span class="o">/</span>src<span class="o">/</span>perl<span class="o">/</span>taint.c
                         <span class="k">}</span> <span class="k">{}</span> quote       <span class="k">;</span><span class="c"># &lt;-- looki looki</span>
<span class="c"># move attribution to line of its own</span>
<span class="nb">regsub</span> <span class="k">{</span><span class="err">\</span><span class="nv">s</span><span class="o">+--</span><span class="k">}</span> <span class="nv">$quote</span> <span class="err">\</span>n-- quote
<span class="nb">format</span> <span class="o">%</span>s <span class="err">\</span>n<span class="nv">$quote</span>
<span class="c"># =&gt; </span>
<span class="c"># =&gt; ...we will have peace, when you and all your works have</span>
<span class="c"># =&gt; perished--and the works of your dark master to whom you would</span>
<span class="c"># =&gt; deliver us. You are a liar, Saruman, and a corrupter of men&#39;s</span>
<span class="c"># =&gt; hearts.</span>
<span class="c"># =&gt; --Theoden in /usr/src/perl/taint.c</span>

<span class="k">proc</span> rememberTheMain <span class="k">{}</span> <span class="k">{</span>
    <span class="nv">dequote</span> <span class="k">{</span>
        <span class="err">@@@</span> <span class="nv">int</span>
        <span class="err">@@@</span> <span class="nv">runops</span><span class="k">()</span> <span class="k">{</span>
        <span class="err">@@@</span>     <span class="nv">SAVEI32</span><span class="k">(</span><span class="nv">runlevel</span><span class="k">);</span>
        <span class="err">@@@</span>     <span class="nv">runlevel</span><span class="o">++</span><span class="k">;</span>
        <span class="err">@@@</span>     <span class="k">while</span> <span class="k">(</span> <span class="nv">op</span> <span class="err">=</span> <span class="k">(</span><span class="o">*</span><span class="nv">op-</span><span class="o">&gt;</span>op_ppaddr<span class="k">)()</span> <span class="k">)</span> <span class="k">;</span>
        <span class="err">@@@</span>     <span class="nv">TAINT_NOT</span><span class="k">;</span>
        <span class="err">@@@</span>     <span class="k">return</span> <span class="mi">0</span><span class="k">;</span>
        <span class="err">@@@</span> <span class="k">}</span>
    <span class="k">}</span>
    <span class="c"># add more code here if you want</span>
<span class="k">}</span>
 
<span class="k">proc</span> roadGoesEverOn <span class="k">{}</span> <span class="k">{</span>
    <span class="nv">dequote</span> <span class="k">{</span>
       <span class="nv">Now</span> far ahead the Road has gone<span class="err">,</span>
          <span class="nv">And</span> I must follow<span class="err">,</span> if I can<span class="err">,</span>
       <span class="nv">Pursuing</span> it with eager feet<span class="err">,</span>
          <span class="nv">Until</span> it joins some larger way
       <span class="nv">Where</span> many paths and errands meet.
          <span class="nv">And</span> whither <span class="k">then</span><span class="o">?</span> I cannot say.
                <span class="nv">--Bilbo</span> <span class="ow">in</span> <span class="o">/</span>usr<span class="o">/</span>src<span class="o">/</span>perl<span class="o">/</span>pp_ctl.c
    <span class="k">}</span>
<span class="k">}</span>
<span class="k">proc</span> quotemeta <span class="k">{</span><span class="nb">string</span><span class="k">}</span> <span class="k">{</span>
    <span class="nb">regsub</span> <span class="o">-</span>all <span class="k">{(</span><span class="err">\</span><span class="nv">W</span><span class="k">)}</span> <span class="nv">$string</span> <span class="k">{</span><span class="err">\\\</span><span class="nv">1</span><span class="k">}</span> string
    <span class="k">return</span> <span class="nv">$string</span>
<span class="k">}</span>
<span class="k">proc</span> dequote <span class="k">{</span><span class="nv">text</span><span class="k">}</span> <span class="k">{</span>
    <span class="k">if</span> <span class="k">{[</span><span class="nb">regexp</span> <span class="o">-</span>line <span class="k">{</span><span class="o">^</span><span class="err">\</span><span class="nv">s</span><span class="o">*</span><span class="k">(</span><span class="o">?:</span><span class="k">([</span><span class="o">^</span><span class="err">\</span><span class="nv">w</span><span class="err">\</span>s<span class="k">]</span><span class="o">+</span><span class="k">)(</span><span class="err">\</span><span class="nv">s</span><span class="o">*</span><span class="k">)</span><span class="nv">.</span><span class="o">*</span><span class="err">\</span>n<span class="k">)(</span><span class="o">?:</span><span class="err">\</span><span class="nv">s</span><span class="o">*</span><span class="err">\</span><span class="mi">1</span><span class="err">\</span><span class="mi">2</span><span class="o">?</span>.<span class="o">*</span><span class="err">\</span>n<span class="k">)</span><span class="o">+</span><span class="k">(</span><span class="o">?:</span><span class="err">\</span><span class="nv">s</span><span class="o">*</span><span class="k">)</span><span class="err">$</span><span class="k">}</span> <span class="nv">$text</span> m <span class="mi">1</span> <span class="mi">2</span><span class="k">]}</span> <span class="k">{</span>
        <span class="k">set</span> white <span class="nv">$2</span>
        <span class="k">set</span> leader <span class="k">[</span><span class="nv">quotemeta</span> <span class="nv">$1</span><span class="k">]</span>
    <span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
        <span class="nb">regexp</span> <span class="o">-</span>line <span class="k">{</span><span class="o">^</span><span class="err">\</span><span class="nv">n</span><span class="o">?</span><span class="k">(</span><span class="err">\</span><span class="nv">s</span><span class="o">+</span><span class="k">)}</span> <span class="nv">$text</span> m white
        <span class="k">set</span> leader <span class="k">{}</span>
    <span class="k">}</span>
    <span class="nb">regsub</span> <span class="o">-</span>line <span class="o">-</span>all <span class="o">^</span><span class="err">\\</span>s<span class="o">*?</span><span class="nv">$leader</span><span class="err">\</span><span class="k">(</span><span class="o">?:</span><span class="nv">$white</span><span class="err">\</span><span class="k">)</span> <span class="nv">$text</span> <span class="k">{}</span> text
    <span class="k">return</span> <span class="k">[</span><span class="nb">string</span> trimright <span class="nv">$text</span><span class="k">]</span><span class="err">\</span>n
<span class="k">}</span>

<span class="c"># @@PLEAC@@_1.12</span>


<span class="c"># The tcllib 1.0 textutil module can adjust text</span>
<span class="c"># to a specified line length, justify left, right,</span>
<span class="c"># and plain, and fill lines to the right margin.</span>
<span class="c"># However, it can&#39;t add indentation.</span>



<span class="c"># A naive implementation of wrap.  Arguments:</span>
<span class="c"># text	the text</span>
<span class="c"># col	the line length (default 72)</span>
<span class="c"># lead	first line indentation (def empty string)</span>
<span class="c"># follow	indentation for following lines (def empty string)</span>
<span class="k">proc</span> wrap <span class="k">{</span><span class="nv">text</span> <span class="k">{</span><span class="nv">col</span> <span class="mi">72</span><span class="k">}</span> <span class="k">{</span><span class="nv">lead</span> <span class="k">{}}</span> <span class="k">{</span><span class="nv">follow</span> <span class="k">{}}}</span> <span class="k">{</span>
    <span class="k">set</span> newtext <span class="k">{}</span>
    <span class="k">set</span> text <span class="nv">$lead</span><span class="k">[</span><span class="nb">string</span> trimleft <span class="nv">$text</span><span class="k">]</span>
    <span class="k">set</span> upto <span class="nv">$col</span>
    <span class="k">while</span> <span class="k">{</span><span class="o">!</span><span class="k">[</span><span class="nb">string</span> is wordchar <span class="k">[</span><span class="nb">string</span> index <span class="nv">$text</span> <span class="nv">$upto</span><span class="k">]]}</span> <span class="k">{</span><span class="nb">incr</span> upto <span class="o">-</span><span class="mi">1</span><span class="k">}</span>
    <span class="k">set</span> upto <span class="k">[</span><span class="nb">string</span> wordstart <span class="nv">$text</span> <span class="nv">$upto</span><span class="k">]</span>
    <span class="k">if</span> <span class="k">{</span><span class="nv">$upto</span> <span class="o">==</span> <span class="nv">0</span><span class="k">}</span> <span class="k">{</span>
        <span class="k">set</span> upto <span class="k">[</span><span class="nb">string</span> wordend <span class="nv">$text</span> <span class="nv">$upto</span><span class="k">]</span>
    <span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
        <span class="nb">incr</span> upto <span class="o">-</span><span class="mi">1</span>
    <span class="k">}</span>
    <span class="nb">append</span> newtext <span class="k">[</span><span class="nb">string</span> range <span class="nv">$text</span> <span class="mi">0</span> <span class="nv">$upto</span><span class="k">]</span><span class="err">\</span>n
    <span class="k">set</span> text <span class="k">[</span><span class="nb">string</span> replace <span class="nv">$text</span> <span class="mi">0</span> <span class="nv">$upto</span><span class="k">]</span>
    <span class="k">while</span> <span class="k">{[</span><span class="nb">string</span> length <span class="nv">$text</span><span class="k">]}</span> <span class="k">{</span>
        <span class="k">set</span> text <span class="nv">$follow</span><span class="k">[</span><span class="nb">string</span> trimleft <span class="nv">$text</span><span class="k">]</span>
        <span class="k">if</span> <span class="k">{[</span><span class="nb">string</span> length <span class="nv">$text</span><span class="k">]</span> <span class="o">&gt;</span> <span class="nv">$col</span><span class="k">}</span> <span class="k">{</span>
            <span class="k">set</span> upto <span class="nv">$col</span>
            <span class="k">while</span> <span class="k">{</span><span class="o">!</span><span class="k">[</span><span class="nb">string</span> is wordchar <span class="k">[</span><span class="nb">string</span> index <span class="nv">$text</span> <span class="nv">$upto</span><span class="k">]]}</span> <span class="k">{</span><span class="nb">incr</span> upto <span class="o">-</span><span class="mi">1</span><span class="k">}</span>
            <span class="k">set</span> upto <span class="k">[</span><span class="nb">string</span> wordstart <span class="nv">$text</span> <span class="nv">$upto</span><span class="k">]</span>
            <span class="k">if</span> <span class="k">{</span><span class="nv">$upto</span> <span class="o">==</span> <span class="nv">0</span><span class="k">}</span> <span class="k">{</span>
                <span class="k">set</span> upto <span class="k">[</span><span class="nb">string</span> wordend <span class="nv">$text</span> <span class="nv">$upto</span><span class="k">]</span>
            <span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
                <span class="nb">incr</span> upto <span class="o">-</span><span class="mi">1</span>
            <span class="k">}</span>
            <span class="nb">append</span> newtext <span class="k">[</span><span class="nb">string</span> range <span class="nv">$text</span> <span class="mi">0</span> <span class="nv">$upto</span><span class="k">]</span><span class="err">\</span>n
            <span class="k">set</span> text <span class="k">[</span><span class="nb">string</span> replace <span class="nv">$text</span> <span class="mi">0</span> <span class="nv">$upto</span><span class="k">]</span>
        <span class="k">}</span> <span class="k">else</span> <span class="k">{</span>
            <span class="nb">append</span> newtext <span class="nv">$text</span>
            <span class="k">set</span> text <span class="k">{}</span>
        <span class="k">}</span>       
    <span class="k">}</span>
    <span class="k">return</span> <span class="nv">$newtext</span>
<span class="k">}</span>

<span class="k">set</span> input <span class="k">{</span><span class="s2">&quot;Folding and splicing is the work of an editor,&quot;</span>
      <span class="s2">&quot;not a mere collection of silicon&quot;</span>
      <span class="s2">&quot;and&quot;</span>
      <span class="s2">&quot;mobile electrons!&quot;</span><span class="k">}</span>
<span class="nb">append</span> res <span class="err">\</span>n <span class="k">[</span><span class="nb">string</span> repeat <span class="mo">01234567</span><span class="mi">89</span> <span class="mi">2</span><span class="k">]</span> <span class="err">\</span>n
<span class="nb">append</span> res <span class="k">[</span><span class="nv">wrap</span> <span class="k">[</span><span class="nb">join</span> <span class="nv">$input</span><span class="k">]</span> <span class="mi">20</span> <span class="k">{</span>    <span class="k">}</span> <span class="k">{</span>  <span class="k">}]</span> <span class="err">\</span>n
<span class="c"># =&gt; </span>
<span class="c"># =&gt; 01234567890123456789</span>
<span class="c"># =&gt;     Folding and </span>
<span class="c"># =&gt;   splicing is the </span>
<span class="c"># =&gt;   work of an </span>
<span class="c"># =&gt;   editor, not a </span>
<span class="c"># =&gt;   mere collection </span>
<span class="c"># =&gt;   of silicon and </span>
<span class="c"># =&gt;   mobile electrons!</span>

<span class="c"># @@PLEAC@@_1.13</span>


<span class="c"># backslash</span>
<span class="nb">regsub</span> <span class="o">-</span>all <span class="k">(</span><span class="err">\</span><span class="k">[</span><span class="nv">$charlist</span><span class="k">])</span> <span class="nv">$var</span> <span class="k">{</span><span class="err">\\\</span><span class="nv">1</span><span class="k">}</span> var


<span class="c"># double</span>
<span class="nb">regsub</span> <span class="o">-</span>all <span class="k">(</span><span class="err">\</span><span class="k">[</span><span class="nv">$charlist</span><span class="k">])</span> <span class="nv">$var</span> <span class="k">{</span><span class="err">\</span><span class="nv">1</span><span class="err">\</span><span class="mi">1</span><span class="k">}</span> var


<span class="k">set</span> string <span class="k">{</span><span class="nv">Mom</span> said<span class="err">,</span> <span class="s2">&quot;Don&#39;t do that.&quot;</span><span class="k">}</span>
<span class="nb">regsub</span> <span class="o">-</span>all <span class="k">{([</span><span class="err">&#39;</span><span class="s2">&quot;])} $string {\\\1} string</span>
<span class="s2">puts $string</span>
<span class="s2"># =&gt; Mom said, \&quot;Don\&#39;t do that.\&quot;</span>

<span class="s2">set string {Mom said, &quot;</span><span class="nv">Don</span><span class="err">&#39;</span>t do that.<span class="s2">&quot;}</span>
<span class="s2">regsub -all {([&#39;&quot;])} $string {\1\1} string</span>
<span class="s2">puts $string</span>
<span class="s2"># =&gt; Mom said, &quot;&quot;Don&#39;&#39;t do that.&quot;&quot;</span>

<span class="s2">set string {Mom said, &quot;</span>Don<span class="err">&#39;</span>t do that.<span class="s2">&quot;}</span>
<span class="s2">regsub -all {([^A-Z])} $string {\\\1} string    ;# or: ([^[:upper:]])</span>
<span class="s2">puts $string</span>
<span class="s2"># =&gt; M\o\m\ \s\a\i\d\,\ \&quot;D\o\n\&#39;\t\ \d\o\ \t\h\a\t\.\&quot;</span>

<span class="s2">regsub -all {([^[:alnum:]])} &quot;</span>is a test<span class="o">!</span><span class="s2">&quot; {\\\1} string</span>
<span class="s2">puts &quot;</span>this <span class="nv">$string</span><span class="s2">&quot;</span>
<span class="s2"># =&gt; this is\ a\ test\!</span>

<span class="s2"># @@PLEAC@@_1.14</span>


<span class="s2">string trim &quot;</span><span class="err">\</span>n<span class="err">\</span>t Tcl <span class="err">\</span>t<span class="err">\</span>n<span class="s2">&quot;</span>
<span class="s2"># =&gt; Tcl</span>


<span class="s2">set string {</span>
<span class="s2">    foo bar</span>
<span class="s2">    baz</span>
<span class="s2">    </span>
<span class="s2">}</span>
<span class="s2">set res [list]</span>
<span class="s2">foreach {s} [split $string \n] {</span>
<span class="s2">    lappend res [string trim $s]</span>
<span class="s2">}</span>
<span class="s2">string trim [join $res]</span>
<span class="s2"># =&gt; foo bar baz</span>


<span class="s2"># The [gets] (get string) command always strips off the EOL</span>
<span class="s2"># sequence, be it CR, LF, or CRLF (configurable for the stream).</span>

<span class="s2"># Anyway, if you have a string that *might* have one or more</span>
<span class="s2"># \n characters at the end, and in case it does, you want to</span>
<span class="s2"># remove them:</span>



<span class="s2">string trimright &quot;</span>foo bar<span class="err">\</span>n<span class="err">\</span>n<span class="s2">&quot; \n</span>
<span class="s2"># =&gt; foo bar</span>

<span class="s2"># @@PLEAC@@_1.15</span>


<span class="s2"># csv is a part of the standard ActiveTcl distribution</span>
<span class="s2">package require csv</span>
<span class="s2">set line {XYZZY,,&quot;</span>O<span class="err">&#39;</span>Reilly<span class="err">,</span> Inc<span class="s2">&quot;,&quot;</span>Wall<span class="err">,</span> Larry<span class="s2">&quot;,&quot;</span>a <span class="s2">&quot;&quot;</span>glug<span class="s2">&quot;&quot;</span> bit<span class="s2">&quot;,5,&quot;</span>Error<span class="err">,</span> Core Dumped<span class="s2">&quot;}</span>
<span class="s2">set fields [::csv::split $line]</span>
<span class="s2">set res {}</span>
<span class="s2">for {set i 0} {$i &lt; [llength $fields]} {incr i} {</span>
<span class="s2">    append res \n &quot;</span><span class="nv">$i</span> <span class="o">:</span> <span class="k">[</span><span class="nb">lindex</span> <span class="nv">$fields</span> <span class="nv">$i</span><span class="k">]</span><span class="s2">&quot;</span>
<span class="s2">}</span>
<span class="s2">puts $res</span>
<span class="s2"># =&gt; </span>
<span class="s2"># =&gt; 0 : XYZZY</span>
<span class="s2"># =&gt; 1 : </span>
<span class="s2"># =&gt; 2 : O&#39;Reilly, Inc</span>
<span class="s2"># =&gt; 3 : Wall, Larry</span>
<span class="s2"># =&gt; 4 : a &quot;</span>glug<span class="s2">&quot; bit</span>
<span class="s2"># =&gt; 5 : 5</span>
<span class="s2"># =&gt; 6 : Error, Core Dumped</span>

<span class="s2"># @@PLEAC@@_1.17</span>


<span class="s2"># fixstyle - switch one set of strings to another set</span>
<span class="s2">#   usage: &lt;scriptname&gt; [-v] [files ...]</span>
<span class="s2">array set ::data {</span>
<span class="s2">    analysed         analyzed</span>
<span class="s2">    built-in         builtin</span>
<span class="s2">    chastized        chastised</span>
<span class="s2">    commandline      command-line</span>
<span class="s2">    de-allocate      deallocate</span>
<span class="s2">    dropin           drop-in</span>
<span class="s2">    hardcode         hard-code</span>
<span class="s2">    meta-data        metadata</span>
<span class="s2">    multicharacter   multi-character</span>
<span class="s2">    multiway         multi-way</span>
<span class="s2">    non-empty        nonempty</span>
<span class="s2">    non-profit       nonprofit</span>
<span class="s2">    non-trappable    nontrappable</span>
<span class="s2">    pre-define       predefine</span>
<span class="s2">    preextend        pre-extend</span>
<span class="s2">    re-compiling     recompiling</span>
<span class="s2">    reenter          re-enter</span>
<span class="s2">    turnkey          turn-key</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">set testtext {</span>
<span class="s2">    Yesterday we analysed the efficiency of the </span>
<span class="s2">    built-in thingummies and were considerably </span>
<span class="s2">    chastized by the results.  It seems that </span>
<span class="s2">    commandline invocation forced the </span>
<span class="s2">    whatchamacallit to de-allocate dropin </span>
<span class="s2">    maguffins.  First, we tested instead to </span>
<span class="s2">    hardcode meta-data -- especially when in </span>
<span class="s2">    multicharacter and multiway format</span>
<span class="s2">    (obviously only for non-empty data sets).  </span>
<span class="s2">    However, that turned out to be a non-profit </span>
<span class="s2">    improvement.  Dr Egnarts then demonstrated </span>
<span class="s2">    using non-trappable signals in pre-define </span>
<span class="s2">    mode to preextend save rates.  When </span>
<span class="s2">    re-compiling we saw the application reenter </span>
<span class="s2">    acceptable ratings on turnkey operations.</span>
<span class="s2">}</span>
<span class="s2"># verbose or non-verbose?</span>
<span class="s2">if {[llength $argv] &amp;&amp; [string equal [lindex $argv 0] -v]} {</span>
<span class="s2">    set ::verbose yes</span>
<span class="s2">    set argv [lrange $argv 1 end]</span>
<span class="s2">} else {</span>
<span class="s2">    set ::verbose no</span>
<span class="s2">}</span>
<span class="s2"># prepare text to be read</span>
<span class="s2">set text {}</span>
<span class="s2">if {[string match *test [info script]]} {</span>
<span class="s2">    # if we&#39;re running a test:</span>
<span class="s2">    set text $testtext</span>
<span class="s2">} else {</span>
<span class="s2">    # Try to assemble text from input.  Do we have arguments?</span>
<span class="s2">    if {[info exists argv]} {</span>
<span class="s2">        # Yes; try to open each and read contents:</span>
<span class="s2">        foreach {fn} [lrange $argv 0 end] {</span>
<span class="s2">            if {![catch {open $fn} chan]} {</span>
<span class="s2">                append text [read $chan]</span>
<span class="s2">                close $chan</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">    if {![string length $text]} {</span>
<span class="s2">        # we still don&#39;t have any text; try standard input</span>
<span class="s2">        # (inform user first)</span>
<span class="s2">        if {[tell stdin] == -1} {</span>
<span class="s2">            puts stderr &quot;</span><span class="k">[</span><span class="nb">info</span> script<span class="k">]</span><span class="o">:</span> Reading from stdin<span class="s2">&quot;</span>
<span class="s2">        }</span>
<span class="s2">        set text [read stdin]</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">proc fixstyle {text} {</span>
<span class="s2">    global data verbose</span>
<span class="s2">    set newtext [list]</span>
<span class="s2">    foreach w $text {</span>
<span class="s2">        if {[catch {set word $data($w)}]} {</span>
<span class="s2">            set word $w</span>
<span class="s2">        } else {</span>
<span class="s2">            if {$verbose} {</span>
<span class="s2">                puts stderr &quot;</span><span class="nv">$w</span> <span class="err">=</span><span class="o">&gt;</span> <span class="nv">$word</span><span class="s2">&quot;</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">        lappend newtext $word</span>
<span class="s2">    }</span>
<span class="s2">    return $newtext</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">fixstyle $text</span>
<span class="s2"># =&gt; Yesterday we analyzed the efficiency of the builtin thingummies and were considerably chastised by the results. It seems that command-line invocation forced the whatchamacallit to deallocate drop-in maguffins. First, we tested instead to hard-code metadata -- especially when in multi-character and multi-way format (obviously only for nonempty data sets). However, that turned out to be a nonprofit improvement. Dr Egnarts then demonstrated using nontrappable signals in predefine mode to pre-extend save rates. When recompiling we saw the application re-enter acceptable ratings on turn-key operations.</span>

<span class="s2"># @@PLEAC@@_2.0</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_2.1</span>


<span class="s2"># The &quot;</span>backwards conditional<span class="s2">&quot; Perl form is useful here</span>
<span class="s2"># to demonstrate the various regexps.  Tcl doesn&#39;t have</span>
<span class="s2"># this syntax, but it can be fudged very easily:</span>



<span class="s2">proc warn {msg cond pattern {string 0}} {</span>
<span class="s2">    if {[string equal if $cond]} {</span>
<span class="s2">        if {[regexp $pattern $string]} {</span>
<span class="s2">            return [format &quot;%s: %s&quot; $string $msg]</span>
<span class="s2">        }</span>
<span class="s2">    } elseif {[string equal unless $cond]} {</span>
<span class="s2">        if {![regexp $pattern $string]} {</span>
<span class="s2">            return [format &quot;%s: %s&quot; $string $msg]</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">    return</span>
<span class="s2">}</span>

<span class="s2">warn &quot;</span>has nondigits<span class="s2">&quot; if {\D}</span>

<span class="s2">warn &quot;</span>not a natural number<span class="s2">&quot; unless {^\d+$}        ;# rejects -3</span>

<span class="s2">warn &quot;</span>not an integer<span class="s2">&quot; unless {^[+-]?\d+$}         ;# rejects +3</span>

<span class="s2">warn &quot;</span>not a real number<span class="s2">&quot; unless {^-?\d+\.?\d*$}   ;# rejects .2</span>

<span class="s2">warn &quot;</span>not a C float<span class="s2">&quot; unless {^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$}</span>


<span class="s2"># Regexps like the above are sometimes necessary for making fine</span>
<span class="s2"># distinctions among string representations of numbers.</span>
<span class="s2"># If the only thing in questions is whether $x is a number</span>
<span class="s2"># or not, or whether it is an integer or a real number, Tcl</span>
<span class="s2"># can help:</span>



<span class="s2">if {[string is integer $x]} {</span>
<span class="s2">    set res &quot;</span><span class="nv">$x</span> is an integer<span class="s2">&quot;</span>
<span class="s2">} elseif {[string is double $x]} {</span>
<span class="s2">    set res &quot;</span><span class="nv">$x</span> is a real number<span class="s2">&quot;</span>
<span class="s2">} else {</span>
<span class="s2">    set res &quot;</span><span class="nv">$x</span> is not a number<span class="s2">&quot;</span>
<span class="s2">}</span>
<span class="s2">set res</span>

<span class="s2"># @@PLEAC@@_2.2</span>


<span class="s2"># limit number of decimals when determining equality of</span>
<span class="s2"># floating point values to avoid rounding errors.</span>
<span class="s2">proc floatEqual-1 {num1 num2 accuracy} {</span>
<span class="s2">    expr {[format %.${accuracy}f $num1] == [format %.${accuracy}f $num2]}</span>
<span class="s2">}</span>


<span class="s2">set wage 536                  ;# $5.36/hour</span>
<span class="s2">set week [expr {40 * $wage}]  ;# $214.40</span>
<span class="s2">format &quot;</span>One week<span class="err">&#39;</span>s wage is: <span class="err">\$</span><span class="o">%</span>.2f<span class="s2">&quot; [expr {$week/100.0}]</span>
<span class="s2"># =&gt; One week&#39;s wage is: $214.40</span>

<span class="s2"># @@PLEAC@@_2.3</span>


<span class="s2">set a 0.255</span>
<span class="s2">set b [format %.2f $a]</span>
<span class="s2">puts &quot;</span>Unrounded: <span class="nv">$a</span><span class="s2">&quot;</span>
<span class="s2">puts &quot;</span>Rounded:   <span class="nv">$b</span><span class="s2">&quot;</span>
<span class="s2"># =&gt; Unrounded: 0.255</span>
<span class="s2"># =&gt; Rounded:   0.26</span>

<span class="s2">set res \nnumber\tint\tfloor\tceil\n</span>
<span class="s2">set a [list 3.3 3.5 3.7 -3.3]</span>
<span class="s2">foreach n $a {</span>
<span class="s2">    append res [format %.1f\t $n]</span>
<span class="s2">    append res [format %.1f\t [expr {int($n)}]]</span>
<span class="s2">    append res [format %.1f\t [expr {floor($n)}]]</span>
<span class="s2">    append res [format %.1f\n [expr {ceil($n)}]]</span>
<span class="s2">}</span>
<span class="s2">puts $res</span>
<span class="s2"># =&gt; </span>
<span class="s2"># =&gt; number	int	floor	ceil</span>
<span class="s2"># =&gt; 3.3	3.0	3.0	4.0</span>
<span class="s2"># =&gt; 3.5	3.0	3.0	4.0</span>
<span class="s2"># =&gt; 3.7	3.0	3.0	4.0</span>
<span class="s2"># =&gt; -3.3	-3.0	-4.0	-3.0</span>

<span class="s2"># @@PLEAC@@_2.4</span>


<span class="s2">proc dec2bin {string} {</span>
<span class="s2">    binary scan [binary format I $string] B32 str</span>
<span class="s2">    return [string trimleft $str 0]</span>
<span class="s2">}</span>
<span class="s2">dec2bin 54</span>
<span class="s2"># =&gt; 110110</span>


<span class="s2">proc bin2dec {string} {</span>
<span class="s2">    set string [format %032s $string]</span>
<span class="s2">    binary scan [binary format B32 $string] I str</span>
<span class="s2">    return $str</span>
<span class="s2">}</span>
<span class="s2">bin2dec 110110</span>
<span class="s2"># =&gt; 54</span>

<span class="s2"># @@PLEAC@@_2.5</span>


<span class="s2">for {set i $X} {$i &lt;= $Y} {incr i} {</span>
<span class="s2">    # $i is set to every integer from X to Y, inclusive</span>
<span class="s2">}</span>

<span class="s2">for {set i $X} {$i &lt;= $Y} {incr i 7} {</span>
<span class="s2">    # $i is set to every integer from X to Y, stepsize = 7</span>
<span class="s2">}</span>

<span class="s2">set res {}</span>
<span class="s2">append res &quot;</span>Infancy is: <span class="s2">&quot;</span>
<span class="s2">foreach i [list 0 1 2] {</span>
<span class="s2">    append res &quot;</span><span class="nv">$i</span> <span class="s2">&quot;</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">proc .. {low high} {</span>
<span class="s2">    for {set i $low} {$i &lt;= $high} {incr i} {</span>
<span class="s2">        lappend res $i</span>
<span class="s2">    }</span>
<span class="s2">    set res</span>
<span class="s2">}</span>
<span class="s2">append res \n</span>
<span class="s2">append res &quot;</span>Toddling is: <span class="s2">&quot;</span>
<span class="s2">foreach i [.. 3 4] {</span>
<span class="s2">    append res &quot;</span><span class="nv">$i</span> <span class="s2">&quot;</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">append res \n</span>
<span class="s2">append res &quot;</span>Childhood is: <span class="s2">&quot;</span>
<span class="s2">for {set i 5} {$i &lt;= 12} {incr i} {</span>
<span class="s2">    append res &quot;</span><span class="nv">$i</span> <span class="s2">&quot;</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">puts $res</span>
<span class="s2"># =&gt; Infancy is: 0 1 2 </span>
<span class="s2"># =&gt; Toddling is: 3 4 </span>
<span class="s2"># =&gt; Childhood is: 5 6 7 8 9 10 11 12 </span>

<span class="s2"># @@PLEAC@@_2.6</span>


<span class="s2"># These procedures were written by Richard Suchenwirth.</span>
<span class="s2"># See &lt;URL: http://mini.net/tcl/1749.html&gt;</span>



<span class="s2">roman:number 15</span>
<span class="s2"># =&gt; XV</span>


<span class="s2">roman:get XV</span>
<span class="s2"># =&gt; 15</span>

<span class="s2"># @@PLEAC@@_2.7</span>


<span class="s2"># The rand function returns a floating point number from zero to</span>
<span class="s2"># just less than one or, in mathematical notation, the range [0,1).</span>
<span class="s2"># The seed comes from the internal clock of the machine or may be</span>
<span class="s2"># set manually with the srand function.</span>
<span class="s2">         </span>
<span class="s2"># The math module of the standard distribution has a wrapper for</span>
<span class="s2"># rand called random; it supports generation of pseudo-random</span>
<span class="s2"># numbers in the [0,n) and [n,m) ranges.</span>



<span class="s2">puts [expr {int(rand()*51)+25}]</span>
<span class="s2"># =&gt; 32</span>

<span class="s2">package require math</span>
<span class="s2">puts [::math::random 25 76]</span>
<span class="s2"># =&gt; 32</span>


<span class="s2">set list [split {Demonstrate selecting a random element from a list.}]</span>
<span class="s2">package require math</span>
<span class="s2">puts [lindex $list [::math::random [llength $list]]]</span>
<span class="s2"># =&gt; selecting</span>


<span class="s2">package require math</span>
<span class="s2">set password {}</span>
<span class="s2">for {set i 0} {$i &lt; 8} {incr i} {</span>
<span class="s2">    append password [lindex $chars [::math::random [llength $chars]]]</span>
<span class="s2">}</span>
<span class="s2">puts $password</span>
<span class="s2"># =&gt; JhzQ!p!$</span>

<span class="s2"># @@PLEAC@@_2.8</span>


<span class="s2">set value 1138</span>
<span class="s2">expr {srand($value)}</span>
<span class="s2"># =&gt; 0.00890640821723</span>

<span class="s2"># @@PLEAC@@_2.9</span>


<span class="s2"># There is no standard module known to me that implements better</span>
<span class="s2"># random number generators than the one in the C library, but at</span>
<span class="s2"># &lt;URL: http://www.elf.org/etc/randomnumbers.html&gt; there is Tcl</span>
<span class="s2"># and C source for a ``very long period random number generator&#39;&#39;.</span>
<span class="s2">         </span>
<span class="s2"># Also see &lt;URL: http://mini.net/cgi-bin/wikit/1551.html&gt; for a</span>
<span class="s2"># `post-processor&#39; that improves the randomness of the output of</span>
<span class="s2"># rand().</span>

<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_2.10</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_2.11</span>


<span class="s2"># You&#39;d typically want a variable like PI to be </span>
<span class="s2"># contained within a namespace and not automatically</span>
<span class="s2"># set in the global namespace.  [variable] creates</span>
<span class="s2"># a variable in the current namespace, and [namespace</span>
<span class="s2"># current] returns the qualified name of the current</span>
<span class="s2"># namespace, or :: for the global namespace.</span>



<span class="s2">variable PI [expr {acos(-1)}]</span>
<span class="s2">puts [set [namespace current]::PI]</span>
<span class="s2"># =&gt; 3.14159265359</span>


<span class="s2">proc deg2rad {degrees} {</span>
<span class="s2">    variable PI</span>
<span class="s2">    return [expr {$degrees / 180.0 * $PI}]</span>
<span class="s2">}</span>


<span class="s2">proc rad2deg {radians} {</span>
<span class="s2">    variable PI</span>
<span class="s2">    return [expr {$radians / $PI * 180}]</span>
<span class="s2">}</span>


<span class="s2"># The core Tcl command [expr] has most of the commonly</span>
<span class="s2"># used trigonometric functions defined, so there is</span>
<span class="s2"># less need for a Trig module.</span>



<span class="s2">proc degreeSine {degrees} {</span>
<span class="s2">    set radians [deg2rad $degrees]</span>
<span class="s2">    return [expr {sin($radians)}]</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_2.12</span>


<span class="s2"># The tangent function is already available in the [expr]</span>
<span class="s2"># command, as is the arcus cosine and many more.</span>
<span class="s2">         </span>
<span class="s2"># In some cases, the [expr] functions raise an error because</span>
<span class="s2"># of overflow or division by zero.  To trap such errors, wrap</span>
<span class="s2"># in [catch]:</span>



<span class="s2">list [catch {expr {1/0}} msg] $msg</span>
<span class="s2"># =&gt; 1 {divide by zero}</span>

<span class="s2"># @@PLEAC@@_2.13</span>


<span class="s2">set value 1138</span>
<span class="s2">puts [expr {log($value)}]</span>
<span class="s2"># =&gt; 7.03702761469</span>


<span class="s2">set value 1138</span>
<span class="s2">puts [expr {log10($value)}]</span>
<span class="s2"># =&gt; 3.05614226206</span>


<span class="s2">proc logN {base value} {</span>
<span class="s2">    return [expr {log($value) / log($base)}]</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_2.14</span>


<span class="s2"># There are a few non-standard matrix modules available for Tcl, e.g.</span>
<span class="s2">#  * TiM: &lt;URL: http://www-obs.univ-lyon1.fr/~thiebaut/TiM/TiM.html&gt;.</span>
<span class="s2">#    In TiM, matrix multiplication seems to be an &quot;A * B&quot; matter.</span>
<span class="s2">#  * La (The Hume Linear Algebra Tcl Package):</span>
<span class="s2">#    &lt;URL: http://www.hume.com/la/index.html&gt;.  Matrix multiplication</span>
<span class="s2">#    in La looks like this: mmult A B.</span>



<span class="s2"># There is also a matrix module in the standard distribution library,</span>
<span class="s2"># but it does not contain arithmetic.  I have used it anyway, with</span>
<span class="s2"># an adaptation of the mmult subroutine in the Perl Cookbook.</span>



<span class="s2">package require struct 1.1.1</span>
<span class="s2">proc mmult {m1 m2} {</span>
<span class="s2">   set m1rows [$m1 rows]</span>
<span class="s2">   set m1cols [$m1 columns]</span>
<span class="s2">   set m2rows [$m2 rows]</span>
<span class="s2">   set m2cols [$m2 columns]</span>
<span class="s2">   if {$m1cols != $m2rows} {</span>
<span class="s2">       error &quot;IndexError: matrices don&#39;t match: $m1cols != $m2rows&quot;</span>
<span class="s2">   }</span>
<span class="s2">   </span>
<span class="s2">   ::struct::matrix result</span>
<span class="s2">   result add rows $m1rows</span>
<span class="s2">   result add columns $m2cols</span>
<span class="s2">   for {set i 0} {$i &lt; $m1rows} {incr i} {</span>
<span class="s2">       for {set j 0} {$j &lt; $m2cols} {incr j} {</span>
<span class="s2">           set v 0</span>
<span class="s2">           for {set k 0} {$k &lt; $m1cols} {incr k} {</span>
<span class="s2">               incr v [expr {[$m1 get cell $k $i] * [$m2 get cell $j $k]}]</span>
<span class="s2">           }</span>
<span class="s2">           result set cell $j $i $v</span>
<span class="s2">       }</span>
<span class="s2">   }</span>
<span class="s2">   return result</span>
<span class="s2">}</span>

<span class="s2">::struct::matrix x</span>
<span class="s2">x add columns 3</span>
<span class="s2">x add row [list 3 2 3]</span>
<span class="s2">x add row [list 5 9 8]</span>
<span class="s2">::struct::matrix y</span>
<span class="s2">y add rows 3</span>
<span class="s2">y add column [list 4 9 3]</span>
<span class="s2">y add column [list 7 3 1]</span>
<span class="s2">set res [mmult x y]</span>
<span class="s2">$res get rect 0 0 end end</span>
<span class="s2"># =&gt; {39 30} {125 70}</span>

<span class="s2"># @@PLEAC@@_2.15</span>


<span class="s2"># See &lt;URL: http://www.mini.net/tcl/Complex&gt; for complex</span>
<span class="s2"># arithmetic routines by Richard Suchenwirth.</span>



<span class="s2">complex::* 3+5i 2-2i</span>
<span class="s2"># =&gt; 16+4i</span>

<span class="s2"># @@PLEAC@@_2.16</span>


<span class="s2"># Tcl does not have hex/oct functions, but</span>
<span class="s2"># they are easy to implement.  If [expr]</span>
<span class="s2"># gets handed an invalid octal/hex number,</span>
<span class="s2"># it raises an error instead of returning</span>
<span class="s2"># 0 as the Perl functions do.</span>



<span class="s2">proc hex {string} {</span>
<span class="s2">    if {[regexp -nocase {^0x} $string]} {</span>
<span class="s2">        return [expr $string]</span>
<span class="s2">    } else {</span>
<span class="s2">        return [expr 0x$string]</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># This simpler version does not raise errors for invalid input:</span>
<span class="s2">#     proc hex {string} {</span>
<span class="s2">#         scan $string %x</span>
<span class="s2">#     }</span>



<span class="s2">proc oct {string} {</span>
<span class="s2">    if {[regexp -nocase {^0x} $string]} {</span>
<span class="s2">        return [hex $string]</span>
<span class="s2">    } else {</span>
<span class="s2">        return [expr 0$string]</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># This simpler version does not raise errors for invalid input:</span>
<span class="s2">#     proc oct {string} {</span>
<span class="s2">#         scan $string %o</span>
<span class="s2">#     }</span>



<span class="s2">if {[string match *.test [info script]]} {</span>
<span class="s2">    # we are testing, supply known value</span>
<span class="s2">    set num 0x39a</span>
<span class="s2">} else {</span>
<span class="s2">    puts &quot;Gimme a number in decimal, octal, or hex: &quot;</span>
<span class="s2">    set num [gets stdin]</span>
<span class="s2">}</span>
<span class="s2">if {[string length $num]} {</span>
<span class="s2">    if {[regexp ^0 $num]} {</span>
<span class="s2">        set num [oct $num]</span>
<span class="s2">    }</span>
<span class="s2">    format &quot;%d %x %o&quot; $num $num $num</span>
<span class="s2">}</span>
<span class="s2"># =&gt; 922 39a 1632</span>

<span class="s2"># @@PLEAC@@_2.17</span>


<span class="s2"># This procedure is written by Keith Vetter and is part of the Tcl</span>
<span class="s2"># Cookbook (&lt;URL: #http://aspn.activestate.com/ASPN/Cookbook/Tcl/Recipe/68381&gt;)</span>
<span class="s2">proc comma {num {sep ,}} {</span>
<span class="s2">    while {[regsub {^([-+]?\d+)(\d\d\d)} $num &quot;\\1$sep\\2&quot; num]} {}</span>
<span class="s2">    return $num</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_2.18</span>


<span class="s2"># See &lt;URL: http://mini.net/tcl/EnglishPlurals&gt; for an</span>
<span class="s2"># English pluralization function by Richard Suchenwirth.</span>



<span class="s2">set data [join {fish fly ox</span>
<span class="s2">species genus phylum</span>
<span class="s2">cherub radius jockey</span>
<span class="s2">index matrix mythos</span>
<span class="s2">phenomenon formula}]</span>
<span class="s2">set res {}</span>
<span class="s2">foreach word $data {</span>
<span class="s2">    append res &quot;One $word, two [en:pl $word]\n&quot;</span>
<span class="s2">}</span>
<span class="s2">puts $res</span>
<span class="s2"># =&gt; One fish, two fish</span>
<span class="s2"># =&gt; One fly, two flies</span>
<span class="s2"># =&gt; One ox, two oxen</span>
<span class="s2"># =&gt; One species, two species</span>
<span class="s2"># =&gt; One genus, two genera</span>
<span class="s2"># =&gt; One phylum, two phyla</span>
<span class="s2"># =&gt; One cherub, two cherubim</span>
<span class="s2"># =&gt; One radius, two radii</span>
<span class="s2"># =&gt; One jockey, two jockeys</span>
<span class="s2"># =&gt; One index, two indices</span>
<span class="s2"># =&gt; One matrix, two matrices</span>
<span class="s2"># =&gt; One mythos, two mythoi</span>
<span class="s2"># =&gt; One phenomenon, two phenomena</span>
<span class="s2"># =&gt; One formula, two formulae</span>

<span class="s2"># @@PLEAC@@_2.19</span>


<span class="s2"># See &lt;URL: http://www.mini.net/tcl/AdditionalMath&gt;:</span>
<span class="s2"># the primefactors function by Richard Suchenwirth.</span>



<span class="s2">primefactors 2178</span>
<span class="s2"># =&gt; 2 3 3 11 11</span>

<span class="s2">primefactors 2099999990</span>
<span class="s2"># =&gt; 2 5 11 19090909</span>

<span class="s2"># @@PLEAC@@_3.0</span>


<span class="s2"># A single command, [clock], is used for a wide range</span>
<span class="s2"># of date/time-related tasks.  Subcommands include</span>
<span class="s2"># seconds, which returns a seconds-since-epoch value,</span>
<span class="s2"># and format, which formats a date/time-string like</span>
<span class="s2"># the result of POSIX strftime.</span>



<span class="s2"># get current time in epoch seconds</span>
<span class="s2">set now [clock seconds]</span>
<span class="s2"># print default-formatted time</span>
<span class="s2">puts [clock format $now]</span>
<span class="s2"># print custom formatted time</span>
<span class="s2">set fmt &quot;Today is day %j of the current year.&quot;</span>
<span class="s2">puts [clock format $now -format $fmt]</span>

<span class="s2"># @@PLEAC@@_3.1</span>


<span class="s2">set now [clock seconds]</span>
<span class="s2">foreach {day month year} [clock format $now -format &quot;%d %m %Y&quot;] break</span>

<span class="s2">set now [clock seconds]</span>
<span class="s2">set fmt &quot;%Y-%m-%d&quot;</span>
<span class="s2">puts &quot;The current date is [clock format $now -format $fmt].&quot;</span>

<span class="s2"># @@PLEAC@@_3.2</span>


<span class="s2"># this is one of several possible variants of scannable</span>
<span class="s2"># date/time strings; clock scan is considerably more</span>
<span class="s2"># versatile than the Perl functions in this recipe.</span>
<span class="s2">set time [clock scan &quot;$hours:$min:$sec $year-$mon-$mday&quot;]</span>
<span class="s2"># =&gt; 999955820</span>


<span class="s2">set time [clock scan &quot;$hours:$min:$sec $year-$mon-$mday&quot; -gmt yes]</span>
<span class="s2"># =&gt; 999963020</span>

<span class="s2"># @@PLEAC@@_3.3</span>


<span class="s2">if {[string match *.test [info script]]} {</span>
<span class="s2">    # we are testing, supply a known value</span>
<span class="s2">    set now 1000000000</span>
<span class="s2">} else {</span>
<span class="s2">    set now [clock seconds]</span>
<span class="s2">}</span>
<span class="s2">set vars [list seconds minutes hours dayOfMonth month year wday yday]</span>
<span class="s2">set desc [list S       M       H     d          m     Y    w    j]</span>
<span class="s2">foreach v $vars d $desc {</span>
<span class="s2">    set $v [clock format $now -format %$d]</span>
<span class="s2">}</span>
<span class="s2">format %s-%s-%sT%s:%s:%s $year $month $dayOfMonth $hours $minutes $seconds</span>
<span class="s2"># =&gt; 2001-09-09T03:46:40</span>


<span class="s2">if {[string match *.test [info script]]} {</span>
<span class="s2">    # we are testing, supply a known value</span>
<span class="s2">    set now 1000000000</span>
<span class="s2">} else {</span>
<span class="s2">    set now [clock seconds]</span>
<span class="s2">}</span>
<span class="s2">set vars [list seconds minutes hours dayOfMonth month year wday yday]</span>
<span class="s2">set desc [list S       M       H     d          m     Y    w    j]</span>
<span class="s2">foreach v $vars d $desc {</span>
<span class="s2">    set $v [clock format $now -format %$d -gmt yes]</span>
<span class="s2">}</span>
<span class="s2">format %s-%s-%sT%s:%s:%s $year $month $dayOfMonth $hours $minutes $seconds</span>
<span class="s2"># =&gt; 2001-09-09T01:46:40</span>

<span class="s2"># @@PLEAC@@_3.4</span>


<span class="s2">#     set when [expr {$now + $difference}]</span>
<span class="s2">#     set when [expr {$now - $difference}]</span>

<span class="s2"># The following is slightly more idiomatic:</span>

<span class="s2">#     set when [clock scan &quot;$difference seconds&quot;]</span>
<span class="s2">#     set when [clock scan &quot;$difference seconds ago&quot;]</span>
<span class="s2">#     set when [clock scan &quot;-$difference seconds&quot;] ;# same as previous</span>



<span class="s2">set newTime [clock scan &quot;$y-$m-$d $offset days&quot;]</span>
<span class="s2">foreach {y2 m2 d2} [clock format $newTime -format &quot;%Y %m %d&quot;] break</span>
<span class="s2">return [list $y2 $m2 $d2]</span>


<span class="s2">set oldTime [clock scan $time]</span>
<span class="s2">set newTime [clock scan &quot;</span>
<span class="s2">    $daysOffset days</span>
<span class="s2">    $hourOffset hours</span>
<span class="s2">    $minuteOffset minutes</span>
<span class="s2">    $secondOffset seconds</span>
<span class="s2">&quot; -base $oldTime]</span>

<span class="s2"># @@PLEAC@@_3.5</span>


<span class="s2">set bree [clock scan &quot;16 Jun 1981 4:35:25&quot;]</span>
<span class="s2">set nat  [clock scan &quot;18 Jan 1973 3:45:50&quot;]</span>
<span class="s2">set difference [expr {$bree - $nat}]</span>
<span class="s2">format &quot;There were $difference seconds between Nat and Bree&quot;</span>
<span class="s2"># =&gt; There were 265333775 seconds between Nat and Bree</span>


<span class="s2">set bree [clock scan &quot;16 Jun 1981 4:35:25&quot;]</span>
<span class="s2">set nat  [clock scan &quot;18 Jan 1973 3:45:50&quot;]</span>
<span class="s2">set difference [expr {$bree - $nat}]</span>
<span class="s2">set vars    {seconds minutes hours days}</span>
<span class="s2">set factors {60      60      24    7}</span>
<span class="s2">foreach v $vars f $factors {</span>
<span class="s2">    set $v [expr {$difference % $f}]</span>
<span class="s2">    set difference [expr {($difference-[set $v]) / $f}]</span>
<span class="s2">}</span>
<span class="s2">set weeks $difference</span>
<span class="s2">format &quot;($weeks weeks, $days days, $hours:$minutes:$seconds)&quot;</span>
<span class="s2"># =&gt; (438 weeks, 4 days, 23:49:35)</span>

<span class="s2"># @@PLEAC@@_3.6</span>


<span class="s2">set then [clock scan 6/16/1981]</span>
<span class="s2">set format {</span>
<span class="s2">%Y-%m-%d was a %A</span>
<span class="s2">in week number %W,</span>
<span class="s2">and day %j of the year.</span>
<span class="s2">}</span>
<span class="s2">clock format $then -format $format</span>
<span class="s2"># =&gt; </span>
<span class="s2"># =&gt;         1981-06-16 was a Tuesday</span>
<span class="s2"># =&gt;         in week number 24,</span>
<span class="s2"># =&gt;         and day 167 of the year.</span>
<span class="s2"># =&gt;         </span>

<span class="s2"># @@PLEAC@@_3.7</span>


<span class="s2"># The [clock scan] command parses a wide variety of date/time</span>
<span class="s2"># strings, converting them to epoch seconds.</span>

<span class="s2"># Examples:</span>

<span class="s2">#     set t [clock scan &quot;1998-06-03&quot;]</span>
<span class="s2">#     set t [clock scan &quot;2 weeks ago Friday&quot;]</span>
<span class="s2">#     set t [clock scan &quot;today&quot;]</span>

<span class="s2">#     # second Sunday of 1996:</span>
<span class="s2">#     set t [clock scan &quot;Sunday&quot; -base [clock scan &quot;1996-01-01 1 week&quot;]]</span>

<span class="s2"># The result can be converted to lists of year, month, etc</span>
<span class="s2"># values or to other date/time strings by the [clock format]</span>
<span class="s2"># command.</span>


<span class="s2"># @@PLEAC@@_3.8</span>


<span class="s2">puts [clock format [clock scan 01/18/73] -gmt yes]</span>
<span class="s2"># =&gt; Wed Jan 17 23:00:00 GMT 1973</span>

<span class="s2">puts [clock format [clock scan 01/18/73] -format &quot;%A %D&quot;]</span>
<span class="s2"># =&gt; Thursday 01/18/73</span>

<span class="s2">set format &quot;%a %b %e %H:%M:%S %Z %Y&quot;</span>
<span class="s2">puts [clock format [clock scan &quot;18 Jan 1973 3:45:50 GMT&quot;] -format $format -gmt yes]</span>
<span class="s2"># =&gt; Thu Jan 18 03:45:50 GMT 1973</span>

<span class="s2"># @@PLEAC@@_3.9</span>


<span class="s2">puts &quot;Press return when ready&quot;</span>
<span class="s2">set before [clock clicks -milliseconds]</span>
<span class="s2">gets stdin</span>
<span class="s2">set elapsed [expr {([clock clicks -milliseconds] - $before) / 1000.0}]</span>
<span class="s2">puts &quot;You took $elapsed seconds&quot;</span>

<span class="s2">set size 500</span>
<span class="s2">set numberOfTimes 100</span>
<span class="s2">set a [list]</span>
<span class="s2">for {set j 0} {$j &lt; $size} {incr j} {</span>
<span class="s2">    lappend a [expr {rand()}]</span>
<span class="s2">}</span>
<span class="s2">puts &quot;Sorting $size random numbers:&quot;</span>
<span class="s2">puts [time {</span>
<span class="s2">    set a [lsort -real $a]</span>
<span class="s2">} $numberOfTimes]</span>

<span class="s2"># @@PLEAC@@_3.10</span>


<span class="s2"># wait 25 milliseconds</span>
<span class="s2">after 25</span>

<span class="s2"># @@PLEAC@@_3.11</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_4.0</span>


<span class="s2">set presidents [list Reagan Bush Clinton]</span>
<span class="s2"># =&gt; Reagan Bush Clinton</span>


<span class="s2">set nested [list this that [list the other]]</span>
<span class="s2">llength $nested</span>
<span class="s2"># =&gt; 3</span>


<span class="s2">set tune [list The Star-spangled Banner]</span>
<span class="s2">list #0 = [lindex $tune 0] #1 = [lindex $tune 1]</span>
<span class="s2"># =&gt; #0 = The #1 = Star-spangled</span>

<span class="s2"># @@PLEAC@@_4.1</span>


<span class="s2">set a [list quick brown fox]</span>
<span class="s2"># =&gt; quick brown fox</span>

<span class="s2">set a &quot;Why are you teasing me?&quot;</span>
<span class="s2"># =&gt; Why are you teasing me?</span>

<span class="s2">set lines [list]</span>
<span class="s2">foreach {l} [split {</span>
<span class="s2">    The boy stood on the burning deck,</span>
<span class="s2">    It was as hot as glass.</span>
<span class="s2">} \n ] {</span>
<span class="s2">    set line [string trimleft $l]</span>
<span class="s2">    if {[string length $line]} {</span>
<span class="s2">        lappend lines $line</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">puts $lines</span>
<span class="s2"># =&gt; {The boy stood on the burning deck,} {It was as hot as glass.}</span>

<span class="s2">set f [open $mydatafile]          ;# Automatically raises error on failure</span>
<span class="s2">set biglist [split [read $f] \n]</span>

<span class="s2">lappend banner1 Costs only \$4.95</span>
<span class="s2">set banner2 [list Costs only \$4.95]</span>
<span class="s2">set banner3 [split {Costs only $4.95}]</span>
<span class="s2">expr {&quot;$banner1&quot; == &quot;$banner2&quot; &amp;&amp; &quot;$banner2&quot; == &quot;$banner3&quot;}</span>
<span class="s2"># =&gt; 1</span>

<span class="s2">set ships [list Niсa Pinta Santa Marнa]   ;# WRONG (4 ships)</span>
<span class="s2">llength $ships</span>
<span class="s2"># =&gt; 4</span>

<span class="s2">set ships [list Niсa Pinta {Santa Marнa}] ;# right (3 ships)</span>
<span class="s2">llength $ships</span>
<span class="s2"># =&gt; 3</span>

<span class="s2"># @@PLEAC@@_4.2</span>


<span class="s2">set list [list red yellow green]</span>
<span class="s2">puts [list I have $list marbles.]</span>
<span class="s2"># =&gt; I have {red yellow green} marbles.</span>

<span class="s2">set list [list red yellow green]</span>
<span class="s2">puts &quot;I have $list marbles.&quot;</span>
<span class="s2"># =&gt; I have red yellow green marbles.</span>


<span class="s2">set lists {</span>
<span class="s2">    {{just one thing}}</span>
<span class="s2">    {Mutt Jeff}</span>
<span class="s2">    {Peter Paul Mary}</span>
<span class="s2">    {{to our parents} {Mother Theresa} God}</span>
<span class="s2">    {{pastrami} {ham and cheese} {peanut butter and jelly} {tuna}}</span>
<span class="s2">    {{recycle tired, old phrases} {ponder big, happy thoughts}}</span>
<span class="s2">    {{recycle tired, old phrases}  {ponder big, happy thoughts}  {sleep and dream peacefully}  }</span>
<span class="s2">}</span>
<span class="s2">proc commifySeries {args} {</span>
<span class="s2">    if {[regexp , $args]} {</span>
<span class="s2">        set sepchar &quot;;&quot;</span>
<span class="s2">    } else {</span>
<span class="s2">        set sepchar ,</span>
<span class="s2">    }</span>
<span class="s2">    # Tcl has a switch command, nyah nyah nyah</span>
<span class="s2">    switch [llength $args] {</span>
<span class="s2">        0 { return {} }</span>
<span class="s2">        1 { eval return $args }</span>
<span class="s2">        2 { return [join $args { and }] }</span>
<span class="s2">        default {</span>
<span class="s2">            set args [lreplace $args end end [concat and [lindex $args end]]]</span>
<span class="s2">            return [join $args &quot;$sepchar &quot;]</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># =&gt; just one thing</span>

<span class="s2"># =&gt; Mutt and Jeff</span>

<span class="s2"># =&gt; Peter, Paul, and Mary</span>

<span class="s2"># =&gt; to our parents, Mother Theresa, and God</span>

<span class="s2"># =&gt; pastrami, ham and cheese, peanut butter and jelly, and tuna</span>

<span class="s2"># =&gt; recycle tired, old phrases and ponder big, happy thoughts</span>

<span class="s2"># =&gt; recycle tired, old phrases; ponder big, happy thoughts; and sleep and dream peacefully</span>

<span class="s2"># @@PLEAC@@_4.3</span>


<span class="s2"># There is no equivalent to $#ARRAY in Tcl.</span>



<span class="s2">proc whatAboutThatList args {</span>
<span class="s2">    variable people</span>
<span class="s2">    append res &quot;The list now has [set len [llength $people]] elements.\n&quot;</span>
<span class="s2">    append res &quot;The index of the last element is [incr len -1].\n&quot;</span>
<span class="s2">    append res &quot;Element #3 is `[lindex $people 3]&#39;.&quot;</span>
<span class="s2">}</span>

<span class="s2">set people [list Crosby Stills Nash Young]</span>
<span class="s2">whatAboutThatList</span>
<span class="s2"># =&gt; The list now has 4 elements.</span>
<span class="s2"># =&gt; The index of the last element is 3.</span>
<span class="s2"># =&gt; Element #3 is `Young&#39;.</span>

<span class="s2">set people [lrange $people 0 end-1]</span>
<span class="s2">whatAboutThatList</span>
<span class="s2"># =&gt; The list now has 3 elements.</span>
<span class="s2"># =&gt; The index of the last element is 2.</span>
<span class="s2"># =&gt; Element #3 is `&#39;.</span>

<span class="s2"># append 10001-(length of list) null elements to the list:</span>
<span class="s2">for {set i [llength $people]} {$i &lt;= 10000} {incr i} {</span>
<span class="s2">    lappend people {}</span>
<span class="s2">}</span>
<span class="s2">whatAboutThatList</span>
<span class="s2"># =&gt; The list now has 10001 elements.</span>
<span class="s2"># =&gt; The index of the last element is 10000.</span>
<span class="s2"># =&gt; Element #3 is `&#39;.</span>

<span class="s2"># @@PLEAC@@_4.4</span>


<span class="s2">foreach user $badUsers {</span>
<span class="s2">    complain $user</span>
<span class="s2">}</span>

<span class="s2">foreach key [lsort [array names env]] {</span>
<span class="s2">    puts $key=$env($key)</span>
<span class="s2">}</span>

<span class="s2">foreach {user} $allUsers {</span>
<span class="s2">    set diskSpace [getUsage $user]</span>
<span class="s2">    if {$diskSpace &gt; $MAXQUOTA} {</span>
<span class="s2">        complain $user</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># Tcl has no implicit variables like Perl&#39;s $_.</span>
<span class="s2">foreach _ [exec who] {</span>
<span class="s2">    if [regexp tchrist $_] {</span>
<span class="s2">        puts $_</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># Tcl does not sneak in references unexpectedly.</span>
<span class="s2"># If you need to mutate a list, this is the preferred</span>
<span class="s2"># idiom:</span>

<span class="s2">#     set mylist [mutate $mylist args]</span>

<span class="s2"># You *can* &#39;simulate&#39; manipulation by reference by</span>
<span class="s2"># using call-by-name and connecting a local variable</span>
<span class="s2"># to a variable with that name in the outer scope:</span>



<span class="s2">proc timesSeven {listname} {</span>
<span class="s2">    upvar $listname listref</span>
<span class="s2">    for {set i 0} {$i &lt; [llength $listref]} {incr i} {</span>
<span class="s2">        set listref [lreplace $listref $i $i [expr {[lindex $listref $i] * 7}]]</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_4.5</span>


<span class="s2">variable res {}</span>
<span class="s2">set fruits [list Apple Blackberry]</span>
<span class="s2">set fruitRef fruits</span>
<span class="s2"># the variable fruitRef is now set to the name of the fruit list,</span>
<span class="s2"># which makes it a kind of reference variable</span>
<span class="s2">foreach fruit [set $fruitRef] {</span>
<span class="s2">    append res &quot;$fruit tastes good in a pie.\n&quot;</span>
<span class="s2">}</span>
<span class="s2">puts $res</span>
<span class="s2"># =&gt; Apple tastes good in a pie.</span>
<span class="s2"># =&gt; Blackberry tastes good in a pie.</span>

<span class="s2"># @@PLEAC@@_4.6</span>


<span class="s2">lsort -unique [list how much wood would a wood chuck chuck]</span>
<span class="s2"># =&gt; a chuck how much wood would</span>


<span class="s2"># This is an order of magnitude slower than the previous solution.</span>
<span class="s2">foreach e $list {</span>
<span class="s2">    array set unique [list $e {}]</span>
<span class="s2">}</span>
<span class="s2">array names unique</span>
<span class="s2"># =&gt; a wood much chuck how would</span>

<span class="s2"># @@PLEAC@@_4.7</span>


<span class="s2"># Use the TclX standard package (contained in</span>
<span class="s2"># the ActiveTcl distribution).</span>
<span class="s2">package require Tclx</span>
<span class="s2">set listA [list 1 1 2 2 3 3 3 4 5]</span>
<span class="s2">set listB [list 1 2 4]</span>
<span class="s2">set res [intersect3 $listA $listB]</span>
<span class="s2"># [intersect3] yields three result lists;</span>
<span class="s2"># we want the first one:</span>
<span class="s2">lindex $res 0</span>
<span class="s2"># =&gt; 3 5</span>

<span class="s2"># @@PLEAC@@_4.8</span>

<span class="s2"># Use the TclX standard package (contained in</span>
<span class="s2"># the ActiveTcl distribution).</span>
<span class="s2">package require Tclx</span>
<span class="s2">set listA [list 1 1 2 2 3 3 3 4 5]</span>
<span class="s2">set listB [list 1 2 4 4 6 7]</span>
<span class="s2">foreach {difference intersection -} [intersect3 $listA $listB] break</span>
<span class="s2">set union [union $listA $listB]</span>
<span class="s2">list $difference $intersection $union</span>
<span class="s2"># =&gt; {3 5} {1 2 4} {1 2 3 4 5 6 7}</span>

<span class="s2"># @@PLEAC@@_4.9</span>


<span class="s2">set members [list Time Flies]</span>
<span class="s2">lappend members An Arrow</span>
<span class="s2"># =&gt; Time Flies An Arrow</span>


<span class="s2">set members [list Time Flies]</span>
<span class="s2">set initiates [list An Arrow]</span>
<span class="s2">set members [concat $members $initiates]</span>
<span class="s2"># =&gt; Time Flies An Arrow</span>


<span class="s2">set members [list Time Flies An Arrow]</span>
<span class="s2">set members [linsert $members 2 Like]</span>
<span class="s2"># =&gt; Time Flies Like An Arrow</span>


<span class="s2">set members [list Time Flies Like An Arrow]</span>
<span class="s2">set members [lreplace $members 0 0 Fruit]</span>
<span class="s2">set members [lreplace $members end-1 end A Banana]</span>
<span class="s2"># =&gt; Fruit Flies Like A Banana</span>

<span class="s2"># @@PLEAC@@_4.10</span>


<span class="s2">set list [list 0 1 2 3 4 5 6 7 8 9]</span>
<span class="s2">set rlist [list]</span>
<span class="s2">for {set i [expr {[llength $list]-1}]} {$i &gt;= 0} {incr i -1} {</span>
<span class="s2">    lappend rlist [lindex $list $i]</span>
<span class="s2">}</span>
<span class="s2">puts $rlist</span>
<span class="s2"># =&gt; 9 8 7 6 5 4 3 2 1 0</span>


<span class="s2">set list [list 0 1 2 3 4 5 6 7 8 9]</span>
<span class="s2">lsort -decreasing $list</span>
<span class="s2"># =&gt; 9 8 7 6 5 4 3 2 1 0</span>

<span class="s2"># @@PLEAC@@_4.11</span>


<span class="s2">proc splice-ish {listname number} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    set length [llength $list]</span>
<span class="s2">    if {$number &lt; 0} {</span>
<span class="s2">        set number [expr {abs($number)}]</span>
<span class="s2">        set res [lrange $list end-[expr {$number-1}] end]</span>
<span class="s2">        set list [lrange $list 0 end-$number]</span>
<span class="s2">    } else {</span>
<span class="s2">        set res [lrange $list 0 [expr {$number-1}]]</span>
<span class="s2">        set list [lrange $list $number end]</span>
<span class="s2">    }</span>
<span class="s2">    return $res</span>
<span class="s2">}</span>


<span class="s2">proc shift2 {listname} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    return [splice-ish list 2]</span>
<span class="s2">}</span>

<span class="s2">set friends [list Peter Paul Mary Jim Tim]</span>
<span class="s2">foreach {this that} [shift2 friends] break</span>
<span class="s2">list $this $that $friends</span>
<span class="s2"># =&gt; Peter Paul {Mary Jim Tim}</span>


<span class="s2">proc pop2 {listname} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    return [splice-ish list -2]</span>
<span class="s2">}</span>

<span class="s2">set beverages [list Dew Jolt Cola Sprite Fresca]</span>
<span class="s2">set pair [pop2 beverages]</span>
<span class="s2">list $beverages $pair</span>
<span class="s2"># =&gt; {Dew Jolt Cola} {Sprite Fresca}</span>

<span class="s2"># @@PLEAC@@_4.12</span>


<span class="s2">set matchIdx [lsearch $list $criterion]</span>
<span class="s2">if {$matchIdx &gt;= 0} {</span>
<span class="s2">    set match [lindex $list $matchIdx]</span>
<span class="s2">    ## do something with $match</span>
<span class="s2">} else {</span>
<span class="s2">    ## unfound</span>
<span class="s2">}</span>


<span class="s2">set matchIdx [lsearch $list $criterion]</span>
<span class="s2">if {$matchIdx &gt;= 0} {</span>
<span class="s2">    ## found in [lindex $list $matchIdx]</span>
<span class="s2">} else {</span>
<span class="s2">    ## unfound</span>
<span class="s2">}</span>


<span class="s2">Employee is an [incr Tcl] class with the members category,</span>
<span class="s2">name, salary, ssn, and age.</span>


<span class="s2">lappend employees [Employee #auto {manager John 120000 {}}]</span>
<span class="s2">lappend employees [Employee #auto {engineer Susie 100000 {}}]</span>
<span class="s2">lappend employees [Employee #auto {programmer Harold 90000 {}}]</span>
<span class="s2">foreach employee $employees {</span>
<span class="s2">    if {[$employee category] eq &quot;engineer&quot;} {</span>
<span class="s2">        set highestEngineer $employee</span>
<span class="s2">        break</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">$highestEngineer name</span>
<span class="s2"># =&gt; Susie</span>

<span class="s2"># @@PLEAC@@_4.13</span>


<span class="s2"># If the test is matching an element&#39;s value against</span>
<span class="s2"># an exact string, a wildcard pattern, or a regular</span>
<span class="s2"># expression, use the standard package TclX (contained</span>
<span class="s2"># in the ActiveTcl distribution).</span>



<span class="s2">package require Tclx</span>
<span class="s2">set matching [lmatch [list ab ac bc dk ab] a*]</span>
<span class="s2"># =&gt; ab ac ab</span>


<span class="s2"># If another type of test is necessary, or TclX is</span>
<span class="s2"># unavailable, a foreach loop is useful:</span>



<span class="s2"># TEST could have been a regular proc, of course</span>
<span class="s2">interp alias {} TEST {} string match a*</span>
<span class="s2">set matching [list]</span>
<span class="s2">foreach e [list ab ac bc dk ab] {</span>
<span class="s2">    if {[TEST $e]} {</span>
<span class="s2">        lappend matching $e</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">set matching</span>
<span class="s2"># =&gt; ab ac ab</span>

<span class="s2"># @@PLEAC@@_4.14</span>


<span class="s2">set numsorted [lsort -real [list 38 388.7 1.56 279 1e7]]</span>
<span class="s2"># =&gt; 1.56 38 279 388.7 1e7</span>


<span class="s2">set descending [lsort -decreasing -real [list 38 388.7 1.56 279 1e7]]</span>
<span class="s2"># =&gt; 1e7 388.7 279 38 1.56</span>

<span class="s2"># @@PLEAC@@_4.15</span>


<span class="s2"># Generic code for using a custom comparison in a list sort:</span>

<span class="s2">#     set ordered [lsort -command compare $unordered]</span>

<span class="s2"># Tcl doesn&#39;t have a standard map command as used by the following</span>
<span class="s2"># examples.</span>

<span class="s2"># Pool (&lt;URL: http://www.purl.org/NET/akupries/soft/pool/index.htm&gt;)</span>
<span class="s2"># includes a command, ::pool::list::apply, which is similar to Perl&#39;s</span>
<span class="s2"># map.</span>



<span class="s2">package require Pool_Base</span>
<span class="s2">namespace import ::pool::list::apply</span>
<span class="s2">set unordered [list 1+7 5-2 3+4]</span>
<span class="s2">proc compute e {list [expr $e] $e}</span>
<span class="s2">proc second args {lindex $args 1}</span>
<span class="s2">set precomputed [apply compute $unordered]</span>
<span class="s2">set orderedPrecomputed [lsort -integer -index 0 $precomputed]</span>
<span class="s2">set ordered [apply second $orderedPrecomputed]</span>
<span class="s2"># =&gt; 5-2 3+4 1+7</span>


<span class="s2">Employee is an [incr Tcl] class with the members category,</span>
<span class="s2">name, salary, ssn, and age.</span>



<span class="s2">apply names $employees</span>
<span class="s2"># =&gt; Betsy Ewan Fran Andy Carl Diane</span>
<span class="s2">set ordered [lsort -command Employee::compare-name $employees]</span>
<span class="s2">apply names $ordered</span>
<span class="s2"># =&gt; Andy Betsy Carl Diane Ewan Fran</span>

<span class="s2">foreach employee [lsort -command Employee::compare-name $employees] {</span>
<span class="s2">    puts &quot;[$employee name] earns \$[$employee salary]&quot;</span>
<span class="s2">}</span>
<span class="s2"># =&gt; Andy earns $110000</span>
<span class="s2"># =&gt; Betsy earns $120000</span>
<span class="s2"># =&gt; Carl earns $90000</span>
<span class="s2"># =&gt; Diane earns $80000</span>
<span class="s2"># =&gt; Ewan earns $115000</span>
<span class="s2"># =&gt; Fran earns $110000</span>

<span class="s2">set sortedEmployees [lsort -command Employee::compare-name $employees]</span>
<span class="s2">foreach employee $sortedEmployees {</span>
<span class="s2">    puts &quot;[$employee name] earns \$[$employee salary]&quot;</span>
<span class="s2">}</span>
<span class="s2"># load bonus array</span>
<span class="s2">foreach employee $sortedEmployees {</span>
<span class="s2">    if {[info exists bonus([$employee ssn])]} {</span>
<span class="s2">        puts &quot;[$employee name] got a bonus!&quot;</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2"># =&gt; Andy earns $110000</span>
<span class="s2"># =&gt; Betsy earns $120000</span>
<span class="s2"># =&gt; Carl earns $90000</span>
<span class="s2"># =&gt; Diane earns $80000</span>
<span class="s2"># =&gt; Ewan earns $115000</span>
<span class="s2"># =&gt; Fran earns $110000</span>
<span class="s2"># =&gt; Ewan got a bonus!</span>
<span class="s2"># =&gt; Fran got a bonus!</span>


<span class="s2"># The class procedure Employee::compare-name-or-age looks</span>
<span class="s2"># like this:</span>

<span class="s2">#     proc compare-name-or-age {a b} {</span>
<span class="s2">#         set cmp [string compare [[namespace parent]::$a name] [[namespace parent]::$b name]]</span>
<span class="s2">#         if {$cmp != 0} {</span>
<span class="s2">#             return $cmp</span>
<span class="s2">#         } else {</span>
<span class="s2">#             return [expr {[[namespace parent]::$a age]-[[namespace parent]::$b age]}]</span>
<span class="s2">#         }</span>
<span class="s2">#     }</span>



<span class="s2">lappend employees [Employee #auto {{} Andy  95000 28}] ;# add another Andy</span>
<span class="s2">set sorted [lsort -command Employee::compare-name-or-age $employees]</span>
<span class="s2">apply names-and-ages $sorted</span>
<span class="s2"># =&gt; {Andy 28} {Andy 30} {Betsy 43} {Carl 30} {Diane 27} {Ewan 37} {Fran 35}</span>

<span class="s2"># @@PLEAC@@_4.16</span>


<span class="s2">set circular [concat [lrange $list 1 end] [lindex $list 0]]</span>
<span class="s2">set circular [concat [lindex $list end] [lrange $list 0 end-1]]</span>


<span class="s2">proc grabAndRotate {listname} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    set first [lindex $list 0]</span>
<span class="s2">    set list [concat [lrange $list 1 end] $first]</span>
<span class="s2">    return $first</span>
<span class="s2">}</span>
<span class="s2">while 1 {</span>
<span class="s2">    set process [grabAndRotate processes]</span>
<span class="s2">    puts &quot;Handling process $process&quot;</span>
<span class="s2">    after 1000</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_4.17</span>


<span class="s2">proc FisherYatesShuffle {listname} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    for {set i [expr {[llength $list]-1}]} {$i &gt;= 0} {incr i -1} {</span>
<span class="s2">        set j [expr {int(rand()*$i+1)}]</span>
<span class="s2">        if {$i != $j} {</span>
<span class="s2">            set temp [lindex $list $i]</span>
<span class="s2">            set list [lreplace $list $i $i [lindex $list $j]]</span>
<span class="s2">            set list [lreplace $list $j $j $temp]</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2">#   Several shuffle algorithms in Tcl are compared for performance</span>
<span class="s2">#   here: &lt;URL: http://mini.net/cgi-bin/nph-wikit/941.html&gt;.</span>
<span class="s2">#   This is a very efficient algorithm for small lists:</span>


<span class="s2">proc K {x y} {return $x}</span>
<span class="s2"> </span>
<span class="s2">proc shuffle5a { list } {</span>
<span class="s2">    set n 1</span>
<span class="s2">    set slist {}</span>
<span class="s2">    foreach item $list {</span>
<span class="s2">        set index [expr {int(rand()*$n)}]</span>
<span class="s2">        set slist [linsert [K $slist [set slist {}]] $index $item]</span>
<span class="s2">        incr n</span>
<span class="s2">    }</span>
<span class="s2">    return $slist</span>
<span class="s2">} ;# Christoph Bauer</span>

<span class="s2"># @@PLEAC@@_4.18</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_4.19</span>


<span class="s2">package require math 1.2</span>
<span class="s2"> </span>
<span class="s2"># n2pat N len : produce the $N-th pattern of length $len</span>
<span class="s2">proc n2pat {N len} {</span>
<span class="s2">    set i 1</span>
<span class="s2">    set pat [list]</span>
<span class="s2">    while {$i &lt;= $len + 1} {</span>
<span class="s2">        lappend pat [expr {$N % $i}]</span>
<span class="s2">        set N [expr {int($N/$i)}]</span>
<span class="s2">        incr i</span>
<span class="s2">    }</span>
<span class="s2">    return $pat</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2"># pat2perm pat : turn pattern returned by n2pat into</span>
<span class="s2"># permutation of integers.</span>
<span class="s2">proc pat2perm {args} {</span>
<span class="s2">    if {[llength $args] == 1} {</span>
<span class="s2">        set pat [lindex $args 0]</span>
<span class="s2">    } else {</span>
<span class="s2">        set pat $args</span>
<span class="s2">    }</span>
<span class="s2">    set source [list]</span>
<span class="s2">    for {set i 0} {$i &lt; [llength $pat]} {incr i} {</span>
<span class="s2">        lappend source $i</span>
<span class="s2">    }</span>
<span class="s2">    set perm [list]</span>
<span class="s2">    while {[llength $pat]} {</span>
<span class="s2">        set i [lindex $pat end]</span>
<span class="s2">        set pat [lrange $pat 0 end-1]</span>
<span class="s2">        lappend perm [lindex $source $i]</span>
<span class="s2">        set source [lreplace $source $i $i]</span>
<span class="s2">    }</span>
<span class="s2">    return $perm;</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2"># n2perm N len : generate the $Nth permutation of $len objects</span>
<span class="s2">proc n2perm {N len} {</span>
<span class="s2">    return [pat2perm [n2pat $N $len]]</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">proc main {} {</span>
<span class="s2">    while {[gets stdin _] &gt;= 0} {</span>
<span class="s2">        set data [split $_]</span>
<span class="s2">        set len [llength $data]</span>
<span class="s2">        set numPermutations [::math::factorial $len]</span>
<span class="s2">        for {set i 0} {$i &lt; $numPermutations} {incr i} {</span>
<span class="s2">            set permutation [list]</span>
<span class="s2">            foreach {p} [n2perm $i [expr {$len - 1}]] {</span>
<span class="s2">                lappend permutation [lindex $data $p]</span>
<span class="s2">            }</span>
<span class="s2">            puts $permutation</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">main</span>

<span class="s2"># @@PLEAC@@_5.0</span>


<span class="s2">array set age {</span>
<span class="s2">    Nat   24</span>
<span class="s2">    Jules 25</span>
<span class="s2">    Josh  17</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">set age(Nat)   24</span>
<span class="s2">set age(Jules) 25</span>
<span class="s2">set age(Josh)  17</span>

<span class="s2"> </span>
<span class="s2">array set foodColor {</span>
<span class="s2">    Apple   red</span>
<span class="s2">    Banana  yellow</span>
<span class="s2">    Lemon   yellow</span>
<span class="s2">    Carrot  orange</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_5.1</span>


<span class="s2">set array(foo) bar</span>
<span class="s2"> </span>
<span class="s2"># or</span>
<span class="s2"> </span>
<span class="s2">set key foo</span>
<span class="s2">set value bar</span>
<span class="s2">set array($key) $value</span>
<span class="s2"> </span>
<span class="s2"># or</span>
<span class="s2"> </span>
<span class="s2">array set array [list $key $value]</span>

<span class="s2"> </span>
<span class="s2"># foodColor defined per the introduction</span>
<span class="s2">set foodColor(Raspberry) pink</span>
<span class="s2">puts &quot;Known foods:&quot;</span>
<span class="s2">foreach food {[array names foodColor]} {</span>
<span class="s2">    puts $food</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_5.2</span>


<span class="s2">if {[info exists array($key)]} {</span>
<span class="s2">    # it exists</span>
<span class="s2">} else {</span>
<span class="s2">    # it doesn&#39;t</span>
<span class="s2">}</span>

<span class="s2"> </span>
<span class="s2"># foodColor per the introduction</span>
<span class="s2">foreach name {Banana Martini} {</span>
<span class="s2">    if {[info exists foodColor($name)]} {</span>
<span class="s2">        puts &quot;$name is a food.&quot;</span>
<span class="s2">    } else {</span>
<span class="s2">        puts &quot;$name is a drink.&quot;;</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"> </span>
<span class="s2">array unset age</span>
<span class="s2">set age(Toddler)  3</span>
<span class="s2">set age(Unborn)   0</span>
<span class="s2">set age(Phantasm) false</span>

<span class="s2">foreach thing {Toddler Unborn Phantasm Relic} {</span>
<span class="s2">	set result &quot;$thing:&quot;</span>
<span class="s2">	if {[info exists age($thing)]} {</span>
<span class="s2">		append result &quot; Exists&quot;  </span>
<span class="s2">		if {$age($thing)} {</span>
<span class="s2">			append result &quot; True&quot;</span>
<span class="s2">		} </span>
<span class="s2">		if {$age($thing) != 0} {</span>
<span class="s2">			append result &quot; Non-zero&quot;</span>
<span class="s2">		}</span>
<span class="s2">	}</span>
<span class="s2">	puts $result</span>
<span class="s2">} ;# improved by Bob Techentin</span>


<span class="s2"># @@PLEAC@@_5.3</span>


<span class="s2"># remove $KEY and its value from ARRAY</span>
<span class="s2">array unset ARRAY $KEY</span>

<span class="s2"># foodColor as per Introduction</span>
<span class="s2">proc print-foods {} {</span>
<span class="s2">    variable foodColor</span>
<span class="s2">    set foods [array names foodColor]</span>
<span class="s2">    set food {}</span>
<span class="s2">     </span>
<span class="s2">    puts &quot;Keys: $foods&quot;</span>
<span class="s2">    puts -nonewline &quot;Values: &quot;</span>
<span class="s2">     </span>
<span class="s2">    foreach food $foods {</span>
<span class="s2">        set color $foodColor($food)</span>
<span class="s2">         </span>
<span class="s2">        if {$color ne {}} {</span>
<span class="s2">            puts -nonewline &quot;$color &quot;</span>
<span class="s2">        } else {</span>
<span class="s2">            puts -nonewline {(empty) }</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">    puts {}</span>
<span class="s2">}</span>
<span class="s2">puts &quot;Initially:&quot;</span>
<span class="s2">print-foods</span>
<span class="s2">puts &quot;\nWith Banana empty&quot;</span>
<span class="s2">set foodColor(Banana) {}</span>
<span class="s2">print-foods</span>
<span class="s2">puts &quot;\nWith Banana deleted&quot;</span>
<span class="s2">array unset foodColor Banana</span>
<span class="s2">print-foods</span>
<span class="s2"># =&gt; Initially:</span>
<span class="s2"># =&gt; Keys: Banana Apple Carrot Lemon</span>
<span class="s2"># =&gt; Values: yellow red orange yellow </span>
<span class="s2"># =&gt; </span>
<span class="s2"># =&gt; With Banana empty</span>
<span class="s2"># =&gt; Keys: Banana Apple Carrot Lemon</span>
<span class="s2"># =&gt; Values: (empty) red orange yellow </span>
<span class="s2"># =&gt; </span>
<span class="s2"># =&gt; With Banana deleted</span>
<span class="s2"># =&gt; Keys: Apple Carrot Lemon</span>
<span class="s2"># =&gt; Values: red orange yellow </span>

<span class="s2"># several members can be deleted in one</span>
<span class="s2"># go if their names match a glob pattern,</span>
<span class="s2"># otherwise the [array unset] command must</span>
<span class="s2"># be called once for each name.</span>
<span class="s2">array unset foodColor ?a*</span>
<span class="s2">print-foods</span>
<span class="s2"># =&gt; Keys: Apple Lemon</span>
<span class="s2"># =&gt; Values: red yellow </span>

<span class="s2"># @@PLEAC@@_5.4</span>


<span class="s2">foreach {key value} [array get ARRAY] {</span>
<span class="s2">    # do something with $key and $value</span>
<span class="s2">}</span>

<span class="s2"># another way</span>
<span class="s2">set searchId [array startsearch ARRAY]</span>
<span class="s2">while {[set key [array nextelement ARRAY $searchId]] ne {}} {</span>
<span class="s2">    set value $ARRAY($key)</span>
<span class="s2">    # do something with $key and $value</span>
<span class="s2">}</span>

<span class="s2">foreach {food color} [array get foodColor] {</span>
<span class="s2">    puts &quot;$food is $color.&quot;</span>
<span class="s2">}</span>
<span class="s2"># =&gt; Banana is yellow.</span>
<span class="s2"># =&gt; Apple is red.</span>
<span class="s2"># =&gt; Carrot is orange.</span>
<span class="s2"># =&gt; Lemon is yellow.</span>

<span class="s2">set searchId [array startsearch foodColor]</span>
<span class="s2">while {[set food [array nextelement foodColor $searchId]] ne {}} {</span>
<span class="s2">    set color $foodColor($food)</span>
<span class="s2">    puts &quot;$food is $color.&quot;</span>
<span class="s2">}</span>
<span class="s2"># =&gt; Banana is yellow.</span>
<span class="s2"># =&gt; Apple is red.</span>
<span class="s2"># =&gt; Carrot is orange.</span>
<span class="s2"># =&gt; Lemon is yellow.</span>


<span class="s2"># countfrom - count number of messages from each sender</span>
<span class="s2">if {[llength $argv] &gt; 0} {</span>
<span class="s2">    if {[catch {set f [open [lindex $argv 0]]} err]} {</span>
<span class="s2">        error $err</span>
<span class="s2">    }</span>
<span class="s2">} else {</span>
<span class="s2">    set f stdin</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">while {[gets $f line] &gt;= 0} {</span>
<span class="s2">    if {[regexp {^From: (.*)} $line --&gt; name]} {</span>
<span class="s2">        if {[info exists from($name)]} {</span>
<span class="s2">            incr from($name)</span>
<span class="s2">        } else {</span>
<span class="s2">            set from($name) 1</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">if {[array size from] == 0} {</span>
<span class="s2">    puts &quot;No senders found&quot;</span>
<span class="s2">    exit</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">foreach person [lsort [array names from]] {</span>
<span class="s2">    puts &quot;$person: $from($person)&quot;</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_5.5</span>


<span class="s2"># print each member of the array...</span>
<span class="s2">foreach {k v} [array get ARRAY] {</span>
<span class="s2">    puts &quot;$k =&gt; $v&quot;</span>
<span class="s2">}</span>

<span class="s2"># ...or print all of it at once...</span>
<span class="s2">puts [array get ARRAY]</span>

<span class="s2"># ...or copy it to a list variable and print that...</span>
<span class="s2">set temp [array get ARRAY]</span>
<span class="s2">puts $temp</span>

<span class="s2"># ...or use the inspection command [parray]</span>
<span class="s2">parray ARRAY</span>

<span class="s2"># print with sorted keys</span>
<span class="s2">foreach {k} [lsort [array names ARRAY]] {</span>
<span class="s2">    puts &quot;$k =&gt; $ARRAY($k)&quot;</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_5.6</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_5.7</span>


<span class="s2"># A list is a string in Tcl, so there is</span>
<span class="s2"># no problem storing multiple values as an</span>
<span class="s2"># array (&quot;hash&quot;) item.</span>



<span class="s2">array set ttys [list]</span>
<span class="s2"> </span>
<span class="s2">set WHO [open &quot;|who&quot;]</span>
<span class="s2">while {[gets $WHO line] &gt; -1} {</span>
<span class="s2">    foreach {user tty} [split $line] break</span>
<span class="s2">    lappend ttys($user) $tty</span>
<span class="s2">}</span>
<span class="s2">close $WHO</span>
<span class="s2"> </span>
<span class="s2">foreach user [lsort [array names ttys]] {</span>
<span class="s2">    puts &quot;$user: $ttys($user)&quot;</span>
<span class="s2">}</span>

<span class="s2"># dummy code; there is no getpwuid command</span>
<span class="s2">foreach user [lsort [array names ttys]] {</span>
<span class="s2">    puts &quot;$user: [llength $ttys($user)] ttys.&quot;</span>
<span class="s2">     </span>
<span class="s2">    foreach tty [lsort $ttys($user)] {</span>
<span class="s2">        if {![catch {file stat /dev/$tty stat}]} {</span>
<span class="s2">            set user [lindex [getpwuid $stat(uid)] 0]</span>
<span class="s2">        } else {</span>
<span class="s2">            set user &quot;(not available)&quot;</span>
<span class="s2">        }</span>
<span class="s2">        puts &quot;\t$tty (owned by $user)&quot; </span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">proc multihash_delete {arrayname key value} {</span>
<span class="s2">    upvar $arrayname array</span>
<span class="s2">    set i {}</span>
<span class="s2">     </span>
<span class="s2">    set len [llength $array($key)]</span>
<span class="s2">    for {set i 0} {$i &lt; $len} {incr i} {</span>
<span class="s2">        if {[lindex $array($key) $i] eq $value} {</span>
<span class="s2">            lset array($key) [lreplace $array($key) $i $i]</span>
<span class="s2">            break</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">     </span>
<span class="s2">    if {[llength $array($key)] &lt;= 0} {</span>
<span class="s2">        array unset array $key</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_5.8</span>
<span class="s2">#-----------------------------</span>
<span class="s2">package require struct 1.4</span>
<span class="s2">array set REVERSE [::struct::list reverse [array get LOOKUP]]</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># foodfind - find match for food or color</span>
<span class="s2">package require struct 1.4</span>
<span class="s2">proc foodfind foodOrColor {</span>
<span class="s2">	array set color {</span>
<span class="s2">		Apple	red</span>
<span class="s2">		Banana	yellow</span>
<span class="s2">		Lemon	yellow</span>
<span class="s2">		Carrot	orange</span>
<span class="s2">	}</span>
<span class="s2">	array set food [::struct::list reverse [array get color]]</span>
<span class="s2">	if {[info exists color($foodOrColor)]} {</span>
<span class="s2">		puts &quot;$foodOrColor is a food with color $color($foodOrColor).&quot;</span>
<span class="s2">	}</span>
<span class="s2">	if {[info exists food($foodOrColor)]} {</span>
<span class="s2">		puts &quot;$food($foodOrColor) is a food with color $foodOrColor.&quot;</span>
<span class="s2">	}</span>
<span class="s2">}</span>

<span class="s2">foreach {f c} [array get color] {</span>
<span class="s2">	lappend food($c) $f</span>
<span class="s2">}</span>
<span class="s2">puts &quot;[join $food(yellow)] were yellow foods.&quot;</span>


<span class="s2"># @@PLEAC@@_5.9</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># a is the array to sort</span>
<span class="s2">set keys [lsort OPTIONS [array names a]]</span>
<span class="s2">foreach key $keys {</span>
<span class="s2">	set value $a($key)</span>
<span class="s2">	# do something with $key, $value</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">foreach food [lsort [array names foodColor]] {</span>
<span class="s2">	puts &quot;$food is $foodColor($food).&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">proc sortFoods {a b} {</span>
<span class="s2">	expr {[string length $a] - [string length $b]}</span>
<span class="s2">}</span>
<span class="s2">foreach food [lsort -command sortFoods [array names foodColor]] {</span>
<span class="s2">	lappend foods $food</span>
<span class="s2">}</span>
<span class="s2">foreach food $foods {</span>
<span class="s2">	puts &quot;$food is $foodColor($food).&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@PLEAC@@_5.10</span>
<span class="s2">#-----------------------------</span>
<span class="s2">array set merged [concat [array get A] [array get B]]</span>
<span class="s2">#-----------------------------</span>
<span class="s2">array unset merged</span>
<span class="s2">foreach {k v} [array get A] {</span>
<span class="s2">	set merged($k) $v</span>
<span class="s2">}</span>
<span class="s2">foreach {k v} [array get B] {</span>
<span class="s2">	set merged($k) $v</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># foodColor as per the introduction</span>
<span class="s2">array set drinkColor {</span>
<span class="s2">	Galliano	yellow</span>
<span class="s2">	&quot;Mai Tai&quot;	blue</span>
<span class="s2">}</span>
<span class="s2">array set ingestedColor [concat [array get drinkColor] [array get foodColor]]</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># foodColor per the introduction, then</span>
<span class="s2">array set drinkColor {</span>
<span class="s2">	Galliano	yellow</span>
<span class="s2">	&quot;Mai Tai&quot;	blue</span>
<span class="s2">}</span>
<span class="s2">array unset ingestedColor</span>
<span class="s2">foreach {k v} [array get foodColor] {</span>
<span class="s2">	set ingestedColor($k) $v</span>
<span class="s2">}</span>
<span class="s2">foreach {k v} [array get drinkColor] {</span>
<span class="s2">	set ingestedColor($k) $v</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">foreach substanceref {foodColor drinkColor} {</span>
<span class="s2">	foreach {k v} [array get $substanceref] {</span>
<span class="s2">		set substanceColor($k) $v</span>
<span class="s2">	}</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">foreach substanceref {foodColor drinkColor} {</span>
<span class="s2">	foreach {k v} [array get $substanceref] {</span>
<span class="s2">		if {[info exists substanceColor($k)]} {</span>
<span class="s2">			puts &quot;Warning: $k seen twice.  Using the first definition.&quot;</span>
<span class="s2">			continue</span>
<span class="s2">		}</span>
<span class="s2">		set substanceColor($k) $v</span>
<span class="s2">	}</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@PLEAC@@_5.11</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set common {}</span>
<span class="s2">foreach k [array names arr1] {</span>
<span class="s2">	if {[info exists arr2($k)]} {</span>
<span class="s2">		lappend common $k</span>
<span class="s2">	}</span>
<span class="s2">}</span>
<span class="s2"># common now contains common keys</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set thisNotThat {}</span>
<span class="s2">foreach k [array names arr1] {</span>
<span class="s2">	if {![info exists arr2($k)]} {</span>
<span class="s2">		lappend thisNotThat $k</span>
<span class="s2">	}</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># foodColor per the introduction</span>

<span class="s2"># citrusColor is an array mapping citrus food name to its color.</span>
<span class="s2">array set citrusColor {</span>
<span class="s2">	Lemon	yellow</span>
<span class="s2">	Orange	orange</span>
<span class="s2">	Lime	green</span>
<span class="s2">}</span>

<span class="s2"># build up a list of non-citrus foods</span>
<span class="s2">set nonCitrus {}</span>

<span class="s2">foreach k [array names foodColor] {</span>
<span class="s2">	if {![info exists citrusColor($k)]} {</span>
<span class="s2">		lappend nonCitrus $k</span>
<span class="s2">	}</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@PLEAC@@_5.12</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@PLEAC@@_5.13</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@PLEAC@@_5.14</span>
<span class="s2">#-----------------------------</span>

<span class="s2">array unset count</span>
<span class="s2">foreach element $LIST {</span>
<span class="s2">	if {![info exists count($element)]} {</span>
<span class="s2">		set count($element) 1</span>
<span class="s2">	} else {</span>
<span class="s2">		incr count($element)</span>
<span class="s2">	}</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@PLEAC@@_5.15</span>
<span class="s2">#-----------------------------</span>

<span class="s2">array set father {</span>
<span class="s2">	Cain		Adam</span>
<span class="s2">	Abel		Adam</span>
<span class="s2">	Seth		Adam</span>
<span class="s2">	Enoch		Cain</span>
<span class="s2">	Irad		Enoch</span>
<span class="s2">	Mehujael	Irad</span>
<span class="s2">	Methusael	Mehujael</span>
<span class="s2">	Lamech		Methusael</span>
<span class="s2">	Jabal		Lamech</span>
<span class="s2">	Jubal		Lamech</span>
<span class="s2">	Tubalcain	Lamech</span>
<span class="s2">	Enos		Seth</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">foreach name {Adam Tubalcain Elvis Enos} {</span>
<span class="s2">	set fathers {}</span>
<span class="s2">	while {[info exists father($name)]} {    ;# if &lt;name&gt; has a father</span>
<span class="s2">		lappend fathers $name            ;# add it to the list</span>
<span class="s2">		set name $father($name)         ;# and check the father&#39;s father</span>
<span class="s2">	}</span>
<span class="s2">	puts $fathers</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2">foreach {k v} [array get father] {</span>
<span class="s2">	lappend children($v) $k</span>
<span class="s2">}</span>
<span class="s2">set sep {, }                ;# separate output with commas</span>
<span class="s2">foreach name {Adam Tubalcain Elvis Lamech} {</span>
<span class="s2">	if {[info exists children($name)] &amp;&amp; [llength children($name)]} {</span>
<span class="s2">		set res $children($name)</span>
<span class="s2">	} else {</span>
<span class="s2">		set res nobody</span>
<span class="s2">	}</span>
<span class="s2">	puts &quot;$name begat [join $res $sep]&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2">foreach file $files {</span>
<span class="s2">	if {[catch {open $file} F]} {</span>
<span class="s2">		puts stderr &quot;Couldn&#39;t read $file: $F; skipping.&quot;</span>
<span class="s2">		continue</span>
<span class="s2">	}</span>
<span class="s2">	while {[gets $F line] &gt;= 0} {</span>
<span class="s2">		if {![regexp {^\s*#\s*include\s*&lt;([^&gt;]+)&gt;} $line --&gt; name]} {</span>
<span class="s2">			continue</span>
<span class="s2">		}</span>
<span class="s2">		lappend includes($name) $file</span>
<span class="s2">	}</span>
<span class="s2">	close $F</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2">set includeFree {}                  ;# list of files that don&#39;t include others</span>
<span class="s2">foreach k [array names includes] {</span>
<span class="s2">	set uniq($k) {}</span>
<span class="s2">}</span>
<span class="s2">forech file [lsort [array names uniq]] {</span>
<span class="s2">	if {![info exists includes($file)]} {</span>
<span class="s2">		lappend includeFree $file</span>
<span class="s2">	}</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@PLEAC@@_5.16</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2">#-----------------------------</span>

<span class="s2"># @@PLEAC@@_6.0</span>
<span class="s2">#-----------------------------</span>
<span class="s2">regexp $pattern $string</span>
<span class="s2">regsub $pattern $string $replacement</span>
<span class="s2">#-----------------------------</span>
<span class="s2">regexp sheep $meadow            # True if $meadow contains &quot;sheep&quot;</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub old $meadow new meadow   # Replace &quot;old&quot; with &quot;new&quot; in $meadow</span>

<span class="s2">#-----------------------------</span>
<span class="s2">if [regexp -nocase {\bovines?\b} $meadow ] {</span>
<span class="s2">    puts -nonewline {Here be sheep!}</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set string {good food}</span>
<span class="s2">set string [regsub {o*} $string e] # regsub with out replacement var returns result.</span>

<span class="s2">#-----------------------------</span>
<span class="s2">foreach i [regexp -all -inline {\d+}] {</span>
<span class="s2">    puts &quot;Found number $i&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set numbers [regexp -all -inline {\d+}]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set digits 123456789</span>
<span class="s2">set nonlap [regexp -inline -all {\d\d\d} $digits]</span>
<span class="s2">#no direct way for overlap since the regex behavior of /g|-all in tcl is differnt from perl.</span>
<span class="s2">set yeslap {}</span>
<span class="s2">for {set i 0} {$i &lt; [string length $digits]} {incr i} {</span>
<span class="s2">     set match [regexp -inline {\d\d\d} [string range $digits $i end]]</span>
<span class="s2">     if {[string length $match]} {</span>
<span class="s2">        lappend yeslap $match</span>
<span class="s2">     }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># no direct pre and post match vars in tcl.</span>
<span class="s2">set string {And little lambs eat ivy}</span>
<span class="s2">regexp -indices  -- {l.*s} $string idxs</span>
<span class="s2">set start [lindex $idxs 0]</span>
<span class="s2">set stop [lindex $idxs 1]</span>
<span class="s2">puts &quot;([string range $string 0 $start-1]) ([string range $string $start $stop]) ([string range $string $stop+1 end])&quot;</span>

<span class="s2"># @@PLEAC@@_6.1</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set dst $src</span>
<span class="s2">regsub this $dst that dst</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub this $src that dst</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># strip to basename</span>
<span class="s2">regsub ^.*/ $::argv0 {} progname</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># it is easier to do it this way than the next.</span>
<span class="s2">package require struct::list</span>
<span class="s2">::struct::list map $words {string totitle}</span>

<span class="s2"># using regex.</span>
<span class="s2">set capword [gregsub {(\w+)} $words {</span>
<span class="s2">      r {return [string totitle $r]}</span>
<span class="s2">}]</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># /usr/man/man3/foo.1 changes to /usr/man/cat3/foo.1</span>
<span class="s2">regsub {man(?=\d)} $manpage cat catpage</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set bindirs {/usr/bin /bin /usr/local/bin}</span>
<span class="s2">set libdirs [string map {bin lib} $bindirs]</span>
<span class="s2">puts $libdirs</span>
<span class="s2"># /usr/lib /lib /usr/local/lib</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub -all x $a y b # copy changed string to b</span>
<span class="s2">set b [regsub -all x $a y a] # change a, count goes in b</span>

<span class="s2"># @@PLEAC@@_6.2</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># matching letters</span>
<span class="s2">if [regexp {^[A-Za-z]+$} $var] {</span>
<span class="s2">    #may be better to user [[:alpha:]]+$</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">if [regexp {^[[:alpha:]]+$} $var] {</span>
<span class="s2">    puts &quot;var is purely alphabetic&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">readlines $data {</span>
<span class="s2">    {line} {</span>
<span class="s2">        if {[regexp {^[[:alpha:]]+$} $line]} {</span>
<span class="s2">            puts -nonewline &quot;$line: alphabetic&quot;</span>
<span class="s2">        } else {</span>
<span class="s2">            puts -nonewline &quot;$line: line noice&quot;</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">#__END__</span>
<span class="s2">#silly</span>
<span class="s2">#faзade</span>
<span class="s2">#coцperate</span>
<span class="s2">#niсo</span>
<span class="s2">#Renйe</span>
<span class="s2">#Moliиre</span>
<span class="s2">#hжmoglobin</span>
<span class="s2">#naпve</span>
<span class="s2">#tschья</span>
<span class="s2">#random!stuff#here</span>

<span class="s2"># @@PLEAC@@_6.3</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># matching words</span>
<span class="s2">{\S+} # as many non-whitespace bytes as possible</span>
<span class="s2">{[A-Za-z&#39;-]+} # as many letters apostrophes and hyphens</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{\y([A-Za-z]+)\y} # usually best</span>
<span class="s2">{\s([A-Za-z]+)\s} # fails at ends or w/ punctuation</span>

<span class="s2"># @@PLEAC@@_6.4</span>
<span class="s2">#-----------------------------</span>
<span class="s2">package require Tclx</span>
<span class="s2">set str {www.tcl.tk}</span>

<span class="s2">set re {(?x)                # allow formatting</span>
<span class="s2">    (                       # capture group</span>
<span class="s2">        (?:                 # grouping parens</span>
<span class="s2">            (?! [-_] )      # lookahead for neither - nor _</span>
<span class="s2">            [\w] +          # hostname component</span>
<span class="s2">            \.              # add domain dot</span>
<span class="s2">        )+                  # repeat</span>
<span class="s2">        [A-Za-z]            # next must be letter</span>
<span class="s2">        [\w-]+              # now trailing domain part</span>
<span class="s2">    )</span>
<span class="s2">}</span>

<span class="s2">puts [gregsub $re $str {</span>
<span class="s2">        {host} {</span>
<span class="s2">            return &quot;$host \[[host_info addresses $host]\]&quot;</span>
<span class="s2">        }</span>
<span class="s2">    }]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set re {(?x)       # replace</span>
<span class="s2">    \#             # a pound</span>
<span class="s2">    (\w+)          # varname</span>
<span class="s2">    \#             # another pound</span>
<span class="s2">}</span>

<span class="s2">puts [gregsub $re $str {</span>
<span class="s2">        {var} {</span>
<span class="s2">            return [uplevel 2 &quot;set $var&quot;]</span>
<span class="s2">        }</span>
<span class="s2">    }]</span>

<span class="s2"># @@PLEAC@@_6.5</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># finding Nth occurence of a match</span>
<span class="s2">set pond  &quot;One fish two fish red fish blue fish&quot;</span>
<span class="s2">set want 3</span>
<span class="s2">set count 0</span>
<span class="s2">gregsub {(?i)(\w+)\s+fish} $pond {</span>
<span class="s2">    {c} {</span>
<span class="s2">        variable want</span>
<span class="s2">        variable count</span>
<span class="s2">        incr count</span>
<span class="s2">        if {$want == $count} {</span>
<span class="s2">            puts &quot;The third fish is a $c one&quot;</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fishes [regexp -all -inline -- {(?i)\w+(?=\s+fish)} $pond ]</span>
<span class="s2">puts &quot;The third fish is a [lindex $fishes 2] one.&quot;</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{(?i)(?:\w+\s+fish\s+){2}(\w+)\s+fish}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set count 0</span>
<span class="s2">gregsub {(?i)(\w+)\s+fish} $pond {</span>
<span class="s2">    {c} {</span>
<span class="s2">        uplevel 2 {incr count} #or what eveer you want to do.</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set count [regsub -all -- {PAT} $string {} {}]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set count [expr [llength [regexp -all -- {PAT} $string]] + 1]</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># no overlapping matches.</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set colors [regexp -all -inline -- {(?i)\w+(?=\s+fish)} $pond ]</span>
<span class="s2">set color [lindex $colors 2]</span>

<span class="s2"># with out temporary.</span>
<span class="s2">set color [lindex [regexp -all -inline -- {(?i)\w+(?=\s+fish)} $pond ] 2]</span>
<span class="s2">puts &quot;The third fish in the pond is $color&quot;</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set evens {}</span>
<span class="s2">foreach {a b} [regexp -all -inline -- {(?i)\w+(?=\s+fish)} $pond ] {</span>
<span class="s2">    lappend evens $b</span>
<span class="s2">}</span>
<span class="s2">puts &quot;The even numbered fish are $evens&quot;</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># hard to do sushi.</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set pond  &quot;One fish two fish red fish blue fish swim here&quot;</span>
<span class="s2">set color [lindex [regexp -all -inline -- {(?i)\w+(?=\s+fish)} $pond ] end]</span>
<span class="s2">puts &quot;Last fish is $color&quot;</span>

<span class="s2"># last fish is blue</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set re {(?x)</span>
<span class="s2">    A           # find some pattern A</span>
<span class="s2">    (?!         # mustn&#39;t be able to find</span>
<span class="s2">        .*      # something</span>
<span class="s2">        A       # and A</span>
<span class="s2">    )</span>
<span class="s2">    $           # thru end of str</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set pond  &quot;One fish two fish red fish blue fish swim here&quot;</span>
<span class="s2">if [regexp -- {(?x)</span>
<span class="s2">        \y(\w+)\s+fish\y</span>
<span class="s2">        (?!.*\yfish\y)</span>
<span class="s2">    } $pond all one] {</span>
<span class="s2">    puts &quot;Last fish is $one&quot;</span>
<span class="s2">} else {</span>
<span class="s2">    puts &quot;Failed.&quot;</span>
<span class="s2">}</span>
<span class="s2"># last fish is blue</span>

<span class="s2"># @@PLEAC@@_6.6</span>
<span class="s2">#-----------------------------</span>
<span class="s2">argf-iter {</span>
<span class="s2">    line {</span>
<span class="s2">        puts [regsub -all -- {&lt;.*&gt;} $line {}]</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># headerfy: change certain chapter headers to html</span>
<span class="s2">set re {(?xn)</span>
<span class="s2">    \A              # start of record</span>
<span class="s2">    (</span>
<span class="s2">        ^Chapter    # title</span>
<span class="s2">        \s+</span>
<span class="s2">        \d+         # decimal number</span>
<span class="s2">        \s+</span>
<span class="s2">        :</span>
<span class="s2">        .*</span>
<span class="s2">     )$</span>
<span class="s2">}</span>

<span class="s2">set options(CR) &quot;\n&quot;</span>
<span class="s2">argf-iter {</span>
<span class="s2">    para {</span>
<span class="s2">        variable re</span>
<span class="s2">        puts -nonewline [regsub -all -- $re $para {&lt;H1&gt;\1&lt;/H1&gt;}]</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">array unset options(CR)</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set options(CR) &quot;\n\n&quot;</span>
<span class="s2">argf-iter {</span>
<span class="s2">    para {</span>
<span class="s2">        gregsub {(?w)^START(.*?)^END} $para {</span>
<span class="s2">            {chunk} {</span>
<span class="s2">                puts -nonewline &quot;chunk in $::argv has $chunk&quot;</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_6.7</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># reading records with a pattern separator</span>
<span class="s2">set chunks [split [regsub -all -- {pattern} [read -nonewline $fd] &quot;\0&quot;] &quot;\0&quot;]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set chunks [split [regsub -all -- {(?n)^\.(Ch|Se|Ss)$} [read -nonewline $fd] &quot;\0&quot;] &quot;\0&quot;]</span>
<span class="s2">set len [llength $chunks]</span>
<span class="s2">puts &quot;I read $len chunks&quot;</span>

<span class="s2"># @@PLEAC@@_6.8</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># tcl does not have regexp range operators</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open $argv]</span>
<span class="s2">set data [split [read $fd] &quot;\n&quot;]</span>

<span class="s2">regrange {BEGIN PATTERN} .. {ENDPATTERN} $data {</span>
<span class="s2">    {line} {</span>
<span class="s2">        puts &quot;&gt;$line&quot;</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">set fd [open $argv]</span>
<span class="s2">set data [split [read $fd] &quot;\n&quot;]</span>
<span class="s2">foreach line [lrange $data $first_line_no $last_line_no-1] {</span>
<span class="s2">    puts $line</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open $argv]</span>
<span class="s2">set data [split [read $fd] &quot;\n&quot;]</span>

<span class="s2">regrange {BEGIN PATTERN} ... {ENDPATTERN} $data {</span>
<span class="s2">    {line} {</span>
<span class="s2">        puts &quot;&gt;$line&quot;</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">set fd [open $argv]</span>
<span class="s2">set data [split [read $fd] &quot;\n&quot;]</span>
<span class="s2">foreach line [lrange $data $first_line_no-1 $last_line_no] {</span>
<span class="s2">    puts $line</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open $argv]</span>
<span class="s2">set data [split [read $fd] &quot;\n&quot;]</span>
<span class="s2">puts [lrange $data 15-1 17-1] # prints lines 15 .. 17 as it is indexed by 0.</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># the perl logic is not directly portable due to absence of range operators.</span>
<span class="s2">set in_header {}</span>
<span class="s2">regrange {} .. {^$} $data {</span>
<span class="s2">    {line} {</span>
<span class="s2">        variable in_header</span>
<span class="s2">        lappend in_header $line</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">set in_body {}</span>
<span class="s2">regrange {^$} .. {$-^} $data { # $-^ will not match any thing thus leaving an open end.</span>
<span class="s2">    {line} {</span>
<span class="s2">        variable in_body</span>
<span class="s2">        lappend in_body $line</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open $argv]</span>
<span class="s2">set data [split [read $fd] &quot;\n&quot;]</span>
<span class="s2">array set seen {}</span>
<span class="s2">regrange {(?i)^From:?\s} .. {^$} $data {</span>
<span class="s2">    line {</span>
<span class="s2">        variable seen</span>
<span class="s2">        set ids [regexp -inline -all {[^&lt;&gt;(),;\s]+\@[^&lt;&gt;(),;\s]+} $line]</span>
<span class="s2">        foreach id $ids {</span>
<span class="s2">            if {![info exists seen($id)]} {</span>
<span class="s2">                puts $id</span>
<span class="s2">                set seen($id) 0</span>
<span class="s2">            } else {</span>
<span class="s2">                incr seen($id)</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_6.9</span>
<span class="s2">#-----------------------------</span>
<span class="s2">proc glob2pat globstr {</span>
<span class="s2">    # note - we dont need to do this, we already have &#39;glob&#39; command.</span>
<span class="s2">    # escapes the chars &#39;\&#39; &#39;.&#39; &#39;+&#39; &#39;^&#39; &#39;$&#39; &#39;{&#39; &#39;}&#39; &#39;(&#39; &#39;)&#39;</span>
<span class="s2">    set patmap {</span>
<span class="s2">       &quot;\\&quot; &quot;\\\\&quot;</span>
<span class="s2">        {.} {\.}</span>
<span class="s2">        {+} {\+}</span>
<span class="s2">        {^} {\^}</span>
<span class="s2">        {$} {\$}</span>
<span class="s2">        &quot;{&quot; &quot;\{&quot;</span>
<span class="s2">        &quot;}&quot; &quot;\}&quot;</span>
<span class="s2">        {(} {\(}</span>
<span class="s2">        {)} {\)}</span>

<span class="s2">        * .*</span>
<span class="s2">        ? .</span>
<span class="s2">        [ [</span>
<span class="s2">        ] ]</span>
<span class="s2">    }</span>
<span class="s2">    # using a bre to avoid other regexp rules</span>
<span class="s2">    return [append {} (?b)^ [string map $patmap [join $globstr]] $]</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_6.10</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># tcl caches compiled regexp if it is assigned to a variable (and even if it is not,</span>
<span class="s2"># but that is restricted to last 30) so /o in perl is not necessary here.</span>
<span class="s2">set pattern {blue}</span>
<span class="s2">argf-iter {</span>
<span class="s2">    line {</span>
<span class="s2">        variable pattern</span>
<span class="s2">        if [regexp  -- $pattern $line] {</span>
<span class="s2">            # do something.</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set popstates {CO ON MI WI MN}</span>
<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    foreach state $popstates {</span>
<span class="s2">        if [regexp  -- $state $line] {</span>
<span class="s2">            puts $line</span>
<span class="s2">            break</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># using argf-iter</span>
<span class="s2">set popstates {CO ON MI WI MN}</span>
<span class="s2">argf-iter {</span>
<span class="s2">    line {</span>
<span class="s2">        variable popstates</span>
<span class="s2">        foreach state $popstates {</span>
<span class="s2">            if [regexp  -- $state $line] {</span>
<span class="s2">                puts -nonewline $line</span>
<span class="s2">                break</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set popstates {CO ON MI WI MN}</span>
<span class="s2">set pre {while {[gets $fd line]&gt;= 0}}</span>
<span class="s2">set code {}</span>
<span class="s2">foreach state $popstates {</span>
<span class="s2">    append code [subst -nocommands {</span>
<span class="s2">    if [regexp  -- $state [set line]] {</span>
<span class="s2">        puts [set line]</span>
<span class="s2">    }</span>
<span class="s2">    }]</span>
<span class="s2">}</span>

<span class="s2">eval [lappend pre $code]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">package require struct::list</span>

<span class="s2">set fd [open $argv]</span>
<span class="s2">set sw_pre {[switch -regexp {$line}}</span>
<span class="s2">set code {}</span>
<span class="s2">append code [::struct::list map $popstates {apply {</span>
<span class="s2">        {state} {</span>
<span class="s2">            return &quot;$state {return 1}&quot;</span>
<span class="s2">        }</span>
<span class="s2">    }}]</span>
<span class="s2">lappend code {default {return 0}}</span>

<span class="s2">set tmp {}</span>
<span class="s2">set myproc [append tmp $sw_pre { } [list [join $code]] {]}]</span>
<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    if [subst [subst -nocommands $myproc]] {</span>
<span class="s2">        puts $line</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">proc build_exp words {</span>
<span class="s2">    # return a list of lambdas that can be applied to a line to get a</span>
<span class="s2">    # result string containing matching results.</span>
<span class="s2">    return [::struct::list map $words {apply</span>
<span class="s2">        {{word} {</span>
<span class="s2">            return &quot;line {return \[regexp $word \$line\]}&quot;</span>
<span class="s2">        }}</span>
<span class="s2">    }]</span>
<span class="s2">}</span>

<span class="s2">proc func {var f} {</span>
<span class="s2">    return [apply $f $var]</span>
<span class="s2">}</span>

<span class="s2">proc + {a b} {return [expr ($a + $b)]}</span>
<span class="s2">proc * {a b} {return [expr ($a * $b)]}</span>

<span class="s2">proc build_match_func {func init words} {</span>
<span class="s2">    #return an applicable lambda.</span>
<span class="s2">    return &quot;line {return \[::struct::list fold \[::struct::list map \[build_exp {$words}\] \[list func \$line\]\] $init $func\]}&quot;</span>
<span class="s2">}</span>

<span class="s2">set match_any [build_match_func + 0 $words]</span>
<span class="s2">set match_all [build_match_func * 1 $words]</span>

<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    if [apply $match_all $line] {</span>
<span class="s2">        puts $line</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># we cache all regex in tcl. so there is no difference here.</span>
<span class="s2">set popstates {CO ON MI WI MN}</span>
<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    foreach state $popstates {</span>
<span class="s2">        if [regexp  -- $state $line] {</span>
<span class="s2">            puts $line</span>
<span class="s2">            break</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_6.11</span>
<span class="s2">#-----------------------------</span>
<span class="s2">chan configure stdout -buffering none</span>
<span class="s2">while {![eof stdin]} {</span>
<span class="s2">    if {[catch {</span>
<span class="s2">        puts -nonewline &quot;Pattern? &quot;</span>
<span class="s2">        gets stdin pat</span>
<span class="s2">        regexp $pat {}</span>
<span class="s2">    } err]} {</span>
<span class="s2">        puts &quot;Invalid pattern&quot;</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">proc is_valid_pattern pat {</span>
<span class="s2">    return [expr ![catch {regexp $pat {}} err]]</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set rexp [lindex $argv 0]</span>
<span class="s2">if [catch &quot;regexp $rexp {}&quot; err] {</span>
<span class="s2">    puts &quot;Bad Pattern $rexp: $::argv0&quot;</span>
<span class="s2">    exit -1</span>
<span class="s2">}</span>
<span class="s2">set fd [open [lindex $argv 1]]</span>
<span class="s2">foreach para [split [regsub -all -- &quot;\n\n&quot; [read $fd] &quot;\0&quot;] &quot;\0&quot;] {</span>
<span class="s2">    if [regexp $rexp $para] {</span>
<span class="s2">        puts $para</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">close $fd</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set safe [interp create -safe]</span>
<span class="s2">if [$safe eval {regexp $pat $line}] {</span>
<span class="s2">    do_something</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_6.12</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_6.13</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_6.14</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># perl does not support \G switch</span>
<span class="s2"># so we are left with:</span>

<span class="s2">gregsub {(\d+)} $str {</span>
<span class="s2">        {match} {</span>
<span class="s2">            puts &quot;Found $match&quot;</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set n [gregsub {^( )} $str {</span>
<span class="s2">        {match} {</span>
<span class="s2">            return 0</span>
<span class="s2">        }</span>
<span class="s2">    }]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">gregsub {^,?(\d+)} $str {</span>
<span class="s2">        {match} {</span>
<span class="s2">            puts &quot;Found number $match&quot;</span>
<span class="s2">        }</span>
<span class="s2">    }</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># tcl does not have /c modifier either.</span>
<span class="s2">proc gmatch {exp str block} {</span>
<span class="s2">    set start 0</span>
<span class="s2">    while 1 {</span>
<span class="s2">        if {[regexp -indices -start $start -- $exp $str idx]} {</span>
<span class="s2">            set start [expr [lindex $idx 1] + 1]</span>
<span class="s2">            apply $block [string range $str {expand}$idx]</span>
<span class="s2">        } else break</span>
<span class="s2">    }</span>
<span class="s2">    return $start</span>
<span class="s2">}</span>

<span class="s2">set str &quot;The year 1752 lost 10 days on the 3rd of September&quot;</span>
<span class="s2">set e [gmatch {\d+} $str {</span>
<span class="s2">        {match} {</span>
<span class="s2">            puts $match</span>
<span class="s2">        }</span>
<span class="s2">    }]</span>

<span class="s2">if [regexp -indices -start $e -- {\S+} $str idx] {</span>
<span class="s2">    puts &quot;Found [string range $str {expand}$idx] after last number&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># use the [lindex $idx end] as the pos for next regexp match..</span>

<span class="s2"># @@PLEAC@@_6.15</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># try removing tags very badly</span>
<span class="s2">regsub -all -- {&lt;.*&gt;} $line {} line</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># non greedy but still bad.</span>
<span class="s2">regsub -all -- {&lt;.*?&gt;} $line {} line</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># stil wrong</span>
<span class="s2">set txt &quot;&lt;b&gt;&lt;i&gt;this&lt;/i&gt; and &lt;i&gt;that&lt;/i&gt; are important&lt;/b&gt; Oh, &lt;b&gt;&lt;i&gt;me</span>
<span class="s2">too!&lt;/i&gt;&lt;/b&gt;&quot;</span>
<span class="s2">regexp -all -inline -- {(?x) &lt;b&gt;&lt;i&gt;(.*?)&lt;/i&gt;&lt;/b&gt; } $txt</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{(?x)BEGIN((?:(?!BEGIN).)*)END}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{(?x) &lt;b&gt;&lt;i&gt;(  (?:  (?!&lt;/b&gt;|&lt;/i&gt;). )* )&lt;/i&gt;&lt;/b&gt; }</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{(?x) &lt;b&gt;&lt;i&gt;(  (?:  (?!&lt;/[bi]&gt;). )* )&lt;/i&gt;&lt;/b&gt; }</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{(?x)</span>
<span class="s2">    &lt;b&gt;&lt;i&gt;</span>
<span class="s2">    [^&lt;]*       #stuff not possibly bad and not possibly end</span>
<span class="s2">    (?:</span>
<span class="s2">        (?!  &lt;/?[ib]&gt;  ) #what we cant have</span>
<span class="s2">        &lt;</span>
<span class="s2">        [^&gt;]*</span>
<span class="s2">    ) *</span>
<span class="s2">    &lt;/i&gt;&lt;/b&gt;</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_6.16</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># no easy way to do this.</span>
<span class="s2"># a difference in the tcl regex implementation means that if I say \1+, it immediatly</span>
<span class="s2"># changes the definition of \1 do not know if this behavior is correct.</span>
<span class="s2"># but it means that unlike the perl version, we print the dup words multiple times.</span>
<span class="s2"># if they are repeated more than 2 times .</span>
<span class="s2"># using a non capturing gropu (?:xx\1xx) did not help.</span>

<span class="s2">set fd [open $argv]</span>
<span class="s2">set p 0</span>
<span class="s2">foreach para [split [regsub -all -- &quot;\n\n&quot; [read -nonewline $fd] &quot;\0&quot;] &quot;\0&quot;] {</span>
<span class="s2">    incr p</span>
<span class="s2">    set start 0</span>
<span class="s2">    while 1 {</span>
<span class="s2">        set re {\y(\S+)\y(\s+\1\y)}</span>
<span class="s2">        if {[regexp -indices -start $start -- $re $para all one two]} {</span>
<span class="s2">            puts &quot;dup word &#39;[string range $para {expand}$one]&#39; at paragraph $p&quot;</span>
<span class="s2">            set start [expr [lindex $all end] + 1]</span>
<span class="s2">        } else break</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set a nobody</span>
<span class="s2">set b bodysnatcher</span>
<span class="s2">if [regexp -- {^(\w+)(\w+) \2(\w+)$} &quot;$a $b&quot; all 1 2 3] {</span>
<span class="s2">    puts &quot;$2 overlaps in $1-$2-$3&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{^(\w+?)(\w+) \2(\w+)$}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># prime factors</span>
<span class="s2">set arg 180</span>
<span class="s2">set cap [string repeat o $arg]</span>
<span class="s2">while {[regexp -- {^(oo+?)\1+$} $cap all one]} {</span>
<span class="s2">    puts -nonewline [string length $one]</span>
<span class="s2">    regsub -all $one $cap o cap</span>
<span class="s2">}</span>
<span class="s2">puts [string length $cap]</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># diophantine</span>
<span class="s2">set cap [string repeat o 281]</span>
<span class="s2">if {[regexp -- {(o*)\1{11}(o*)\2{14}(o*)\3{15}$} [string repeat o 281]</span>
<span class="s2">all 1 2 3]} {</span>
<span class="s2">    puts &quot;One solution is x=[string length $1] y=[string length $2]</span>
<span class="s2">z=[string length $3]&quot;</span>
<span class="s2">} else {</span>
<span class="s2">    puts &quot;No match&quot;</span>
<span class="s2">}</span>

<span class="s2"># One solution is x=17 y=3 z=2</span>
<span class="s2">#-----------------------------</span>
<span class="s2">{^(o+)\1{11}(o+)\2{14}(o+)\3{15}$}  =&gt; One solution is x=17 y=3 z=2</span>
<span class="s2">{^(o*?)\1{11}(o*)\2{14}(o*)\3{15}$} =&gt; One solution is x=0 y=7 z=11</span>
<span class="s2">{^(o+?)\1{11}(o*)\2{14}(o*)\3{15}$} =&gt; One solution is x=1 y=3 z=14</span>

<span class="s2"># @@PLEAC@@_6.17</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># alpha | beta</span>
<span class="s2">{alpha|beta}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># alpha &amp; beta</span>
<span class="s2">{(?=.*alpha)(?=.*beta)}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># alpha beta | beta alpha</span>
<span class="s2">{alpha.*beta|beta.*alpha}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># !beta</span>
<span class="s2">{^(?:(?!beta).)*$}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># !bad but good</span>
<span class="s2">{(?=(?:(?!BAD).)*$)GOOD}</span>
<span class="s2"># we dont have an operator like =~ or !~ in tcl so no prefered way.</span>

<span class="s2">#-----------------------------</span>
<span class="s2">if {[expr [regexp {pat1} $string] &amp;&amp; [regexp {pat2} $string]]} {</span>
<span class="s2">    something</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">if {[expr [regexp {pat1} $string] || [regexp {pat2} $string]]} {</span>
<span class="s2">    something</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># mini grep</span>
<span class="s2">set pat [::struct::list shift argv]</span>
<span class="s2">argf-iter {</span>
<span class="s2">    line {</span>
<span class="s2">        variable pat</span>
<span class="s2">        if [regexp $pat $line] {</span>
<span class="s2">            puts -nonewline $line</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regexp {(?=.*bell)(?=.*lab)} &quot;labelled&quot;</span>
<span class="s2">[expr {[regexp {} bell] &amp;&amp; [regexp {} lab]}]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">if [regexp {(?xw)</span>
<span class="s2">    ^               # start</span>
<span class="s2">    (?=             # lookahead</span>
<span class="s2">        .*</span>
<span class="s2">        bell</span>
<span class="s2">    )</span>
<span class="s2">    (?=</span>
<span class="s2">        .*</span>
<span class="s2">        lab</span>
<span class="s2">    )</span>
<span class="s2">} $murray_hill] {</span>
<span class="s2">    puts &quot;Looks like Bell Labs might be in Murray Hill!&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regexp {(?:^.*bell.*lab)|(?:^.*lab.*bell)} labelled</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set brand labelled</span>
<span class="s2">if [regexp {(?xw)</span>
<span class="s2">        (?:                 # non-capturing grouper</span>
<span class="s2">            ^ .*?           # any amount of stuff at the front</span>
<span class="s2">              bell          # look for a bell</span>
<span class="s2">              .*?           # followed by any amount of anything</span>
<span class="s2">              lab           # look for a lab</span>
<span class="s2">          )                 # end grouper</span>
<span class="s2">    |                       # otherwise, try the other direction</span>
<span class="s2">        (?:                 # non-capturing grouper</span>
<span class="s2">            ^ .*?           # any amount of stuff at the front</span>
<span class="s2">              lab           # look for a lab</span>
<span class="s2">              .*?           # followed by any amount of anything</span>
<span class="s2">              bell          # followed by a bell</span>
<span class="s2">          )                 # end grouper</span>
<span class="s2">} $brand] {</span>
<span class="s2">    puts &quot;Our brand has bell and lab separate.&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regexp {(?w)^(?:(?!waldo).)*$} $map</span>

<span class="s2">#-----------------------------</span>
<span class="s2">if [regexp {(?xw)</span>
<span class="s2">        ^                   # start of string</span>
<span class="s2">        (?:                 # non-capturing grouper</span>
<span class="s2">            (?!             # look ahead negation</span>
<span class="s2">                waldo       # is he ahead of us now?</span>
<span class="s2">            )               # is so, the negation failed</span>
<span class="s2">            .               # any character (cuzza /s)</span>
<span class="s2">        ) *                 # repeat that grouping 0 or more</span>
<span class="s2">        $                   # through the end of the string</span>
<span class="s2">} $map] {</span>
<span class="s2">    puts &quot;There&#39;s no waldo here!&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{(?x)</span>
<span class="s2">    ^                       # anchored to the start</span>
<span class="s2">    (?!                     # zero-width look-ahead assertion</span>
<span class="s2">        .*                  # any amount of anything (faster than .*?)</span>
<span class="s2">        ttyp                # the string you don&#39;t want to find</span>
<span class="s2">    )                       # end look-ahead negation; rewind to start</span>
<span class="s2">    .*                      # any amount of anything (faster than .*?)</span>
<span class="s2">    tchrist                 # now try to find Tom</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_6.18</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_6.19</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_6.20</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set ans [gets stdin]</span>
<span class="s2">set safe [interp create -safe]</span>
<span class="s2">if [$safe eval {regexp -nocase SEND $ans}] {</span>
<span class="s2">    puts {Action is send}</span>
<span class="s2">} elseif [$safe eval {regexp -nocase STOP $ans}] {</span>
<span class="s2">    puts {Action is stop}</span>
<span class="s2">} elseif [$safe eval {regexp -nocase START $ans}] {</span>
<span class="s2">    puts {Action is start}</span>
<span class="s2">} elseif [$safe eval {regexp -nocase ABORT $ans}] {</span>
<span class="s2">    puts {Action is abort}</span>
<span class="s2">} elseif [$safe eval {regexp -nocase LIST $ans}] {</span>
<span class="s2">    puts {Action is list}</span>
<span class="s2">} elseif [$safe eval {regexp -nocase EDIT $ans}] {</span>
<span class="s2">    puts {Action is edit}</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set ans [gets stdin]</span>
<span class="s2">set safe [interp create -safe]</span>
<span class="s2">proc smatch {exp data} {</span>
<span class="s2">    variable safe</span>
<span class="s2">    return [$safe eval [list regexp -nocase $exp $data]]</span>
<span class="s2">}</span>

<span class="s2">set actions {SEND STOP START ABORT LIST EDIT}</span>
<span class="s2">foreach act $actions {</span>
<span class="s2">    if [smatch $act $ans] {</span>
<span class="s2">        puts &quot;Action is [string tolower $act]&quot;</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set errors 0</span>
<span class="s2">argf-iter {</span>
<span class="s2">    cmd {</span>
<span class="s2">        variable errors</span>
<span class="s2">        switch -regexp $cmd {</span>
<span class="s2">            edit invoke_editor</span>
<span class="s2">            send deliver_message</span>
<span class="s2">            list {$pager $file}</span>
<span class="s2">            abort {</span>
<span class="s2">                puts {see you}</span>
<span class="s2">                exit</span>
<span class="s2">            }</span>
<span class="s2">            default {</span>
<span class="s2">                puts &quot;unknown command $cmd&quot;</span>
<span class="s2">                incr errors</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_6.21</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set urls {(http|telnet|gopher|file|wais|ftp)}</span>
<span class="s2">set ltrs {\w}</span>
<span class="s2">set gunk {/#~:.?+=&amp;%@!\-}</span>
<span class="s2">set punc {.:?\-}</span>
<span class="s2">set any  &quot;$ltrs$gunk$punc&quot;</span>
<span class="s2">argf-iter {</span>
<span class="s2">    line {</span>
<span class="s2">        variable urls</span>
<span class="s2">        variable ltrs</span>
<span class="s2">        variable gunk</span>
<span class="s2">        variable punc</span>
<span class="s2">        variable any</span>
<span class="s2">        #puts [subst -nocommands (?x)</span>
<span class="s2">        regsub -all [subst -nocommands {(?x)</span>
<span class="s2">          \\y</span>
<span class="s2">          (</span>
<span class="s2">           $urls     :</span>
<span class="s2">           [$any] +?</span>
<span class="s2">          )</span>
<span class="s2">          (?=</span>
<span class="s2">           [$punc]*</span>
<span class="s2">           [^$any]</span>
<span class="s2">           |</span>
<span class="s2">           $</span>
<span class="s2">          )</span>
<span class="s2">         }] $line {&lt;A HREF=&quot;\1&quot;&gt;\1&lt;/A&gt;} line</span>
<span class="s2">        puts $line</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_6.22</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_6.23</span>
<span class="s2">#-----------------------------</span>
<span class="s2">{(?i)^m*(d?c{0,3}|c[dm])(l?x{0,3}|x[lc])(v?i{0,3}|i[vx])$}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub {(\S+)(\s+)(\S+)} $str {\3\2\1} str</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{(\w+)\s*=\s*(.*)\s*$}             # keyword is $1, value is $2</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{.{80,}}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">{(\d+)/(\d+)/(\d+) (\d+):(\d+):(\d+)}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub -all {/usr/bin} $str {/usr/local/bin} str</span>

<span class="s2">#-----------------------------</span>
<span class="s2">gregsub {%([0-9A-Fa-f][0-9A-Fa-f])} $str {</span>
<span class="s2">    {match} {</span>
<span class="s2">        return [format %x $match]</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub -all {(?x)</span>
<span class="s2">    /\*                    # Match the opening delimiter</span>
<span class="s2">    .*?                    # Match a minimal number of characters</span>
<span class="s2">    \*/                    # Match the closing delimiter</span>
<span class="s2">} $str {}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub {^\s+} $str {} str</span>
<span class="s2">regsub {\s+$} $str {} str</span>

<span class="s2"># but really, in Ruby we&#39;d just do:</span>
<span class="s2">string trim $str</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub -all {\\n} $str &quot;\n&quot; str</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub -all {^.*::} $str {} str</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{(?x)^([01]?\d\d|2[0-4]\d|25[0-5])\.([01]?\d\d|2[0-4]\d|25[0-5])\.</span>
<span class="s2">    ([01]?\d\d|2[0-4]\d|25[0-5])\.([01]?\d\d|2[0-4]\d|25[0-5])$}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub {.*$/|} $str {} str</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set cols { }</span>
<span class="s2">if [info exists env::(TERMCAP)] {</span>
<span class="s2">    set cols $::env(TERMCAP)</span>
<span class="s2">}</span>
<span class="s2">if [regexp {:co#(\d+):} $cols all one] {</span>
<span class="s2">    set cols $one</span>
<span class="s2">} {</span>
<span class="s2">    set cols 80</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set name [regsub -all { /\S+/|} &quot;$::argv0 $argv&quot; { }]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">if {![regexp -nocase {linux} $tcl_platform(os)]} {</span>
<span class="s2">    error &quot;This isn&#39;t Linux&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regsub -all {\n\s+} $str {} str</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regexp -all {\d+\.?\d*|\.\d+} $line nums</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># no direct translation for \W</span>
<span class="s2"># regexp -all {\y[^\Wa-z0-9_]+\y} $line capword</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># regexp -all {\y[^\WA-Z0-9_]+\y} $line lowords</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># regexp -all {\y[^\Wa-z0-9_][^\WA-Z0-9_]*\y} $line icwords</span>

<span class="s2">#-----------------------------</span>
<span class="s2">regexp -all {&lt;A[^&gt;]+?HREF\s*=\s*[&quot;&#39;]?([^&#39;&quot; &gt;]+?)[ &#39;&quot;]?&gt;} $line links</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set initial {}</span>
<span class="s2">regexp {^\S+\s+(\S)\S*\s+\S} $line all initial</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set sentences {}</span>
<span class="s2">foreach para [split [regsub -all -- &quot;\n\n&quot; [read -nonewline $fd] &quot;\0&quot;] &quot;\0&quot;] {</span>
<span class="s2">    regsub -all -- &quot;\n&quot; $para { } para</span>
<span class="s2">    regsub -all -- { {3,}} $para {  } para</span>
<span class="s2">    lappend sentences [regexp -all -inline {\S.*?[!?.](?=  |\Z)}]</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">{(\d{4})-(\d\d)-(\d\d)}            # YYYY in $1, MM in $2, DD in $3</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2">#-----------------------------</span>
<span class="s2">{(?i)\yoh\s+my\s+gh?o(d(dess(es)?|s?)|odness|sh)\y}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_7.0</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set filename {/tmp/messages}</span>
<span class="s2">if {![catch {open $filename r} F]} {</span>
<span class="s2">    while {[gets $F line] &gt;= 0} {</span>
<span class="s2">        if [regexp  -- {blue} $line] {</span>
<span class="s2">            puts $line</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">close $F</span>
<span class="s2">} else {</span>
<span class="s2">error &quot;Opening $filename: $F&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">while {[gets stdin line] &gt;= 0} {        #read from STDIN</span>
<span class="s2">    if {![regexp -- {\d} $line]} {</span>
<span class="s2">        puts stderr {No digit found}    #writes to STDERR</span>
<span class="s2">    }</span>
<span class="s2">    puts &quot;Read: $line&quot;                  #writes to STDOUT</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set logfile [open {/tmp/log} w]</span>
<span class="s2">close $logfile</span>

<span class="s2">#-----------------------------</span>
<span class="s2">puts $logfile {Countdown initiated}</span>
<span class="s2">puts {You have 30 seconds to reach minimum safety distance.}</span>

<span class="s2"># @@PLEAC@@_7.1</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># open file &quot;path&quot; for reading only</span>
<span class="s2">set source  [open $path r]</span>
<span class="s2"># open file &quot;path&quot; for writing only</span>
<span class="s2">set sink    [open $path w]</span>

<span class="s2"># open file &quot;path&quot; for reading only</span>
<span class="s2">set source  [open $path RDONLY]</span>
<span class="s2"># open file &quot;path&quot; for writing only</span>
<span class="s2">set sink    [open $path WRONLY]</span>

<span class="s2"># open &quot;path&quot; for reading and writing</span>
<span class="s2">set file    [open $path r+ ]</span>
<span class="s2"># open &quot;path&quot; with the flags &quot;flags&quot; (see examples below for flags)</span>
<span class="s2">set file    [open $path $flags]</span>

<span class="s2"># open file &quot;path&quot; read only</span>
<span class="s2">set file    [open $path r]</span>
<span class="s2">set file    [open $path RDONLY]</span>

<span class="s2"># open file &quot;path&quot; write only, create it if it does not exist</span>
<span class="s2"># truncate it to zero length if it exists</span>
<span class="s2">set file    [open $path w]</span>
<span class="s2">set file    [open $path {WRONLY TRUNC CREAT}]</span>

<span class="s2"># open file &quot;path&quot; write only, fails if file exists</span>
<span class="s2">set file    [open $path {WRONLY EXCL CREAT}]</span>

<span class="s2"># open file &quot;path&quot; for appending</span>
<span class="s2">set file    [open $path a]</span>
<span class="s2">set file    [open $path {WRONLY APPEND CREAT}]</span>

<span class="s2"># open file &quot;path&quot; for appending only when file exists</span>
<span class="s2">set file    [open $path {WRONLY APPEND}]</span>

<span class="s2"># open file &quot;path&quot; for reading and writing</span>
<span class="s2">set file    [open $path r+]</span>
<span class="s2">set file    [open $path w+]</span>
<span class="s2">set file    [open $path RDWR]</span>

<span class="s2"># open file for reading and writing, create a new file if it does not exist</span>
<span class="s2">set file    [open $path {RDWR CREAT}]</span>

<span class="s2"># open file &quot;path&quot; reading and writing, fails if file exists</span>
<span class="s2">set file   [open $path {RDWR EXCL CREAT}]</span>

<span class="s2"># @@PLEAC@@_7.2</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># tcl open does not use chars with special meaning.</span>
<span class="s2">set file [open $filename]</span>

<span class="s2"># @@PLEAC@@_7.3</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set el [file split $path]</span>
<span class="s2">lset el 0 [glob [lindex $el 0]]</span>
<span class="s2">set expandedpath [file join {expand}$el]</span>

<span class="s2"># @@PLEAC@@_7.4</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># the raised exception contains the filename.</span>
<span class="s2">open afile r</span>

<span class="s2"># @@PLEAC@@_7.6</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set data {</span>
<span class="s2">Your data goes here</span>
<span class="s2">}</span>
<span class="s2">foreach line [split $data &quot;\n&quot;] {</span>
<span class="s2">    # process the line</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_7.6</span>
<span class="s2">#-----------------------------</span>
<span class="s2">while {[gets stdin line] &gt;= 0} {</span>
<span class="s2">    # do something with the line.</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">foreach filename $argv {</span>
<span class="s2">    # closing and exception handling are done by the block</span>
<span class="s2">    if {![catch {open $filename r} F]} {</span>
<span class="s2">        set line [gets $F] #do stuff with $line</span>
<span class="s2">        close $F</span>
<span class="s2">    } else {</span>
<span class="s2">        error &quot;can&#39;t open $filename&quot;</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">if {![llength $argv]} {</span>
<span class="s2">    set argv [glob {*.[Cch]}]</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># arg demo 1</span>
<span class="s2">set chop_first 0</span>
<span class="s2">if {![string compare [lindex $argv 0] {-c}]} {</span>
<span class="s2">    incr chop_first</span>
<span class="s2">    set argv [lrange $argv 1 end]</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># arg demo 2</span>
<span class="s2">if [regexp -- {^-(\d+)$} [lindex $argv 0] all one] {</span>
<span class="s2">    set columns $one</span>
<span class="s2">    set argv [lrange $argv 1 end]</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># arg demo 3 - clustered options</span>
<span class="s2"># unfortunately tcllib does not yet provide clustered opts</span>
<span class="s2"># so using the same logic as that of perl.</span>
<span class="s2">set append 0</span>
<span class="s2">set ignore_ints 0</span>
<span class="s2">set nostdout 0</span>
<span class="s2">set unbuffer 0</span>
<span class="s2">foreach arg $argv {</span>
<span class="s2">    #process arg for -abcd</span>
<span class="s2">    set parg $arg</span>
<span class="s2">    while 1 {</span>
<span class="s2">        if [regexp -- {^-(.)(.*)$} $parg all one two] {</span>
<span class="s2">            switch -- $one {</span>
<span class="s2">                {a} {incr append}</span>
<span class="s2">                {i} {incr ignore_ints}</span>
<span class="s2">                {n} {incr ignore_ints}</span>
<span class="s2">                {u} {incr unbuffer}</span>
<span class="s2">                default { error {usage: [-ainu] [filenames] ...}}</span>
<span class="s2">            }</span>
<span class="s2">            set parg -$two</span>
<span class="s2">        } else {</span>
<span class="s2">            break</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open [lindex $argv 0]]</span>
<span class="s2">set data [read -nonewline $fd]</span>
<span class="s2">close $fd</span>

<span class="s2">#-----------------------------</span>
<span class="s2">foreach arg $argv {</span>
<span class="s2">    set F [open $arg r]</span>
<span class="s2">    for {set i 0} {[gets $F line] &gt;= 0} {incr i} {</span>
<span class="s2">        puts $arg:$i:$line</span>
<span class="s2">    }</span>
<span class="s2">    close $F</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">foreach arg $argv {</span>
<span class="s2">    set F [open $arg r]</span>
<span class="s2">    while {[gets $F line] &gt;= 0} {</span>
<span class="s2">        if [regexp -- {login} $line] {</span>
<span class="s2">            puts $line</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">    close $F</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open [lindex $argv 0] r]</span>
<span class="s2">set data [read -nonewline $fd]</span>
<span class="s2">close $fd</span>
<span class="s2">set chunks 0</span>
<span class="s2">foreach line [split $data &quot;\n&quot;] {</span>
<span class="s2">    switch $line {</span>
<span class="s2">    {^#} continue</span>
<span class="s2">    {__(DATA|END)__} break</span>
<span class="s2">    default { set chunks [llength $line]}</span>
<span class="s2">}</span>

<span class="s2">puts &quot;Found $chunks chunks&quot;</span>

<span class="s2"># @@PLEAC@@_7.8</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set old [open $old_file]</span>
<span class="s2">set new [open $new_file w]</span>
<span class="s2">while {[gets $old line] &gt;= 0} {</span>
<span class="s2">    # change $line, then...</span>
<span class="s2">    puts $new $line</span>
<span class="s2">}</span>
<span class="s2">close $old</span>
<span class="s2">close $new</span>

<span class="s2">file rename $old_file &quot;old.orig&quot;</span>
<span class="s2">file rename $new_file $old_file</span>

<span class="s2">for {set i 0} {[gets $old line] &gt;= 0} {incr i} {</span>
<span class="s2">    if {$i == 20} { # we are at the 20th line</span>
<span class="s2">        puts $new &quot;Extra line 1&quot;</span>
<span class="s2">        puts $new &quot;Extra line 2&quot;</span>
<span class="s2">    }</span>
<span class="s2">    puts $new $line</span>
<span class="s2">}</span>

<span class="s2">for {set i 0} {[gets $old line] &gt;= 0} {incr i} {</span>
<span class="s2">    if {![expr (20 &lt;= $i) &amp;&amp; ($i &lt;= 30)]} {</span>
<span class="s2">        puts $new $line</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_7.10</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open {itest} r+]</span>
<span class="s2">set data [read -nonewline $fd]</span>
<span class="s2">regsub {foo} $data {QQQ} data</span>
<span class="s2">chan seek $fd 0</span>
<span class="s2">puts $fd $data</span>
<span class="s2">chan truncate $fd</span>
<span class="s2">close $fd</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open {itest} r+]</span>
<span class="s2">set data [read -nonewline $fd]</span>
<span class="s2">regsub {foo} $data [clock format [clock seconds]] data</span>
<span class="s2">chan seek $fd 0</span>
<span class="s2">puts $fd $data</span>
<span class="s2">chan truncate $fd</span>
<span class="s2">close $fd</span>

<span class="s2"># @@PLEAC@@_7.11</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># tcl does not yet support locking of files though it is available in tclx</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_7.12</span>
<span class="s2">#-----------------------------</span>
<span class="s2">chan configure $fd none</span>
<span class="s2">if [llength $argv] {</span>
<span class="s2">    chan configure stdout none</span>
<span class="s2">}</span>
<span class="s2">puts -nonewline {Now you dont see it...}</span>
<span class="s2">sleep 2</span>
<span class="s2">puts {Now you do}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># stderr is unbuffered by default. so this is not necessary</span>
<span class="s2">chan configure stderr none</span>
<span class="s2">chan configure $fd full</span>

<span class="s2">#-----------------------------</span>
<span class="s2">chan configure $sock none</span>
<span class="s2">chan configure $fd full</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set sock [socket {www.tcl.tk} 80]</span>
<span class="s2">chan configure $sock -buffering none</span>
<span class="s2">puts $sock &quot;GET / HTTP/1.0\n\n&quot;</span>
<span class="s2">set resp [read -nonewline $sock]</span>
<span class="s2">close $sock</span>
<span class="s2">puts &quot;DOC is \n$resp\n&quot;</span>

<span class="s2"># @@PLEAC@@_7.13</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># assume fh1 fh2 fh3 are open channels</span>
<span class="s2">foreach $f {fh1 fh2 fh3} {</span>
<span class="s2">    chan event [set $f] readable {</span>
<span class="s2">        # do something when this becomes readable.</span>
<span class="s2">    }</span>
<span class="s2">    chan event [set $f] writable {</span>
<span class="s2">        # do something when this becomes writable.</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">vwait forever</span>

<span class="s2"># @@PLEAC@@_7.14</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open {/dev/cua0} r+]</span>
<span class="s2">chan configure $fd -blocking 0</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set blocked [chan configure $fd -blocking]</span>
<span class="s2">chan configure $fd -blocking 0</span>

<span class="s2">#-----------------------------</span>
<span class="s2">chan configure $fd -blocking 0</span>
<span class="s2">chan puts $fd {some data}</span>
<span class="s2">if [chan blocked $fd] {</span>
<span class="s2">    # incomplete write, but there is no case of</span>
<span class="s2">    # us having to redo the write again since tcl</span>
<span class="s2">    # does it in the back ground for us.</span>
<span class="s2">}</span>

<span class="s2">set buffer [chan read -nonewline $fd $bufsize]</span>
<span class="s2">if [chan blocked $fd] {</span>
<span class="s2">    # did not read full bufsize.</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_7.15</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_7.16</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># tcl filehandles are like any other vars</span>
<span class="s2">set fd [open {myfile}]</span>
<span class="s2">set newfd $fd</span>
<span class="s2">set data [myproc $newfd]</span>

<span class="s2"># @@PLEAC@@_7.17</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_7.18</span>
<span class="s2">#-----------------------------</span>
<span class="s2">foreach $f {fh1 fh2 fh3} {</span>
<span class="s2">    puts [set $f] $stuff_to_print</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open {| tee file1 file2 &gt; /dev/null} w]</span>
<span class="s2">puts $fd {data\n}</span>
<span class="s2">close $fd</span>

<span class="s2"># @@PLEAC@@_7.19</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_7.20</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># file descriptors are just like any other variables</span>
<span class="s2">set fd [open {file}]</span>
<span class="s2">set newfd $fd</span>

<span class="s2"># @@PLEAC@@_8.0</span>
<span class="s2">#-----------------------------</span>
<span class="s2">foreach line [split [read -nonewline $fd] &quot;\n&quot;] {</span>
<span class="s2">   puts [string length $line] # we get chomped line by default.</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set lines [split [read -nonewline $fd] &quot;\n&quot;]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set data [read $fd]</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># not a direct equivalent but it is not required in tcl.</span>
<span class="s2">puts $fd [list one two three]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">puts {Baa baa black sheep.}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set buffer [read $fd 4096]</span>
<span class="s2">set rv [string length $buffer]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">chan truncate $fd $length</span>
<span class="s2"># truncating with out a file handle is not possible directly in tcl.</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set pos [chan tell $datafd]</span>
<span class="s2">puts &quot;I am $pos bytes from the start of datafd&quot;</span>

<span class="s2">#-----------------------------</span>
<span class="s2">chan seek $logfd 0 end</span>
<span class="s2">chan seek $datafd $pos start</span>
<span class="s2">chan seek $outfd -20 current</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># in tcl, there is no partial write, as even in non blocking mode,</span>
<span class="s2"># tcl writes in the background to complete the write.</span>
<span class="s2">chan configure $datafd -blocking 0 -buffering none</span>
<span class="s2">puts -nonewline $mystring</span>

<span class="s2">chan configure $infd -blocking 0 -buffering none</span>
<span class="s2">set block [read $infd 256]</span>
<span class="s2">set len [string length $block]</span>
<span class="s2">expr {($len != 256) ? [puts &quot;only read $len bytes&quot;] : 0 }</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set pos [seek $handle 0 current] #dont change position.</span>

<span class="s2"># @@PLEAC@@_8.1</span>
<span class="s2">#-----------------------------</span>
<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    while {[regexp -- {\\$} $line]} {</span>
<span class="s2">        regsub -- {\\$} $line [gets $fd] line</span>
<span class="s2">    }</span>
<span class="s2">    #process the full $line here.</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.2</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set count [wc -l $filename]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open $file]</span>
<span class="s2">set count [llength [split [read -nonewline $fd] &quot;\n&quot;]]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set count [expr [regsub -all -- &quot;\n&quot; [read -nonewline $fd] {} tmp] + 1]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">for {set count 0} {[gets $fd line] &gt; -1} {incr count} {}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># para is just \n\n</span>
<span class="s2">set count [expr [regsub -all -- &quot;\n\n&quot; [read -nonewline $fd] {} tmp] + 1]</span>

<span class="s2"># @@PLEAC@@_8.3</span>
<span class="s2">#-----------------------------</span>
<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    foreach word $line {</span>
<span class="s2">        #do something with the word.</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    foreach word [regexp -all -inline -- {\w[\w&#39;-]*} $line] {</span>
<span class="s2">        #do something with the word.</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># word frequency</span>
<span class="s2">array set seen {}</span>
<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    foreach word [regexp -all -inline -- {\w[\w&#39;-]*} $line] {</span>
<span class="s2">        incr seen([string tolower $word])</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">array set seen {}</span>
<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    incr seen([string tolower $line])</span>
<span class="s2">}</span>

<span class="s2">set names [lsort -command {apply {{a b} {upvar seen seen; expr $seen($a) &gt; $seen($b)}}} [array names seen]]</span>
<span class="s2">foreach line $names {</span>
<span class="s2">    puts &quot;$line $seen($line)&quot;</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.4</span>
<span class="s2">#-----------------------------</span>
<span class="s2">package require struct::list</span>

<span class="s2">set lines [split [read -nonewline $fd] &quot;\n&quot;]</span>
<span class="s2">foreach line [struct::list reverse $lines] {</span>
<span class="s2">    # do something with the line.</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set lines [split [read -nonewline $fd] &quot;\n&quot;]</span>
<span class="s2">for {set i [llength $lines]} {$i} {incr i -1} {</span>
<span class="s2">    set line [lindex $lines $i-1]</span>
<span class="s2">}</span>
<span class="s2"># same strategy for paragraphs.</span>

<span class="s2"># @@PLEAC@@_8.5</span>
<span class="s2">#-----------------------------</span>
<span class="s2">while 1 {</span>
<span class="s2">    myproc [read $fd]</span>
<span class="s2">    while {[eof $fd]} {</span>
<span class="s2">        after 5000</span>
<span class="s2">        seek $fd 0 current</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set naptime 1000</span>
<span class="s2">set fd [open {/tmp/logfile}]</span>
<span class="s2">while 1 {</span>
<span class="s2">    set out [gets $fd]</span>
<span class="s2">    if [string length $out] {</span>
<span class="s2">        puts $out</span>
<span class="s2">    }</span>
<span class="s2">    while {[eof $fd]} {</span>
<span class="s2">        after $naptime</span>
<span class="s2">        seek $fd 0 current</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">file stat $logfile info</span>
<span class="s2">if {!$info(nlink)} {</span>
<span class="s2">    exit 0</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.6</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set lines [split [read -nonewline $fd] &quot;\n&quot;]</span>
<span class="s2">set randline [lindex $lines [expr &quot;round(rand() * [llength $lines])&quot;]]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fd [open {/usr/share/fortune/humorists}]</span>
<span class="s2">set lines [split [regsub -all -- {%\n} [read -nonewline $fd] &quot;\0&quot;] &quot;\0&quot;]</span>
<span class="s2">set idx [expr &quot;round(rand() * [llength $lines])&quot;]</span>
<span class="s2">puts [lindex $lines $idx]</span>

<span class="s2"># @@PLEAC@@_8.7</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set lines [split [read -nonewline $input] &quot;\n&quot;]</span>
<span class="s2">foreach line [shuffle $lines] { #assumes shuffle from chapt 4</span>
<span class="s2">    puts $output $line</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.8</span>
<span class="s2">#-----------------------------</span>
<span class="s2">for {set i 0} {[gets $fd line] &gt;= 0} {incr i} {</span>
<span class="s2">    if {$desired_line_number == $i} break</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set lines [split [read -nonewline $input] &quot;\n&quot;]</span>
<span class="s2">set line [lindex $lines $desired_line_number]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">proc build_index {data_file index_file} {</span>
<span class="s2">    puts -nonewline $index_file [binary format i 0]</span>
<span class="s2">    while {[gets $data_file line] &gt;= 0} {</span>
<span class="s2">        puts -nonewline $index_file [binary format i [tell $data_file]]</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">proc line_with_index {data_file index_file line_no} {</span>
<span class="s2">    set size [string length [binary format i 0]]</span>
<span class="s2">    set i_offset [expr $size * ($line_no - 1)]</span>
<span class="s2">    seek $index_file $i_offset start</span>
<span class="s2">    if {[tell $index_file] != $i_offset} {</span>
<span class="s2">        error &quot;Did not find $line_no&quot;</span>
<span class="s2">    }</span>
<span class="s2">    set entry [read $index_file $size]</span>
<span class="s2">    binary scan $entry i* d_offset</span>
<span class="s2">    seek $data_file $d_offset start</span>
<span class="s2">    if {[tell $data_file] != $d_offset} {</span>
<span class="s2">        error &quot;Did not find $line_no&quot;</span>
<span class="s2">    }</span>
<span class="s2">    return [gets $data_file]</span>
<span class="s2">}</span>

<span class="s2"># usage</span>
<span class="s2">set dfd [open fortune.dat]</span>
<span class="s2">set ifd [open fortune.dat.index w]</span>
<span class="s2">build_index $dfd $ifd</span>
<span class="s2">close $dfd</span>
<span class="s2">close $ifd</span>

<span class="s2">set dfd [open fortune.dat]</span>
<span class="s2">set ifd [open fortune.dat.index]</span>
<span class="s2">puts [line_with_index $dfd $ifd 90]</span>
<span class="s2">close $dfd</span>
<span class="s2">close $ifd</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># we dont have a tie.</span>
<span class="s2">package require struct::list</span>

<span class="s2">expr {([llength $argv] == 2) || [error &quot;usage: print_line FILENAME</span>
<span class="s2">LINE_NUMBER\n&quot;]}</span>
<span class="s2">::struct::list assign $argv filename linenumber</span>

<span class="s2">set fd [open $filename]</span>
<span class="s2">for {set i 0} {[gets $fd line] &gt;= 0} {incr i} {</span>
<span class="s2">    if {$linenumber == $i} {</span>
<span class="s2">        puts $line</span>
<span class="s2">        exit 0</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">error &quot;Didn&#39;t find line $line_number in $filename\n&quot;</span>

<span class="s2">#-----------------------------</span>
<span class="s2">package require struct::list</span>

<span class="s2">expr {([llength $argv] == 2) || [error &quot;usage: print_line FILENAME LINE_NUMBER\n&quot;]}</span>
<span class="s2">::struct::list assign $argv filename linenumber</span>
<span class="s2">set dfd [open $filename]</span>
<span class="s2">set ifd [open $filename.index]</span>
<span class="s2">build_index $dfd $ifd</span>
<span class="s2">puts [line_with_index $dfd $ifd]</span>

<span class="s2"># @@PLEAC@@_8.9</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set fields [split [regsub -all -- {PATTERN} $record {\0}] &quot;\0&quot;]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fields [split [regsub -all -- {:} $record {\0}] &quot;\0&quot;]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fields [split [regsub -all -- {\s+} $record {\0}] &quot;\0&quot;]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fields [split [regsub -all -- { } $record {\0}] &quot;\0&quot;]</span>

<span class="s2"># @@PLEAC@@_8.10</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set last 0</span>
<span class="s2">while {[gets $fd line] &gt;= 0} {</span>
<span class="s2">    if {![eof $fd]} {</span>
<span class="s2">        set last [tell $fd]</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">chan truncate $fd $last</span>

<span class="s2"># @@PLEAC@@_8.11</span>
<span class="s2">#-----------------------------</span>
<span class="s2">chan configure $handle -translation binary</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set gifname &quot;picture.gif&quot;</span>
<span class="s2">set gif [open $gifname]</span>
<span class="s2">chan configure $gif -translation binary</span>
<span class="s2">chan configure stdout -translation binary</span>
<span class="s2">while {![eof $gif]} {</span>
<span class="s2">    puts -nonewline [read $gif [expr 8 * 2**10]]</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.12</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set addr [expr $recsize * $recno]</span>
<span class="s2">seek $fh $addr start</span>
<span class="s2">set data [read $fh $recsize]</span>
<span class="s2">binary scan $buffer $format field1 field2 #we can not pass a list/array as argument.</span>
<span class="s2">#update fields</span>
<span class="s2">set buffer [binary format $format $field1 $field2]</span>
<span class="s2">seek $fh -$recsize current</span>
<span class="s2">puts -nonewline $fh $buffer</span>
<span class="s2">close $fh</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># setting the login date.</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_8.13</span>
<span class="s2">#-----------------------------</span>
<span class="s2">chan configure $fh -translation binary</span>
<span class="s2">seek $fh $addr start</span>
<span class="s2">set out [read $fh]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">#not optimal. do not use it for large strings.</span>
<span class="s2">proc get_till_null {fh} {</span>
<span class="s2">    set out {}</span>
<span class="s2">    while {![eof $fh]} {</span>
<span class="s2">        set char [read $fh 1]</span>
<span class="s2">        set out &quot;$out$char&quot;</span>
<span class="s2">        if [regexp -- {\0} $char] break</span>
<span class="s2">    }</span>
<span class="s2">    return $out</span>
<span class="s2">}</span>

<span class="s2">foreach addr $addrs {</span>
<span class="s2">    #seek will detect the oct if it is prefixed with &#39;0&#39;.</span>
<span class="s2">    seek $fh $addr start</span>
<span class="s2">    puts [format {%x %o %d &quot;%s&quot;} $addr $addr $addr [get_till_null $fh]]</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">set fh [open $argv]</span>
<span class="s2">chan configure $fh -translation binary</span>
<span class="s2">foreach line [split [read $fh] &quot;\0&quot;] {</span>
<span class="s2">    foreach word [regexp -all -inline -- {[\x20-\x7e]+} $line] {</span>
<span class="s2">        puts $word</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.14</span>
<span class="s2">#-----------------------------</span>
<span class="s2">chan configure $fh -translation binary</span>
<span class="s2">while {![eof $fh]} {</span>
<span class="s2">    set record [read $fh $recordsize]</span>
<span class="s2">    binary scan $data $template field1 field2 field3</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.15</span>
<span class="s2">#-----------------------------</span>
<span class="s2">array set user_preferences {}</span>
<span class="s2">foreach line [split [read -nonewline $fh] &quot;\n&quot;] {</span>
<span class="s2">    regsub -- {#.*$} [string trim $line] {} line</span>
<span class="s2">    if [string length $line] {</span>
<span class="s2">        array set user_preferences [string map {= { }} $line]</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.16</span>
<span class="s2">#-----------------------------</span>
<span class="s2">file stat $filename statinfo</span>
<span class="s2"># statinfo now contains the relevant information.</span>
<span class="s2">foreach var [array names statinfo] {</span>
<span class="s2">    set $var $statinfo($var)</span>
<span class="s2">}</span>
<span class="s2">set mode [expr $mode &amp; 07777]</span>

<span class="s2">#-----------------------------</span>
<span class="s2">file stat $filename statinfo</span>
<span class="s2">if {!$statinfo(uid)) {</span>
<span class="s2">    puts &quot;Superuser owns $filename&quot;</span>
<span class="s2">}</span>
<span class="s2">if {$statinfo(atime) &gt; $statinfo(mtime)} {</span>
<span class="s2">    puts &quot;$filename has been read since it was written.&quot;</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">proc is_safe path {</span>
<span class="s2">    file stat $path info</span>
<span class="s2">    # owner neither su nor me</span>
<span class="s2">    if {$info(uid) &amp;&amp; ![file owned $path]} {</span>
<span class="s2">        return 0</span>
<span class="s2">    }</span>
<span class="s2">    # check if group or other can write file.</span>
<span class="s2">    if {$info(mode) &amp; 022} {</span>
<span class="s2">        if {![file isdirectory $path]} {</span>
<span class="s2">            return 0</span>
<span class="s2">        }</span>
<span class="s2">        if {!($info(mode) &amp; 01000)} {</span>
<span class="s2">            return 0</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">    return 1</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>
<span class="s2">proc is_verysafe path {</span>
<span class="s2">    set build {}</span>
<span class="s2">    foreach elem [file split $path] {</span>
<span class="s2">        set build [file join $build $elem]</span>
<span class="s2">        if {![is_safe $build]} {</span>
<span class="s2">            return 0</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">    return 1</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.17</span>
<span class="s2">#-----------------------------</span>
<span class="s2">#struct tmp {</span>
<span class="s2">#    short ut_type;                 +2      -&gt; s    short</span>
<span class="s2">#                                   +2      -&gt; x2   padding</span>
<span class="s2">#    pid_t ut_pid;                  +4      -&gt; i    int</span>
<span class="s2">#    //alignment                    +20     -&gt; x20  padding</span>
<span class="s2">#    char ut_line[UT_LINESIZE];     +12     -&gt; A12  char</span>
<span class="s2">#    char ut_id[4];                 +4      -&gt; A4   char</span>
<span class="s2">#    char ut_user[UT_NAMESIZE];     +32     -&gt; A32  char</span>
<span class="s2">#    char ut_host[UT_HOSTSIZE];     +256    -&gt; A256 char</span>
<span class="s2">#    struct exit_status ut_exit;    +4      -&gt; x4   skip</span>
<span class="s2">#</span>
<span class="s2">#    long ut_session;               +4      -&gt; x4   skip</span>
<span class="s2">#    struct timeval ut_tv;          +8      -&gt; ii   int</span>
<span class="s2">#    int32_t ut_addr_v6[4];         +16     -&gt; iiii int</span>
<span class="s2">#    char pad[20];                          -&gt; x20  skip</span>
<span class="s2">#};</span>

<span class="s2">set typedef {s x2 i x20 A12 A4 A32 A256 x4 x4 ii iiii x20}</span>
<span class="s2">set sizeof [string length [binary format $typedef 0 0 {} {} {} {} 0 0 0 0 0 0 ]]</span>

<span class="s2">set wtmp [open {/var/log/wtmp}]</span>
<span class="s2">seek $wtmp 0 end</span>
<span class="s2">while 1 {</span>
<span class="s2">        set buffer [read $wtmp $sizeof]</span>
<span class="s2">        binary scan $buffer $typedef type pid line id user host tsec tmsec addr addr2 addr3 addr4</span>
<span class="s2">        scan $user %c ord</span>
<span class="s2">        if {!$user || !$time || !$ord} continue</span>
<span class="s2">        puts &quot;type:$type user:$user uid:$line id:$id host:$host pid:$pid time:[clock format $tval1]&quot;</span>
<span class="s2">        puts [format &quot;-&gt;%u.%u.%u.%u&quot; [expr $addr &amp; 0xff] [expr ($addr &gt;&gt; 8) &amp; 0xff] [expr ($addr &gt;&gt; 16) &amp; 0xff] [expr ($addr &gt;&gt; 24) &amp; 0xff]]</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_8.18</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_8.19</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2">#-----------------------------</span>
<span class="s2"># @@PLEAC@@_9.0</span>
<span class="s2"># feat. Bob Techentin</span>
<span class="s2">#-----------------------------</span>
<span class="s2">if {[catch {file stat /usr/bin/vi entry} err]} {error &quot;Couldn&#39;t stat /usr/bin/vi : $err&quot;}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">if {[catch {file stat /usr/bin entry} err]} {error &quot;Couldn&#39;t stat /usr/bin : $err&quot;}</span>
<span class="s2">#-----------------------------</span>
<span class="s2"># can&#39;t [file stat] a filehandle</span>
<span class="s2">#-----------------------------</span>
<span class="s2">file stat /usr/bin/vi inode</span>
<span class="s2">set ctime $inode(ctime)</span>
<span class="s2">set size $inode(size)</span>

<span class="s2"># or you can use specific [file] subcommands</span>
<span class="s2">set size [file size /usr/bin/vi]</span>
<span class="s2">#-----------------------------</span>
<span class="s2">#  You have to read the file to test for binary data</span>
<span class="s2">if {![catch {open $filename r} F]} {</span>
<span class="s2">	set data [read $F]</span>
<span class="s2">	close $F</span>
<span class="s2">	if {![string is ascii $data]} {</span>
<span class="s2">		error &quot;$filename doesn&#39;t have text in it.&quot;</span>
<span class="s2">	}</span>
<span class="s2">} else {</span>
<span class="s2">	error &quot;Opening $filename: $F&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set files [glob /usr/bin/*]</span>
<span class="s2">foreach f $files {</span>
<span class="s2">    puts &quot;Inside /usr/bin is something called [file tail $f]&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@PLEAC@@_9.1</span>
<span class="s2"># feat. Bob Techentin</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set READTIME [file atime $filename]</span>
<span class="s2">set WRITETIME [file mtime $filename]</span>

<span class="s2">file atime $filename $NEWREADTIME</span>
<span class="s2">file mtime $filename $NEWWRITETIME</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set atime [file atime $filename]</span>
<span class="s2">set mtime [file mtime $filename]</span>

<span class="s2">set atime [clock scan &quot;- 1 week&quot; -base $atime]</span>
<span class="s2">set mtime [clock scan &quot;- 1 week&quot; -base $mtime]</span>

<span class="s2">if {[catch {</span>
<span class="s2">	file atime $filename $atime</span>
<span class="s2">	file mtime $filename $mtime</span>
<span class="s2">} err]} {</span>
<span class="s2">	error &quot;couldn&#39;t backdate $filename by a week w/ file (a|m)time: $err&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">file atime $file [clock seconds]</span>
<span class="s2">#-----------------------------</span>
<span class="s2">#!/bin/sh</span>
<span class="s2"># uvi - vi a file without changing its access times</span>
<span class="s2"># the next line restarts using tclsh \</span>
<span class="s2">exec tclsh &quot;$0&quot; &quot;$@&quot;</span>
<span class="s2">if {[llength $argv] != 1} {</span>
<span class="s2">	error &quot;usage: uvi filename&quot;</span>
<span class="s2">}</span>
<span class="s2">set file [lindex $argv 0]</span>
<span class="s2">file stat $file statinfo</span>
<span class="s2">if {[info exists env(EDITOR)]} {</span>
<span class="s2">	exec $env(EDITOR) $file</span>
<span class="s2">} else {</span>
<span class="s2">	exec vi $file</span>
<span class="s2">}</span>
<span class="s2">file atime $file $statinfo(atime)</span>
<span class="s2">file mtime $file $statinfo(mtime)</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@PLEAC@@_9.2</span>
<span class="s2"># feat. Bob Techentin</span>
<span class="s2">#-----------------------------</span>
<span class="s2">file delete $filename</span>
<span class="s2">eval file delete $filenames</span>
<span class="s2">#-----------------------------</span>
<span class="s2">if {[catch {file delete $file}]} {</span>
<span class="s2">	error &quot;Can&#39;t unlink $file&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2">#  Tcl&#39;s [file delete] command doesn&#39;t return a count,</span>
<span class="s2">#  so we have to count files before and after deletion.</span>
<span class="s2">set existing 0</span>
<span class="s2">foreach f $filelist {</span>
<span class="s2">	if {[file exists $f]} {incr existing}</span>
<span class="s2">}</span>
<span class="s2">catch {eval file delete $filelist}</span>
<span class="s2">set remaining 0</span>
<span class="s2">foreach f $filelist {</span>
<span class="s2">	if {[file exists $f]} {incr remaining}</span>
<span class="s2">}</span>
<span class="s2">if {$remaining &gt; 0} {</span>
<span class="s2">	set count [expr {$existing-$remaining}]</span>
<span class="s2">	puts stderr &quot;could only delete $count of $existing files&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@PLEAC@@_9.2</span>
<span class="s2"># feat. Bob Techentin</span>
<span class="s2">#-----------------------------</span>
<span class="s2">file delete $filename</span>
<span class="s2">eval file delete $filenames</span>
<span class="s2">#-----------------------------</span>
<span class="s2">if {[catch {file delete $file}]} {</span>
<span class="s2">	error &quot;Can&#39;t unlink $file&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2">if {[catch {eval file delete $filelist}]} {</span>
<span class="s2">	set remaining 0</span>
<span class="s2">	foreach f $filelist {</span>
<span class="s2">		if {[file exists $f]} {incr remaining}</span>
<span class="s2">	}</span>
<span class="s2">	set count [expr {[llength $filelist] - $remaining}]</span>
<span class="s2">	puts stderr &quot;could only delete $count of $existing files&quot;</span>
<span class="s2">}</span>
<span class="s2">#  Tcl&#39;s [file delete] command doesn&#39;t return a count,</span>
<span class="s2">#  so we have to count files before and after deletion.</span>
<span class="s2">set existing 0</span>
<span class="s2">foreach f $filelist {</span>
<span class="s2">	if {[file exists $f]} {incr existing}</span>
<span class="s2">}</span>
<span class="s2">catch {eval file delete $filelist}</span>
<span class="s2">set remaining 0</span>
<span class="s2">foreach f $filelist {</span>
<span class="s2">	if {[file exists $f]} {incr remaining}</span>
<span class="s2">}</span>
<span class="s2">if {$remaining &gt; 0} {</span>
<span class="s2">	set count [expr {$existing-$remaining}]</span>
<span class="s2">	puts stderr &quot;could only delete $count of $existing files&quot;</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@PLEAC@@_9.3</span>
<span class="s2"># feat. Bob Techentin</span>
<span class="s2">#-----------------------------</span>
<span class="s2">file copy $oldfile $newfile</span>
<span class="s2">#-----------------------------</span>
<span class="s2">if {[catch {open $oldfile &quot;r&quot;} IN]}  {error &quot;can&#39;t open $oldfile: $IN&quot;}</span>
<span class="s2">if {[catch {open $newfile &quot;w&quot;} OUT]} {error &quot;can&#39;t open $newfile: $OUT&quot;}</span>

<span class="s2">set blksize [fconfigure $IN -buffersize]</span>
<span class="s2">fcopy $IN $OUT -size $blksize</span>
<span class="s2">close $IN</span>
<span class="s2">close $OUT</span>

<span class="s2">#-----------------------------</span>
<span class="s2">#  Tcl file operations are portable</span>
<span class="s2">file copy $oldfile $newfile</span>
<span class="s2">#-----------------------------</span>
<span class="s2">file copy datafile.dat datafile.bak</span>
<span class="s2">file rename -force datafile.new datafile.dat</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@PLEAC@@_9.4</span>
<span class="s2"># feat. Bob Techentin</span>
<span class="s2">#-----------------------------</span>

<span class="s2">unset seen</span>
<span class="s2">foreach filename $argv {</span>
<span class="s2">	file stat $filename statinfo</span>
<span class="s2">	set dev $statinfo(dev)</span>
<span class="s2">	set ino $statinfo(ino)</span>
<span class="s2">	if {![info exists seen($dev,$ino)]} {</span>
<span class="s2">		#  do something with $filename because</span>
<span class="s2">		#  we haven&#39;t seen it before</span>

<span class="s2">		lappend seen($dev,$ino) $filename</span>
<span class="s2">		#  seen($dev,$ino) is a list of filenames for the same file</span>
<span class="s2">	}</span>
<span class="s2">}</span>

<span class="s2">#-----------------------------</span>

<span class="s2"># @@PLEAC@@_9.5</span>
<span class="s2"># feat. Bob Techentin</span>
<span class="s2">#-----------------------------</span>
<span class="s2">foreach file [glob [file join $dirname &quot;*&quot;]] {</span>
<span class="s2">	# do something with $file</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">set dir /usr/local/bin</span>
<span class="s2">puts &quot;Text files in $dir are:&quot;</span>
<span class="s2">foreach file [glob [file join $dir &quot;*&quot;]] {</span>
<span class="s2">	set fp [open $file &quot;r&quot;]</span>
<span class="s2">	if {[string is ascii [read $fp]]} {</span>
<span class="s2">		puts $file</span>
<span class="s2">	}</span>
<span class="s2">	close $fp</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">foreach file [glob [file join $dir &quot;*&quot;]] {</span>
<span class="s2">	if {$file eq &quot;..&quot; || $file eq &quot;.&quot;} continue</span>
<span class="s2">	# ...</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>
<span class="s2">proc plainfiles {dir} {</span>
<span class="s2">	set result [list]</span>
<span class="s2">	foreach file [lsort [glob [file join $dir &quot;*&quot;]]] {</span>
<span class="s2">		if {[string index [file tail $file] 0] eq &quot;.&quot;} continue</span>
<span class="s2">		if {[file type $file] eq &quot;file&quot;} {</span>
<span class="s2">			lappend result $file</span>
<span class="s2">		}</span>
<span class="s2">	}</span>
<span class="s2">	return $result</span>
<span class="s2">}</span>
<span class="s2">#-----------------------------</span>

<span class="s2"># @@PLEAC@@_9.6</span>
<span class="s2"># List of regular files in current directory - file names only in list</span>
<span class="s2">set files [glob -nocomplain -type f -- *.c]</span>

<span class="s2"># -------------</span>

<span class="s2"># As above, but with full path</span>
<span class="s2">set files [glob -directory [pwd] -nocomplain -type f -- *.c]</span>

<span class="s2"># -------------</span>

<span class="s2"># As previous [which is more compact, so preferred], showing use of &#39;file&#39; to build file names</span>
<span class="s2">set pwd [pwd] ; set files [glob -nocomplain -type f -- *.c]</span>

<span class="s2"># Assemble full path names from list entries</span>
<span class="s2">foreach f $files {</span>
<span class="s2">  puts [file nativename [file join &quot;$pwd&quot; &quot;$f&quot;]]</span>
<span class="s2">}</span>

<span class="s2"># -------------</span>

<span class="s2"># Variants of the *NIX, &#39;find&#39;, command from the &#39;fileutil&#39; package</span>
<span class="s2">package require fileutil</span>

<span class="s2"># Set search path to current directory. Could have also have used either of ~,</span>
<span class="s2"># for the user&#39;s HOME directory, or a relative / absolute path</span>
<span class="s2">set path .</span>

<span class="s2"># -----</span>

<span class="s2"># 1. Similar to, &#39;glob&#39;, but also allows &#39;regexp&#39;-based globbing</span>
<span class="s2">set files [fileutil::findByPattern $path -glob -- *.c]</span>

<span class="s2"># -----</span>

<span class="s2"># 2. Makes use of a &#39;filter&#39; procedure</span>
<span class="s2">proc is_c {name} { return [string match *.c $name] }</span>

<span class="s2">set files [fileutil::find $path is_c]</span>

<span class="s2"># -----</span>

<span class="s2"># In both cases:</span>
<span class="s2"># * Search is recursive</span>
<span class="s2"># * Full path names printed</span>
<span class="s2">foreach f $files {</span>
<span class="s2">  puts $f</span>
<span class="s2">}</span>

<span class="s2"># -----------------------------</span>

<span class="s2"># Two lists generated, first one filtered by file extension, second one by file type</span>
<span class="s2">package require fileutil</span>

<span class="s2">proc is_c_or_h {name} { return [string match -nocase *.\[ch\] $name] }</span>

<span class="s2">set path . ; set files [fileutil::find $path is_c_or_h]</span>

<span class="s2">foreach f $files {</span>
<span class="s2">  if {[string match &quot;text&quot; [fileutil::fileType $f]]} { lappend textfiles $f }</span>
<span class="s2">}</span>

<span class="s2">foreach f $textfiles {</span>
<span class="s2">  puts $f</span>
<span class="s2">}</span>

<span class="s2"># -------------</span>

<span class="s2"># As above, but both file extension and file type considered in filter procedure, so</span>
<span class="s2"># only a single list is generated</span>
<span class="s2">package require fileutil</span>

<span class="s2">proc is_c_or_h_and_text {name} {</span>
<span class="s2">  if {[string match -nocase *.\[ch\] $name] &amp;&amp; ![catch {fileutil::fileType $name} filetype]} {</span>
<span class="s2">    return [expr [string compare &quot;text&quot; $filetype] == 0]</span>
<span class="s2">  }</span>
<span class="s2">  return 0</span>
<span class="s2">}</span>

<span class="s2">set path . ; set files [fileutil::find $path is_c_or_h_and_text]</span>

<span class="s2">foreach f $files {</span>
<span class="s2">  puts $f</span>
<span class="s2">}</span>

<span class="s2"># -----------------------------</span>

<span class="s2"># Sorted list of all subdirectories in the current directory which commence with the</span>
<span class="s2"># digits 0-9</span>
<span class="s2">set dirs [lsort [glob -directory [pwd] -nocomplain -type d -- \[0-9\]*]]</span>

<span class="s2"># @@PLEAC@@_9.7</span>
<span class="s2"># Minimal-code approach to this problem is to generate a list of paths using the</span>
<span class="s2"># &#39;find&#39; or &#39;findByPattern&#39; commands of the &#39;fileutil&#39; package, then traverse that</span>
<span class="s2"># list processing each file in turn. A variation is to write a filter procedure for</span>
<span class="s2"># &#39;find&#39; that processes each selected file whilst still retaining its expected </span>
<span class="s2"># behaviour. Whilst the latter is likely to be better-performing, it isn&#39;t generally</span>
<span class="s2"># recommended to have a filter procedure possess side-effecting behaviour</span>

<span class="s2">package require fileutil</span>

<span class="s2"># Conventional filter procedures for use with, fileutil::find</span>
<span class="s2">proc is_dir {name} { return [expr [fileutil::test $name {d}] != 0] }</span>

<span class="s2"># -----</span>

<span class="s2"># Generate list of directories in a directory</span>
<span class="s2">set path . ; set files [fileutil::find $path is_dir]</span>

<span class="s2"># -------------</span>

<span class="s2"># Side-effecting filter procedures</span>
<span class="s2">proc accum_filesize {name} {</span>
<span class="s2">  global filesize</span>
<span class="s2">  if [fileutil::test $name {f}] { set filesize [expr $filesize + [file size $name]] }</span>
<span class="s2">  return 0</span>
<span class="s2">}</span>

<span class="s2">proc biggest_file {name} {</span>
<span class="s2">  global biggest</span>
<span class="s2">  if {[fileutil::test $name {f}] &amp;&amp; [file size $name] &gt; $biggest} {</span>
<span class="s2">    set biggest [file size $name]</span>
<span class="s2">  }</span>
<span class="s2">  return 0</span>
<span class="s2">}</span>

<span class="s2">proc youngest_file {name} {</span>
<span class="s2">  global youngest</span>
<span class="s2">  if {[fileutil::test $name {f}] &amp;&amp; [file mtime $name] &lt; $youngest} {</span>
<span class="s2">    set youngest [file mtime $name]</span>
<span class="s2">  }</span>
<span class="s2">  return 0</span>
<span class="s2">}</span>

<span class="s2"># -----</span>

<span class="s2"># Obtain total size of all files in a directory and its subdirectories</span>
<span class="s2">set path . ; set filesize 0 ; set files [fileutil::find $path accum_filesize]</span>
<span class="s2">puts $filesize</span>

<span class="s2"># Find biggest size file in a directory and its subdirectories</span>
<span class="s2">set path . ; set biggest 0 ; set files [fileutil::find $path biggest_file]</span>
<span class="s2">puts $biggest</span>

<span class="s2"># Find most recent file in a directory and its subdirectories</span>
<span class="s2">set youngest 2147483647 ; set files [fileutil::find $path youngest_file]</span>
<span class="s2">puts [clock format $youngest -format %D]</span>

<span class="s2"># Alternatively, one could implement a procedure that actually recurses through</span>
<span class="s2"># directories performing required processing. One approach would see the intermixing</span>
<span class="s2"># of recursing and processing code; another would see a generic recursing procedure</span>
<span class="s2"># passed the name of a processing procedure which is then applied to each selected</span>
<span class="s2"># file via the &#39;eval&#39; command. The latter approach has the advanatage of being flexible,</span>
<span class="s2"># though performance is hampered due to the use of &#39;eval&#39;; the former approach is more</span>
<span class="s2"># &#39;one-shot&#39;, but most likely, better performing</span>

<span class="s2">proc processDirectory {baseDir proc} {</span>
<span class="s2">  set pwd [pwd] ; if [catch {cd $baseDir} result] { return }</span>

<span class="s2">  foreach dir [glob -nocomplain -type d -- *] {</span>
<span class="s2">    processDirectory $dir $proc</span>
<span class="s2">  }</span>

<span class="s2">  eval &quot;$proc [pwd]&quot; ; cd $pwd</span>
<span class="s2">}</span>

<span class="s2"># -------------</span>

<span class="s2">proc show {dir} { puts $dir }</span>

<span class="s2">proc accum_filesize {dir} {</span>
<span class="s2">  global filesize</span>
<span class="s2">  foreach file [glob -directory $dir -nocomplain -type f -- *] {</span>
<span class="s2">    set filesize [expr $filesize + [file size $file]]</span>
<span class="s2">  }</span>
<span class="s2">}</span>

<span class="s2">proc biggest_file {dir} {</span>
<span class="s2">  global biggest</span>
<span class="s2">  foreach file [glob -directory $dir -nocomplain -type f -- *] {</span>
<span class="s2">    if {[file size $file] &gt; $biggest} { set biggest [file size $file]}</span>
<span class="s2">  }</span>
<span class="s2">}</span>

<span class="s2">proc youngest_file {dir} {</span>
<span class="s2">  global youngest</span>
<span class="s2">  foreach file [glob -directory $dir -nocomplain -type f -- *] {</span>
<span class="s2">    if {[file mtime $file] &lt; $youngest} { set youngest [file mtime $file]}</span>
<span class="s2">  }</span>
<span class="s2">}</span>

<span class="s2"># -------------</span>

<span class="s2"># Obtain total size of all files in a directory and its subdirectories</span>
<span class="s2">set filesize 0 ; processDirectory [pwd] &quot;accum_filesize&quot; ; puts $filesize</span>

<span class="s2"># Find biggest size file in a directory and its subdirectories</span>
<span class="s2">set biggest 0 ; processDirectory [pwd] &quot;biggest_file&quot; ; puts $biggest</span>

<span class="s2"># Find most recent file in a directory and its subdirectories</span>
<span class="s2">set youngest 2147483647 ; processDirectory [pwd] &quot;youngest_file&quot;</span>
<span class="s2">puts [clock format $youngest -format %D]</span>

<span class="s2"># -----------------------------</span>

<span class="s2"># Generate list of directories in a list of directories</span>

<span class="s2">if {$argc &lt; 1} { puts stderr &quot;usage: $argv0 dir...&quot; ; exit 1 }</span>

<span class="s2">foreach dirname $argv {</span>
<span class="s2">  processDirectory $dirname &quot;show&quot;</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_9.8</span>
<span class="s2"># The &#39;file delete&#39; command can:</span>
<span class="s2"># * Delete both files and subdirectories</span>
<span class="s2"># * Recursively delete the latter</span>
<span class="s2"># Therefore, it is not necessary to construct a tree-traversing [recursive or otherwise]</span>
<span class="s2"># procedure in order to remove a directory tree. It may be, however, useful to use such</span>
<span class="s2"># an approach should it be necessary to implement special processing [e.g. interactive</span>
<span class="s2"># prompting]. The use of a custom procedure that intermixes recursing and processing code</span>
<span class="s2"># [as shown in the previous section] is probably the simplest, best performing approach,</span>
<span class="s2"># to this latter task.</span>

<span class="s2"># &#39;rmtree1&#39; - straightforward implementation </span>

<span class="s2">if {$argc &lt; 1} { puts stderr &quot;usage: $argv0 dir...&quot; ; exit 1 }</span>

<span class="s2">foreach dirname $argv {</span>
<span class="s2">  if [catch {file delete -force -- $dirname} result] {</span>
<span class="s2">    puts &quot;Error deleting $dirname \[$result\]&quot;</span>
<span class="s2">  }</span>
<span class="s2">}</span>

<span class="s2"># -----------------------------</span>

<span class="s2"># &#39;rmtree2&#39; - recursive, tree-traversing implementation </span>

<span class="s2"># Recurser - recursively traverses directory tree</span>
<span class="s2">proc rmtree_ {baseDir} {</span>
<span class="s2">  set pwd [pwd] ; if [catch {cd $baseDir} result] { return }</span>

<span class="s2">  foreach dir [glob -nocomplain -type d -- *] {</span>
<span class="s2">    rmtree_ $dir</span>
<span class="s2">  }</span>

<span class="s2">  # Let&#39;s delete the regular files in, &#39;baseDir&#39;</span>
<span class="s2">  foreach filename [glob -nocomplain -type f -- *] {</span>
<span class="s2">    if [catch {file delete -force -- $filename} result] {</span>
<span class="s2">      puts &quot;Error deleting $filename \[$result\]&quot;</span>
<span class="s2">    }</span>
<span class="s2">  }</span>

<span class="s2">  # Let&#39;s move up, out of, &#39;baseDir&#39;, so as to allow it&#39;s deletion</span>
<span class="s2">  cd $pwd</span>

<span class="s2">  # Let&#39;s delete, &#39;baseDir&#39;</span>
<span class="s2">  set dirname [file join $pwd $baseDir]</span>

<span class="s2">  if [catch {file delete -force -- $dirname} result] {</span>
<span class="s2">    puts &quot;Error deleting $dirname \[$result\]&quot;</span>
<span class="s2">  }</span>
<span class="s2">}</span>

<span class="s2"># -----</span>

<span class="s2"># Launcher - performs validation, then starts recursive routine</span>
<span class="s2">proc rmtree {baseDir} {</span>
<span class="s2">  if {![file exists $baseDir]} {</span>
<span class="s2">    puts stderr &quot;Directory does not exist&quot; ; return</span>
<span class="s2">  }</span>

<span class="s2">  if [string match $baseDir* [pwd]] {</span>
<span class="s2">    puts stderr &quot;Cannot remove current directory or its parent&quot; ; return</span>
<span class="s2">  }</span>

<span class="s2">  # Validation passed, so start recursing through subdirectories </span>
<span class="s2">  return [rmtree_ $baseDir]</span>
<span class="s2">}</span>

<span class="s2"># -------------</span>

<span class="s2">if {$argc &lt; 1} { puts stderr &quot;usage: $argv0 dir...&quot; ; exit 1 }</span>

<span class="s2">foreach dirname $argv {</span>
<span class="s2">  rmtree $dirname</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_9.9</span>
<span class="s2">set names [list x y z]</span>

<span class="s2">foreach file $names {</span>
<span class="s2">  # This deliberately atempts to rename an existing file to it&#39;s own, same name,</span>
<span class="s2">  # thus forcing an error [unless the -force option is used]</span>
<span class="s2">  set newname file</span>

<span class="s2">  # Error display mimics Perl example</span>
<span class="s2">  ## if [catch {file rename $file $newname} result] {</span>
<span class="s2">  ##   puts stderr &quot;Couldn&#39;t rename $file to $newname&quot;</span>
<span class="s2">  ## }</span>

<span class="s2">  # However, approach shown here is preferable as it furnishes more relevant</span>
<span class="s2">  # diagnostic message(s)</span>
<span class="s2">  if [catch {file rename $file $newname} result] {</span>
<span class="s2">    puts stderr $result</span>
<span class="s2">  }</span>
<span class="s2">}</span>

<span class="s2"># -----------------------------</span>

<span class="s2">#</span>
<span class="s2"># A modified implementation of Larry&#39;s Filename Fixer. Rather than passing</span>
<span class="s2"># a single expression, a &#39;from&#39; regexp is passed; each match in the file</span>
<span class="s2"># name(s) is changed to the value of &#39;to&#39;. It otherwise behaves the same</span>
<span class="s2"># </span>
<span class="s2">if {$argc &lt; 2} { puts stderr &quot;usage: $argv0 from to \[files...\]&quot; ; exit 1 }</span>

<span class="s2">set from [lrange $argv 0 0] ; set to [lrange $argv 1 1]</span>
<span class="s2">set argv [lrange $argv 2 [llength $argv]]</span>

<span class="s2">if {$argv == {}} {</span>
<span class="s2">  while {[gets stdin line] &gt;= 0} {lappend argv $line}</span>
<span class="s2">} </span>

<span class="s2">foreach f $argv {</span>
<span class="s2">  set was $f ; regsub $from $f $to file</span>
<span class="s2">  if {[string compare $was $file] != 0} {</span>
<span class="s2">    if [catch {file rename $was $file} result] {</span>
<span class="s2">      puts stderr $result</span>
<span class="s2">    }</span>
<span class="s2">  }</span>
<span class="s2">}</span>

<span class="s2"># @@PLEAC@@_9.10</span>
<span class="s2">set path {/usr/lib/libc.a}</span>

<span class="s2"># -----</span>

<span class="s2">set basename [file tail $path]</span>
<span class="s2">set dirname [file dirname $path]</span>

<span class="s2"># No equivalent to Perl&#39;s, &#39;fileparse&#39;, so must do:</span>
<span class="s2">set base [file tail $path]</span>
<span class="s2">set dir [file dirname $path]</span>
<span class="s2">set ext [file extension $path]</span>

<span class="s2"># -------------</span>

<span class="s2">set path {/usr/lib/libc.a}</span>

<span class="s2"># -----</span>

<span class="s2">set file [file tail $path]</span>
<span class="s2">set dir [file dirname $path]</span>

<span class="s2">puts &quot;dir is $dir, file is $file&quot;</span>

<span class="s2"># -----</span>

<span class="s2">set name [file tail $path]</span>
<span class="s2">set dir [file dirname $path]</span>
<span class="s2">set ext [file extension $path]</span>

<span class="s2">puts &quot;dir is $dir, name is $name, extension is $ext&quot;</span>

<span class="s2"># -------------</span>

<span class="s2"># According to the Tcl documentation, the &#39;file&#39; command is platform-independant, so</span>
<span class="s2"># should correctly work for platforms such as MacOS. Code below assumes this, but is</span>
<span class="s2"># otherwise untested</span>
<span class="s2">set path {Hard%20Drive:System%20Folder:README.txt}</span>

<span class="s2"># -----</span>

<span class="s2">set name [file tail $path]</span>
<span class="s2">set dir [file dirname $path]</span>
<span class="s2">set ext [file extension $path]</span>

<span class="s2">puts &quot;dir is $dir, name is $name, extension is $ext&quot;</span>

<span class="s2"># @@PLEAC@@_9.11</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_9.12</span>
<span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span>

<span class="s2"># @@PLEAC@@_10.1</span>


<span class="s2"># Subroutines in Tcl are created with the [proc] command,</span>
<span class="s2"># which takes a list of formal parameters as its second</span>
<span class="s2"># argument.</span>
<span class="s2">         </span>
<span class="s2"># On activation, the parameters are bound to the &quot;words&quot;</span>
<span class="s2"># of the call (which may contain data, variable/subroutine</span>
<span class="s2"># names, executable expressions, etc).  This is a variant</span>
<span class="s2"># of call-by-name semantics.</span>



<span class="s2">proc hypotenuse {x y} {</span>
<span class="s2">   return [expr {sqrt($x*$x+$y*$y)}]   ;# Better still: use hypot()</span>
<span class="s2">}</span>
<span class="s2">set diag [hypotenuse 3 4]</span>
<span class="s2"># =&gt; 5.0</span>


<span class="s2"># Subroutines may have a variable number of </span>
<span class="s2"># arguments, by using the special argument &quot;args&quot;:</span>


<span class="s2">proc hypotenuse args {</span>
<span class="s2">   foreach {x y} $args break</span>
<span class="s2">   return [expr {hypot($x, $y)}]</span>
<span class="s2">}</span>


<span class="s2"># A subroutine can be applied to a list using [eval],</span>
<span class="s2"># which concatenates and then executes its arguments.</span>


<span class="s2">set a [list 3 4]</span>
<span class="s2">eval hypotenuse $a</span>
<span class="s2"># =&gt; 5.0</span>


<span class="s2"># It is possible to create local references</span>
<span class="s2"># to variables in other stack frames using</span>
<span class="s2"># [upvar], so the typical idiom for</span>
<span class="s2"># pass-by-reference is to pass the variable&#39;s</span>
<span class="s2"># name as argument, and [upvar] it:</span>


<span class="s2">set nums [list 1.4 3.5 6.7]</span>
<span class="s2">proc trunc-em {name} {</span>
<span class="s2">    upvar $name a</span>
<span class="s2">    set len [llength $a]</span>
<span class="s2">    for {set i 0} {$i &lt; $len} {incr i} {</span>
<span class="s2">        lset a $i [expr {int([lindex $a $i])}]</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">trunc-em nums</span>
</pre></div>
</body>
</html>
