<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Packages, Libraries, and Modules</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-REXX "
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="References and Records"
HREF="referencesandrecords.html"><LINK
REL="NEXT"
TITLE="Classes, Objects, and Ties"
HREF="classesetc.html"></HEAD
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-REXX </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="referencesandrecords.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="classesetc.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PACKAGESETC"
>12. Packages, Libraries, and Modules</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN642"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* A REXX program is just a sequence of instructions residing in a    */
/* file. It may pass control to labelled blocks of code residing in   */
/* the same file [internal subroutines], as well as to other REXX     */
/* programs which, in this context, are known as external subroutines.*/
/* Things worth noting:                                               */
/*                                                                    */
/* * REXX possesses no formal notion of the module / package concept; */
/*   each program is a standalone, totally independant entity with no */
/*   program being able to - directly - access the contents of another*/
/*   program                                                          */
/*                                                                    */
/* * The name of a REXX program plays no part in naming or otherwise  */
/*   identifying any of that program's contents. Thus, there is also  */
/*   no notion of namespace, nor is it possible to create an alias for*/
/*   an existing entity. Each subroutine used in a program must be    */
/*   named so as to be uniquely identifiable                          */
/*                                                                    */
/* * REXX possesses no pre-processing facility, thus conditional code */
/*   inclusion [e.g. debugging code, code from other source files]    */
/*   is not possible                                                  */
/*                                                                    */
/* The lack of a module/package system may be of concern to some, just*/
/* as a lack of pre-processing facility may be to others. However, it */
/* should be remembered that REXX was designed to be an easy-to-use,  */
/* general purpose, end-user tool, one which would facilitate the     */
/* creation of simple scripts such as those for one-off tasks or for  */
/* tying together several applications. Key to ensuring its achieving */
/* this goal is to keep the language simple, and facilities offered   */
/* quite minimal. Put simply, REXX was not intended for large-scale,  */
/* team-based development, so does not offer facilities which cater   */
/* to this.                                                           */
/*                                                                    */
/* Of course it is possible to implement such functionality, though of*/
/* course it would not be as 'clean', and sophisticated as would the  */
/* equivalent native facility:                                        */
/*                                                                    */
/* * A compilation step could be introduced using an an external pre- */
/*   processor [e.g. third-party package like 'm4' or a script written*/
/*   in REXX or other tool like 'awk']. This would allow conditional  */
/*   code inclusion in the same way it is achieved in C using #define */
/*   and #include.                                                    */
/*                                                                    */
/* * Use the filesystem [e.g. directories / folders] to act as module */
/*   or packages in much the same way it is done in Perl and Java     */
/*                                                                    */
/* * Package a REXX file as a module [i.e. collection of subroutines],*/
/*   and adopt the convention of invoking a particular subroutine when*/
/*   the 'module' [invoked as an external subroutine] is accessed     */
/*                                                                    */
/* These techniques will be described in the relevant sections. The   */
/* third approach - REXX file as module - will be used in all the     */
/* sections where Perl package / module use is made. However, given   */
/* the very significant differences between REXX and Perl, these, and */
/* other examples will differ from the original cookbook code.        */
/*                                                                    */
/* Finally, related to the idea of modules, is REXX support for ext-  */
/* ernal libraries [i.e. collections of machine code routines]. These */
/* cannot be considered true modules because they are not part of the */
/* core language. However, their use is key to extending REXX funct-  */
/* ionality, so it is important to understand how they are used. As   */
/* the examples will show they are managed in a manner quite like     */
/* Perl modules.                                                      */
/* ------------------------------------------------------------------ */

/*
   The first Perl example ['Alpha / Omega'] illustrates how a 'package'
   can be created 'on the fly'. Inapplicable to REXX.
*/

/* ----------------------------- */

/*
   The second Perl example illustrates both the compile-time and run-
   tie loading of packages / modules. Neither applies to REXX; the
   closest equivalent is to check for the availability of a REXX file
*/

/* Run-time availability check i.e. ensure 'FileHandle.rexx' exists */
available = require(&quot;FileHandle.rexx&quot;)
available = require(&quot;FileHandle&quot;)

if available then ; say &quot;'FileHandle' package is available&quot;
else ; say &quot;'FileHandle' package *NOT* available&quot;

/* ----------- */

available = require(&quot;Cards/Poker.rexx&quot;)

if available then ; say &quot;'Cards/Poker' package is available&quot;
else ; say &quot;'Cards/Poker' package *NOT* available&quot;

/* ----------------------------- */

/*
   Rough outline of how a REXX file might be stuctured to play the
   role of a 'module'. Example is roughly functionally equivalent to
   the Perl example
*/

/* Contents of file, 'Poker.rexx' located in 'Cards' directory */

/*

  /* Module Name */
  _modname = &quot;Poker&quot;
  ...

  /* Method List [i.e. exports] */
  _methods = &quot;shuffle getCardDeck setCardDeck&quot;
  ...

  /* Method Implementations */
  shuffle : procedure ...
  getCardDeck : procedure ...
  setCardDeck : procedure ...
  ...

*/</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN645"
>Defining a Module's Interface</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* Since REXX does not support modules this issue is moot. However an */
/* outline of how to implement a 'REXX file as module' is shown; in   */
/* the current section an outline of how to structure, then use, one  */
/* is provided, whilst a complete implementation [and example of use] */
/* appears in the second last section of this chapter.                */
/*                                                                    */
/* Implementing a 'module' system in REXX is actually quite simple. It*/
/* makes use of some key REXX features:                               */
/*                                                                    */
/* * A source file is self-contained: all contents are private to that*/
/*   file, thus making it an ideal vehicle for acting as a 'module'   */
/*                                                                    */
/* * A source file is callable as an external subroutine, and is able */
/*   to accept arguments, and return result(s) to the caller          */
/*                                                                    */
/* * The INTERPRET instruction allows for the evaluation of arbitrary */
/*   strings as code. Therefore, it is possible to pass the name of a */
/*   subroutine, and any arguments it might require, to a subroutine  */
/*   and have *that* subroutine execute                               */
/*                                                                    */
/* as well as requiring an adherence to certain conventions:          */
/*                                                                    */
/* * Module data access must be via 'accessor' subroutines and updates*/
/*   via 'mutator' subroutines                                        */
/*                                                                    */
/* * Module subroutine calls are via argument passing to module file  */
/*   calls                                                            */
/*                                                                    */
/* * Module data is stored via some 'persistence' mechanism [since a  */
/*   module is really a REXX subroutine, data is destroyed on exit;   */
/*   any data needing to be retained needs to be externally stored]   */
/*                                                                    */
/* * Metadata such as the module name, version, and perhaps list of   */
/*   subroutines [and optionally associated descriptions] be kept as  */
/*   module data [and suitable accessors provided]                    */
/*                                                                    */
/* All these ideas appear in the module example in the second last    */
/* section of this chapter.                                           */
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN648"
>Trapping Errors in require or use</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* REXX lack of module support makes it unnecessary for it to offer   */
/* facilities / keywords like Perl's 'require' or 'use'. If a native  */
/* REXX subroutine is to be invoked [particularly an internal routine]*/
/* it is simply assumed to exist. Calling a non-existent routine will */
/* raise a SYNTAX condition which can, of course, be trapped, but this*/
/* approach is rarely worth the trouble as it merely complicates the  */
/* application design [an extensive example is in &lt;&lt;PLEAC&gt;&gt;_10.15].   */
/*                                                                    */
/* Invoking an external subroutine assumes that it resides in a known */
/* location, thus a check for its presence can be made prior to the   */
/* call, and appropriate recovery steps taken [i.e. look for it else- */
/* where, generate the required code, etc ...]. This is, in effect,   */
/* an implementation of 'require'-like functionality. The example in  */
/* the previous section well-illustrates the use of the custom routine*/
/* 'require', for this task, as well as how module information may be */
/* obtained [though a simple example also appears below].             */
/*                                                                    */
/* A run-time facility akin to module use is the loading / registering*/
/* of external library functions [i.e. machine code routines residing */
/* in shared library files]. REXX sports a complete API for handling  */
/* such entities, including the ability to test whether any such have */
/* been correctly loaded.                                             */
/*                                                                    */
/* Library loading is actually a two-step process:                    */
/*                                                                    */
/* * Loading the library file [i.e. shared library / DLL]             */
/* * Loading the desired function [a step repeated for each function] */
/*                                                                    */
/* A convention has been adopted for such libraries in which both a   */
/* a loader [of all functions] and an unloader function are provided  */
/* to facilitate library function handling. The example below shows   */
/* their use.                                                         */
/*                                                                    */
/* Another means of trapping 'module' errors is to introduce a kind of*/
/* 'compilation step', something easily achieved via the use of a pre-*/
/* processor. For example, one could adopt the convention that a line */
/* such as:                                                           */
/*                                                                    */
/*    #include &quot;myModule.rexx&quot;                                        */
/*                                                                    */
/* would see a search for the relevant file made, and its contents    */
/* inlined starting at that location. Failure to locate and include   */
/* the 'module' would see a 'complation' error signalled, and remedial*/
/* steps taken. Needless to say, the pre-processor could be something */
/* like a small REXX or awk script, or a sophisticated application    */
/* such as 'm4'.                                                      */
/* ------------------------------------------------------------------ */

if \require(&quot;modulename&quot;) then ; say &quot;Couldn't load 'modulename'&quot;

/* ----------- */

modulelist = &quot;Giant/Eanie Giant/Meanie Mouse/Mynie Moe&quot;

do while modulelist &lt;&gt; NULL
  parse var modulelist mod modulelist
  if \require(mod) then ; say &quot;Couldn't load&quot; mod
end

/* ----------------------------- */

/* *** Regina-specific Examples *** */

/* Dynamically adding / removing external library functions */

/* Load general-purpose functions from external library */

/* [1] Load / register the 'library loader' function */
if \rxFuncAdd('sysLoadFuncs', 'rexxUtil', 'sysLoadFuncs') then
  say &quot;Error loading ...&quot;

/* [2] Call the 'library loader' function to load *all* functions */
call sysLoadFuncs

/* Use some of these general-purpose function(s) */
call sysCls

/* Invoke 'unloader' function to remove all functions from memory */
call sysDropFuncs</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN651"
>Delaying use Until Run Time</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* Since REXX does not support modules the issue of delaying their use*/
/* until runtime is moot. Additionally, using the 'external subroutine*/
/* as module' approach [as has been extensively done] sees all module */
/* contents unavailable until it is actually needed. Thus, the issue  */
/* delaying module loading does not arise.                            */
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN654"
>Making Variables Private to a Module</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* Assuming the conceit of having a REXX file / external subroutine   */
/* mimic a 'module', it should be noted that all variables declared   */
/* within that file are local to that file. Therefore, the issue of   */
/* making variables private to a module is not one applicable in REXX.*/
/*                                                                    */
/* Whilst on this matter, it should be pointed out that it is not     */
/* possible to make those variables externally accessable, nor is it  */
/* possible to make those variables persistent. Both tasks *can* be   */
/* accomplished, albeit indirectly, through the use of an external    */
/* storage system together with a set of 'accessor' methods.          */
/*                                                                    */
/* The example below - based on the first Perl example in this section*/
/* - illustrates the above except that variables are non-persistent   */
/* [persistent variables are illustarted elsewhere].                  */
/* ------------------------------------------------------------------ */

/* Module Name */
_modname = &quot;Alpha&quot;
...

/* Method List [i.e. exports] */
_methods = &quot;getAA setAA getX setX&quot;
...

/* Data [private, non-persistent, set to initial values] */
aa = NULL ; x = NULL
...

/* Method Implementations */
getAA : procedure expose aa ; return aa
setAA : procedure expose aa ; aa = ARG(1) ; return aa

getX : procedure expose x ; return x
setX : procedure expose x ; x = ARG(1) ; return x
...

/* ----------- */

/* As above [with appropriate name changes] for package, 'Beta' */

/* ----------- */

if requires(&quot;Alpha&quot;) then do
  call Alpha &quot;setAA&quot;, 10
  call Alpha &quot;setX&quot;, &quot;azure&quot;
end

if requires(&quot;Beta&quot;) then do
  call Beta &quot;setBB&quot;, 20
  call Beta &quot;setX&quot;, &quot;blue&quot;
end

/* In current package */
say Alpha(&quot;getAA&quot;) Beta(&quot;getBB&quot;) Alpha(&quot;getX&quot;) Beta(&quot;getX&quot;)</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN657"
>Determining the Caller's Package</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* The only information obtainable about a caller is information      */
/* actually passed to the callee such as, for example, the caller's   */
/* name. The Perl examples are, therefore, not translatable.          */
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN660"
>Automating Module Clean-Up</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* Since REXX does not support modules the issue of automating their  */
/* cleanup is moot. However, it does help highlight the issue of      */
/* application cleanup, something of equal importance especially where*/
/* there are external resources which must be properly released prior */
/* to application exit.                                               */
/*                                                                    */
/* REXX does not implement the equivalent of Perl's END block, so it  */
/* not possible to specify code blocks that must *always* execute e.g.*/
/* like a C++ destructor. It does, however, allow the trapping of     */
/* certain CONDITIONS [roughly the same as Perl signals], and the     */
/* specifying of handlers for those conditions.                       */
/*                                                                    */
/* A condition may be raised by the interpreter, or by the program    */
/* [via an explicit 'signal CONDITION' instruction]. An easy way to   */
/* ensure a block of code is executed both at the end of normal exe-  */
/* cution, and when a condition is raised is to place such code at the*/
/* end of the application. The Perl-equivalent example below uses this*/
/* approach.                                                          */
/* ------------------------------------------------------------------ */

/* Outline of a 'cleanup' subroutine triggered by HALT and SYNTAX */

/* Set 'cleanup' routine to trigger specified conditions */
signal on SYNTAX name cleanup
signal on HALT name cleanup

/* ... application main body ... */

exit 0

/* ----------- */

/* Application 'cleanup' routine */
cleanup :
  /* ... cleanup tasks ... */
  exit 0

/* ----------------------------- */

/* As per Perl example */

LOG = &quot;mylogfile.txt&quot;

/* Control jumps to 'cleanup' in the event of a raised condition */
signal on SYNTAX name cleanup
signal on HALT name cleanup

call logmsg LOG, &quot;startup&quot;

/* ... application main body ... */

/* Control falls through to this block under normal execution */
cleanup :
  call logmsg LOG, &quot;shutdown&quot;
  exit 0

/* ----------- */

logmsg : procedure expose (globals)
  logfile = ARG(1) ; message = ARG(2)
  call LINEOUT logfile, message
  return</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN663"
>Keeping Your Own Module Directory</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* Keeping your own module directory                                  */
/* ------------------------------------------------------------------ */

@@INCOMPLETE@@
@@INCOMPLETE@@</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN666"
>Preparing a Module for Distribution</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* REXX is an interpreted language, therefore, a REXX application is  */
/* normally distributed as a set of source files [it is assumed that  */
/* intended client / user possesses a suitable interpreter; refer to  */
/* later section on interpreter installation / distribution].         */
/*                                                                    */
/* Considerations:                                                    */
/*                                                                    */
/* * Any general purpose distribution tool may be used; packaging up  */
/*   applications as .zip or .tgz files is common and easy to do, as  */
/*   is the use of utilities such as InstallShield to largely automate*/
/*   application installation                                         */
/*                                                                    */
/* * REXX compilers are available. Aside from the performance benefits*/
/*   obtainable via such tools, it avoids the need for source code    */
/*   distribution                                                     */
/*                                                                    */
/* * A particularly useful tool is Rexx/Wrapper, available from:      */
/*                                                                    */
/*     http://rexxwrapper.sourceforge.net/doc/index.html              */
/*                                                                    */
/*   This utility bundles up source code [optionally encrypted] into  */
/*   executable form, simplifying and helping secure the application  */
/*   distribution process.                                            */
/* ------------------------------------------------------------------ */

/* Sample Rexx/Wrapper Session [not all required options shown] */

/*
    /* Command-line use [may also be used interactively]
    rexx rexxwrap.cmd -options ...

    /* Create 'Planets' module distribution package [incomplete] */
    rexx rexxwrap.cmd -program Planets -rexxfiles /home/Planets.rexx

    /* Create 'Planets' module distribution package [incomplete] */
    rexx rexxwrap.cmd -program Orbits -rexxfiles /home/Orbits.rexx
*/</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN669"
>Speeding Module Loading with SelfLoader</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* REXX does not implement a facility like Perl's Self Loader. Hence  */
/* this concept is inapplicable in REXX.                              */
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN672"
>Speeding Up Module Loading with Autoloader</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* REXX does not implement a facility like Perl's Auto Loader. Hence  */
/* this concept is inapplicable in REXX.                              */
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN675"
>Overriding Built-In Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* Implementing a subroutine having the same name as a built-in [BIF] */
/* sees the replacement subroutine invoked whenever that name is used */
/* in a call. Unfortunately, it also renders the BIF inaccessable, and*/
/* it is not even possible to call the BIF from within the replacement*/
/* subroutine. Hence, this is a practice best avoided in REXX.        */
/*                                                                    */
/* The lack of native module support renders this concept otherwise   */
/* inapplicable in REXX.                                              */
/* ------------------------------------------------------------------ */

/* Call the built-in 'TIME' function; displays the actual HH:MM:SS */
say TIME('N')

/* ----------------------------- */

/* Call 'TIME' function override; displays the string &quot;[[HH:MM:SS]]&quot; */
say TIME('N')

/* ----------- */

TIME : procedure expose (globals)
  return &quot;[[HH:MM:SS]]&quot;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN678"
>Reporting Errors and Warnings Like Built-Ins</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* REXX BIF's will generally raise SYNTAX conditions to signal errors */
/* such as, for example, the passing of invalid arguments. It is quite*/
/* possible to both:                                                  */
/*                                                                    */
/* * Override the default SYNTAX condition handler so as to customise */
/*   the handling of BIF errors                                       */
/*                                                                    */
/* * Mimic this error trapping / handling strategy in custom code     */
/*                                                                    */
/* An example of each is shown; only the second is based on the Perl  */
/* cookbook code.                                                     */
/* ------------------------------------------------------------------ */

/* Customised BIF Error Handling */

/* Install handler [default name is 'SYNTAX'] for SYNTAX condition */
signal on SYNTAX

/* ... */

/* Force SYNTAX condition: invoke 'TIME' BIF with erroneous argument */
say TIME('Z')

/* ... */

/* SYNTAX condition handler */
SYNTAX :
  /* Display error information, and exit interprter */
  say makeErrorMsg(40, SIGL)
  exit 1

/* ----------- */

/* Displays error information in same format as default handler */
makeErrorMsg :
  n = ARG(1) ; lineno = ARG(2) ; parse source . . name
  return &quot;Error&quot; n &quot;running&quot; '&quot;' || name || '&quot;, line',
         lineno || &quot;:&quot; ERRORTEXT(n)

/* ----------------------------- */

/* Custom Subroutine Error Handling */

call even_only 2                      /* Executes ok */

call even_only 3                      /* Error trapped and reported */

/* ----------- */

even_only : procedure expose (globals)
  n = ARG(1) ; signal on SYNTAX name eo_error

  if (n // 2) &gt; 0 then ; signal SYNTAX
  /* ... */
  return TRUE

eo_error :
  say &quot;Error in 'even_only' subroutine: is not even&quot;
  return FALSE</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN681"
>Referring to Packages Indirectly</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* Since REXX does not support modules this issue is moot. Examples,  */
/* are therefore not translatable.                                    */
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN684"
>Using h2ph to Translate C #include Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* There is, AFAIK, no publically-available REXX translation tool that*/
/* is similar in functionality to Perl's 'h2ph' utility.              */
*/
/* ------------------------------------------------------------------ */

@@INCOMPLETE@@
@@INCOMPLETE@@</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN687"
>Using h2xs to Make a Module with C Code</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* There is, AFAIK, no publically-available REXX translation tool that*/
/* is similar in functionality to Perl's 'h2xs' utility.              */
*/
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN690"
>Documenting Your Module with Pod</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* There is, AFAIK, no publically-available documentation generation  */
/* tool for REXX [though, doubtless, a significant number do exist,   */
/* though as proprietary products].                                   */
/*                                                                    */
/* However, there are a number of general purpose documentation tools */
/* available. A particularly useful one is ROBODoc, available from:   */
/*                                                                    */
/*     http://www.xs4all.nl/~rfsber/Robo/robodoc.html                 */
/*                                                                    */
/* This product is language-neutral, and works something like the very*/
/* widely used javadoc tool [Java Documentation] in that it scans the */
/* source code it is fed looking for specially-formatted comments from*/
/* which it extracts information and assembles it into one of several */
/* formats including HTML and PDF.                                    */
/*                                                                    */
/* ROBODoc is fully configurable, but does recognise several comment  */
/* types by default, including that for the C language. Since REXX    */
/* utilises the same comment type it is possible to use it 'out of the*/
/* box' by using the C language commentary conventions. What could be */
/* easier :) ?                                                        */
/* ------------------------------------------------------------------ */

/* *** Translation skipped *** */</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN693"
>Building and Installing a CPAN Module</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* Since REXX does not support modules the issue of installing such is*/
/* moot. However, it is worth discussing the issue of REXX interpreter*/
/* distribution / installation [REXX application distribution and     */
/* installation was discussed in an earliuer section].                */
/*                                                                    */
/* Quite obviously this is both an interpreter-specific and platform- */
/* specific issue. In the case of Regina, a popular implementation    */
/* which emphasises cross-platform workability, installation options  */
/* for several platforms are available. In fact, the one interpreter  */
/* package may be used to generate interpreter executables for several*/
/* platforms. See: http://regina-rexx.sf.net                          */
/* ------------------------------------------------------------------ */

/*
   Sample Regina REXX Installation Session for *NIX / Linux
   ---
   % ./configure
   % make install
*/

/* ----------------------------- */

/*
   Sample Regina REXX Installation Session for OpenVMS
   ---
   % @BUILD
*/

/* ----------------------------- */

/*
   Sample Regina REXX Installation Session for Win32
   ---
   1. Unzip archive file

   2. Copy the files:
      * regina.exe
      * regina.dll
      into a directory specified in your PATH environment variable

   3. [Optional] configuration steps outlined in documentation
*/</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN696"
>Example: Module Template</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1">/* ------------------------------------------------------------------ */
/* Example: Module Template                                           */
/*                                                                    */
/* The following example consists of:                                 */
/*                                                                    */
/* * A complete 'module' implementation                               */
/* * A complete module usage example                                  */
/*                                                                    */
/* The only assumption made is that the module reside in a REXX source*/
/* file having the same name as the module [in this case, 'modtime']. */
/* More details on module structure is in the earlier section on      */
/* module interfaces.                                                 */
/* ------------------------------------------------------------------ */

/* *** Module name and version *** */
_modname = &quot;modtime&quot; ; _modversion = 1.0

/* ----------------------------- */

/* *** Module Constants *** */
FALSE = 0 ; TRUE = 1 ; NULL = &quot;&quot; ; NEWLINE = &quot;0A&quot;X ; SPACE = ' '
globals = &quot;sys. env. args. $. FALSE TRUE NULL NEWLINE SPACE&quot;

/* ----------------------------- */

/* *** Module Non-persistent Storage *** */

/* ... */

/* ----------------------------- */

/* *** Module routine table *** */
/* [1] Housekeeping routines list */
_code = &quot;init cleanup getModuleName getModuleVersion getMethodList&quot;

/* [2] User methods list */
_method = &quot;getTime setTime&quot;

/* ----------------------------- */

/* *** Module Entry Point / Method Dispatcher *** */
parse value ARG(1) with _proc &quot;,&quot; . ; _args = ARG() ; _arglist = NULL

/* Extract arguments and construct callable routine */
if _args &gt; 1 then do
  do i = 2 to _args ; _arglist = _arglist ARG(i) ; end
  _cmd = &quot;_result =&quot; _proc || &quot;(&quot; || STRIP(_arglist) || &quot;)&quot;
end ; else do
  _cmd = &quot;_result =&quot; _proc || &quot;()&quot;
end

/* Ensure constructed routine is actually a module routine */
if \hasCode(_proc) &amp; \hasMethod(_proc) then ; return NULL

/* Invoke routine and return its result to caller */
interpret _cmd ; return _result

/* ----------------------------- */

/* *** Module Code *** */

/* [1] Housekeeping Routines */

init :
  /* Module setup routine [i.e. module 'constructor'] */
  call setTime DATE()
  return NULL

/* ----------- */

cleanup :
  /* Module cleanup rotuine [i.e. module 'destructor'] */
  return NULL

/* ----------- */

/* Module Information Accessors */
getModuleName : ; return _modname
getModuleVersion : ; return _modversion
getMethodList : ; return _method

/* ----------- */

/* Module Validation Routines */
hasCode : ; return POS(ARG(1), _code) &gt; 0
hasMethod : ; return POS(ARG(1), _method) &gt; 0
hasGlobal : ; return LENGTH(VALUE(ARG(1),, 'SYSTEM')) &gt; 0

/* ----------- */

/* External Persistent Storage */
updateGlobal : ; call VALUE ARG(1), ARG(2), 'SYSTEM' ; return NULL
extractGlobal : ; return VALUE(ARG(1),, 'SYSTEM')

/* ----------------------------- */

/* [2] User Methods */

getTime : procedure expose (globals)
  /* Extract value of &quot;TIME&quot; from external storage */
  return extractGlobal(&quot;TIME&quot;)

/* ----------- */

setTime : procedure expose (globals)
  /* Set &quot;TIME&quot; in external storage to specified value */
  call updateGlobal &quot;TIME&quot;, ARG(1)
  return ARG(1)

/* ----------------------------- */ /* ----------------------------- */

/* Module Usage Example */

/* Application Options */
options 'NO_STRICT_ANSI'
trace 'OFF'
signal on NOVALUE

/* Global Constants */
FALSE = 0 ; TRUE = 1 ; NULL = &quot;&quot; ; NEWLINE = &quot;0A&quot;X ; SPACE = ' '

/* Global Roots and 'expose' list */
globals = &quot;sys. env. args. $. FALSE TRUE NULL NEWLINE SPACE&quot;

/* ----------- */

/* Check module availability */
available = require(&quot;modtime&quot;)

if available then do

  /* Initialise module */
  call modtime &quot;init&quot;

  /* Extract and print module information */
  name = modtime(&quot;getModuleName&quot;)
  version = modtime(&quot;getModuleVersion&quot;)
  methods = modtime(&quot;getMethodList&quot;)

  say &quot;Module 'modtime' is available&quot;
  say &quot;Details:&quot;
  say &quot;   Name:&quot; name
  say &quot;   Version:&quot; version
  say &quot;   Methods:&quot; methods

  /* Invoke user-available module routine(s) */
  say modtime(&quot;getTime&quot;)

  /* Cleanup module */
  call modtime &quot;cleanup&quot;

end ; else do
  say &quot;Module 'modtime' *NOT* available&quot;
end

/* ----------------------------- */

/* Current implementation is Win32 / *NIX specific */
require : procedure expose (globals)

  /* Extract PATH components */
  parse value ARG(1) with name &quot;.&quot; extension ; version = ARG(2)
  if extension == NULL then ; extension = &quot;rexx&quot;
  path = name || &quot;.&quot; || extension

  /* Check file / module existence, and its version [if required] */
  if LENGTH(STREAM(path,'C',&quot;QUERY EXISTS&quot;)) &gt; 0 then do
    if version == NULL then ; return TRUE
    _cmd = &quot;_result =&quot; name || '(&quot;getModuleVersion&quot;)'
    interpret _cmd ; return _result == version
  end

  return FALSE</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN699"
>Program: Finding Versions and Descriptions of Installed Modules</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="referencesandrecords.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="classesetc.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>References and Records</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Classes, Objects, and Ties</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>