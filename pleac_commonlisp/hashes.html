<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Hashes</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Common Lisp"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Arrays"
HREF="arrays.html"><LINK
REL="NEXT"
TITLE="Pattern Matching"
HREF="patternmatching.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Common Lisp</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="arrays.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="patternmatching.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="HASHES"
>5. Hashes</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN232"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">age</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="ss">&#39;equal</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Nat&quot;</span> <span class="nv">age</span><span class="p">)</span> <span class="mi">24</span>
      <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Jules&quot;</span> <span class="nv">age</span><span class="p">)</span> <span class="mi">25</span>
      <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Josh&quot;</span> <span class="nv">age</span><span class="p">)</span> <span class="mi">17</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">l</span><span class="p">)</span> <span class="nv">age</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">l</span><span class="p">)))</span>
        <span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;Nat&quot;</span> <span class="o">.</span> <span class="mi">24</span><span class="p">)</span>
          <span class="p">(</span><span class="s">&quot;Jules&quot;</span> <span class="o">.</span> <span class="mi">25</span><span class="p">)</span>
          <span class="p">(</span><span class="s">&quot;Josh&quot;</span> <span class="o">.</span> <span class="mi">17</span><span class="p">)))</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*food-color*</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="ss">&#39;equal</span><span class="p">))</span>

<span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">l</span><span class="p">)</span> <span class="vg">*food-color*</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">l</span><span class="p">)))</span>
        <span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;Apple&quot;</span> <span class="o">.</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
          <span class="p">(</span><span class="s">&quot;Banana&quot;</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
          <span class="p">(</span><span class="s">&quot;Lemon&quot;</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
          <span class="p">(</span><span class="s">&quot;Carrot&quot;</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">l</span><span class="p">)</span> <span class="vg">*food-color*</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">l</span><span class="p">)))</span>
        <span class="o">&#39;</span><span class="p">((</span><span class="nv">Apple</span> <span class="o">.</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">Banana</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">Lemon</span> <span class="o">.</span> <span class="s">&quot;yellow&quot;</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">Carrot</span> <span class="o">.</span> <span class="s">&quot;orange&quot;</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN235"
>Adding an Element to a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">hash</span><span class="p">)</span> <span class="nv">value</span><span class="p">)</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; *FOOD-COLOR* defined per the introduction</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Raspberry&quot;</span> <span class="vg">*food-color*</span><span class="p">)</span> <span class="s">&quot;pink&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Known foods:~%~{~A~%~}&quot;</span>
        <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">f</span> <span class="nv">being</span> <span class="k">the</span> <span class="nv">hash-keys</span> <span class="nv">of</span> <span class="vg">*food-color*</span>
           <span class="nv">collect</span> <span class="nv">f</span><span class="p">))</span>
<span class="c1">;;Known foods:</span>
<span class="c1">;;Apple</span>
<span class="c1">;;Banana</span>
<span class="c1">;;Lemon</span>
<span class="c1">;;Carrot</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN238"
>Testing for the Presence of a Key in a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="c1">;; does HASH have a value for KEY ?</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">nth-value</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">hash</span><span class="p">))</span>
    <span class="p">(</span><span class="k">progn</span>
      <span class="c1">;; it exists</span>
      <span class="p">)</span>
    <span class="p">(</span><span class="k">progn</span>
      <span class="c1">;; it doesn&#39;t</span>
      <span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; *FOOD-COLOR* per the introduction</span>
<span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">name</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Banana&quot;</span> <span class="s">&quot;Martini&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A is a ~A.~%&quot;</span>
          <span class="nv">name</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">nth-value</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">name</span> <span class="vg">*food-color*</span><span class="p">))</span>
              <span class="s">&quot;food&quot;</span> <span class="s">&quot;drink&quot;</span><span class="p">)))</span>

<span class="c1">;;Banana is a food.</span>
<span class="c1">;;Martini is a drink.</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">age</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="ss">&#39;equal</span><span class="p">))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Toddler&quot;</span> <span class="nv">age</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Unborn&quot;</span> <span class="nv">age</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Phantasm&quot;</span> <span class="nv">age</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">thing</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Toddler&quot;</span> <span class="s">&quot;Unborn&quot;</span> <span class="s">&quot;Phantasm&quot;</span> <span class="s">&quot;Relic&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~a: &quot;</span> <span class="nv">thing</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">defined</span> <span class="nv">exists</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">gethash</span> <span class="nv">thing</span> <span class="nv">age</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">when</span> <span class="nv">exists</span>
        <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Exists &quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">when</span> <span class="nv">defined</span>
          <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Defined &quot;</span><span class="p">)</span>
          <span class="c1">;; 0 is &quot;true&quot; in CL, so explicitly mimic Perl</span>
          <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">defined</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;True &quot;</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~%&quot;</span><span class="p">))</span>

<span class="c1">;;Toddler: Exists Defined True</span>
<span class="c1">;;Unborn: Exists Defined</span>
<span class="c1">;;Phantasm: Exists</span>
<span class="c1">;;Relic:</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;;; @@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN241"
>Deleting from a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="c1">;; remove KEY and its value from HASH</span>
<span class="p">(</span><span class="nb">remhash</span> <span class="nv">key</span> <span class="nv">hash</span><span class="p">)</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; *FOOD-COLOR* as per Introduction</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-foods</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">foods</span> <span class="p">(</span><span class="nv">hash-keys</span> <span class="vg">*food-color*</span><span class="p">)))</span> <span class="c1">; HASH-KEYS defined in Appendix</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Keys: ~{~A~^ ~}~%Values: ~{~A~^ ~}~%&quot;</span>
            <span class="nv">foods</span>
            <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">food</span> <span class="nv">in</span> <span class="nv">foods</span>
               <span class="nv">collect</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">food</span> <span class="vg">*food-color*</span><span class="p">)</span>
                           <span class="s">&quot;(undef)&quot;</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Initially~%&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">print-foods</span><span class="p">)</span>

<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~%With Banana undef~%&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Banana&quot;</span> <span class="vg">*food-color*</span><span class="p">)</span>

<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~%With Banana deleted~%&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">remhash</span> <span class="s">&quot;Banana&quot;</span> <span class="vg">*food-color*</span><span class="p">)</span>
<span class="p">(</span><span class="nv">print-foods</span><span class="p">)</span>

<span class="c1">;; Initially</span>
<span class="c1">;; Keys: Apple Banana Lemon Carrot</span>
<span class="c1">;; Values: red yellow yellow orange</span>
<span class="c1">;;</span>
<span class="c1">;; With Banana undef</span>
<span class="c1">;; Keys: Apple Banana Lemon Carrot</span>
<span class="c1">;; Values: red (undef) yellow orange</span>
<span class="c1">;;</span>
<span class="c1">;; With Banana deleted</span>
<span class="c1">;; Keys: Apple Lemon Carrot</span>
<span class="c1">;; Values: red yellow orange</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">mapc</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span><span class="p">)</span> <span class="p">(</span><span class="nb">remhash</span> <span class="nv">key</span> <span class="vg">*food-color*</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Banana&quot;</span> <span class="s">&quot;Apple&quot;</span> <span class="s">&quot;Cabbage&quot;</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN244"
>Traversing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">being</span> <span class="k">the</span> <span class="nv">hash-keys</span> <span class="nv">of</span> <span class="nv">hash</span> <span class="nv">using</span> <span class="p">(</span><span class="nv">hash-value</span> <span class="nv">value</span><span class="p">)</span>
     <span class="c1">;; do something with KEY and VALUE</span>
     <span class="p">)</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">maphash</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">value</span><span class="p">)</span>
             <span class="c1">;; do something with KEY and VALUE</span>
             <span class="p">)</span>
         <span class="nv">hash</span><span class="p">)</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; *FOOD-COLOR* per the introduction</span>
<span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">food</span> <span class="nv">being</span> <span class="k">the</span> <span class="nv">hash-keys</span> <span class="nv">of</span> <span class="vg">*food-color*</span> <span class="nv">using</span> <span class="p">(</span><span class="nv">hash-value</span> <span class="nv">color</span><span class="p">)</span>
     <span class="nb">do</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A is ~A.~%&quot;</span> <span class="nv">food</span> <span class="nv">color</span><span class="p">))</span>
<span class="c1">;; Apple is red.</span>
<span class="c1">;; Banana is yellow.</span>
<span class="c1">;; Lemon is yellow.</span>
<span class="c1">;; Carrot is orange.</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">maphash</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">food</span> <span class="nv">color</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A is ~A.~%&quot;</span> <span class="nv">food</span> <span class="nv">color</span><span class="p">))</span>
         <span class="vg">*food-color*</span><span class="p">)</span>
<span class="c1">;; Apple is red.</span>
<span class="c1">;; Banana is yellow.</span>
<span class="c1">;; Lemon is yellow.</span>
<span class="c1">;; Carrot is orange.</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; No equivalent</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">food</span> <span class="nv">in</span> <span class="p">(</span><span class="nb">sort</span> <span class="p">(</span><span class="nv">hash-keys</span> <span class="vg">*food-color*</span><span class="p">)</span> <span class="ss">&#39;string-lessp</span><span class="p">)</span>
   <span class="nb">do</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A is ~A~%&quot;</span> <span class="nv">food</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">food</span> <span class="vg">*food-color*</span><span class="p">)))</span>
<span class="c1">;; Apple is red</span>
<span class="c1">;; Banana is yellow</span>
<span class="c1">;; Carrot is orange</span>
<span class="c1">;; Lemon is yellow</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; Not sure what the following Perl is supposed to do:</span>
<span class="c1">;;while ( ($k,$v) = each %food_color ) {</span>
<span class="c1">;;    print &quot;Processing $k\n&quot;;</span>
<span class="c1">;;    keys %food_color;               # goes back to the start of %food_color</span>
<span class="c1">;;}</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">use-package</span> <span class="ss">:cl-ppcre</span><span class="p">)</span>
<span class="p">(</span><span class="nb">use-package</span> <span class="ss">:iterate</span><span class="p">)</span>

<span class="c1">;; The following handles the case that the Perl handles where there is</span>
<span class="c1">;; no filename (and it then opens &#39;-&#39;.  To do the same thing you&#39;d do</span>
<span class="c1">;; something like: (countfrom *standard-input*) and this method would</span>
<span class="c1">;; automatically get triggered instead of the one requiring a</span>
<span class="c1">;; filename.</span>
<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">countfrom</span> <span class="p">((</span><span class="nc">stream</span> <span class="nc">stream</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">from</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="ss">&#39;equal</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">with-open-stream</span> <span class="p">(</span><span class="nv">input</span> <span class="nc">stream</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">iter</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">line</span> <span class="nv">in-stream</span> <span class="nv">input</span> <span class="nv">using</span> <span class="ss">&#39;read-line</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">register-groups-bind</span> <span class="p">(</span><span class="nv">person</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;^From: (.*)\\s&quot;</span> <span class="nv">line</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">person</span> <span class="nv">from</span> <span class="mi">0</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">person</span> <span class="nv">in</span> <span class="p">(</span><span class="nb">sort</span> <span class="p">(</span><span class="nv">hash-keys</span> <span class="nv">from</span><span class="p">)</span> <span class="ss">&#39;string-lessp</span><span class="p">)</span>
       <span class="nb">do</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A: ~A~%&quot;</span> <span class="nv">person</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">person</span> <span class="nv">from</span><span class="p">)))))</span>

<span class="c1">;; This method is a bit of a hack in that it shouldn&#39;t really assume</span>
<span class="c1">;; that the string designates a filename, but for the purposes of this</span>
<span class="c1">;; example that seems ok.  Note that it just calls OPEN directly</span>
<span class="c1">;; without WITH-OPEN-FILE because it knows that the STREAM version of</span>
<span class="c1">;; this method will always close it.</span>
<span class="p">(</span><span class="nb">defmethod</span> <span class="nv">countfrom</span> <span class="p">((</span><span class="nv">filename</span> <span class="nb">string</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">countfrom</span> <span class="p">(</span><span class="nb">open</span> <span class="nv">filename</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN247"
>Printing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*table*</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">))</span>

<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~R&quot;</span> <span class="nv">i</span><span class="p">)</span> <span class="vg">*table*</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>

<span class="p">(</span><span class="nb">maphash</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A~%&quot;</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">key</span> <span class="nv">val</span><span class="p">)))</span> <span class="vg">*table*</span><span class="p">)</span>
<span class="c1">; =&gt; (&quot;nine&quot;  . 9)</span>
<span class="c1">;    (&quot;eight&quot; . 8)</span>
<span class="c1">;    (&quot;seven&quot; . 7)</span>
<span class="c1">;    (&quot;six&quot;   . 6)</span>
<span class="c1">;    (&quot;five&quot;  . 5)</span>
<span class="c1">;    (&quot;four&quot;  . 4)</span>
<span class="c1">;    (&quot;three&quot; . 3)</span>
<span class="c1">;    (&quot;two&quot;   . 2)</span>
<span class="c1">;    (&quot;one&quot;   . 1)</span>
<span class="c1">;    (&quot;zero&quot;  . 0)</span>

<span class="c1">;;; Unfortunately there doesn&#39;t exist a  `FORMAT&#39; directive for hash tables. But</span>
<span class="c1">;;; one can easily override existing `PRINT-OBJECT&#39; method for hash tables.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN250"
>Retrieving from a Hash in Insertion Order</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;; There doesn&#39;t exist a portable way of preserving insertion order of contents</span>
<span class="c1">;;; of a hash table in Common Lisp.   (Neither there is a rational behind such a</span>
<span class="c1">;;; feature, IMHO.)  On the  other hand, one  can keep  a history of  hash table</span>
<span class="c1">;;; modifications separately.</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">make-ordered-hash-table</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">make-hash-table-args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">make-hash-table</span> <span class="nv">make-hash-table-args</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">setkey</span> <span class="p">(</span><span class="nv">table</span> <span class="nv">key</span> <span class="nv">val</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">table</span><span class="p">))</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">table</span><span class="p">))</span> <span class="nv">val</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">remkey</span> <span class="p">(</span><span class="nv">table</span> <span class="nv">key</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">remhash</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">table</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">getkey</span> <span class="p">(</span><span class="nv">table</span> <span class="nv">key</span> <span class="k">&amp;optional</span> <span class="nv">default</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">missing-key</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">val</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">table</span><span class="p">)</span> <span class="nv">missing-key</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">missing-key</span> <span class="nv">val</span><span class="p">)</span> <span class="nv">default</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">val</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">keys</span> <span class="p">(</span><span class="nv">table</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">key-id-pairs</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">maphash</span>
     <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">val</span><span class="p">))</span> <span class="nv">key-id-pairs</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">car</span> <span class="nv">table</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">car</span> <span class="p">(</span><span class="nb">sort</span> <span class="nv">key-id-pairs</span> <span class="nf">#&#39;</span><span class="nb">&lt;</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">cdr</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*table*</span> <span class="p">(</span><span class="nv">make-ordered-hash-table</span><span class="p">))</span>

<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">setkey</span> <span class="vg">*table*</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">i</span><span class="p">))</span> <span class="nv">i</span><span class="p">))</span>

<span class="p">(</span><span class="nv">keys</span> <span class="vg">*table*</span><span class="p">)</span>
<span class="c1">; =&gt; (1 1/2 1/3 1/4 1/5 1/6 1/7 1/8 1/9 1/10)</span>

<span class="p">(</span><span class="nv">setkey</span> <span class="vg">*table*</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">20</span><span class="p">)</span>
<span class="p">(</span><span class="nv">setkey</span> <span class="vg">*table*</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">40</span><span class="p">)</span>
<span class="p">(</span><span class="nv">remkey</span> <span class="vg">*table*</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">6</span><span class="p">))</span>

<span class="p">(</span><span class="nv">keys</span> <span class="vg">*table*</span><span class="p">)</span>
<span class="c1">; =&gt; (1 1/3 1/5 1/7 1/8 1/9 1/10 1/2 1/4)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN253"
>Hashes with Multiple Values Per Key</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;; You can  easily create hash tables  using multiple values per  key. For this</span>
<span class="c1">;;; purpose you  just need to increase  the verbosity of the  used test function</span>
<span class="c1">;;; during hash table creation.</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*employee-table*</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*employee-list*</span>
  <span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;R&amp;D&quot;</span>   <span class="s">&quot;Bob&quot;</span>   <span class="s">&quot;1000&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;R&amp;D&quot;</span>   <span class="s">&quot;Trudy&quot;</span> <span class="s">&quot;1001&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;R&amp;D&quot;</span>   <span class="s">&quot;Alice&quot;</span> <span class="s">&quot;1002&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Sales&quot;</span> <span class="s">&quot;Bob&quot;</span>   <span class="s">&quot;2001&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Sales&quot;</span> <span class="s">&quot;Jane&quot;</span>  <span class="s">&quot;2003&quot;</span><span class="p">)))</span>

<span class="c1">;;; Pay attention that  we have to &quot;Bob&quot;s in  different departments. We&#39;ll place</span>
<span class="c1">;;; employees into  the `*EMPLOYEE-TABLE*&#39; using  these two (name  &amp; department)</span>
<span class="c1">;;; identifier fields.</span>

<span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">employee</span> <span class="vg">*employee-list*</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">destructuring-bind</span> <span class="p">(</span><span class="nv">dept</span> <span class="nv">name</span> <span class="nv">phone</span><span class="p">)</span> <span class="nv">employee</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">dept</span> <span class="nv">name</span><span class="p">)</span> <span class="vg">*employee-table*</span><span class="p">)</span>
          <span class="nv">phone</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">maphash</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~S =&gt; ~S~%&quot;</span> <span class="nv">key</span> <span class="nv">val</span><span class="p">))</span>
         <span class="vg">*employee-table*</span><span class="p">)</span>
<span class="c1">; =&gt; (&quot;R&amp;D&quot; &quot;Bob&quot;)    =&gt; &quot;1000&quot;</span>
<span class="c1">;    (&quot;R&amp;D&quot; &quot;Trudy&quot;)  =&gt; &quot;1001&quot;</span>
<span class="c1">;    (&quot;R&amp;D&quot; &quot;Alice&quot;)  =&gt; &quot;1002&quot;</span>
<span class="c1">;    (&quot;Sales&quot; &quot;Bob&quot;)  =&gt; &quot;2001&quot;</span>
<span class="c1">;    (&quot;Sales&quot; &quot;Jane&quot;) =&gt; &quot;2003&quot;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN256"
>Inverting a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">reverse-hash-table</span> <span class="p">(</span><span class="nv">old-table</span> <span class="k">&amp;key</span> <span class="nv">test</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">new-table</span>
         <span class="p">(</span><span class="nb">make-hash-table</span>
          <span class="ss">:test</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">test</span> <span class="p">(</span><span class="nb">hash-table-test</span> <span class="nv">old-table</span><span class="p">))</span>
          <span class="ss">:size</span> <span class="p">(</span><span class="nb">hash-table-size</span> <span class="nv">old-table</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">maphash</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">val</span> <span class="nv">new-table</span><span class="p">)</span> <span class="nv">key</span><span class="p">))</span>
             <span class="nv">old-table</span><span class="p">)</span>
    <span class="nv">new-table</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*table*</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">))</span>

<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">i</span><span class="p">))</span> <span class="vg">*table*</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>

<span class="p">(</span><span class="nb">maphash</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~S =&gt; ~S~%&quot;</span> <span class="nv">key</span> <span class="nv">val</span><span class="p">))</span>
         <span class="vg">*table*</span><span class="p">)</span>
<span class="c1">; =&gt; 1    =&gt; 0</span>
<span class="c1">;    1/2  =&gt; 1</span>
<span class="c1">;    1/3  =&gt; 2</span>
<span class="c1">;    1/4  =&gt; 3</span>
<span class="c1">;    1/5  =&gt; 4</span>
<span class="c1">;    1/6  =&gt; 5</span>
<span class="c1">;    1/7  =&gt; 6</span>
<span class="c1">;    1/8  =&gt; 7</span>
<span class="c1">;    1/9  =&gt; 8</span>
<span class="c1">;    1/10 =&gt; 9</span>

<span class="p">(</span><span class="nb">maphash</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~S =&gt; ~S~%&quot;</span> <span class="nv">key</span> <span class="nv">val</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">reverse-hash-table</span> <span class="vg">*table*</span><span class="p">))</span>
<span class="c1">; =&gt; 0 =&gt; 1</span>
<span class="c1">;    1 =&gt; 1/2</span>
<span class="c1">;    2 =&gt; 1/3</span>
<span class="c1">;    3 =&gt; 1/4</span>
<span class="c1">;    4 =&gt; 1/5</span>
<span class="c1">;    5 =&gt; 1/6</span>
<span class="c1">;    6 =&gt; 1/7</span>
<span class="c1">;    7 =&gt; 1/8</span>
<span class="c1">;    8 =&gt; 1/9</span>
<span class="c1">;    9 =&gt; 1/10</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN259"
>Sorting a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;; One cannot (and shouldn&#39;t) make assumptions  on the order of the elements in</span>
<span class="c1">;;; a hash table in  Common Lisp. Anyway, while you&#39;re here, below  is a quick &amp;</span>
<span class="c1">;;; dirty solution.</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">ordered-keys</span> <span class="p">(</span><span class="nv">table</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">sort</span>
   <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">being</span> <span class="nv">each</span> <span class="nv">hash-key</span> <span class="nv">of</span> <span class="nv">table</span>
         <span class="nv">collect</span> <span class="nv">key</span><span class="p">)</span>
   <span class="nf">#&#39;</span><span class="nb">&lt;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*table*</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">))</span>

<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span>  <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">i</span><span class="p">))</span> <span class="vg">*table*</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>

<span class="p">(</span><span class="nv">ordered-keys</span> <span class="vg">*table*</span><span class="p">)</span>
<span class="c1">; =&gt; (1/10 1/9 1/8 1/7 1/6 1/5 1/4 1/3 1/2 1)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN262"
>Merging Hashes</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">merge-hash-tables</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">tables</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">union</span>
         <span class="p">(</span><span class="nb">make-hash-table</span>
          <span class="ss">:test</span> <span class="p">(</span><span class="nb">first</span>
                 <span class="p">(</span><span class="nb">sort</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">hash-table-test</span> <span class="nv">tables</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nb">&gt;</span>
                       <span class="ss">:key</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">test</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">ecase</span> <span class="nv">test</span>
                                <span class="p">(</span><span class="nb">eq</span> <span class="mi">0</span><span class="p">)</span>
                                <span class="p">(</span><span class="nb">eql</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="p">(</span><span class="nb">equal</span> <span class="mi">2</span><span class="p">)</span>
                                <span class="p">(</span><span class="nb">equalp</span> <span class="mi">3</span><span class="p">)))))</span>
          <span class="ss">:size</span> <span class="p">(</span><span class="nb">reduce</span> <span class="nf">#&#39;</span><span class="nb">max</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">hash-table-size</span> <span class="nv">tables</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">table</span> <span class="nv">tables</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">maphash</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nb">union</span><span class="p">)</span> <span class="nv">val</span><span class="p">))</span> <span class="nv">table</span><span class="p">))</span>
    <span class="nb">union</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*table-x*</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*table-y*</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">))</span>

<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">5</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">i</span> <span class="vg">*table-x*</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">10</span> <span class="nv">i</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~R&quot;</span> <span class="nv">i</span><span class="p">)</span> <span class="vg">*table-y*</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*table-u*</span> <span class="p">(</span><span class="nv">merge-hash-tables</span> <span class="vg">*table-x*</span> <span class="vg">*table-y*</span><span class="p">))</span>

<span class="p">(</span><span class="nb">maphash</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~10S =&gt; ~S~%&quot;</span> <span class="nv">key</span> <span class="nv">val</span><span class="p">))</span> <span class="vg">*table-u*</span><span class="p">)</span>
<span class="c1">; =&gt; 0       =&gt; 0</span>
<span class="c1">;    1       =&gt; 10</span>
<span class="c1">;    2       =&gt; 20</span>
<span class="c1">;    3       =&gt; 30</span>
<span class="c1">;    4       =&gt; 40</span>
<span class="c1">;    &quot;zero&quot;  =&gt; 0</span>
<span class="c1">;    &quot;one&quot;   =&gt; 1</span>
<span class="c1">;    &quot;two&quot;   =&gt; 2</span>
<span class="c1">;    &quot;three&quot; =&gt; 3</span>
<span class="c1">;    &quot;four&quot;  =&gt; 4</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN265"
>Finding Common or Different Keys in Two Hashes</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;; Before  going  into  the  details   about  how  to  find  intersections  and</span>
<span class="c1">;;; differences between two hash tables,  one should note the existence of below</span>
<span class="c1">;;; functions operating on lists.</span>

<span class="c1">;;; Function &lt;a href=&quot;http://l1sp.org/cl/set-exclusive-or&quot;&gt;SET-EXCLUSIVE-OR&lt;/a&gt;, &lt;a href=&quot;http://l1sp.org/cl/nset-exclusive-or&quot;&gt;NSET-EXCLUSIVE-OR&lt;/a&gt;</span>
<span class="c1">;;; Function &lt;a href=&quot;http://l1sp.org/cl/set-difference&quot;&gt;SET-DIFFERENCE&lt;/a&gt;, &lt;a href=&quot;http://l1sp.org/cl/nset-difference&quot;&gt;NSET-DIFFERENCE&lt;/a&gt;</span>
<span class="c1">;;; Function &lt;a href=&quot;http://l1sp.org/cl/intersection&quot;&gt;INTERSECTION&lt;/a&gt;, &lt;a href=&quot;http://l1sp.org/cl/nintersection&quot;&gt;NINTERSECTION&lt;/a&gt;</span>
<span class="c1">;;; Function &lt;a href=&quot;http://l1sp.org/cl/union&quot;&gt;UNION&lt;/a&gt;, &lt;a href=&quot;http://l1sp.org/cl/nunion&quot;&gt;NUNION&lt;/a&gt;</span>

<span class="c1">;;; While  a hash  table implementation  of above  set operations  would perform</span>
<span class="c1">;;; better  for large  data sets,  people  report that  above functions  perform</span>
<span class="c1">;;; better than hash tables for collections of size 20-30 elements. On the other</span>
<span class="c1">;;; hand, it&#39;s  obvious that  working with  lists is much  more suitable  to the</span>
<span class="c1">;;; nature of a lisp program.</span>

<span class="c1">;;; Simple &amp; Clean Hash Table Intersection/Difference Implementations</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">hash-table-keys</span> <span class="p">(</span><span class="nv">table</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">being</span> <span class="nv">each</span> <span class="nv">hash-key</span> <span class="nv">of</span> <span class="nv">table</span>
        <span class="nv">collect</span> <span class="nv">key</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">key-intersection</span> <span class="p">(</span><span class="nv">u</span> <span class="nv">v</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">intersection</span>
   <span class="p">(</span><span class="nv">hash-table-keys</span> <span class="nv">u</span><span class="p">)</span> <span class="p">(</span><span class="nv">hash-table-keys</span> <span class="nv">v</span><span class="p">)</span>
   <span class="ss">:test</span> <span class="p">(</span><span class="nb">hash-table-test</span> <span class="nv">u</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">key-difference</span> <span class="p">(</span><span class="nv">u</span> <span class="nv">v</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">set-difference</span>
   <span class="p">(</span><span class="nv">hash-table-keys</span> <span class="nv">u</span><span class="p">)</span> <span class="p">(</span><span class="nv">hash-table-keys</span> <span class="nv">v</span><span class="p">)</span>
   <span class="ss">:test</span> <span class="p">(</span><span class="nb">hash-table-test</span> <span class="nv">u</span><span class="p">)))</span>


<span class="c1">;;; Hairy Hash Table Intersection/Difference Implementations</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">hairy-key-frequency</span> <span class="p">(</span><span class="nv">tables</span> <span class="k">&amp;key</span> <span class="p">(</span><span class="nv">test</span> <span class="ss">&#39;eql</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">frequency</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="nv">test</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">table</span> <span class="nv">tables</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">maphash</span>
       <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span>
         <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">ignore</span> <span class="nv">val</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">frequency</span> <span class="mi">0</span><span class="p">)))</span>
       <span class="nv">table</span><span class="p">))</span>
    <span class="nv">frequency</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">with-table-test-consistency</span> <span class="p">((</span><span class="nv">tables</span> <span class="nv">test</span><span class="p">)</span> <span class="k">&amp;body</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">alexandria:with-unique-names</span> <span class="p">(</span><span class="nv">table</span><span class="p">)</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">test</span> <span class="p">(</span><span class="nb">hash-table-test</span> <span class="p">(</span><span class="nb">first</span> <span class="o">,</span><span class="nv">tables</span><span class="p">))))</span>
       <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">every</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="o">,</span><span class="nv">table</span><span class="p">)</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">hash-table-test</span> <span class="o">,</span><span class="nv">table</span><span class="p">)</span> <span class="o">,</span><span class="nv">test</span><span class="p">))</span>
                      <span class="p">(</span><span class="nb">rest</span> <span class="o">,</span><span class="nv">tables</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;Inconsistent test functions! (Expecting ~S.)&quot;</span> <span class="o">,</span><span class="nv">test</span><span class="p">))</span>
       <span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">hairy-key-frequency-filter</span> <span class="p">(</span><span class="nv">tables</span> <span class="nv">pred</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">tables</span>
    <span class="p">(</span><span class="nv">with-table-test-consistency</span> <span class="p">(</span><span class="nv">tables</span> <span class="nv">test</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">accum</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">maphash</span>
         <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">pred</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">push</span> <span class="nv">key</span> <span class="nv">accum</span><span class="p">)))</span>
         <span class="p">(</span><span class="nv">hairy-key-frequency</span> <span class="nv">tables</span> <span class="ss">:test</span> <span class="nv">test</span><span class="p">))</span>
        <span class="nv">accum</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">hairy-key-intersection</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">tables</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">hairy-key-frequency-filter</span> <span class="nv">tables</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="mi">1</span> <span class="nv">val</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">hairy-key-difference</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">tables</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">hairy-key-frequency-filter</span> <span class="nv">tables</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">val</span> <span class="mi">2</span><span class="p">))))</span>


<span class="c1">;;; Example Usage</span>

<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">u</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">v</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">i</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">i</span> <span class="nv">u</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">i</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">i</span> <span class="nv">v</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">list</span> <span class="ss">:simple</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:intersection</span> <span class="p">(</span><span class="nv">key-intersection</span> <span class="nv">u</span> <span class="nv">v</span><span class="p">)</span>
                      <span class="ss">:difference</span>   <span class="p">(</span><span class="nv">key-difference</span> <span class="nv">u</span> <span class="nv">v</span><span class="p">))</span>
        <span class="ss">:hairy</span>  <span class="p">(</span><span class="nb">list</span> <span class="ss">:intersection</span> <span class="p">(</span><span class="nv">hairy-key-intersection</span> <span class="nv">u</span> <span class="nv">v</span><span class="p">)</span>
                      <span class="ss">:difference</span>   <span class="p">(</span><span class="nv">hairy-key-difference</span> <span class="nv">u</span> <span class="nv">v</span><span class="p">))))</span>
<span class="c1">; =&gt; (:SIMPLE (:INTERSECTION (5 4 3) :DIFFERENCE (2 1))</span>
<span class="c1">;     :HAIRY  (:INTERSECTION (5 4 3) :DIFFERENCE (7 6 2 1)))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN268"
>Hashing References</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">consume-stream</span> <span class="p">(</span><span class="nc">stream</span> <span class="k">&amp;key</span> <span class="p">(</span><span class="nv">buffer-size</span> <span class="mi">8192</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">buffer</span>
         <span class="p">(</span><span class="nb">make-sequence</span>
          <span class="o">`</span><span class="p">(</span><span class="nb">vector</span> <span class="o">,</span><span class="p">(</span><span class="nb">stream-element-type</span> <span class="nc">stream</span><span class="p">))</span>
          <span class="nv">buffer-size</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">pos</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">read-sequence</span> <span class="nv">buffer</span> <span class="nc">stream</span><span class="p">)</span>
          <span class="nv">until</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">sum</span> <span class="nv">pos</span><span class="p">)))</span>

<span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">streams</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">open</span> <span class="p">(</span><span class="nb">list</span> <span class="s">&quot;/etc/passwd&quot;</span> <span class="s">&quot;/etc/motd&quot;</span> <span class="s">&quot;/etc/fstab&quot;</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">unwind-protect</span>
       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">table</span> <span class="p">(</span><span class="nb">make-hash-table</span><span class="p">)))</span>
         <span class="c1">;; Place `(STREAM . PATHNAME)&#39; pairs as table key and values.</span>
         <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nc">stream</span> <span class="nv">streams</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nc">stream</span> <span class="nv">table</span><span class="p">)</span> <span class="p">(</span><span class="nb">pathname</span> <span class="nc">stream</span><span class="p">)))</span>
         <span class="c1">;; Let&#39;s find the sizes of the streams.</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">accum</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">maphash</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span> <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">val</span> <span class="p">(</span><span class="nv">consume-stream</span> <span class="nv">key</span><span class="p">))</span> <span class="nv">accum</span><span class="p">))</span>
            <span class="nv">table</span><span class="p">)</span>
           <span class="nv">accum</span><span class="p">))</span>
    <span class="c1">;; Don&#39;t forget to close open file streams.</span>
    <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">close</span> <span class="nv">streams</span><span class="p">)))</span>
<span class="c1">; =&gt; ((#P&quot;/etc/fstab&quot;  . 488)</span>
<span class="c1">;     (#P&quot;/etc/motd&quot;   . 351)</span>
<span class="c1">;     (#P&quot;/etc/passwd&quot; . 1232))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN271"
>Presizing a Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;; In Common Lisp,  you can create hash tables of  previously known sizes using</span>
<span class="c1">;;; `SIZE&#39;             keyword             supplied            to             &lt;a</span>
<span class="c1">;;; href=&quot;http://l1sp.org/cl/make-hash-table&quot;&gt;`MAKE-HASH-TABLE&#39;&lt;/a&gt;.    (Moreover</span>
<span class="c1">;;; there are `REHASH-SIZE&#39;  and `REHASH-THRESHOLD&#39; keyword parameters available</span>
<span class="c1">;;; which  might  interest  you.) But  once  you  created  a hash  table,  these</span>
<span class="c1">;;; configurations  stay as  is;  in  other words  later  modifications are  not</span>
<span class="c1">;;; allowed.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN274"
>Finding the Most Common Anything</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;; See  `HAIRY-KEY-FREQUENCY&#39;  in  &quot;Hairy  Hash  Table  Intersection/Difference</span>
<span class="c1">;;; Implementations&quot;.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN277"
>Representing Relationships Between Data</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;; We construct  the family  tree (in s-expressions)  extracted from  the given</span>
<span class="c1">;;; parent-child relationship table.</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*relations*</span>
  <span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;Cain&quot;</span>      <span class="o">.</span> <span class="s">&quot;Adam&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Abel&quot;</span>      <span class="o">.</span> <span class="s">&quot;Adam&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Seth&quot;</span>      <span class="o">.</span> <span class="s">&quot;Adam&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Enoch&quot;</span>     <span class="o">.</span> <span class="s">&quot;Cain&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Irad&quot;</span>      <span class="o">.</span> <span class="s">&quot;Enoch&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Mehujael&quot;</span>  <span class="o">.</span> <span class="s">&quot;Irad&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Methusael&quot;</span> <span class="o">.</span> <span class="s">&quot;Mehujael&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Lamech&quot;</span>    <span class="o">.</span> <span class="s">&quot;Methusael&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Jabal&quot;</span>     <span class="o">.</span> <span class="s">&quot;Lamech&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Jubal&quot;</span>     <span class="o">.</span> <span class="s">&quot;Lamech&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="s">&quot;Tubalcain&quot;</span> <span class="o">.</span> <span class="s">&quot;Lamech&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">construct-relation-tree</span> <span class="p">(</span><span class="nv">rels</span><span class="p">)</span>
  <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">construct</span> <span class="p">(</span><span class="nv">parent</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">cons</span> <span class="nv">parent</span>
                   <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nv">construct</span>
                           <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">car</span>
                                   <span class="p">(</span><span class="nb">remove</span> <span class="nv">parent</span> <span class="nv">rels</span>
                                           <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">cdr</span>
                                           <span class="ss">:test</span> <span class="p">(</span><span class="nb">complement</span> <span class="nf">#&#39;</span><span class="nb">string-equal</span><span class="p">)))))))</span>
    <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nv">construct</span>
            <span class="p">(</span><span class="nb">remove-duplicates</span>
             <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">cdr</span>
                     <span class="p">(</span><span class="nb">remove-if</span>
                      <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">pair</span><span class="p">)</span>
                        <span class="p">(</span><span class="nb">find</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">pair</span><span class="p">)</span> <span class="nv">rels</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">string-equal</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">car</span><span class="p">))</span>
                      <span class="nv">rels</span><span class="p">))</span>
             <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">string-equal</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">construct-relation-tree</span> <span class="vg">*relations*</span><span class="p">)</span>
<span class="c1">; =&gt; ((&quot;Adam&quot;</span>
<span class="c1">;      (&quot;Cain&quot;</span>
<span class="c1">;       (&quot;Enoch&quot;</span>
<span class="c1">;        (&quot;Irad&quot;</span>
<span class="c1">;         (&quot;Mehujael&quot; (&quot;Methusael&quot; (&quot;Lamech&quot; (&quot;Jabal&quot;) (&quot;Jubal&quot;) (&quot;Tubalcain&quot;)))))))</span>
<span class="c1">;      (&quot;Abel&quot;)</span>
<span class="c1">;      (&quot;Seth&quot;)))</span>

<span class="c1">;;; In a similar way, we can  construct the dependency tree between C source and</span>
<span class="c1">;;; header files.</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">parse-file-dependencies</span> <span class="p">(</span><span class="nb">pathname</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">deps</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">in</span> <span class="nb">pathname</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">line</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">read-line</span> <span class="nv">in</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">)</span>
            <span class="nv">while</span> <span class="nv">line</span>
            <span class="nb">do</span> <span class="p">(</span><span class="nv">ppcre:do-scans</span>
                   <span class="p">(</span><span class="nv">m-s</span> <span class="nv">m-e</span> <span class="nv">r-ss</span> <span class="nv">r-es</span>
                    <span class="s">&quot;\\s*#\\s*include\\s*[&lt;\&quot;]([^&gt;\&quot;]+)[&gt;\&quot;]&quot;</span> <span class="nv">line</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">line</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">r-ss</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">r-es</span> <span class="mi">0</span><span class="p">))</span> <span class="nv">deps</span><span class="p">))))</span>
    <span class="nv">deps</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">construct-file-relations</span> <span class="p">(</span><span class="nv">pathnames</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">mapcan</span>
   <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">child</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">mapcar</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">parent</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">cons</span>
                <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;~A.~A&quot;</span> <span class="p">(</span><span class="nb">pathname-name</span> <span class="nv">child</span><span class="p">)</span> <span class="p">(</span><span class="nb">pathname-type</span> <span class="nv">child</span><span class="p">))</span>
                <span class="nv">parent</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">parse-file-dependencies</span> <span class="nv">child</span><span class="p">)))</span>
   <span class="nv">pathnames</span><span class="p">))</span>

<span class="p">(</span><span class="nv">construct-file-relations</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;/tmp/c/hello.c&quot;</span> <span class="s">&quot;/tmp/c/hello.h&quot;</span> <span class="s">&quot;/tmp/c/main.c&quot;</span><span class="p">))</span>
<span class="c1">; =&gt; ((&quot;hello.c&quot; . &quot;hello.h&quot;)</span>
<span class="c1">;     (&quot;hello.c&quot; . &quot;stdio.h&quot;)</span>
<span class="c1">;     (&quot;main.c&quot; . &quot;hello.h&quot;)</span>
<span class="c1">;     (&quot;main.c&quot; . &quot;stdlib.h&quot;)</span>
<span class="c1">;     (&quot;main.c&quot; . &quot;stdio.h&quot;))</span>

<span class="p">(</span><span class="nv">construct-relation-tree</span>
 <span class="p">(</span><span class="nv">construct-file-relations</span>
  <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;/tmp/c/hello.c&quot;</span> <span class="s">&quot;/tmp/c/hello.h&quot;</span> <span class="s">&quot;/tmp/c/main.c&quot;</span><span class="p">)))</span>
<span class="c1">; =&gt; ((&quot;hello.h&quot; (&quot;hello.c&quot;) (&quot;main.c&quot;))</span>
<span class="c1">;     (&quot;stdlib.h&quot; (&quot;main.c&quot;))</span>
<span class="c1">;     (&quot;stdio.h&quot; (&quot;hello.c&quot;) (&quot;main.c&quot;)))</span>

<span class="c1">;;; Actually, whole PLEAC  example was related with hash  tables in its original</span>
<span class="c1">;;; demonstration.  But  the more I  think about it,  the more I find  that list</span>
<span class="c1">;;; structures are  more suitable for  this kind of  a tasks. But it  is obvious</span>
<span class="c1">;;; that, `REMOVE-DUPLICATES&#39; kind of  tricks will perform poorly when duplicate</span>
<span class="c1">;;; eliminations will consume the majority  of the computation power and in such</span>
<span class="c1">;;; a situation you&#39;ll inevitably need hash tables.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN280"
>Program: dutree</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">hash-branch</span> <span class="p">(</span><span class="nv">weight</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">tree</span> <span class="no">nil</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">hash-tree-add</span> <span class="p">(</span><span class="nv">branch</span> <span class="nv">path</span> <span class="nv">weight</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">branch</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">branch</span> <span class="p">(</span><span class="nv">make-hash-branch</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">prog1</span> <span class="nv">branch</span>
      <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nv">hash-branch-weight</span> <span class="nv">branch</span><span class="p">)</span> <span class="nv">weight</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">when</span> <span class="nv">path</span>
        <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">hash-branch-tree</span> <span class="nv">branch</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">hash-branch-tree</span> <span class="nv">branch</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">path</span><span class="p">)</span> <span class="p">(</span><span class="nv">hash-branch-tree</span> <span class="nv">branch</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">hash-tree-add</span>
               <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">path</span><span class="p">)</span> <span class="p">(</span><span class="nv">hash-branch-tree</span> <span class="nv">branch</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">rest</span> <span class="nv">path</span><span class="p">)</span> <span class="nv">weight</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">hash-tree-&gt;list-tree</span> <span class="p">(</span><span class="nv">branch</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">branch</span>
    <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">hash-branch-weight</span> <span class="nv">branch</span><span class="p">)</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">tree</span> <span class="p">(</span><span class="nv">hash-branch-tree</span> <span class="nv">branch</span><span class="p">))</span>
                <span class="p">(</span><span class="nv">accum</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">when</span> <span class="nv">tree</span>
              <span class="p">(</span><span class="nb">maphash</span>
               <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">val</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">key</span> <span class="p">(</span><span class="nv">hash-tree-&gt;list-tree</span> <span class="nv">val</span><span class="p">))</span> <span class="nv">accum</span><span class="p">))</span>
               <span class="nv">tree</span><span class="p">)</span>
              <span class="nv">accum</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-list-tree</span> <span class="p">(</span><span class="nv">branches</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">depth</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">branch</span> <span class="p">(</span><span class="nb">sort</span> <span class="p">(</span><span class="nb">copy-list</span> <span class="nv">branches</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nb">&gt;</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">second</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~8D |&quot;</span> <span class="p">(</span><span class="nb">second</span> <span class="nv">branch</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">loop</span> <span class="nv">repeat</span> <span class="nv">depth</span> <span class="nb">do</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;--&quot;</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;-&gt; ~A~%&quot;</span> <span class="p">(</span><span class="nb">first</span> <span class="nv">branch</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">print-list-tree</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">branch</span><span class="p">)</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">depth</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">du-output-&gt;size-path-pair</span> <span class="p">(</span><span class="nb">string</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-input-from-string</span> <span class="p">(</span><span class="nv">in</span> <span class="nb">string</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">line</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">read-line</span> <span class="nv">in</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">)</span>
          <span class="nv">while</span> <span class="nv">line</span>
          <span class="nv">collect</span> <span class="p">(</span><span class="nv">ppcre:register-groups-bind</span> <span class="p">(</span><span class="nv">size</span> <span class="nv">path</span><span class="p">)</span>
                      <span class="p">(</span><span class="s">&quot;^\(\[^\\s\]+\)\\s+\(\[^\\s\]+\)$&quot;</span> <span class="nv">line</span><span class="p">)</span>
                    <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">parse-integer</span> <span class="nv">size</span><span class="p">)</span>
                          <span class="p">(</span><span class="nb">delete-if</span> <span class="nf">#&#39;</span><span class="nb">zerop</span> <span class="p">(</span><span class="nv">ppcre:split</span> <span class="s">&quot;/&quot;</span> <span class="nv">path</span><span class="p">)</span>
                                     <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">length</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">du-output-&gt;list-tree</span> <span class="p">(</span><span class="nb">string</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">branch</span> <span class="p">(</span><span class="nv">make-hash-branch</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">size-path-pair</span> <span class="p">(</span><span class="nv">du-output-&gt;size-path-pair</span> <span class="nb">string</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">hash-tree-add</span> <span class="nv">branch</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">size-path-pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">size-path-pair</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">rest</span> <span class="p">(</span><span class="nv">hash-tree-&gt;list-tree</span> <span class="nv">branch</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">du-output-&gt;list-tree</span>
  <span class="p">(</span><span class="nv">trivial-shell:shell-command</span> <span class="s">&quot;du -ab /tmp/c&quot;</span><span class="p">))</span>
<span class="c1">; =&gt; ((&quot;tmp&quot; 21026</span>
<span class="c1">;      (&quot;c&quot; 21026 (&quot;hello.h&quot; 71) (&quot;hello.c&quot; 128) (&quot;main.c&quot; 123) (&quot;main&quot; 9168)</span>
<span class="c1">;       (&quot;out&quot; 1212 (&quot;stdout&quot; 44) (&quot;stderr&quot; 246) (&quot;debug&quot; 256)))))</span>

<span class="p">(</span><span class="nv">print-list-tree</span>
 <span class="p">(</span><span class="nv">du-output-&gt;list-tree</span>
  <span class="p">(</span><span class="nv">trivial-shell:shell-command</span> <span class="s">&quot;du -ab /tmp/c&quot;</span><span class="p">)))</span>
<span class="c1">; =&gt;    21026 |-&gt; tmp</span>
<span class="c1">;       21026 |---&gt; c</span>
<span class="c1">;        9168 |-----&gt; main</span>
<span class="c1">;        1212 |-----&gt; out</span>
<span class="c1">;         256 |-------&gt; debug</span>
<span class="c1">;         246 |-------&gt; stderr</span>
<span class="c1">;          44 |-------&gt; stdout</span>
<span class="c1">;         128 |-----&gt; hello.c</span>
<span class="c1">;         123 |-----&gt; main.c</span>
<span class="c1">;          71 |-----&gt; hello.h</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="arrays.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="patternmatching.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Arrays</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Pattern Matching</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>