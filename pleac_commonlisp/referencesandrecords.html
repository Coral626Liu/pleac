<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>References and Records</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Common Lisp"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Subroutines"
HREF="subroutines.html"><LINK
REL="NEXT"
TITLE="Packages, Libraries, and Modules"
HREF="packagesetc.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Common Lisp</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="subroutines.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="packagesetc.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="REFERENCESANDRECORDS"
>11. References and Records</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN592"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="c1">;; In CL you don&#39;t need extra syntax to treat variables (symbols) as</span>
<span class="c1">;; references, they already work that way.</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="nv">sref</span><span class="p">)</span> <span class="c1">; prints the value that the reference SREF refers to</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">sref</span> <span class="mi">3</span><span class="p">)</span>                           <span class="c1">; assigns SREF&#39;s referent</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; The Perl subsection here isn&#39;t any different from the above, in CL.</span>
<span class="c1">;;print ${$sref};             # prints the scalar $sref refers to</span>
<span class="c1">;;${$sref} = 3;               # assigns to $sref&#39;s referent</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; We&#39;re calling this MY-AREF instead of AREF to avoid confusion with</span>
<span class="c1">;; CL&#39;s built-in AREF function.</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">my-aref</span> <span class="nc">array</span><span class="p">)</span>       <span class="c1">; no special synatx needed to get reference</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; Not sure what the Perl here is trying to show.  Probably has no</span>
<span class="c1">;; realistic equivalent in CL.</span>
<span class="c1">;; $pi = \3.14159;</span>
<span class="c1">;; $$pi = 4;           # runtime error</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">my-aref</span> <span class="o">#(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; new array (no &quot;anonymous&quot; distinction in CL)</span>
<span class="c1">;; MKHASH defined in appendix, not standard CL</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">href</span> <span class="p">(</span><span class="nv">mkhash</span> <span class="s">&quot;How&quot;</span> <span class="s">&quot;Now&quot;</span> <span class="s">&quot;Brown&quot;</span> <span class="s">&quot;Cow&quot;</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">makunbound</span> <span class="ss">&#39;my-aref</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">my-aref</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="nv">my-aref</span><span class="p">)</span>
<span class="c1">;; #(1 2 3)</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; Perl doesn&#39;t support &quot;rectangular&quot; multi-dimensional arrays (i.e.,</span>
<span class="c1">;; a continuous block of memory with all cells preallocated), instead</span>
<span class="c1">;; it supports &quot;jagged&quot; arrays (i.e., arrays of references to other</span>
<span class="c1">;; arrays).  CL supports rectangular arrays by default, but there&#39;s</span>
<span class="c1">;; nothing stopping you from using jagged arrays instead, since CL</span>
<span class="c1">;; arrays can contain anything.  In this example we&#39;ll assume jagged</span>
<span class="c1">;; arrays, to match the Perl example&#39;s semantics.</span>

<span class="c1">;; You could go like this, but it is a lot of typing and is confusing</span>
<span class="c1">;; to read.</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">aref</span> <span class="p">(</span><span class="nb">aref</span> <span class="p">(</span><span class="nb">aref</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">a</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">23</span><span class="p">)</span> <span class="mi">53</span><span class="p">)</span> <span class="mi">21</span><span class="p">)</span> <span class="s">&quot;fred&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="p">(</span><span class="nb">aref</span> <span class="p">(</span><span class="nb">aref</span> <span class="p">(</span><span class="nb">aref</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">a</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">23</span><span class="p">)</span> <span class="mi">53</span><span class="p">)</span> <span class="mi">21</span><span class="p">))</span>
<span class="c1">;; fred</span>

<span class="c1">;; An AREF-like macro to handle jagged arrays will save typing/errors.</span>
<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">perl-aref</span> <span class="p">(</span><span class="nc">array</span> <span class="k">&amp;rest</span> <span class="nv">subscripts</span><span class="p">)</span>
  <span class="s">&quot;Allows AREF-like access to arrays-of-refrences (as opposed to true</span>
<span class="s">multidimensional arrays.)&quot;</span>
  <span class="p">(</span><span class="k">labels</span> <span class="p">((</span><span class="nv">make-arefs</span> <span class="p">(</span><span class="nc">array</span> <span class="nv">subscripts</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if</span> <span class="nv">subscripts</span>
                 <span class="p">(</span><span class="nv">make-arefs</span> <span class="o">`</span><span class="p">(</span><span class="nb">aref</span> <span class="o">,</span><span class="nc">array</span> <span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">subscripts</span><span class="p">))</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">subscripts</span><span class="p">))</span>
                 <span class="nc">array</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">make-arefs</span> <span class="nc">array</span> <span class="nv">subscripts</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">perl-aref</span> <span class="nv">a</span> <span class="mi">4</span> <span class="mi">23</span> <span class="mi">53</span> <span class="mi">21</span><span class="p">)</span> <span class="s">&quot;fred&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="p">(</span><span class="nv">perl-aref</span> <span class="nv">a</span> <span class="mi">4</span> <span class="mi">23</span> <span class="mi">53</span> <span class="mi">21</span><span class="p">))</span>
<span class="c1">;; fred</span>

<span class="c1">;; Each of the following will print out the entire substructure.</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="p">(</span><span class="nv">perl-aref</span> <span class="nv">a</span> <span class="mi">4</span> <span class="mi">23</span> <span class="mi">53</span><span class="p">))</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="p">(</span><span class="nv">perl-aref</span> <span class="nv">a</span> <span class="mi">4</span> <span class="mi">23</span><span class="p">))</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="p">(</span><span class="nv">perl-aref</span> <span class="nv">a</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">op-cit</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">cite</span> <span class="nv">ibid</span><span class="p">)</span> <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;couldn&#39;t make a reference&quot;</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; MKHASH defined in appendix</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">nat</span> <span class="p">(</span><span class="nv">mkhash</span> <span class="s">&quot;Name&quot;</span> <span class="s">&quot;Leonhard Euler&quot;</span>
                  <span class="s">&quot;Address&quot;</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;1729 Ramanujan Lane~%Mathworld, PI 31416&quot;</span><span class="p">)</span>
                  <span class="s">&quot;Birthday&quot;</span> <span class="mh">#x5bb5580</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN595"
>Taking References to Arrays</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">my-aref</span> <span class="nc">array</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">anon-array</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">anon-copy</span> <span class="p">(</span><span class="nb">copy-seq</span> <span class="nv">my-array</span><span class="p">))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">implicit-creation</span> <span class="p">(</span><span class="nb">copy-seq</span> <span class="o">#(</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">8</span> <span class="mi">10</span><span class="p">)))</span> <span class="c1">; not sure this is what the Perl means</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">vector-push-extend</span> <span class="mi">11</span> <span class="nv">anon-array</span><span class="p">)</span>      <span class="c1">; ANON-ARRAY must have fill pointer (unlike above)</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">two</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">implicit-creation</span> <span class="mi">0</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">last-idx</span> <span class="p">(</span><span class="nb">1-</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">my-aref</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">num-items</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">my-aref</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; check wehther SOMEREF contains a simple array reference</span>
<span class="p">(</span><span class="nb">check-type</span> <span class="nv">someref</span> <span class="kt">simple-vector</span><span class="p">)</span> <span class="c1">; CHECK-TYPE does a die() implicitly, if necessary</span>

<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~{~A~^ ~}~%&quot;</span> <span class="p">(</span><span class="nb">coerce</span> <span class="nv">array-ref</span> <span class="ss">&#39;list</span><span class="p">))</span>

<span class="c1">;; SORT modifies the original array so we use STABLE-SORT to be more</span>
<span class="c1">;; like the Perl example.</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">order</span> <span class="p">(</span><span class="nb">stable-sort</span> <span class="nv">array-ref</span> <span class="ss">&#39;&lt;</span><span class="p">))</span>

<span class="c1">;; Only works if ARRAY-REF has a fill-pointer</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">array-ref</span> <span class="p">(</span><span class="nb">make-array</span> <span class="mi">0</span> <span class="ss">:adjustable</span> <span class="no">t</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span><span class="p">))</span> <span class="c1">; for example</span>
<span class="p">(</span><span class="nb">vector-push-extend</span> <span class="nv">item</span> <span class="nv">array-ref</span><span class="p">)</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">array-ref</span> <span class="p">()</span>
  <span class="c1">;; This is probably the closest to what the Perl would return.</span>
  <span class="p">(</span><span class="nb">make-array</span> <span class="mi">0</span> <span class="ss">:adjustable</span> <span class="no">t</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="nv">aref1</span> <span class="p">(</span><span class="nv">array-ref</span><span class="p">))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">aref2</span> <span class="p">(</span><span class="nv">array-ref</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">array-ref</span> <span class="nv">n</span><span class="p">))</span>      <span class="c1">; access item in position N, works on any array</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">array-ref</span> <span class="nv">n</span><span class="p">))</span> <span class="c1">; access item in position N, possibly fastest, only</span>
                                    <span class="c1">; works on type SIMPLE-VECTOR (single-dimensional arrays)</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">array-ref</span> <span class="nv">n</span><span class="p">))</span>       <span class="c1">; same, works on any sequence type, but possibly slower</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">pie</span> <span class="o">#(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">))</span>
<span class="p">(</span><span class="nb">make-array</span> <span class="mi">3</span> <span class="ss">:displaced-to</span> <span class="nv">pie</span> <span class="ss">:displaced-index-offset</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; array slice</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">pie</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="o">#(</span><span class="s">&quot;blackberry&quot;</span> <span class="s">&quot;blueberry&quot;</span> <span class="s">&quot;pumpkin&quot;</span><span class="p">))</span> <span class="c1">; note 6 instead of 5, not a typo</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">sliceref</span> <span class="p">(</span><span class="nb">make-array</span> <span class="mi">3</span> <span class="ss">:displaced-to</span> <span class="nv">pie</span> <span class="ss">:displaced-index-offset</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; not wrong</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">map</span> <span class="no">nil</span>
     <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">item</span><span class="p">)</span>
         <span class="c1">;; ITEM has data</span>
         <span class="p">)</span>
     <span class="nv">array-ref</span><span class="p">)</span>

<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">idx</span> <span class="p">(</span><span class="nb">array-dimension</span> <span class="nv">array-ref</span> <span class="mi">0</span><span class="p">))</span>
  <span class="c1">;; (svref array-ref idx) has data</span>
  <span class="p">)</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN598"
>Making Hashes of Arrays</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="c1">;; Note: HASH must be creaed with :TEST &#39;EQUAL</span>
<span class="p">(</span><span class="nb">push</span> <span class="s">&quot;new value&quot;</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;KEYNAME&quot;</span> <span class="nv">hash</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">loop</span>
   <span class="nv">for</span> <span class="nb">string</span> <span class="nv">being</span> <span class="k">the</span> <span class="nv">hash-keys</span> <span class="nv">of</span> <span class="nv">hash</span>
   <span class="nb">do</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A: ~A~%&quot;</span> <span class="nb">string</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nb">string</span> <span class="nv">hash</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;a key&quot;</span> <span class="nv">hash</span><span class="p">)</span> <span class="o">#(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1">; anonymous array</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;a key&quot;</span> <span class="nv">hash</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1">; ...or a list would work too</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nb">values</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;a key&quot;</span> <span class="nv">hash</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">push</span> <span class="nv">value</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;a key&quot;</span> <span class="nv">hash</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">residents</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nc">number</span> <span class="nv">phone2name</span><span class="p">))</span> <span class="c1">; will be NIL if not found</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; The Perl example would translate to the same thing as the previous</span>
<span class="c1">;; subsection in CL (since GETHASH returns NIL when there is no value,</span>
<span class="c1">;; and NIL is the empty list).  However, to match the &quot;sprit&quot; of the</span>
<span class="c1">;; Perl example (and return an empty array instead of an empty list),</span>
<span class="c1">;; you could do the following, which takes advantage of the fact that</span>
<span class="c1">;; GETHASH returns a second value indicating whether or not the hash</span>
<span class="c1">;; key actually has a value.</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">residents</span> <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">value</span> <span class="nv">exists</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nc">number</span> <span class="nv">phone2name</span><span class="p">)</span>
                  <span class="p">(</span><span class="k">if</span> <span class="nv">exists</span>
                      <span class="nv">value</span>
                      <span class="o">#(</span><span class="p">))))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN601"
>Taking References to Hashes</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">href</span> <span class="nv">hash</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">anon-hash</span> <span class="p">(</span><span class="nv">mkhash</span> <span class="s">&quot;key1&quot;</span> <span class="s">&quot;value1&quot;</span> <span class="s">&quot;key2&quot;</span> <span class="s">&quot;value2&quot;</span> <span class="o">...</span><span class="p">))</span> <span class="c1">; MKHASH defined in appendix</span>

<span class="c1">;; Couldn&#39;t find anything like this in standard CL.  Someone please</span>
<span class="c1">;; correct me if I&#39;m wrong.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">copy-hash-table</span> <span class="p">(</span><span class="nc">hash-table</span><span class="p">)</span>
  <span class="s">&quot;Make shallow copy of HASH.&quot;</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">newhash</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="p">(</span><span class="nb">hash-table-test</span> <span class="nc">hash-table</span><span class="p">)</span>
                                  <span class="ss">:size</span> <span class="p">(</span><span class="nb">hash-table-size</span> <span class="nc">hash-table</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">being</span> <span class="k">the</span> <span class="nv">hash-keys</span> <span class="nv">of</span> <span class="nc">hash-table</span> <span class="nv">using</span> <span class="p">(</span><span class="nv">hash-value</span> <span class="nv">value</span><span class="p">)</span>
         <span class="nb">do</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">newhash</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nc">hash-table</span><span class="p">)))</span>
    <span class="nv">newhash</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="nv">anonymous-hash-copy</span> <span class="p">(</span><span class="nv">copy-hash-table</span> <span class="nv">hash</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">hash</span> <span class="nv">href</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">value</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">href</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="nv">slice</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">in</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">key1</span> <span class="nv">key2</span> <span class="nv">key3</span><span class="p">)</span>
                 <span class="nv">collect</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">href</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">keys</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">being</span> <span class="k">the</span> <span class="nv">hash-keys</span> <span class="nv">of</span> <span class="nv">href</span> <span class="nv">collect</span> <span class="nv">key</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">check-type</span> <span class="nv">someref</span> <span class="nc">hash-table</span><span class="p">)</span> <span class="c1">; CHECK-TYPE does a die() implicitly, if necessary</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">href</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">env</span> <span class="nv">inc</span><span class="p">))</span> <span class="c1">; ENV and INC don&#39;t exist in CL, just matching the Perl</span>
  <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">being</span> <span class="k">the</span> <span class="nv">hash-keys</span> <span class="nv">of</span> <span class="nv">href</span> <span class="nv">using</span> <span class="p">(</span><span class="nv">hash-value</span> <span class="nv">value</span><span class="p">)</span>
       <span class="nb">do</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A =&gt; ~A~%&quot;</span> <span class="nv">key</span> <span class="nv">value</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nb">values</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">in</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;key1&quot;</span> <span class="s">&quot;key2&quot;</span> <span class="s">&quot;key3&quot;</span><span class="p">)</span>
                <span class="nv">collect</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">hash-ref</span><span class="p">)))</span>

<span class="c1">;; The following will NOT work like the Perl example, VAL is a copy of</span>
<span class="c1">;; the hash value because numeric values are copied.</span>
<span class="p">(</span><span class="nb">dolist</span> <span class="nv">val</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">in</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;key1&quot;</span> <span class="s">&quot;key2&quot;</span> <span class="s">&quot;key3&quot;</span><span class="p">)</span>
               <span class="nv">collect</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">hash-ref</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">incf</span> <span class="nv">val</span> <span class="mi">7</span><span class="p">))</span>              <span class="c1">; does NOT modify hash table at all</span>

<span class="c1">;; You&#39;d have to do something like this instead.</span>
<span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">in</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;key1&quot;</span> <span class="s">&quot;key2&quot;</span> <span class="s">&quot;key3&quot;</span><span class="p">)</span>
   <span class="nb">do</span> <span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">hash-ref</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">7</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN604"
>Taking References to Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="c1">;; If you want to be able to call the function using the alias like</span>
<span class="c1">;; &quot;normal&quot; (i.e., as the first element of a form) SETF its</span>
<span class="c1">;; SYMBOL-FUNCTION:</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;cref</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nv">func</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;cref</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="o">...</span><span class="p">)))</span>

<span class="c1">;; If you do the following instead, you&#39;ll have to use APPLY and/or</span>
<span class="c1">;; FUNCALL.</span>
<span class="p">(</span><span class="nb">setf</span> <span class="ss">&#39;cref2</span> <span class="nf">#&#39;</span><span class="nv">func</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="ss">&#39;cref2</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="o">...</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">returned</span> <span class="p">(</span><span class="nv">cref</span> <span class="o">...</span><span class="p">))</span>
<span class="c1">;; If you have a list of arguments (more like the Perl example):</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">returned</span> <span class="p">(</span><span class="nb">apply</span> <span class="ss">&#39;cref</span> <span class="nv">arguments</span><span class="p">))</span>
<span class="c1">;; Or you can use FUNCALL (not that you really need to in this case)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">returned</span> <span class="p">(</span><span class="nb">funcall</span> <span class="ss">&#39;cref</span> <span class="o">...</span><span class="p">))</span>

<span class="c1">;; If you didn&#39;t use SYMBOL-FUNCTION, then you can do the following:</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">returned</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">cref</span> <span class="nv">arguments</span><span class="p">))</span> <span class="c1">; note the lack of a &#39; in front of CREF</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">returned</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">cref</span> <span class="o">...</span><span class="p">))</span>      <span class="c1">; ditto</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">thefunc</span> <span class="p">()</span>
  <span class="c1">;; ...</span>
  <span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">funcname</span> <span class="s">&quot;THEFUNC&quot;</span><span class="p">)</span>  <span class="c1">; upper-case to pick up correct symbol name</span>
<span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">intern</span> <span class="nv">funcname</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; MKHASH defined in appendix</span>
<span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*commands*</span>
  <span class="p">(</span><span class="nv">mkhash</span> <span class="s">&quot;happy&quot;</span> <span class="nf">#&#39;</span><span class="nv">joy</span>
          <span class="s">&quot;sad&quot;</span> <span class="nf">#&#39;</span><span class="nv">sullen</span>
          <span class="s">&quot;done&quot;</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;See ya!&quot;</span><span class="p">))</span>
          <span class="s">&quot;mad&quot;</span> <span class="nf">#&#39;</span><span class="nv">angry</span><span class="p">))</span>

<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;How are you?&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nb">string</span> <span class="p">(</span><span class="nv">chomp</span> <span class="p">(</span><span class="nb">read-line</span><span class="p">)))</span> <span class="c1">; CHOMP defined in appendix</span>
       <span class="p">(</span><span class="nv">command</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nb">string</span> <span class="vg">*commands*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">command</span>
      <span class="p">(</span><span class="nb">funcall</span> <span class="nv">command</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;No such command: ~A~%&quot;</span> <span class="nb">string</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">counter-maker</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">start</span> <span class="mi">0</span><span class="p">))</span>
    <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
        <span class="p">(</span><span class="nb">prog1</span> <span class="nv">start</span>                       <span class="c1">; return value of START prior to increment</span>
          <span class="p">(</span><span class="nb">incf</span> <span class="nv">start</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;counter</span><span class="p">)</span> <span class="p">(</span><span class="nv">counter-maker</span><span class="p">))</span>

<span class="p">(</span><span class="nb">loop</span> <span class="nv">repeat</span> <span class="mi">5</span> <span class="nb">do</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A~%&quot;</span> <span class="p">(</span><span class="nv">counter</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;counter1</span><span class="p">)</span> <span class="p">(</span><span class="nv">counter-maker</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;counter2</span><span class="p">)</span> <span class="p">(</span><span class="nv">counter-maker</span><span class="p">))</span>

<span class="p">(</span><span class="nb">loop</span> <span class="nv">repeat</span> <span class="mi">5</span> <span class="nb">do</span> <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A~%&quot;</span> <span class="p">(</span><span class="nv">counter1</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A ~A~%&quot;</span> <span class="p">(</span><span class="nv">counter1</span><span class="p">)</span> <span class="p">(</span><span class="nv">counter2</span><span class="p">))</span>
<span class="c1">;; 0</span>
<span class="c1">;; 1</span>
<span class="c1">;; 2</span>
<span class="c1">;; 3</span>
<span class="c1">;; 4</span>
<span class="c1">;; 5 0</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">timestamp</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">start-time</span> <span class="p">(</span><span class="nb">get-universal-time</span><span class="p">)))</span>
    <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
        <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">get-universal-time</span><span class="p">)</span> <span class="nv">start-time</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;early</span><span class="p">)</span> <span class="p">(</span><span class="nv">timestamp</span><span class="p">))</span>
<span class="p">(</span><span class="nb">sleep</span> <span class="mi">20</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;later</span><span class="p">)</span> <span class="p">(</span><span class="nv">timestamp</span><span class="p">))</span>
<span class="p">(</span><span class="nb">sleep</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;It&#39;s been ~D seconds since early.~%&quot;</span> <span class="p">(</span><span class="nv">early</span><span class="p">))</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;It&#39;s been ~D seconds since later.~%&quot;</span> <span class="p">(</span><span class="nv">later</span><span class="p">))</span>
<span class="c1">;; It&#39;s been 30 seconds since early.</span>
<span class="c1">;; It&#39;s been 10 seconds since later.</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN607"
>Taking References to Scalars</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="c1">;; Although you can&#39;t get a reference directly to the scalar that a</span>
<span class="c1">;; symbol points to (at least, not if it&#39;s a number or character), you</span>
<span class="c1">;; can just refer to the symbol itself, for largely the same effect.</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">scalar-ref</span> <span class="ss">&#39;scalar</span><span class="p">)</span>               <span class="c1">; get reference to symbol</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; Not sure what this was trying to demonstrate.</span>
<span class="c1">;;undef $anon_scalar_ref;</span>
<span class="c1">;;$$anon_scalar_ref = 15;</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; There&#39;s no way to do this in CL that I know of.</span>
<span class="c1">;;$anon_scalar_ref = \15;</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A&quot;</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">scalar-ref</span><span class="p">))</span> <span class="c1">; dereference it</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">scalar-ref</span><span class="p">)</span> <span class="p">(</span><span class="nb">concatenate</span> <span class="ss">&#39;string</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">scalar-ref</span><span class="p">)</span> <span class="s">&quot;string&quot;</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; This is a BAD idea in CL.  Symbols are relatively expensive, there</span>
<span class="c1">;; is no guarantee that name collisions won&#39;t happen, possible memory</span>
<span class="c1">;; leak issues, etc.</span>
<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">symbol-number</span> <span class="mi">-1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">defun</span> <span class="nv">new-anon-symbol</span> <span class="p">()</span>
    <span class="p">(</span><span class="nb">intern</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">&quot;_NEWANONSYM~D&quot;</span> <span class="p">(</span><span class="nb">incf</span> <span class="nv">symbol-number</span><span class="p">)))))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">sref</span> <span class="p">(</span><span class="nv">new-anon-symbol</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">sref</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Three = ~A~%&quot;</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">sref</span><span class="p">))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">my-array</span> <span class="p">(</span><span class="nb">vector</span> <span class="p">(</span><span class="nv">new-anon-symbol</span><span class="p">)</span> <span class="p">(</span><span class="nv">new-anon-symbol</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">my-array</span> <span class="mi">0</span><span class="p">))</span> <span class="mf">6.02e23</span>
      <span class="p">(</span><span class="nb">symbol-value</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">my-array</span> <span class="mi">1</span><span class="p">))</span> <span class="s">&quot;avocado&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;ARRAY contains: ~{~A~^, ~}~%&quot;</span> <span class="p">(</span><span class="nb">map</span> <span class="ss">&#39;list</span> <span class="ss">&#39;symbol-value</span> <span class="nc">array</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">var</span> <span class="p">(</span><span class="nb">with-output-to-string</span> <span class="p">(</span><span class="nv">output</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">sb-ext:run-program</span> <span class="s">&quot;uptime&quot;</span> <span class="no">nil</span> <span class="ss">:search</span> <span class="no">t</span> <span class="ss">:output</span> <span class="nv">output</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">vref</span> <span class="ss">&#39;var</span><span class="p">)</span>
<span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">scan</span> <span class="s">&quot;load&quot;</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">vref</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">vref</span><span class="p">)</span> <span class="p">(</span><span class="nv">chomp</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">vref</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; check whether SOMEREF contains a reference to a symbol, which we&#39;re</span>
<span class="c1">;; using instead of Perl&#39;s scalar references.</span>
<span class="p">(</span><span class="nb">check-type</span> <span class="nv">someref</span> <span class="ss">&#39;symbol</span><span class="p">)</span>            <span class="c1">; does the die() for us</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN610"
>Creating Arrays of Scalar References</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">array-of-scalar-refs</span> <span class="p">(</span><span class="nb">vector</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; Note that because #() quotes its contents, A and B refer to the</span>
<span class="c1">;; symbols A and B, not their values, which is the closest</span>
<span class="c1">;; approximation to what the Perl is doing.</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">array-of-scalar-refs</span> <span class="o">#(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">array-of-scalar-refs</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">12</span><span class="p">)</span> <span class="c1">; B = 12</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="k">setq</span> <span class="nv">a</span> <span class="mi">1</span> <span class="nv">b</span> <span class="mi">2</span> <span class="nv">c</span> <span class="mi">3</span> <span class="nv">d</span> <span class="mi">4</span><span class="p">)</span>                  <span class="c1">; initialize</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">my-array</span> <span class="p">(</span><span class="nb">vector</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span> <span class="ss">&#39;d</span><span class="p">))</span>    <span class="c1">; refs to each symbol</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">my-array</span> <span class="o">#(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>              <span class="c1">; same thing!</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">my-array</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">repeat</span> <span class="mi">4</span> <span class="nv">collect</span> <span class="p">(</span><span class="nv">new-anon-symbol</span><span class="p">)))</span> <span class="c1">; allocate 4 anon symbols</span>

<span class="p">(</span><span class="nb">incf</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">my-array</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">9</span><span class="p">)</span> <span class="c1">; C now 12</span>

<span class="p">(</span><span class="k">symbol-macrolet</span> <span class="p">((</span><span class="nv">element</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">my-array</span> <span class="p">(</span><span class="nb">1-</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">my-array</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="nv">element</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">element</span> <span class="mi">5</span><span class="p">))</span>          <span class="c1">; D now 20</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="nv">element</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">element</span> <span class="mi">5</span><span class="p">)))</span>         <span class="c1">; D now 100</span>

<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">tmp</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">my-array</span> <span class="p">(</span><span class="nb">1-</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">my-array</span><span class="p">)))))</span>   <span class="c1">; using temporary</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">tmp</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">tmp</span><span class="p">))))</span> <span class="c1">; D now 500</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; Note that PI is built in to CL.</span>
<span class="p">(</span><span class="nb">map</span> <span class="ss">&#39;nil</span>
     <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">sref</span><span class="p">)</span>
         <span class="s">&quot;Replace with spherical volumes.&quot;</span>
         <span class="p">(</span><span class="k">symbol-macrolet</span> <span class="p">((</span><span class="nv">element</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="nv">sref</span><span class="p">)))</span>
           <span class="p">(</span><span class="nb">setf</span> <span class="nv">element</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">expt</span> <span class="nv">element</span> <span class="mi">3</span><span class="p">)</span>
                            <span class="p">(</span><span class="nb">*</span> <span class="m">4/3</span> <span class="nv">pi</span><span class="p">)))))</span>
     <span class="nv">my-array</span><span class="p">)</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN613"
>Using Closures Instead of Objects</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">c1</span> <span class="p">(</span><span class="nv">mkcounter</span> <span class="mi">20</span><span class="p">)</span>
      <span class="nv">c2</span> <span class="p">(</span><span class="nv">mkcounter</span> <span class="mi">77</span><span class="p">))</span>

<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;next c1: ~d~%&quot;</span> <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;NEXT&quot;</span> <span class="nv">c1</span><span class="p">)))</span> <span class="c1">; 21</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;next c2: ~d~%&quot;</span> <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;NEXT&quot;</span> <span class="nv">c2</span><span class="p">)))</span> <span class="c1">; 78</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;next c1: ~d~%&quot;</span> <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;NEXT&quot;</span> <span class="nv">c1</span><span class="p">)))</span> <span class="c1">; 22</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;last c1: ~d~%&quot;</span> <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;PREV&quot;</span> <span class="nv">c1</span><span class="p">)))</span> <span class="c1">; 21</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;old  c2: ~d~%&quot;</span> <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;RESET&quot;</span> <span class="nv">c2</span><span class="p">)))</span> <span class="c1">; 77</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">mkcounter</span> <span class="p">(</span><span class="nv">start</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nb">count</span> <span class="nv">start</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">bundle</span>
          <span class="c1">;; MKHASH defined in appendix</span>
          <span class="p">(</span><span class="nv">mkhash</span>
           <span class="s">&quot;NEXT&quot;</span>   <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nb">incf</span> <span class="nb">count</span><span class="p">))</span>
           <span class="s">&quot;PREV&quot;</span>   <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nb">decf</span> <span class="nb">count</span><span class="p">))</span>
           <span class="s">&quot;GET&quot;</span>    <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="nb">count</span><span class="p">)</span>
           <span class="s">&quot;SET&quot;</span>    <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">new-count</span><span class="p">)</span> <span class="p">(</span><span class="nb">setf</span> <span class="nb">count</span> <span class="nv">new-count</span><span class="p">))</span>
           <span class="s">&quot;BUMP&quot;</span>   <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">delta</span><span class="p">)</span> <span class="p">(</span><span class="nb">incf</span> <span class="nb">count</span> <span class="nv">delta</span><span class="p">))</span>
           <span class="s">&quot;RESET&quot;</span>  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nb">setf</span> <span class="nb">count</span> <span class="nv">start</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;LAST&quot;</span> <span class="nv">bundle</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;PREV&quot;</span> <span class="nv">bundle</span><span class="p">))</span>
    <span class="nv">bundle</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN616"
>Creating References to Methods</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="c1">;; Methods in CL are generic functions that can be specialized on any</span>
<span class="c1">;; of their arguments.  The technique that the Perl code is using to</span>
<span class="c1">;; allow calling meth() without the $obj-&gt; is needless in CL.  You can</span>
<span class="c1">;; make a reference to a method, the same way you might make a</span>
<span class="c1">;; referece a normal function.  There&#39;s not much point in doing this,</span>
<span class="c1">;; normally.</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;mref</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nv">meth</span><span class="p">)</span>
<span class="c1">;; later...</span>
<span class="p">(</span><span class="nv">mref</span> <span class="s">&quot;args&quot;</span> <span class="s">&quot;go&quot;</span> <span class="s">&quot;here&quot;</span><span class="p">)</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">symbol-funtion</span> <span class="ss">&#39;sref</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nv">meth</span><span class="p">)</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN619"
>Constructing Records</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="c1">;; MKHASH defined in appendix</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">record</span> <span class="p">(</span><span class="nv">mkhash</span>
              <span class="ss">:name</span>    <span class="s">&quot;Jason&quot;</span>
              <span class="ss">:empno</span>   <span class="mi">132</span>
              <span class="ss">:title</span>   <span class="s">&quot;deputy peon&quot;</span>
              <span class="ss">:age</span>     <span class="mi">23</span>
              <span class="ss">:salary</span>  <span class="mi">37000</span>
              <span class="ss">:pals</span>    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Norbert&quot;</span> <span class="s">&quot;Rhys&quot;</span> <span class="s">&quot;Phineas&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;I am ~A, and my pals are ~{~A~^, ~}~%&quot;</span>
        <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:name</span> <span class="nv">record</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:pals</span> <span class="nv">record</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*byname*</span> <span class="p">(</span><span class="nb">make-hash-table</span> <span class="ss">:test</span> <span class="ss">&#39;equal</span><span class="p">))</span>
<span class="c1">;; store record</span>
<span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">gethash</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:name</span> <span class="nv">record</span><span class="p">)</span> <span class="vg">*byname*</span><span class="p">)</span> <span class="nv">record</span><span class="p">)</span>

<span class="c1">;; later on, look up by name</span>
<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">rp</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Aron&quot;</span> <span class="vg">*byname*</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">rp</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Aron is employee number ~D~%&quot;</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:empno</span> <span class="nv">rp</span><span class="p">))))</span>

<span class="c1">;; give jason a new pal</span>
<span class="p">(</span><span class="nb">push</span> <span class="s">&quot;Theodore&quot;</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:pals</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Jason&quot;</span> <span class="vg">*byname*</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Jason now has ~D pals~%&quot;</span> <span class="p">(</span><span class="nb">length</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:pals</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Jason&quot;</span> <span class="vg">*byname*</span><span class="p">))))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; Go through all records</span>
<span class="p">(</span><span class="nb">maphash</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">record</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A is employee number ~D~%&quot;</span> <span class="nv">name</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:empno</span> <span class="nv">record</span><span class="p">)))</span>
         <span class="vg">*byname*</span><span class="p">)</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; store record</span>
<span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*employees*</span> <span class="p">(</span><span class="nb">make-array</span> <span class="mi">0</span> <span class="ss">:adjustable</span> <span class="no">t</span><span class="p">))</span>
<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">empno</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:empno</span> <span class="nv">record</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">array-in-bounds-p</span> <span class="vg">*employees*</span> <span class="nv">empno</span><span class="p">)</span>
    <span class="c1">;; :INITIAL-ELEMENT used to prevent array from being extended with 0&#39;s</span>
    <span class="p">(</span><span class="nb">adjust-array</span> <span class="vg">*employees*</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">empno</span><span class="p">)</span> <span class="ss">:initial-element</span> <span class="no">nil</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">aref</span> <span class="vg">*employees*</span> <span class="nv">empno</span><span class="p">)</span> <span class="nv">record</span><span class="p">))</span>

<span class="c1">;; lookup by id</span>
<span class="p">(</span><span class="nv">when-let</span> <span class="p">(</span><span class="nv">rp</span> <span class="p">(</span><span class="nb">aref</span> <span class="vg">*employees*</span> <span class="mi">132</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;employee 132 is ~A~%&quot;</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:name</span> <span class="nv">rp</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; The use of SYMBOL-MACROLET saves us from repeating a complicated</span>
<span class="c1">;; expression multiple times.  Could also define a macro to make this</span>
<span class="c1">;; easier.</span>
<span class="p">(</span><span class="k">symbol-macrolet</span> <span class="p">((</span><span class="nv">salary</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:salary</span> <span class="p">(</span><span class="nb">gethash</span> <span class="s">&quot;Jason&quot;</span> <span class="vg">*byname*</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="nv">salary</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">salary</span> <span class="mf">1.035</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">peons</span> <span class="p">(</span><span class="nb">remove-if-not</span>
             <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">employee</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">and</span> <span class="nv">employee</span>
                      <span class="p">(</span><span class="nv">scan</span> <span class="p">(</span><span class="nv">create-scanner</span> <span class="s">&quot;peon&quot;</span> <span class="ss">:case-insensitive-mode</span> <span class="no">t</span><span class="p">)</span>
                                     <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:title</span> <span class="nv">employee</span><span class="p">))))</span>
             <span class="vg">*employees*</span><span class="p">))</span>
<span class="c1">;; Or:</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">peons</span> <span class="p">(</span><span class="nv">perl-grep</span> <span class="vg">*employees*</span>
              <span class="p">(</span><span class="nb">and</span> <span class="nv">it</span>
                   <span class="p">(</span><span class="nv">scan</span> <span class="p">(</span><span class="nv">create-scanner</span> <span class="s">&quot;peon&quot;</span> <span class="ss">:case-insensitive-mode</span> <span class="no">t</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:title</span> <span class="nv">it</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">setf</span> <span class="nv">tsevens</span> <span class="p">(</span><span class="nb">remove-if-not</span>
               <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">employee</span><span class="p">)</span>
                   <span class="p">(</span><span class="nb">and</span> <span class="nv">employee</span>
                        <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:age</span> <span class="nv">employee</span><span class="p">)</span>
                           <span class="mi">27</span><span class="p">)))</span>
               <span class="vg">*employees*</span><span class="p">))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">hash-slice</span> <span class="p">(</span><span class="nv">hash</span> <span class="k">&amp;rest</span> <span class="nv">keys</span><span class="p">)</span>
  <span class="s">&quot;Meant to emulate Perl&#39;s built-in hash slicing feature.&quot;</span>
  <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">in</span> <span class="nv">keys</span> <span class="nv">collect</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">hash</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">rp</span> <span class="p">(</span><span class="nb">sort</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">v</span> <span class="nv">being</span> <span class="k">the</span> <span class="nv">hash-values</span> <span class="nv">of</span> <span class="vg">*byname*</span> <span class="nv">collect</span> <span class="nv">v</span><span class="p">)</span>
                 <span class="ss">&#39;string-lessp</span>
                 <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">hash</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:age</span> <span class="nv">hash</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A is employee number ~D.~%&quot;</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:name</span> <span class="nv">rp</span><span class="p">)</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:age</span> <span class="nv">rp</span><span class="p">))</span>
  <span class="c1">;; or with a hash slice on the reference (note that we&#39;re using the</span>
  <span class="c1">;; non-standard HASH-SLICE function defined above, whereas Perl</span>
  <span class="c1">;; has a built-in to do it).</span>
  <span class="p">(</span><span class="nb">apply</span> <span class="ss">&#39;format</span> <span class="no">t</span> <span class="s">&quot;~A is employee number ~D.~%&quot;</span> <span class="p">(</span><span class="nv">hash-slice</span> <span class="nv">rp</span> <span class="ss">:name</span> <span class="ss">:age</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; use BYAGE, an array of lists of records</span>
<span class="p">(</span><span class="nb">push</span> <span class="nv">record</span> <span class="p">(</span><span class="nb">aref</span> <span class="vg">*byage*</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:age</span> <span class="nv">record</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">age</span> <span class="p">(</span><span class="nb">length</span> <span class="vg">*byage*</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">when-let</span> <span class="p">(</span><span class="nv">records</span> <span class="p">(</span><span class="nb">aref</span> <span class="vg">*byage*</span> <span class="nv">age</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Age ~D: &quot;</span> <span class="nv">age</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">rp</span> <span class="nv">records</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:name</span> <span class="nv">rp</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~%&quot;</span><span class="p">)))</span>
<span class="c1">;;;-----------------------------</span>
<span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">age</span> <span class="p">(</span><span class="nb">length</span> <span class="vg">*byage*</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">when-let</span> <span class="p">(</span><span class="nv">records</span> <span class="p">(</span><span class="nb">aref</span> <span class="vg">*byage*</span> <span class="nv">age</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Age ~D: ~{~A~^, ~}~%&quot;</span> <span class="nv">age</span> <span class="p">(</span><span class="nb">map</span> <span class="ss">&#39;list</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">employee</span><span class="p">)</span>
                                                        <span class="p">(</span><span class="nb">gethash</span> <span class="ss">:name</span> <span class="nv">employee</span><span class="p">))</span>
                                              <span class="p">(</span><span class="nb">aref</span> <span class="vg">*byage*</span> <span class="nv">age</span><span class="p">)))))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN622"
>Reading and Writing Hash Records to Text Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>
<span class="c1">;; FieldName: Value</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; Using list instead of array since random access not required.</span>
<span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*list-of-records*</span> <span class="no">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">map</span> <span class="no">nil</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">record</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">key</span> <span class="p">(</span><span class="nb">sort</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">k</span> <span class="nv">being</span> <span class="k">the</span> <span class="nv">hash-keys</span> <span class="nv">of</span> <span class="nv">record</span> <span class="nv">collect</span> <span class="nv">k</span><span class="p">)</span>
                                <span class="ss">&#39;string-lessp</span> <span class="ss">:key</span> <span class="ss">&#39;symbol-name</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A: ~A~%&quot;</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">gethash</span> <span class="nv">key</span> <span class="nv">record</span><span class="p">)))</span>
             <span class="p">(</span><span class="nb">terpri</span><span class="p">))</span>                  <span class="c1">; same as (format t &quot;~%&quot;)</span>
     <span class="vg">*list-of-records*</span><span class="p">)</span>
<span class="c1">;;;-----------------------------</span>
<span class="c1">;; GET-PARAGRAPH defined above</span>
<span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">filename</span> <span class="nv">filenames</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">file</span> <span class="nv">filename</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">loop</span>
       <span class="nv">for</span> <span class="nv">paragraph</span> <span class="nb">=</span> <span class="p">(</span><span class="nv">get-paragraph</span> <span class="nv">file</span><span class="p">)</span>
       <span class="nv">until</span> <span class="p">(</span><span class="nb">string-equal</span> <span class="nv">paragraph</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
       <span class="nb">do</span>
       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">fields</span>
              <span class="p">(</span><span class="nv">split</span> <span class="p">(</span><span class="nv">create-scanner</span> <span class="s">&quot;^([^:]+):\\s*&quot;</span> <span class="ss">:multi-line-mode</span> <span class="no">t</span><span class="p">)</span>
                              <span class="nv">paragraph</span> <span class="ss">:with-registers-p</span> <span class="no">t</span><span class="p">)))</span>
         <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">apply</span> <span class="ss">&#39;mkhash</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">fields</span><span class="p">))</span> <span class="vg">*list-of-records*</span><span class="p">)))))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN625"
>Printing Data Structures</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN628"
>Copying Data Structures</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN631"
>Storing Data Structures to Disk</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN634"
>Transparently Persistent Data Structures</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN637"
>Program: Binary Trees</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;;-----------------------------</span>

<span class="c1">;;; Binary trees example</span>
<span class="p">(</span><span class="nb">deftype</span> <span class="nv">tree</span> <span class="p">()</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">or</span> <span class="nb">null</span> <span class="nv">tree-node</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defstruct</span> <span class="p">(</span><span class="nv">tree-node</span>
             <span class="p">(</span><span class="ss">:conc-name</span> <span class="ss">#:tree-</span><span class="p">))</span>
  <span class="nv">value</span>
  <span class="c1">;; subtrees</span>
  <span class="p">(</span><span class="nv">left</span> <span class="no">nil</span> <span class="ss">:type</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">right</span> <span class="no">nil</span> <span class="ss">:type</span> <span class="nv">tree</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">tree-insert</span> <span class="p">(</span><span class="nv">tree</span> <span class="nv">value</span><span class="p">)</span>
  <span class="s">&quot;Return TREE with destructively inserted VALUE.&quot;</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">type</span> <span class="nv">tree</span> <span class="nv">tree</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">tree</span>
      <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">value</span> <span class="p">(</span><span class="nv">tree-value</span> <span class="nv">tree</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">tree-left</span> <span class="nv">tree</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">tree-insert</span> <span class="p">(</span><span class="nv">tree-left</span> <span class="nv">tree</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">tree-right</span> <span class="nv">tree</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">tree-insert</span> <span class="p">(</span><span class="nv">tree-right</span> <span class="nv">tree</span><span class="p">)</span> <span class="nv">value</span><span class="p">)))</span>
             <span class="nv">tree</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">make-tree-node</span> <span class="ss">:value</span> <span class="nv">value</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-tree-in-order</span> <span class="p">(</span><span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">tree</span>
    <span class="p">(</span><span class="nv">print-tree-in-order</span> <span class="p">(</span><span class="nv">tree-left</span> <span class="nv">tree</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~S &quot;</span> <span class="p">(</span><span class="nv">tree-value</span> <span class="nv">tree</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">print-tree-in-order</span> <span class="p">(</span><span class="nv">tree-right</span> <span class="nv">tree</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-tree-in-preorder</span> <span class="p">(</span><span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">tree</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~S &quot;</span> <span class="p">(</span><span class="nv">tree-value</span> <span class="nv">tree</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">print-tree-in-preorder</span> <span class="p">(</span><span class="nv">tree-left</span> <span class="nv">tree</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">print-tree-in-preorder</span> <span class="p">(</span><span class="nv">tree-right</span> <span class="nv">tree</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-tree-in-postorder</span> <span class="p">(</span><span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">tree</span>
    <span class="p">(</span><span class="nv">print-tree-in-postorder</span> <span class="p">(</span><span class="nv">tree-left</span> <span class="nv">tree</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">print-tree-in-postorder</span> <span class="p">(</span><span class="nv">tree-right</span> <span class="nv">tree</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~S &quot;</span> <span class="p">(</span><span class="nv">tree-value</span> <span class="nv">tree</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">search-tree</span> <span class="p">(</span><span class="nv">tree</span> <span class="nv">value</span><span class="p">)</span>
  <span class="s">&quot;Return a subtree of TREE with the specified VALUE in root.&quot;</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">tree</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nv">tree-value</span> <span class="nv">tree</span><span class="p">)</span> <span class="nv">value</span><span class="p">)</span>
        <span class="nv">tree</span>
        <span class="p">(</span><span class="nv">search-tree</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">value</span> <span class="p">(</span><span class="nv">tree-value</span> <span class="nv">tree</span><span class="p">))</span>
                         <span class="p">(</span><span class="nv">tree-left</span> <span class="nv">tree</span><span class="p">)</span>
                         <span class="p">(</span><span class="nv">tree-right</span> <span class="nv">tree</span><span class="p">))</span>
                     <span class="nv">value</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">test-trees</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">tree</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">20</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="nv">tree</span> <span class="p">(</span><span class="nv">tree-insert</span> <span class="nv">tree</span> <span class="p">(</span><span class="nb">random</span> <span class="mi">1000</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~&amp;Pre order: &quot;</span><span class="p">)</span> <span class="p">(</span><span class="nv">print-tree-in-preorder</span> <span class="nv">tree</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~&amp;In order:  &quot;</span><span class="p">)</span> <span class="p">(</span><span class="nv">print-tree-in-order</span> <span class="nv">tree</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~&amp;Postorder: &quot;</span><span class="p">)</span> <span class="p">(</span><span class="nv">print-tree-in-postorder</span> <span class="nv">tree</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">terpri</span><span class="p">)</span>

    <span class="p">(</span><span class="nb">loop</span> <span class="nb">do</span>
         <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~&amp;Search? &quot;</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">finish-output</span><span class="p">)</span>
         <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">eof</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">))</span> <span class="c1">; some hard-to-enter object</span>
                <span class="p">(</span><span class="nv">value</span> <span class="p">(</span><span class="nb">read</span> <span class="vg">*standard-input*</span> <span class="no">nil</span> <span class="nv">eof</span><span class="p">)))</span>
           <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">value</span> <span class="nv">eof</span><span class="p">)</span> <span class="p">(</span><span class="nb">loop-finish</span><span class="p">))</span>
           <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">found</span> <span class="p">(</span><span class="nv">search-tree</span> <span class="nv">tree</span> <span class="nv">value</span><span class="p">)))</span>
             <span class="p">(</span><span class="k">if</span> <span class="nv">found</span>
                 <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Found ~S at ~S~%&quot;</span> <span class="nv">value</span> <span class="nv">found</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;No ~S in tree~%&quot;</span> <span class="nv">value</span><span class="p">)))))))</span>
<span class="c1">;;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="subroutines.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="packagesetc.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Subroutines</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Packages, Libraries, and Modules</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>