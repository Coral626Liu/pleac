<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Arrays</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Guile 1.8"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Dates and Times"
HREF="datesandtimes.html"><LINK
REL="NEXT"
TITLE="Hashes"
HREF="hashes.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Guile 1.8</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="datesandtimes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="hashes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ARRAYS"
>4. Arrays</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN170"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="k">define </span><span class="nv">nested</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;this&quot;</span> <span class="s">&quot;that&quot;</span> <span class="s">&quot;the&quot;</span> <span class="s">&quot;other&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">nested</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;this&quot;</span> <span class="s">&quot;that&quot;</span> <span class="p">(</span><span class="s">&quot;the&quot;</span> <span class="s">&quot;other&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">tune</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;The&quot;</span> <span class="s">&quot;Star-Spangled&quot;</span> <span class="s">&quot;Banner&quot;</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN173"
>Specifying a List In Your Program</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;quick&quot;</span> <span class="s">&quot;brown&quot;</span> <span class="s">&quot;fox&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Why&quot;</span> <span class="s">&quot;are&quot;</span> <span class="s">&quot;you&quot;</span> <span class="s">&quot;teasing&quot;</span> <span class="s">&quot;me?&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">lines</span>
  <span class="p">(</span><span class="nb">map </span><span class="nv">string-trim</span>
       <span class="p">(</span><span class="nf">string-tokenize</span> <span class="s">&quot;\</span>
<span class="s">    The boy stood on the burning deck,</span>
<span class="s">    It was as hot as glass.&quot;</span>
			<span class="sc">#\newline</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">bigarray</span>
  <span class="p">(</span><span class="nb">with-input-from-file </span><span class="s">&quot;mydatafile&quot;</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
      <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">lines</span> <span class="o">&#39;</span><span class="p">())</span>
		 <span class="p">(</span><span class="nf">next-line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">next-line</span><span class="p">)</span>
	    <span class="p">(</span><span class="nb">reverse </span><span class="nv">lines</span><span class="p">)</span>
	    <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">next-line</span> <span class="nv">lines</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">read-line</span><span class="p">)))))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">banner</span> <span class="s">&quot;The Mines of Moria&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">name</span> <span class="s">&quot;Gandalf&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">banner</span>
  <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;Speak, &quot;</span> <span class="nv">name</span> <span class="s">&quot;, and enter!&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">banner</span>
  <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;Speak, ~A, and welcome!&quot;</span> <span class="nv">name</span><span class="p">))</span>

<span class="c1">;; Advanced shell-like function is provided by guile-scsh, the Guile</span>
<span class="c1">;; port of SCSH, the Scheme shell.  Here we roll our own using the</span>
<span class="c1">;; pipe primitives that come with core Guile.</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">popen</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">drain-output</span> <span class="nv">port</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">chars</span> <span class="o">&#39;</span><span class="p">())</span>
             <span class="p">(</span><span class="nf">next</span> <span class="p">(</span><span class="nb">read-char </span><span class="nv">port</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eof-object? </span><span class="nv">next</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">list-&gt;string </span><span class="p">(</span><span class="nf">reverse!</span> <span class="nv">chars</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">next</span> <span class="nv">chars</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">read-char </span><span class="nv">port</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">qx</span> <span class="nv">pipeline</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">pipe</span> <span class="p">(</span><span class="nf">open-input-pipe</span> <span class="nv">pipeline</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">output</span> <span class="p">(</span><span class="nf">drain-output</span> <span class="nv">pipe</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">close-pipe</span> <span class="nv">pipe</span><span class="p">)</span>
    <span class="nv">output</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">his-host</span> <span class="s">&quot;www.perl.com&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">host-info</span> <span class="p">(</span><span class="nf">qx</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;nslookup ~A&quot;</span> <span class="nv">his-host</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">perl-info</span> <span class="p">(</span><span class="nf">qx</span> <span class="p">(</span><span class="nf">format</span> <span class="no">#f</span> <span class="s">&quot;ps ~A&quot;</span> <span class="p">(</span><span class="nf">getpid</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">shell-info</span> <span class="p">(</span><span class="nf">qx</span> <span class="s">&quot;ps $$&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">banner</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Costs&quot;</span> <span class="s">&quot;only&quot;</span> <span class="s">&quot;$4.95&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">brax</span>    <span class="p">(</span><span class="nb">map </span><span class="nv">string</span> <span class="p">(</span><span class="nb">string-&gt;list </span><span class="s">&quot;()&lt;&gt;{}[]&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">rings</span>   <span class="p">(</span><span class="nf">string-tokenize</span> <span class="s">&quot;Nenya Narya Vilya&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">tags</span>    <span class="p">(</span><span class="nf">string-tokenize</span> <span class="s">&quot;LI TABLE TR TD A IMG H1 P&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">sample</span>
  <span class="p">(</span><span class="nf">string-tokenize</span> <span class="s">&quot;The vertical bar (|) looks and behaves like a pipe.&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">ships</span>  <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Nińa&quot;</span> <span class="s">&quot;Pinta&quot;</span> <span class="s">&quot;Santa María&quot;</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN176"
>Printing a List with Commas</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="k">define </span><span class="nv">array</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;red&quot;</span> <span class="s">&quot;yellow&quot;</span> <span class="s">&quot;green&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">begin</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;I have &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">for-each </span><span class="nv">display</span> <span class="nv">array</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot; marbles.\n&quot;</span><span class="p">))</span>
<span class="c1">;; I have redyellowgreen marbles.</span>

<span class="p">(</span><span class="nf">begin</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;I have &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">colour</span><span class="p">)</span>
	      <span class="p">(</span><span class="nb">display </span><span class="nv">colour</span><span class="p">)</span>
	      <span class="p">(</span><span class="nb">display </span><span class="s">&quot; &quot;</span><span class="p">))</span>
	    <span class="nv">array</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="s">&quot;marbles.\n&quot;</span><span class="p">))</span>
<span class="c1">;; I have red yellow green marbles.</span>

<span class="c1">;; commify - insertion of commas into list output</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">commify</span> <span class="nv">strings</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nb">length </span><span class="nv">strings</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">case </span><span class="nv">len</span>
      <span class="p">((</span><span class="mi">0</span><span class="p">)</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
      <span class="p">((</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">strings</span><span class="p">))</span>
      <span class="p">((</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">strings</span><span class="p">)</span> <span class="s">&quot; and &quot;</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">strings</span><span class="p">)))</span>
      <span class="p">((</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">strings</span><span class="p">)</span> <span class="s">&quot;, &quot;</span>
                          <span class="p">(</span><span class="nb">cadr </span><span class="nv">strings</span><span class="p">)</span> <span class="s">&quot;, and &quot;</span>
                          <span class="p">(</span><span class="nb">caddr </span><span class="nv">strings</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">else</span>
       <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">strings</span><span class="p">)</span> <span class="s">&quot;, &quot;</span>
                      <span class="p">(</span><span class="nf">commify</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">strings</span><span class="p">)))))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">lists</span> <span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;just one thing&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;Mutt&quot;</span> <span class="s">&quot;Jeff&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;Peter&quot;</span> <span class="s">&quot;Paul&quot;</span> <span class="s">&quot;Mary&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;To our parents&quot;</span> <span class="s">&quot;Mother Theresa&quot;</span> <span class="s">&quot;God&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;pastrami&quot;</span> <span class="s">&quot;ham and cheese&quot;</span> <span class="s">&quot;peanut butter and jelly&quot;</span> <span class="s">&quot;tuna&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;recycle tired, old phrases&quot;</span> <span class="s">&quot;ponder big, happy thoughts&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="s">&quot;recycle tired, old phrases&quot;</span>
                 <span class="s">&quot;ponder big, happy thoughts&quot;</span>
                 <span class="s">&quot;sleep and dream peacefully&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">list</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">display </span><span class="s">&quot;The list is: &quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">commify</span> <span class="nv">list</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">display </span><span class="s">&quot;.\n&quot;</span><span class="p">))</span>
          <span class="nv">lists</span><span class="p">)</span>

<span class="c1">;; The list is: just one thing.</span>
<span class="c1">;; The list is: Mutt and Jeff.</span>
<span class="c1">;; The list is: Peter, Paul, and Mary.</span>
<span class="c1">;; The list is: To our parents, Mother Theresa, and God.</span>
<span class="c1">;; The list is: pastrami, ham and cheese, peanut butter and jelly, and tuna.</span>
<span class="c1">;; The list is: recycle tired, old phrases and ponder big, happy thoughts.</span>
<span class="c1">;; The list is: recycle tired, old phrases, ponder big, happy thoughts, and</span>
<span class="c1">;; sleep and dream peacefully.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN179"
>Changing Array Size</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;;-----------------------------</span>

<span class="c1">;; Scheme does not normally grow and shrink arrays in the way that</span>
<span class="c1">;; Perl can.  The more usual operations are adding and removing from</span>
<span class="c1">;; the head of a list using the `cons&#39; and `cdr&#39; procedures.</span>
<span class="c1">;; However ...</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">grow/shrink</span> <span class="nv">list</span> <span class="nv">new-size</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">size</span> <span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&lt; </span><span class="nv">size</span> <span class="nv">new-size</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">grow/shrink</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;&quot;</span> <span class="nv">list</span><span class="p">)</span> <span class="nv">new-size</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">&gt; </span><span class="nv">size</span> <span class="nv">new-size</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">grow/shrink</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">list</span><span class="p">)</span> <span class="nv">new-size</span><span class="p">))</span>
          <span class="p">(</span><span class="k">else </span><span class="nv">list</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">element</span> <span class="nv">list</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list-ref </span><span class="nv">list</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">)</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">set-element</span> <span class="nv">list</span> <span class="nv">i</span> <span class="nv">value</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">i</span> <span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">list</span> <span class="p">(</span><span class="nf">grow/shrink</span> <span class="nv">list</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">set-car! </span><span class="p">(</span><span class="nf">list-cdr-ref</span> <span class="nv">list</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">)</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="nv">list</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">what-about</span> <span class="nv">list</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">len</span> <span class="p">(</span><span class="nb">length </span><span class="nv">list</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;The array now has ~A elements.\n&quot;</span> <span class="nv">len</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;The index of the last element is ~A.\n&quot;</span> <span class="p">(</span><span class="nb">- </span><span class="nv">len</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">format</span> <span class="no">#t</span> <span class="s">&quot;Element #3 is `~A&#39;.\n&quot;</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">len</span> <span class="mi">3</span><span class="p">)</span>
                                           <span class="p">(</span><span class="nf">element</span> <span class="nv">list</span> <span class="mi">3</span><span class="p">)</span>
                                           <span class="s">&quot;&quot;</span><span class="p">))))</span>

<span class="c1">;; In the emulation of Perl arrays implemented here, the elements are</span>
<span class="c1">;; in reverse order when compared to normal Scheme lists.</span>
<span class="p">(</span><span class="k">define </span><span class="nv">people</span> <span class="p">(</span><span class="nb">reverse </span><span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Crosby&quot;</span> <span class="s">&quot;Stills&quot;</span> <span class="s">&quot;Nash&quot;</span> <span class="s">&quot;Young&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">what-about</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The array now has 4 elements.</span>
<span class="c1">;; The index of the last element is 3.</span>
<span class="c1">;; Element #3 is `Young&#39;.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">people</span> <span class="p">(</span><span class="nf">grow/shrink</span> <span class="nv">people</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nf">what-about</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The array now has 3 elements.</span>
<span class="c1">;; The index of the last element is 2.</span>
<span class="c1">;; Element #3 is `&#39;.</span>
<span class="c1">;;-----------------------------</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">people</span> <span class="p">(</span><span class="nf">grow/shrink</span> <span class="nv">people</span> <span class="mi">10001</span><span class="p">))</span>
<span class="p">(</span><span class="nf">what-about</span> <span class="nv">people</span><span class="p">)</span>
<span class="c1">;;-----------------------------</span>
<span class="c1">;; The array now has 10001 elements.</span>
<span class="c1">;; The index of the last element is 10000.</span>
<span class="c1">;; Element #3 is `&#39;.</span>
<span class="c1">;;-----------------------------</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN182"
>Doing Something with Every Element in a List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Using a &#39;list&#39; i.e. chain of pairs</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*mylist*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">; Apply procedure to each member of &#39;mylist&#39;</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">item</span><span class="p">))</span>
  <span class="nv">*mylist*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Using a &#39;vector&#39; i.e. one-dimensional array</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*bad-users*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot;lou&quot;</span> <span class="s">&quot;mo&quot;</span> <span class="s">&quot;sterling&quot;</span> <span class="s">&quot;john&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;You&#39;re a *bad user*,&quot;</span> <span class="nv">user</span><span class="p">))</span>

<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span> <span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">))</span>
  <span class="nv">*bad-users*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Could probably get away with sorting a list of strings ...</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*sorted-environ*</span>
  <span class="p">(</span><span class="nf">sort</span> <span class="p">(</span><span class="nf">environ</span><span class="p">)</span> <span class="nv">string&lt;?</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">var</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>
  <span class="nv">*sorted-environ*</span><span class="p">)</span>

<span class="c1">;; ----</span>

<span class="c1">; ... but the intent here is to sort a hash table, so we&#39;ll use</span>
<span class="c1">; an &#39;assoc&#39;, Scheme&#39;s native dictionary type, which is really</span>
<span class="c1">; nothing more than a list of conses / dotted pairs [hash tables</span>
<span class="c1">; will be used in later examples]</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cons-&gt;env-string</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">car </span><span class="nv">a</span><span class="p">)</span> <span class="s">&quot;=&quot;</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">a</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">env-string-&gt;cons</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">key-value</span> <span class="p">(</span><span class="nf">string-split</span> <span class="nv">s</span> <span class="sc">#\=</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">key-value</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">key-value</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*sorted-environ-assoc*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="p">(</span><span class="nf">map</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">var</span><span class="p">)</span> <span class="p">(</span><span class="nf">env-string-&gt;cons</span> <span class="nv">var</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">environ</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span> <span class="p">(</span><span class="nb">string&lt;? </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">)))</span> <span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">var</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">var</span><span class="p">)</span> <span class="s">&quot;=&quot;</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">var</span><span class="p">)))</span>
  <span class="nv">*sorted-environ-assoc*</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*MAX-QUOTA*</span> <span class="mi">100</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-all-users</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-usage</span> <span class="nv">user</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">disk-usage</span> <span class="p">(</span><span class="nf">get-usage</span> <span class="nv">user</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">disk-usage</span> <span class="nv">*MAX-QUOTA*</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">complain</span> <span class="nv">user</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">get-all-users</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">string=? </span><span class="nv">user</span> <span class="s">&quot;tchrist&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">user</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">string-split</span> <span class="p">(</span><span class="nf">qx</span> <span class="s">&quot;who|cut -d&#39; &#39; -f1|uniq&quot;</span><span class="p">)</span> <span class="sc">#\newline</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-13</span><span class="p">)</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-14</span><span class="p">))</span>

<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">line</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)</span> <span class="p">(</span><span class="nf">read-line</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">eof-object? </span><span class="nv">line</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">for-each</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">word</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">string-reverse</span> <span class="nv">word</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">string-tokenize</span> <span class="nv">line</span> <span class="nv">char-set:graphic</span><span class="p">)))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Updates vector in-place [accepts variable number of vectors]</span>
<span class="c1">; See also the library function, &#39;array-map-in-order!&#39; and its</span>
<span class="c1">; brethren</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-map-in-order!</span> <span class="nv">proc</span> <span class="nv">vec</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">all-vec</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">vec</span> <span class="nv">rest</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">vec</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">end</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">idx</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">cond</span>
              <span class="p">((</span><span class="nb">= </span><span class="nv">idx</span> <span class="nv">end</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
              <span class="p">(</span><span class="nf">else</span>
                <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="nv">idx</span>
                  <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">idx</span><span class="p">))))</span>
                <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">idx</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">)))</span>
      <span class="nv">all-vec</span><span class="p">)))</span>

<span class="c1">;; ----</span>

<span class="c1">; A non-mutating version - illustration only, as library routines</span>
<span class="c1">; [SRFI-43 and built-ins] should be preferred</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-map-in-order</span> <span class="nv">proc</span> <span class="nv">vec</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">all-vec</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">vec</span> <span class="nv">rest</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec-len</span> <span class="p">(</span><span class="nf">reduce</span> <span class="nv">+</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">map </span><span class="nv">vector-length</span> <span class="nv">all-vec</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">new-vec-len</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec-idx</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">all-vec</span> <span class="nv">all-vec</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">new-vec-idx</span> <span class="nv">new-vec-len</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="nf">array-for-each</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">list </span><span class="nv">element</span><span class="p">)))</span>
              <span class="p">(</span><span class="k">set! </span><span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-vec-idx</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">car </span><span class="nv">all-vec</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">all-vec</span><span class="p">))</span> <span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;i =&quot;</span> <span class="nv">item</span><span class="p">))</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;i =&quot;</span> <span class="nv">item</span><span class="p">))</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">; Since a &#39;vector&#39; is mutable, in-place updates allowed</span>
<span class="p">(</span><span class="nf">vector-map-in-order!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">item</span> <span class="mi">1</span><span class="p">))</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mf">0.5</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="nf">vector-map-in-order!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">item</span> <span class="mi">7</span><span class="p">))</span>
  <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Using &#39;for-each&#39; to iterate over several container items is a</span>
<span class="c1">; simple matter of passing a list of those items e.g. a list of</span>
<span class="c1">; strings, or of arrays etc.</span>
<span class="c1">;</span>
<span class="c1">; However, complications arise when:</span>
<span class="c1">; * Heterogenous list of items e.g. list contains all of arrays,</span>
<span class="c1">;   hashes, strings, etc. Necesitates different handling based on type</span>
<span class="c1">; * Item needs updating. It is not possible to alter the item reference</span>
<span class="c1">;   and updating an item&#39;s internals is only possible if the relevant</span>
<span class="c1">;   mutating procedures are implemented e.g. specified string characters</span>
<span class="c1">;   may be altered in-place, but character deletion requires a new be</span>
<span class="c1">;   created [i.e. altering the item reference], so is not possible</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*scalar*</span> <span class="s">&quot;123 &quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot; 123 &quot;</span> <span class="s">&quot;456 &quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*hash*</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="s">&quot;key1&quot;</span> <span class="s">&quot;123 &quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="s">&quot;key2&quot;</span> <span class="s">&quot; 456&quot;</span><span class="p">)))</span>

<span class="c1">; Illustrates iteration / handling of heterogenous types</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">string? </span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nf">do-stuff-with-string</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">((</span><span class="nb">vector? </span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nf">do-stuff-with-vector</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">((</span><span class="nb">pair? </span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nf">do-stuff-with-hash</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">print</span> <span class="s">&quot;unknown type&quot;</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">list </span><span class="nv">*scalar*</span> <span class="nv">*array*</span> <span class="nv">*hash*</span><span class="p">))</span>

<span class="c1">; So, for item-replacement-based updating you need to use explicit</span>
<span class="c1">; iteration e.g. &#39;do&#39; loop, or recursion [as is done in the code for</span>
<span class="c1">; &#39;vector-map-in-order!&#39;] - examples in next section. Or, you could</span>
<span class="c1">; create a new &#39;for-each&#39; type control structure using Scheme&#39;s</span>
<span class="c1">; macro facility [example not shown]</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN185"
>Iterating Over an Array by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; Whilst a &#39;vector&#39; is mutable, &#39;array-for-each&#39; passes only a copy</span>
<span class="c1">; of each cell, thus there is no way to perform updates</span>
<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="c1">;; ... do some non-array-mutating task with &#39;item&#39;...</span>
    <span class="o">&#39;</span><span class="p">())</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; For mutating operations, use one of the mutating &#39;array-map-...&#39;</span>
<span class="c1">; routines or the custom, &#39;vector-map-in-order!&#39;</span>
<span class="p">(</span><span class="nf">vector-map-in-order!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="c1">;; ... do some array-mutating task with &#39;item&#39;...</span>
    <span class="o">&#39;</span><span class="p">())</span>
  <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Alternatively, use &#39;do&#39; to iterate over the array and directly</span>
<span class="c1">; update</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">*array*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">vector-length</span><span class="p">))</span>
    <span class="c1">;; ... do some array-mutating task with current element ...</span>
    <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Alternatively, use a &#39;named let&#39; to iterate over array and</span>
<span class="c1">; directly update</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">*array*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">vector-length</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="c1">;; ... do some array-mutating task with current element ...</span>
        <span class="o">&#39;</span><span class="p">()</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*fruits*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot;Apple&quot;</span> <span class="s">&quot;Blackberry&quot;</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">array-for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">fruit</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">fruit</span> <span class="s">&quot;tastes good in a pie.&quot;</span><span class="p">))</span>
  <span class="nv">*fruits*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">*fruits*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">vector-length</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">*fruits*</span> <span class="nv">i</span><span class="p">)</span> <span class="s">&quot;tastes good in a pie.&quot;</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*rogue-cats*</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Blacky&quot;</span> <span class="s">&quot;Ginger&quot;</span> <span class="s">&quot;Puss&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*name-list*</span> <span class="p">(</span><span class="nf">acons</span> <span class="ss">&#39;felines</span> <span class="nv">*rogue-cats*</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">cat</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">cat</span> <span class="s">&quot;purrs hypnotically..&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">&#39;felines</span> <span class="nv">*name-list*</span><span class="p">)))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">felines</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">&#39;felines</span> <span class="nv">*name-list*</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nb">null? </span><span class="nv">felines</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
    <span class="p">(</span><span class="nf">else</span>
      <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">felines</span><span class="p">)</span> <span class="s">&quot;purrs hypnotically..&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">felines</span><span class="p">)))))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN188"
>Extracting Unique Elements from a List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="c1">; Simplest [read: least code] means of removing duplicates is to</span>
<span class="c1">; use SRFI-1&#39;s &#39;delete-duplicates&#39; routine</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*non-uniq-num-list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span> <span class="p">(</span><span class="nf">delete-duplicates</span> <span class="nv">*my-non-uniq-num-list*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="c1">; Another simple alternative is to use SRFI-1&#39;s &#39;lset-union&#39; routine.</span>
<span class="c1">; In general, the &#39;lset-...&#39; routines:</span>
<span class="c1">; - convenient, but not fast; probably best avoided for &#39;large&#39; sets</span>
<span class="c1">; - operate on standard lists, so simple matter of type-converting</span>
<span class="c1">;   arrays and such</span>
<span class="c1">; - care needs to be taken in choosing the needed equality function</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*non-uniq-string-list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;abc&quot;</span> <span class="s">&quot;def&quot;</span> <span class="s">&quot;ghi&quot;</span> <span class="s">&quot;abc&quot;</span> <span class="s">&quot;def&quot;</span> <span class="s">&quot;ghi&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span>
  <span class="p">(</span><span class="nf">lset-union</span> <span class="nv">string=?</span> <span class="nv">*non-uniq-string-list*</span> <span class="nv">*non-uniq-string-list*</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*non-uniq-sym-list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span>
  <span class="p">(</span><span class="nf">lset-union</span> <span class="nv">equal?</span> <span class="nv">*my-non-uniq-sym-list*</span> <span class="nv">*my-non-uniq-sym-list*</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*non-uniq-num-list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span>
  <span class="p">(</span><span class="nf">lset-union</span> <span class="nv">=</span> <span class="nv">*my-non-uniq-num-list*</span> <span class="nv">*my-non-uniq-num-list*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">;; Perl Cookbook-based examples - illustrative only, *not*</span>
<span class="c1">;; recommended approaches</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">1</span> <span class="mi">8</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*seen*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; Use hash to filter out unique items</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*seen*</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*seen*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*seen*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">))))</span>
  <span class="nv">*list*</span><span class="p">)</span>

<span class="c1">; Generate list of unique items</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*uniq*</span>
  <span class="p">(</span><span class="nf">fold-right</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="nv">*seen*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">1</span> <span class="mi">8</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*seen*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; Build list of unique items by checking set membership</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">member </span><span class="nv">item</span> <span class="nv">*seen*</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*seen*</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">*seen*</span><span class="p">))))</span>
  <span class="nv">*list*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*users*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="p">(</span><span class="nf">string-split</span> <span class="p">(</span><span class="nf">qx</span> <span class="s">&quot;who|cut -d&#39; &#39; -f1&quot;</span><span class="p">)</span> <span class="sc">#\newline</span><span class="p">)</span>
    <span class="nv">string&lt;?</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*seen*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; Build list of unique users by checking set membership</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">member </span><span class="nv">user</span> <span class="nv">*seen*</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*seen*</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">*seen*</span><span class="p">))))</span>
  <span class="nv">*list*</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN191"
>Finding Elements in One Array but Not Another</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; All problems in this section involve, at core, set difference</span>
<span class="c1">; operations. Thus, the most compact and straightforward approach</span>
<span class="c1">; is to utilise SRFI-1&#39;s &#39;lset-difference&#39; routine</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">))</span>

<span class="c1">; *difference* contains elements in *a* but not in *b*: 1 6 8</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*difference*</span> <span class="p">(</span><span class="nf">lset-difference</span> <span class="nv">=</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="c1">; *difference* contains elements in *b* but not in *a*: 2 9</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*difference*</span> <span class="p">(</span><span class="nf">lset-difference</span> <span class="nv">=</span> <span class="nv">*b*</span> <span class="nv">*a*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">;; Perl Cookbook-based example - illustrative only, *not*</span>
<span class="c1">;; recommended approaches</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a-only*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; Build list of items in *a* but not in *b*</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">member </span><span class="nv">item</span> <span class="nv">*b*</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*a-only*</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">*a-only*</span><span class="p">))))</span>
  <span class="nv">*a*</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN194"
>Computing Union, Intersection, or Difference of Unique Lists</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; The SRFI-1 &#39;lset-xxx&#39; routines are appropriate here</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">))</span>

<span class="c1">; Combined elements of *a* and *b* sans duplicates: 1 2 3 5 6 7 8 9</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*union*</span> <span class="p">(</span><span class="nf">lset-union</span> <span class="nv">=</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="c1">; Elements common to both *a* and *b*: 3 5 7</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*intersection*</span> <span class="p">(</span><span class="nf">lset-intersection</span> <span class="nv">=</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="c1">; Elements in *a* but not in *b*: 1 6 8</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*difference*</span> <span class="p">(</span><span class="nf">lset-difference</span> <span class="nv">=</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">;; Perl Cookbook-based example - illustrative only, *not*</span>
<span class="c1">;; recommended approaches</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*union*</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*isect*</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*diff*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ------------</span>

<span class="c1">; Union and intersection</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">*union*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*union*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">)))</span>
  <span class="nv">*a*</span><span class="p">)</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*union*</span> <span class="nv">item</span><span class="p">)</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*isect*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*isect*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">*union*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*union*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">)))</span>
  <span class="nv">*b*</span><span class="p">)</span>

<span class="c1">; Difference *a* and *b*</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*isect*</span> <span class="nv">item</span><span class="p">))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*diff*</span> <span class="p">(</span><span class="nf">assoc-set!</span> <span class="nv">*diff*</span> <span class="nv">item</span> <span class="no">#t</span><span class="p">))))</span>
  <span class="nv">*a*</span><span class="p">)</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*union*</span>
  <span class="p">(</span><span class="nf">fold</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="nv">*union*</span><span class="p">))</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*isect*</span>
  <span class="p">(</span><span class="nf">fold</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="nv">*isect*</span><span class="p">))</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*diff*</span>
  <span class="p">(</span><span class="nf">fold</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="nv">*diff*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Union count:       &quot;</span> <span class="p">(</span><span class="nb">length </span><span class="nv">*union*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Intersection count:&quot;</span> <span class="p">(</span><span class="nb">length </span><span class="nv">*isect*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Difference count:  &quot;</span> <span class="p">(</span><span class="nb">length </span><span class="nv">*diff*</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN197"
>Appending One Array to Another</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Arrays, specifically vectors in the current context, are fixed-size</span>
<span class="c1">; entities; joining several such together requires copying of their</span>
<span class="c1">; contents into a new, appropriately-sized, array. This task may be</span>
<span class="c1">; performed:</span>

<span class="c1">; * Directly: loop through existing arrays copying elements into a</span>
<span class="c1">;   newly-created array</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-join</span> <span class="nv">vec</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">all-vec</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">vec</span> <span class="nv">rest</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec-len</span> <span class="p">(</span><span class="nf">reduce</span> <span class="nv">+</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">map </span><span class="nv">vector-length</span> <span class="nv">all-vec</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">new-vec-len</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec-idx</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">all-vec</span> <span class="nv">all-vec</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">new-vec-idx</span> <span class="nv">new-vec-len</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="nf">array-for-each</span>
            <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">new-vec-idx</span> <span class="nv">element</span><span class="p">)</span>
              <span class="p">(</span><span class="k">set! </span><span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-vec-idx</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">car </span><span class="nv">all-vec</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">all-vec</span><span class="p">))</span> <span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array1*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*array2*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*newarray*</span>
  <span class="p">(</span><span class="nf">vector-join</span> <span class="nv">*array1*</span> <span class="nv">*array2*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; * Indirectly; convert arrays to lists, append the lists, convert</span>
<span class="c1">;   resulting list back into an array</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array1*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*array2*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*newarray*</span>
  <span class="p">(</span><span class="nb">list-&gt;vector </span><span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">vector-&gt;list </span><span class="nv">*array1*</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-&gt;list </span><span class="nv">*array2*</span><span class="p">))</span> <span class="p">))</span>

<span class="c1">; Of course if random access is not required, it is probably best to simply</span>
<span class="c1">; use lists since a wealth of list manipulation routines are available</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; While Perl offers an all-purpose &#39;splice&#39; routine, a cleaner approach is</span>
<span class="c1">; to separate out such functionality; here three routines are implemented</span>
<span class="c1">; together offering an equivalent to &#39;splice&#39;. The routines are:</span>
<span class="c1">; * vector-replace! [use with &#39;vector-copy&#39; to avoid changing original]</span>
<span class="c1">;   e.g. (vector-replace! vec ...)</span>
<span class="c1">;        (set! new-vec (vector-replace! (vector-copy vec) ...))</span>
<span class="c1">; * vector-delete</span>
<span class="c1">; * vector-insert</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-replace!</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">item</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">all-items</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">rest</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">pos</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">pos</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">in-bounds</span>
           <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">+ </span><span class="nv">pos</span> <span class="p">(</span><span class="nb">length </span><span class="nv">all-items</span><span class="p">))</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)))))</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">in-bounds</span>
      <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="nf">all-items</span> <span class="nv">all-items</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">cond</span>
          <span class="p">((</span><span class="nb">null? </span><span class="nv">all-items</span><span class="p">)</span> <span class="nv">vec</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">else</span>
            <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">car </span><span class="nv">all-items</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">all-items</span><span class="p">)))</span> <span class="p">))</span>
    <span class="c1">;else</span>
      <span class="nv">vec</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-delete</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">len</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">new-vec-len</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="nv">len</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="no">#f</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">pos</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">&lt; </span><span class="nv">new-vec-len</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">vec</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">new-vec-len</span><span class="p">))</span>
        <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">vec-idx</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">new-vec-idx</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">cond</span>
            <span class="p">((</span><span class="nb">= </span><span class="nv">new-vec-idx</span> <span class="nv">new-vec-len</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">else</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">vec-idx</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">vec-idx</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">vec-idx</span> <span class="nv">len</span><span class="p">)))</span>
              <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">vec-idx</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">vec-idx</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-vec-idx</span> <span class="mi">1</span><span class="p">))</span> <span class="p">)))</span> <span class="p">))</span> <span class="p">))</span>

<span class="c1">; This routine would probably benefit from having &#39;cmd&#39; implemented as</span>
<span class="c1">; a keyword argument. However, &#39;cmd&#39; implemented as a positional to keep</span>
<span class="c1">; example simple</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-insert</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">cmd</span> <span class="nv">item</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">all-item-vec</span> <span class="p">(</span><span class="nf">list-&gt;array</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">rest</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">all-item-vec-len</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">all-item-vec</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">vec-len</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="p">(</span><span class="nb">+ </span><span class="nv">vec-len</span> <span class="nv">all-item-vec-len</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">pos</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="nv">cmd</span> <span class="ss">&#39;after</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">pos</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">pos</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">vector-move-left!</span> <span class="nv">vec</span> <span class="mi">0</span> <span class="nv">pos</span> <span class="nv">new-vec</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">vector-move-left!</span> <span class="nv">all-item-vec</span> <span class="mi">0</span> <span class="nv">all-item-vec-len</span> <span class="nv">new-vec</span> <span class="nv">pos</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">vector-move-left!</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">vec-len</span> <span class="nv">new-vec</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">pos</span> <span class="nv">all-item-vec-len</span><span class="p">))</span>
    <span class="nv">new-vec</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*members*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot;Time&quot;</span> <span class="s">&quot;Flies&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*initiates*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="s">&quot;An&quot;</span> <span class="s">&quot;Arrow&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*members*</span> <span class="p">(</span><span class="nf">vector-join</span> <span class="nv">*members*</span> <span class="nv">*initiates*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*members*</span> <span class="p">(</span><span class="nf">vector-insert</span> <span class="nv">*members*</span> <span class="mi">1</span> <span class="ss">&#39;after</span> <span class="s">&quot;Like&quot;</span> <span class="nv">*initiates*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">*members*</span><span class="p">)</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">*members*</span> <span class="p">(</span><span class="nf">vector-replace</span> <span class="nv">*members*</span> <span class="mi">0</span> <span class="s">&quot;Fruit&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">*members*</span> <span class="p">(</span><span class="nf">vector-replace</span> <span class="nv">*members*</span> <span class="mi">-2</span> <span class="s">&quot;A&quot;</span> <span class="s">&quot;Banana&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">*members*</span><span class="p">)</span>

<span class="c1">; was: &#39;#(&quot;Time&quot; &quot;Flies&quot; &quot;An&quot; &quot;Arrow&quot;)</span>
<span class="c1">; now: &#39;#(&quot;Fruit&quot; &quot;Flies&quot; &quot;Like&quot; &quot;A&quot; &quot;Banana&quot;)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN200"
>Reversing an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; As for appending arrays, there is the choice of iterating through</span>
<span class="c1">; the array:</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-reverse!</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">j</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">&gt;= </span><span class="nv">i</span> <span class="nv">j</span><span class="p">)</span> <span class="nv">vec</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="nf">vector-ref-swap!</span> <span class="nv">vec</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nf">vector-reverse!</span> <span class="nv">*array*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="k">do </span><span class="p">((</span><span class="nf">i</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">*array*</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">&lt; </span><span class="nv">i</span> <span class="mi">0</span><span class="p">))</span>
  <span class="c1">;; ... do something with *array* ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; or of converting to / from a list, performing any manipulation using</span>
<span class="c1">; the list routines</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*newarray*</span>
  <span class="p">(</span><span class="nb">list-&gt;vector </span><span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nf">sort</span> <span class="p">(</span><span class="nb">vector-&gt;list </span><span class="nv">*array*</span><span class="p">)</span> <span class="nv">&lt;</span><span class="p">))</span> <span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN203"
>Processing Multiple Elements of an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Remove first 3 elements</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*front*</span> <span class="p">(</span><span class="nf">vector-delete</span> <span class="nv">*array*</span> <span class="mi">0</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">; Remove last 3 elements</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*end*</span> <span class="p">(</span><span class="nf">vector-delete</span> <span class="nv">*array*</span> <span class="mi">-1</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Another helper routine</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-slice</span> <span class="nv">vec</span> <span class="nv">pos</span> <span class="nv">len</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">vec-len</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">pos</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">pos</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">vec-len</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">pos</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">in-bounds</span>
           <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">+ </span><span class="nv">pos</span> <span class="nv">len</span><span class="p">)</span> <span class="nv">vec-len</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">in-bounds</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">len</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">vec-idx</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="nf">new-vec-idx</span> <span class="mi">0</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">cond</span>
            <span class="p">((</span><span class="nb">= </span><span class="nv">new-vec-idx</span> <span class="nv">len</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">else</span>
              <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">new-vec-idx</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">vec-idx</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">vec-idx</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">new-vec-idx</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">)))</span>
    <span class="c1">;else</span>
      <span class="nv">vec</span><span class="p">)))</span>

<span class="c1">; Both the following use, &#39;values&#39;, to return two values; this approach</span>
<span class="c1">; is quite contrived and is taken to mimic the Perl examples, not</span>
<span class="c1">; because it is a recommended one [returning a single list would probably</span>
<span class="c1">; be more sensible]</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">shift2</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">vector-slice</span> <span class="nv">vec</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="mi">1</span><span class="p">))</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pop2</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">vector-slice</span> <span class="nv">vec</span> <span class="mi">-1</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="mi">1</span><span class="p">))</span> <span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*friends*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="ss">&#39;Peter</span> <span class="ss">&#39;Paul</span> <span class="ss">&#39;Mary</span> <span class="ss">&#39;Jim</span> <span class="ss">&#39;Tim</span><span class="p">))</span>

<span class="p">(</span><span class="nf">let-values</span> <span class="p">(</span> <span class="p">((</span><span class="nf">this</span> <span class="nv">that</span><span class="p">)</span> <span class="p">(</span><span class="nf">shift2</span> <span class="nv">*friends*</span><span class="p">))</span> <span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">this</span> <span class="s">&quot;:&quot;</span> <span class="nv">that</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*beverages*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="ss">&#39;Dew</span> <span class="ss">&#39;Jolt</span> <span class="ss">&#39;Cola</span> <span class="ss">&#39;Sprite</span> <span class="ss">&#39;Fresca</span><span class="p">))</span>

<span class="p">(</span><span class="nf">let-values</span> <span class="p">(</span> <span class="p">((</span><span class="nf">d1</span> <span class="nv">d2</span><span class="p">)</span> <span class="p">(</span><span class="nf">pop2</span> <span class="nv">*beverages*</span><span class="p">))</span> <span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">d1</span> <span class="s">&quot;:&quot;</span> <span class="nv">d2</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN206"
>Finding the First List Element That Passes a Test</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; SRFI-1 [list manipulation] routines are ideal for the types of task</span>
<span class="c1">; in this and the next section, in particular, &#39;for-each&#39; and &#39;find&#39;,</span>
<span class="c1">; &#39;list-index&#39;, and many others for more specialist functions. The same</span>
<span class="c1">; applies to vectors with the SRFI-43 routines, &#39;vector-index&#39; and</span>
<span class="c1">; &#39;vector-skip&#39;, though the approach taken in this chapter has been to</span>
<span class="c1">; implement functionally similar vector manipulation routines to more</span>
<span class="c1">; closely mimic the Perl examples</span>

<span class="c1">; Return #f, or first index for which &#39;pred&#39; returns true</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-first-idx</span> <span class="nv">pred</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">vec-len</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">idx</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">idx</span> <span class="nv">vec-len</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">pred</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">idx</span><span class="p">))</span>
            <span class="nv">idx</span>
          <span class="c1">;else</span>
            <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">idx</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">)))))</span>

<span class="c1">; Return #f, or first index for which &#39;pred&#39; returns true</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">list-first-idx</span> <span class="nv">pred</span> <span class="nv">list</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">idx</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">list</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">null? </span><span class="nv">list</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">pred</span> <span class="p">(</span><span class="nb">car </span><span class="nv">list</span><span class="p">))</span>
          <span class="nv">idx</span>
        <span class="c1">;else</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">idx</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">list</span><span class="p">)))</span> <span class="p">))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*array*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nf">vector-first-idx</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">9</span><span class="p">))</span>
    <span class="nv">*array*</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*list*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nf">list-first-idx</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">4</span><span class="p">))</span>
    <span class="nv">*list*</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nf">list-index</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">4</span><span class="p">))</span>
    <span class="nv">*list*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; The Perl &#39;highest paid engineer&#39; example isn&#39;t really a &#39;first match&#39;</span>
<span class="c1">; type of problem - the routines shown earlier really aren&#39;t suited to</span>
<span class="c1">; this. Better suited, instead, are the SRFI-1 routines like &#39;fold&#39;,</span>
<span class="c1">; &#39;fold-right&#39; and &#39;reduce&#39;, even old standbys like &#39;filter&#39; and &#39;for-each&#39;</span>

<span class="p">(</span><span class="k">define </span><span class="nv">+null-salary-rec+</span>
  <span class="p">(</span><span class="nb">list </span><span class="o">&#39;</span><span class="p">()</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*salaries*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">43000</span> <span class="ss">&#39;Bob</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;programmer</span> <span class="mi">48000</span> <span class="ss">&#39;Andy</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">35000</span> <span class="ss">&#39;Champ</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">49000</span> <span class="ss">&#39;Bubbles</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;programmer</span> <span class="mi">47000</span> <span class="ss">&#39;Twig</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">34000</span> <span class="ss">&#39;Axel</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*highest-paid-engineer*</span>
  <span class="p">(</span><span class="nf">reduce</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span> <span class="nv">acc</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">if</span>
        <span class="p">(</span><span class="nf">and</span>
          <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="ss">&#39;engineer</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">acc</span><span class="p">)))</span>
        <span class="nv">salary-rec</span>
      <span class="c1">;else</span>
        <span class="nv">acc</span><span class="p">))</span>
    <span class="nv">+null-salary-rec+</span>
    <span class="nv">*salaries*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*highest-paid-engineer*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*highest-paid-engineer*</span>
  <span class="p">(</span><span class="nf">fold-right</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span> <span class="nv">acc</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">acc</span><span class="p">))</span>
        <span class="nv">salary-rec</span>
      <span class="c1">;else</span>
        <span class="nv">acc</span><span class="p">))</span>
    <span class="nv">+null-salary-rec+</span>
    <span class="p">(</span><span class="nf">filter</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="ss">&#39;engineer</span><span class="p">))</span>
      <span class="nv">*salaries*</span><span class="p">))</span> <span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*highest-paid-engineer*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*highest-paid-engineer*</span> <span class="nv">+null-salary-rec+</span><span class="p">)</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">if</span>
      <span class="p">(</span><span class="nf">and</span>
        <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="ss">&#39;engineer</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">*highest-paid-engineer*</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">*highest-paid-engineer*</span> <span class="nv">salary-rec</span><span class="p">)))</span>
  <span class="nv">*salaries*</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*highest-paid-engineer*</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN209"
>Finding All Elements in an Array Matching Certain Criteria</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; All tasks in this section consist of either generating a collection,</span>
<span class="c1">; or filtering a larger collection, of elements matching some criteria;</span>
<span class="c1">; obvious candidates are the &#39;filter&#39; and &#39;array-filter&#39; routines, though</span>
<span class="c1">; others like &#39;for-each&#39; can also be applied</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*list-matching*</span> <span class="p">(</span><span class="nf">filter</span> <span class="nv">PRED</span> <span class="nv">LIST</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*vector-matching*</span> <span class="p">(</span><span class="nf">array-filter</span> <span class="nv">PRED</span> <span class="nv">ARRAY</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*nums*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="nv">e7</span> <span class="mi">3</span><span class="nv">e7</span> <span class="mi">2</span><span class="nv">e7</span> <span class="mi">4</span><span class="nv">e7</span> <span class="mi">1</span><span class="nv">e7</span> <span class="mi">3</span><span class="nv">e7</span> <span class="mi">2</span><span class="nv">e7</span> <span class="mi">4</span><span class="nv">e7</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*bigs*</span>
  <span class="p">(</span><span class="nf">filter</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">num</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">num</span> <span class="mi">1000000</span><span class="p">))</span>
    <span class="nv">*nums*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*users*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">u1</span> <span class="o">.</span> <span class="mi">2</span><span class="nv">e7</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">u2</span> <span class="o">.</span> <span class="mi">1</span><span class="nv">e7</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">u3</span> <span class="o">.</span> <span class="mi">4</span><span class="nv">e7</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="nv">u4</span> <span class="o">.</span> <span class="mi">3</span><span class="nv">e7</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*pigs*</span>
  <span class="p">(</span><span class="nf">fold-right</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span> <span class="nv">accum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">accum</span><span class="p">))</span>
    <span class="o">&#39;</span><span class="p">()</span>
    <span class="p">(</span><span class="nf">filter</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">pair</span><span class="p">)</span> <span class="mi">1</span><span class="nv">e7</span><span class="p">))</span>
      <span class="nv">*users*</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*pigs*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*salaries*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">43000</span> <span class="ss">&#39;Bob</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;programmer</span> <span class="mi">48000</span> <span class="ss">&#39;Andy</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">35000</span> <span class="ss">&#39;Champ</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">49000</span> <span class="ss">&#39;Bubbles</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;programmer</span> <span class="mi">47000</span> <span class="ss">&#39;Twig</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;engineer</span> <span class="mi">34000</span> <span class="ss">&#39;Axel</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*engineers*</span>
  <span class="p">(</span><span class="nf">filter</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="ss">&#39;engineer</span><span class="p">))</span>
    <span class="nv">*salaries*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*engineers*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*applicants*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a1</span> <span class="mi">26000</span> <span class="ss">&#39;Bob</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a2</span> <span class="mi">28000</span> <span class="ss">&#39;Andy</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a3</span> <span class="mi">24000</span> <span class="ss">&#39;Candy</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*secondary-assistance*</span>
  <span class="p">(</span><span class="nf">filter</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">salary-rec</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">and</span>
        <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="mi">26000</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">salary-rec</span><span class="p">)</span> <span class="mi">30000</span><span class="p">)))</span>
    <span class="nv">*applicants*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*secondary-assistance*</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN212"
>Sorting an Array Numerically</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Sorting numeric data in Scheme is very straightforward ...</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*unsorted*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span> <span class="mi">8</span> <span class="mi">1</span> <span class="mi">7</span> <span class="mi">4</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Ascending sort - use &#39;&lt;&#39; as comparator</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*sorted*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*unsorted*</span>
    <span class="nv">&lt;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*sorted*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Descending sort - use &#39;&gt;&#39; as comparator</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*sorted*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*unsorted*</span>
    <span class="nv">&gt;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*sorted*</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN215"
>Sorting a List by Computable Field</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; A customised lambda may be passed as comparator to &#39;sort&#39;, so</span>
<span class="c1">; sorting on one or more &#39;fields&#39; is quite straightforward</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*unordered*</span> <span class="o">&#39;</span><span class="p">(</span> <span class="o">...</span> <span class="p">))</span>

<span class="c1">; COMPARE is some comparator suited for the element type being</span>
<span class="c1">; sorted</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*ordered*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*unordered*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">COMPARE</span> <span class="nv">left</span> <span class="nv">right</span><span class="p">))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*unordered*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;s</span> <span class="mi">34</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;e</span> <span class="mi">12</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;c</span> <span class="mi">45</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;q</span> <span class="mi">11</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;g</span> <span class="mi">24</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*pre-computed*</span>
  <span class="p">(</span><span class="nf">map</span>
    <span class="c1">; Here element is returned unaltered, but it would normally be</span>
    <span class="c1">; transformed in som way</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span> <span class="nv">element</span><span class="p">)</span>
    <span class="nv">*unordered*</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*ordered-pre-computed*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*pre-computed*</span>
    <span class="c1">; Sort on the first field [assume it is the &#39;key&#39;]</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))))</span>

<span class="c1">; Extract the second field [assume it is the &#39;value&#39;]</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*ordered*</span>
  <span class="p">(</span><span class="nf">map</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">element</span><span class="p">))</span>
    <span class="nv">*ordered-pre-computed*</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*employees*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Bob</span> <span class="mi">43000</span> <span class="mi">123</span> <span class="mi">42</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Andy</span> <span class="mi">48000</span> <span class="mi">124</span> <span class="mi">35</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Champ</span> <span class="mi">35000</span> <span class="mi">125</span> <span class="mi">37</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Bubbles</span> <span class="mi">49000</span> <span class="mi">126</span> <span class="mi">34</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Twig</span> <span class="mi">47000</span> <span class="mi">127</span> <span class="mi">36</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;Axel</span> <span class="mi">34000</span> <span class="mi">128</span> <span class="mi">31</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*ordered*</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*employees*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">employee</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">employee</span><span class="p">)</span> <span class="s">&quot;earns $&quot;</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">employee</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*employees*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*bonus*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">125</span> <span class="o">.</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">127</span> <span class="o">.</span> <span class="mi">1500</span><span class="p">)</span> <span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">employee</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">bonus</span> <span class="p">(</span><span class="nf">assoc-ref</span> <span class="nv">*bonus*</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">employee</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">bonus</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">()</span>
      <span class="c1">;else</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">employee</span><span class="p">)</span> <span class="s">&quot;earned bonus&quot;</span> <span class="nv">bonus</span><span class="p">)</span> <span class="p">)))</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*employees*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">))))))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">rdelim</span><span class="p">)</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">regex</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*filename*</span> <span class="s">&quot;/etc/passwd&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*users*</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">port</span> <span class="p">(</span><span class="nb">open-input-file </span><span class="nv">*filename*</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">line&amp;terminator</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">eof-object? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">line&amp;terminator</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">*users*</span>
          <span class="p">(</span><span class="nf">assoc-set!</span>
            <span class="nv">*users*</span>
            <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">string-split</span> <span class="p">(</span><span class="nb">car </span><span class="nv">line&amp;terminator</span><span class="p">)</span> <span class="o">#</span><span class="err">\</span><span class="nv">:</span><span class="p">))</span>
            <span class="no">#t</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">read-line</span> <span class="nv">port</span> <span class="ss">&#39;split</span><span class="p">))</span> <span class="p">)))</span>
  <span class="p">(</span><span class="nb">close-input-port </span><span class="nv">port</span><span class="p">))</span>

<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">user</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">car </span><span class="nv">user</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">sort</span>
    <span class="nv">*users*</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">string&lt;?</span>
        <span class="p">(</span><span class="nb">car </span><span class="nv">left</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">car </span><span class="nv">right</span><span class="p">)))))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN218"
>Implementing a Circular List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Use SRFI-1&#39;s &#39;circular-list&#39; routine to build a circular list</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*processes*</span> <span class="p">(</span><span class="nf">circular-list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">processes</span> <span class="nv">*processes*</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Handling process&quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">processes</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">sleep</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">processes</span><span class="p">)))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN221"
>Randomizing an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">srfi</span> <span class="nv">srfi-1</span><span class="p">))</span>

<span class="c1">; Implements Fischer-Yates shuffle algorithm</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-shuffle!</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">vec</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="nv">vector-length</span><span class="p">)</span> <span class="p">(</span><span class="nf">j</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">random</span> <span class="nv">vector-length</span><span class="p">))))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
        <span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">j</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">vector-ref-swap!</span> <span class="nv">vec</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">j</span> <span class="mi">1</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))))</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))))</span> <span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">vector-ref-swap!</span> <span class="nv">vec</span> <span class="nv">idx1</span> <span class="nv">idx2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">tmp</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">idx1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="nv">idx1</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">vec</span> <span class="nv">idx2</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">vec</span> <span class="nv">idx2</span> <span class="nv">tmp</span><span class="p">)))</span>

<span class="c1">; Generate vector of values 1 .. 10</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*irange*</span> <span class="p">(</span><span class="nb">list-&gt;vector </span><span class="p">(</span><span class="nf">iota</span> <span class="mi">10</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1">; Shuffle array values</span>
<span class="p">(</span><span class="nf">vector-shuffle!</span> <span class="nv">*irange*</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN224"
>Program: words</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; @@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN227"
>Program: permute</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; @@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="datesandtimes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="hashes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Dates and Times</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Hashes</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>