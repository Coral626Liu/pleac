<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Packages, Libraries, and Modules</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Guile 1.8"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="References and Records"
HREF="referencesandrecords.html"><LINK
REL="NEXT"
TITLE="Classes, Objects, and Ties"
HREF="classesetc.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Guile 1.8</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="referencesandrecords.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="classesetc.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PACKAGESETC"
>12. Packages, Libraries, and Modules</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN642"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Modules searched for by name in pre-configured paths [refer documentation</span>
<span class="c1">; for details]. For testing it is probably easiest to place them, and</span>
<span class="c1">; all other source files, in the current directory, and specify search</span>
<span class="c1">; path on command-line:</span>
<span class="c1">;</span>
<span class="c1">;     guile -L ./ -s testprog.scm</span>
<span class="c1">;</span>
<span class="c1">; Here, &#39;testprog.scm&#39; [see example] and modules reside in current the</span>
<span class="c1">; directory</span>

<span class="c1">; Load modules</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">alpha</span><span class="p">)</span>
              <span class="c1">; Optionally specify item(s) to use</span>
              <span class="nv">:select</span> <span class="p">(</span><span class="nf">name</span><span class="p">)</span>
              <span class="c1">; Optionally attach a &#39;module alias&#39; to distinguish items</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;alpha:</span><span class="p">))</span> <span class="p">)</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">omega</span><span class="p">)</span>
              <span class="nv">:select</span> <span class="p">(</span><span class="nf">name</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;omega:</span><span class="p">))</span> <span class="p">)</span>

<span class="c1">; Access module members</span>
<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;Alpha is &quot;</span> <span class="nv">alpha:name</span> <span class="s">&quot;, Omega is &quot;</span> <span class="nv">omega:name</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Module name and source file names match -&gt; alpha.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">alpha</span><span class="p">))</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">name</span> <span class="s">&quot;first&quot;</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Module name and source file names match -&gt; omega.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">omega</span><span class="p">))</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">name</span> <span class="s">&quot;last&quot;</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Guile doesn&#39;t distinguish between compile-time and run-time as far</span>
<span class="c1">; as module handling is concerned. A module is loaded when:</span>

<span class="c1">; * A (use-modules ...) is encountered</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">omega</span><span class="p">))</span>
             <span class="o">...</span>
             <span class="p">)</span>

<span class="c1">; * A reference is made to an item in a module specified as being</span>
<span class="c1">; autoloaded</span>

<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">new-module</span><span class="p">)</span>
               <span class="o">#</span><span class="nv">:autoload</span> <span class="p">(</span><span class="nf">mod-x</span><span class="p">)</span> <span class="p">(</span><span class="nf">mod-y</span><span class="p">))</span>
               <span class="c1">;; ...</span>

<span class="c1">; Module code loaded at this point</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">item-from-mod-x</span> <span class="nv">item</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="no">#t</span>
  <span class="c1">; else</span>
  <span class="c1">;; ...</span>
  <span class="no">#f</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN645"
>Defining a Module's Interface</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; All bindings within a module are private to it unless specifically</span>
<span class="c1">; exported, something which is accomplished via:</span>
<span class="c1">;</span>
<span class="c1">; * Use of (define-public ...) in place of (define ...) for each export</span>
<span class="c1">;   item</span>
<span class="c1">;</span>

<span class="c1">; Module name and source file names match -&gt; your-module.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">your-module</span><span class="p">))</span>

<span class="c1">; Module&#39;s &#39;interface&#39; - set of exported / publically-accessable items</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">version</span> <span class="s">&quot;1.2&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nf">a-public-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="s">&quot;a-public-proc&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nf">another-public-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="s">&quot;another-public-proc&quot;</span><span class="p">)</span>

<span class="c1">; Module&#39;s &#39;implementation&#39;, its internals</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a-private-var</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">a-private-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;</span>
<span class="c1">; or via:</span>
<span class="c1">;</span>
<span class="c1">; * Create an export list via: (export item1 item2 ...)</span>
<span class="c1">;</span>

<span class="c1">; Module name and source file names match -&gt; your-module.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">your-module</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">version</span> <span class="s">&quot;1.2&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">a-public-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="s">&quot;a-public-proc&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">another-public-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="s">&quot;another-public-proc&quot;</span><span class="p">)</span>

<span class="c1">; Module&#39;s &#39;interface&#39; - set of exported / publically-accessable items</span>
<span class="p">(</span><span class="nf">export</span> <span class="nv">version</span> <span class="nv">a-public-proc</span> <span class="nv">another-public-proc</span><span class="p">)</span>

<span class="c1">; Module&#39;s &#39;implementation&#39;, its internals</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a-private-var</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">a-private-proc</span> <span class="nv">arg</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Load module, allowing access to all exported items, and uses</span>
<span class="c1">; specified prefix, &#39;ym:, to refer to module items</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">your-module</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;ym:</span><span class="p">))</span> <span class="p">)</span>

<span class="c1">; Access module members</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">ym:version</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">ym:a-public-proc</span> <span class="ss">&#39;x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">ym:another-public-proc</span> <span class="ss">&#39;x</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Load module, allowing access to all exported items, and uses no</span>
<span class="c1">; prefix for module items - they are identified as named within the</span>
<span class="c1">; module, something which may cause name-clash problems</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">your-module</span><span class="p">))</span>

<span class="c1">; Access module members</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">version</span><span class="p">)</span>

<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">a-public-proc</span> <span class="ss">&#39;x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">another-public-proc</span> <span class="ss">&#39;x</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN648"
>Trapping Errors in require or use</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; The module-handling procedures offer some reflective capabilities,</span>
<span class="c1">; including the ability to obtain a module&#39;s export list, and</span>
<span class="c1">; dynamically load / create a module. Here, a custom function is used</span>
<span class="c1">; to obtain a module&#39;s export list; since success indicates said module</span>
<span class="c1">; exists, it may be used to check module availability without the module</span>
<span class="c1">; being loaded. Note: this approach works, but since the documentation</span>
<span class="c1">; is rather sparse, I&#39;m not sure whether this is *the* best approach to</span>
<span class="c1">; this problem</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">module-available?</span> <span class="nv">module-name</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">resolve-interface</span> <span class="nv">module-name</span><span class="p">)</span> <span class="no">#t</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="no">#f</span><span class="p">)))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Is module available ?</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">module-available?</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">alpha</span><span class="p">))</span>
  <span class="c1">; Yes ? Load it for use, else report the problem</span>
  <span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">alpha</span><span class="p">)</span>
                <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;alpha:</span><span class="p">))</span> <span class="p">)</span>
<span class="c1">;else</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Module does not exist / not in load path&quot;</span><span class="p">))</span>

<span class="c1">;; ...</span>

<span class="c1">; Use module item(s) [assuming load was successful]</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">alpha:aa</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN651"
>Delaying use Until Run Time</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Guile doesn&#39;t distinguish between compile-time and run-time as far</span>
<span class="c1">; as module handling is concerned. A module is loaded when:</span>

<span class="c1">; * A (use-modules ...) is encountered</span>

<span class="c1">; (use-modules ((...))</span>

<span class="c1">; * A reference is made to an item in a module specified as being</span>
<span class="c1">; autoloaded</span>

<span class="c1">; (define-module (...)</span>
<span class="c1">;               #:autoload (mod-x) (...))</span>
<span class="c1">;               ...</span>

<span class="c1">; Module code loaded at this point</span>
<span class="c1">; (if (item-from-mod-x ...) ...)</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">num1</span> <span class="no">#f</span><span class="p">)</span> <span class="p">(</span><span class="nf">num2</span> <span class="no">#f</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nf">and</span>
      <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))</span> <span class="mi">3</span><span class="p">)</span>
      <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">num1</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span> <span class="nv">num1</span><span class="p">)</span>
      <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">num2</span> <span class="p">(</span><span class="nb">string-&gt;number </span><span class="p">(</span><span class="nb">caddr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))))</span> <span class="nv">num2</span><span class="p">))</span>

      <span class="c1">; Command-line processing successful - load modules to do some</span>
      <span class="c1">; real work</span>
      <span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">some-module</span><span class="p">)</span>
                    <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;some:</span><span class="p">))</span> <span class="p">)</span>

      <span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">another-module</span><span class="p">)</span>
                    <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;another:</span><span class="p">))</span> <span class="p">)</span>

      <span class="o">...</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">else</span>
      <span class="p">(</span><span class="nf">die</span>
        <span class="p">(</span><span class="nf">string-append</span>
          <span class="s">&quot;usage: guile -s &quot;</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">command-line</span><span class="p">))</span> <span class="s">&quot; num1 num2&quot;</span><span class="p">))</span> <span class="p">)))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="nf">cond</span>
  <span class="p">(</span><span class="nf">opt-b</span>
    <span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">bigmath</span><span class="p">)</span>
                  <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;bigmath:</span><span class="p">))</span> <span class="p">)</span>
  <span class="c1">;; ...</span>
    <span class="c1">; use module</span>
  <span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">else</span>
    <span class="c1">;; ...</span>
    <span class="c1">; work without module</span>
   <span class="o">...</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN654"
>Making Variables Private to a Module</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Variables are private to a module unless exported</span>

<span class="c1">; Module name and source file names match -&gt; alpha.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">alpha</span><span class="p">))</span>

<span class="c1">; If &#39;define&#39; instead of &#39;define-public&#39; used, then items remain</span>
<span class="c1">; private</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">aa</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">x</span> <span class="s">&quot;azure&quot;</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Module name and source file names match -&gt; beta.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">beta</span><span class="p">))</span>

<span class="c1">; If &#39;define&#39; instead of &#39;define-public&#39; used, then items remain</span>
<span class="c1">; private</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">bb</span> <span class="mi">20</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">x</span> <span class="s">&quot;blue&quot;</span><span class="p">)</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Load modules</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">alpha</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;alpha:</span><span class="p">))</span> <span class="p">)</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">beta</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;beta:</span><span class="p">))</span> <span class="p">)</span>

<span class="c1">; Access module items</span>
<span class="p">(</span><span class="nf">print</span>
  <span class="p">(</span><span class="nf">string-append</span>
    <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">alpha:aa</span><span class="p">)</span> <span class="s">&quot;, &quot;</span>
    <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">beta:bb</span><span class="p">)</span> <span class="s">&quot;, &quot;</span>
    <span class="nv">alpha:x</span> <span class="s">&quot;, &quot;</span>
    <span class="nv">beta:x</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN657"
>Determining the Caller's Package</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; caller&#39;s package</span>
<span class="c1">; ??? backtrace trap</span>
<span class="nv">@@INCOMPLETE@@</span>
<span class="nv">@@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN660"
>Automating Module Clean-Up</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; automating module cleanup</span>
<span class="c1">; ??? hooks, guardians</span>
<span class="nv">@@INCOMPLETE@@</span>
<span class="nv">@@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN663"
>Keeping Your Own Module Directory</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; The directories Guile should search for modules are available in the</span>
<span class="c1">; global variable, &#39;%load-path&#39; based on configuration data supplied</span>
<span class="c1">; at installation time. Additional search directories may be specified</span>
<span class="c1">; using:</span>
<span class="c1">;</span>
<span class="c1">; * Command-line Option:   -L DIRNAME</span>
<span class="c1">; * Environment Variable:  GUILE_LOAD_PATH</span>
<span class="c1">;</span>
<span class="c1">; which act to prepend search data to the %load-path variable so that</span>
<span class="c1">; user modules will be processed before non-core system modules</span>
<span class="c1">;</span>
<span class="c1">; Following standalone code could be loaded in several ways - probably</span>
<span class="c1">; easiest to place it in a file and execute via: guile -s FILENAME</span>
<span class="c1">; Use &#39;guile --help&#39; for more execution options</span>
<span class="c1">;</span>

<span class="o">#</span><span class="nv">!</span>
<span class="nv">!</span><span class="o">#</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print</span> <span class="nv">item</span> <span class="o">.</span> <span class="nv">rest</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">all-item</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="nv">rest</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot; &quot;</span><span class="p">))</span>
      <span class="nv">all-item</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">for-each-idx</span> <span class="nv">proc</span> <span class="nv">list</span> <span class="o">.</span> <span class="nv">start-idx</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">start-idx</span><span class="p">)</span>
                  <span class="mi">0</span>
                  <span class="p">(</span><span class="nb">car </span><span class="nv">start-idx</span><span class="p">)))</span>
             <span class="p">(</span><span class="nb">list </span><span class="nv">list</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">null? </span><span class="nv">list</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">(</span><span class="nf">else</span>
        <span class="p">(</span><span class="nf">proc</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">car </span><span class="nv">list</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">list</span><span class="p">))))</span> <span class="p">))</span>

<span class="p">(</span><span class="nf">for-each-idx</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">i</span> <span class="nv">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">i</span> <span class="nv">item</span><span class="p">))</span>
  <span class="nv">%load-path</span><span class="p">)</span>

<span class="c1">; Output:</span>
<span class="c1">;</span>
<span class="c1">; 0 /usr/local/share/guile/site</span>
<span class="c1">; 1 /usr/local/share/guile/1.8</span>
<span class="c1">; 2 /usr/local/share/guile</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; To specify the location of user modules from outside the execution</span>
<span class="c1">; environment use any of the earlier mentioned approaches</span>

<span class="c1">; guile -L /projects/spectre/lib/ -s SCRIPTNAME ...</span>

<span class="c1">; Append:</span>
<span class="c1">;   set GUILE_LOAD_PATH=$GUILE_LOAD_PATH:/projects/spectre/lib/</span>
<span class="c1">; or prepend:</span>
<span class="c1">;   set GUILE_LOAD_PATH=/projects/spectre/lib/:$GUILE_LOAD_PATH</span>
<span class="c1">; export GUILE_LOAD_PATH</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN666"
>Preparing a Module for Distribution</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Module distribution can be:</span>
<span class="c1">;</span>
<span class="c1">; * Informal, consisting of nothing more than copying all</span>
<span class="c1">;   relevant [.scm] files somewhere into the load path [see</span>
<span class="c1">;   previous section]. This task could be performed manually,</span>
<span class="c1">;   or automated using a custom installation script.</span>
<span class="c1">;</span>
<span class="c1">;   This approach would appear reasonable for very small one</span>
<span class="c1">;   or two [.scm] file systems, or where no additional libraries</span>
<span class="c1">;   [e.g. C static and dynamic libraries] are needed, but probably</span>
<span class="c1">;   not suitable for larger system distribution</span>
<span class="c1">;</span>
<span class="c1">; * Formal, using some published distribution means. AFAIK there</span>
<span class="c1">;   are no utilities such as Perl&#39;s &#39;h2xs&#39; to automate this process.</span>
<span class="c1">;   However, major Guile packages appear to use the GNU Build System</span>
<span class="c1">;   [i.e. autoconf, automake et al] for distribution. Since this</span>
<span class="c1">;   system is well known it is recommended that a suitable tutorial</span>
<span class="c1">;   be consulted. A later section will include a simple example</span>
<span class="c1">;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN669"
>Speeding Module Loading with SelfLoader</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Guile has no equivalent to Perl&#39;s &#39;selfloader&#39; facility, thus this</span>
<span class="c1">; section could not be implemented</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN672"
>Speeding Up Module Loading with Autoloader</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Guile has no equivalent to Perl&#39;s &#39;autoloader&#39; facility. The use</span>
<span class="c1">; of the &#39;autoload&#39; keyword with modules serves to ensure a module</span>
<span class="c1">; is loaded [if not already in memory] if specified module items</span>
<span class="c1">; are accessed. In other words, a &#39;load-on-demand&#39; facility which</span>
<span class="c1">; is, I believe, a somewhat different mechanism to Perl&#39;s, therefore,</span>
<span class="c1">; the examples in this section could not be implemented</span>
<span class="c1">;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN675"
>Overriding Built-In Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; In Scheme, a built-in function [BIF] is no more than an object</span>
<span class="c1">; encapsulating a block of code [a &#39;lambda&#39;] that is bound to an</span>
<span class="c1">; identifier. Since identifier bindings can be readily altered, simply</span>
<span class="c1">; rebinding the identifier to a replacement lambda overrides the</span>
<span class="c1">; built-in version</span>

<span class="c1">; Show current time using built-in, &#39;current-time&#39;</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">; Override built-in by rebinding identifier with new lambda</span>
<span class="p">(</span><span class="k">define </span><span class="nv">current-time</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="s">&quot;This isn&#39;t the current time !&quot;</span><span class="p">))</span>

<span class="c1">; Does this show the current time ?</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; However, if overriding of built-ins occurs within a module:</span>
<span class="c1">;</span>
<span class="c1">; * All module code will see overidden code [assuming it occurs</span>
<span class="c1">;   early in the module]; this is as expected</span>
<span class="c1">; * Override will only affect module users if the same identifier</span>
<span class="c1">;   is exported [i.e. no module prefix is used]</span>

<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">override</span><span class="p">))</span>

<span class="c1">; Override &#39;current-time&#39;</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">current-time</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="s">&quot;This isn&#39;t the current time !&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nf">return-current-time</span><span class="p">)</span>
  <span class="c1">; Uses overriden version of, &#39;current-time&#39;</span>
  <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Import module using prefix</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">override</span><span class="p">)</span>
              <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;override:</span><span class="p">))</span> <span class="p">)</span>

<span class="c1">; Use overidden version</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">override:current-time</span><span class="p">))</span>

<span class="c1">; Top-level binding retained</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Import module - no prefix</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">override</span><span class="p">))</span>

<span class="c1">; Top-level binding overidden</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN678"
>Reporting Errors and Warnings Like Built-Ins</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Simple custom error reporter mimicing Perl&#39;s &#39;die&#39;</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">die</span> <span class="nv">msg</span> <span class="o">.</span> <span class="nv">error-code</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">string-append </span><span class="nv">msg</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">exit</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">error-code</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">error-code</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">even-only</span> <span class="nv">num</span><span class="p">)</span>
  <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">modulo </span><span class="nv">num</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">die</span> <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">num</span><span class="p">)</span> <span class="s">&quot; is not even&quot;</span><span class="p">))))</span>

<span class="c1">; Ok for the following:</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1">; ==&gt; #t</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1">; ==&gt; exits with error message and return code, 1</span>

<span class="c1">; However, the following applications:</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="ss">&#39;$</span><span class="p">)</span>     <span class="c1">; ==&gt; wrong type arg exception thrown</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="s">&quot;34&quot;</span><span class="p">)</span>   <span class="c1">; ==&gt; ditto</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Built-ins use the exception handling mechanism to trap and</span>
<span class="c1">; handle errors</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">even-only</span> <span class="nv">num</span><span class="p">)</span>
  <span class="c1">; Catch all exceptions</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
    <span class="c1">; Execute our &#39;work code&#39;</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">modulo </span><span class="nv">num</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1">; Make sure our error handler doesn&#39;t, itself, fail :) !</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">snum</span>
        <span class="p">(</span><span class="nf">cond</span>
          <span class="p">((</span><span class="nb">number? </span><span class="nv">num</span><span class="p">)</span> <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">num</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">symbol? </span><span class="nv">num</span><span class="p">)</span> <span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">num</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">string? </span><span class="nv">num</span><span class="p">)</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;\&quot;&quot;</span> <span class="nv">num</span> <span class="s">&quot;\&quot;&quot;</span><span class="p">))</span>
          <span class="p">(</span><span class="k">else </span><span class="s">&quot;???&quot;</span><span class="p">)</span> <span class="p">)))</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">string-append </span><span class="nv">snum</span> <span class="s">&quot; is not even&quot;</span><span class="p">))</span>
        <span class="no">#f</span><span class="p">))))</span>

<span class="c1">; Ok for all the following:</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1">; ==&gt; #t</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1">; ==&gt; #f</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="ss">&#39;$</span><span class="p">)</span>     <span class="c1">; ==&gt; #f</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="s">&quot;34&quot;</span><span class="p">)</span>   <span class="c1">; ==&gt; #f</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Shorter, but coarser-grained version of the above</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">false-if-exception</span> <span class="nv">proc</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
    <span class="nv">proc</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="no">#f</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">even-only</span> <span class="nv">num</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">false-if-exception</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">modulo </span><span class="nv">num</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span> <span class="p">))</span>

<span class="c1">; Ok for all the following:</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1">; ==&gt; #t</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1">; ==&gt; #f</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="ss">&#39;$</span><span class="p">)</span>     <span class="c1">; ==&gt; #f</span>
<span class="p">(</span><span class="nf">even-only</span> <span class="s">&quot;34&quot;</span><span class="p">)</span>   <span class="c1">; ==&gt; #f</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN681"
>Referring to Packages Indirectly</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; It is, of course, possible to dynamically generate module names</span>
<span class="c1">; and procedures, and gain access to those items indirectly; this is</span>
<span class="c1">; done via macros and &#39;eval&#39;</span>

<span class="c1">; Some helper procedures</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">load-module</span> <span class="nv">module-name</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">name</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="nv">module-name</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">prefix</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="p">(</span><span class="nb">string-append </span><span class="nv">module-name</span> <span class="s">&quot;:&quot;</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">primitive-eval</span>
      <span class="o">`</span><span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="o">,</span><span class="nv">name</span><span class="p">)</span> <span class="nv">:renamer</span> <span class="p">(</span><span class="nf">symbol-prefix-proc</span> <span class="ss">&#39;,prefix</span><span class="p">))))</span> <span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">string-&gt;procedure</span> <span class="nv">proc-name</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">primitive-eval</span> <span class="p">(</span><span class="nb">string-&gt;symbol </span><span class="nv">proc-name</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-prefixed-proc</span> <span class="nv">prefix</span> <span class="nv">proc-name</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">string-&gt;procedure</span> <span class="p">(</span><span class="nb">string-append </span><span class="nv">prefix</span> <span class="s">&quot;:&quot;</span> <span class="nv">proc-name</span><span class="p">)))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Example from earlier using &#39;indirect&#39; module loading and module</span>
<span class="c1">; procedure access</span>

<span class="c1">; Load a module &#39;indirectly&#39; i.e. name could be a string obtained</span>
<span class="c1">; from the user at runtime</span>
<span class="p">(</span><span class="nf">load-module</span> <span class="s">&quot;override&quot;</span><span class="p">)</span>

<span class="c1">; Execute module procedure using runtime-generated names</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nf">make-prefixed-proc</span> <span class="s">&quot;override&quot;</span> <span class="s">&quot;current-time&quot;</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">; This approach:</span>

<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">override:current-time</span><span class="p">))</span>

<span class="c1">; cannot be used because neither the module name nor the module</span>
<span class="c1">; procedure are known until runtime</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Module &#39;main&#39;</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">main</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nb">log </span><span class="nv">n</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Module name</span>
<span class="p">(</span><span class="k">define </span><span class="nv">module-name</span> <span class="s">&quot;main&quot;</span><span class="p">)</span>

<span class="c1">; Load the module</span>
<span class="p">(</span><span class="nf">load-module</span> <span class="nv">module-name</span><span class="p">)</span>

<span class="c1">; Conveneience procedure - alias for module procedure</span>
<span class="p">(</span><span class="k">define </span><span class="nv">log-proc</span> <span class="p">(</span><span class="nf">make-prefixed-proc</span> <span class="nv">module-name</span> <span class="s">&quot;log&quot;</span><span class="p">))</span>

<span class="c1">; Apply module procedure ...</span>
<span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
    <span class="p">(</span><span class="nf">else</span>
      <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">log-proc</span> <span class="p">(</span><span class="nb">list </span><span class="nv">i</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Bind module items to top-level identifiers</span>
<span class="p">(</span><span class="k">define </span><span class="nv">blue</span> <span class="nv">colours:blue</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">main-blue</span> <span class="nv">colours:azure</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN684"
>Using h2ph to Translate C #include Files</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; This section appears to illustrate access to shared library code</span>
<span class="c1">; from Perl. Guile offers several methods of doing the same,</span>
<span class="c1">; including:</span>
<span class="c1">;</span>
<span class="c1">; * The &#39;dynamic-link&#39;, &#39;dynamic-unlink&#39;, &#39;dynamic-call&#39;, and</span>
<span class="c1">;   &#39;dynamic-call-with-args&#39; primitives which, together, provide</span>
<span class="c1">;   a simple [if crude] means of accessing functions in shared</span>
<span class="c1">;   libraries [&#39;.so&#39; files]</span>
<span class="c1">;</span>
<span class="c1">; * The &#39;libffi&#39; facility, a cross-language facility for accessing</span>
<span class="c1">;   &#39;foreign&#39; [i.e. non-Scheme] functions. A Guile implementation is</span>
<span class="c1">;   available, though it does need some fine-tuning when installing</span>
<span class="c1">;   [see: http://www.mail-archive.com/guile-devel@gnu.org/msg00951.html</span>
<span class="c1">;   for more details]</span>
<span class="c1">;</span>
<span class="c1">; * Creating and installing new Guile compiled C primitives. This</span>
<span class="c1">;   process boils down to:</span>
<span class="c1">;</span>
<span class="c1">;   - Writing C worker function(s) to perform whatever is required</span>
<span class="c1">;   - Writing C wrapper function(s) for the workers i.e. glue code</span>
<span class="c1">;     that packs / unpacks and conerts arguments and return values</span>
<span class="c1">;   - Compiling using: #include &lt;libguile.h&gt;, and placing code into a</span>
<span class="c1">;     shared library [&#39;.so&#39;]</span>
<span class="c1">;   - Loading shared library in Guile via the &#39;load-extension&#39; primitive</span>
<span class="c1">;</span>

<span class="c1">; !!! dynamic-link example goes here</span>
<span class="nv">@@INCOMPLETE@@</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; !!! libffi example goes here</span>
<span class="c1">; ./configure --disable-deprecated --disable-discouraged</span>
<span class="nv">@@INCOMPLETE@@</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; !!! libguile.h example goes here</span>
<span class="nv">@@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN687"
>Using h2xs to Make a Module with C Code</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; !!!</span>
<span class="c1">; This section appears to illustrate how a Perl module, in particular,</span>
<span class="c1">; one using C code, is built, ready for distribution. The Guile example</span>
<span class="c1">; will use the GNU Build system ...</span>
<span class="nv">@@INCOMPLETE@@</span>
<span class="nv">@@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN690"
>Documenting Your Module with Pod</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Possibly the simplest means of documenting Guile code,</span>
<span class="c1">; aside, of course, from manually inserting commentary, is</span>
<span class="c1">; via the use of &quot;docstrings&quot; in procedure definitions:</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sample-proc</span><span class="p">)</span>
    <span class="s">&quot;This procedure does this, that, and the other ...&quot;</span>
      <span class="o">...</span> <span class="nv">procedure</span> <span class="nv">code</span> <span class="o">...</span><span class="p">)</span>

<span class="c1">; With the code loaded, the docstring for a procedure may be</span>
<span class="c1">; accessed via:</span>

    <span class="p">(</span><span class="nf">procedure-documentation</span> <span class="nv">sample-proc</span><span class="p">)</span>

<span class="c1">; Several packages for documenting Scheme / Guile code are</span>
<span class="c1">; available, and which may be roughly catergorised as:</span>
<span class="c1">;</span>
<span class="c1">; * Producing HTML-based documention [ala JavaDoc]</span>
<span class="c1">;   http://www.cs.auc.dk/~normark/schemedoc/</span>
<span class="c1">;</span>
<span class="c1">; * Generating TexInfo source for subsequent processing</span>
<span class="c1">;   http://swissnet.ai.mit.edu/~jaffer/Docupage/schmooz.html</span>
<span class="c1">;</span>
<span class="c1">; Both varieties rely on processing specially-formatted comment</span>
<span class="c1">; blocks, or other commen-embedded tags</span>
<span class="c1">;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN693"
>Building and Installing a CPAN Module</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; The Guile website hosts a libraries / projects page:</span>
<span class="c1">;</span>
<span class="c1">; http://www.gnu.org/software/guile/gnu-guile-projects.html#Libraries</span>
<span class="c1">;</span>
<span class="c1">; General installation procedure [assumes *NIX-based system and</span>
<span class="c1">; superuser privelages]:</span>
<span class="c1">;</span>
<span class="c1">; 1. Click on a link, follow download instructions</span>
<span class="c1">; 2. tar -zxvf newlibrary-x.y.z.tar.gz</span>
<span class="c1">; 3. cd newlibrary-x.y.z</span>
<span class="c1">; 4. ./configure</span>
<span class="c1">; 5. make</span>
<span class="c1">; 6. make check</span>
<span class="c1">; 7. make install</span>
<span class="c1">;</span>
<span class="c1">; A simple, Guile source-only library would simply see source files</span>
<span class="c1">; copied to the default Guile modules directory, and any relevant</span>
<span class="c1">; documentation installed, whilst a more complex library would also</span>
<span class="c1">; see native code libraries built and installed</span>
<span class="c1">;</span>
<span class="c1">; Notes:</span>
<span class="c1">;</span>
<span class="c1">; * Libraries may be available in other forms e.g. RPM&#39;s, Debian</span>
<span class="c1">;   packages, Window&#39;s installers or .zips - follow relevant</span>
<span class="c1">;   instructions</span>
<span class="c1">;</span>
<span class="c1">; * A simple, Guile source-only library may be manually copied</span>
<span class="c1">;   into the default modules directory or placed into an arbitrary</span>
<span class="c1">;   directory and location information passed to the interpreter</span>
<span class="c1">;   via environment variables or command-line. For example, for a</span>
<span class="c1">;   quick look one could copy relevant module .scm files into</span>
<span class="c1">;   the current directory and load them via:</span>
<span class="c1">;</span>
<span class="c1">;       guile -L ./ -s tester.scm</span>
<span class="c1">;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN696"
>Example: Module Template</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; The format of a Guile module really is quite simple; it is a</span>
<span class="c1">; source file:</span>
<span class="c1">;</span>
<span class="c1">; * Containing a &#39;define-module&#39; definition which serves to</span>
<span class="c1">;   name the module [the name would match the source file</span>
<span class="c1">;   basename (if a single name is used), or the last name</span>
<span class="c1">;   in a name list (preceding names are subdirectory names)]</span>
<span class="c1">;</span>
<span class="c1">; * A list of bindings to be exported, either via individual</span>
<span class="c1">;   &#39;define-public&#39; definitions, or via an &#39;export&#39; list</span>
<span class="c1">;</span>
<span class="c1">; Documentation is optional [but useful :)], as is any runtime</span>
<span class="c1">; accessable data such as version number or author name, or any</span>
<span class="c1">; special routines such as a module cleanup routine [just</span>
<span class="c1">; &#39;define-public&#39; whatever variable or procedure you want, and</span>
<span class="c1">; adopt a convention for its use]</span>
<span class="c1">;</span>

<span class="c1">; module.scm</span>
<span class="p">(</span><span class="nf">define-module</span> <span class="p">(</span><span class="nf">module</span><span class="p">))</span>

<span class="c1">; ---</span>

<span class="c1">; Module implementation</span>
<span class="p">(</span><span class="k">define </span><span class="nv">private-variable</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">private-procedure</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">; ---</span>

<span class="c1">; Module interface</span>
<span class="p">(</span><span class="nf">define-public</span> <span class="nv">exported-variable</span> <span class="s">&quot;...&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">define-public</span> <span class="p">(</span><span class="nf">exported-procedure</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="o">&#39;</span><span class="p">())</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN699"
>Program: Finding Versions and Descriptions of Installed Modules</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="referencesandrecords.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="classesetc.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>References and Records</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Classes, Objects, and Ties</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>