<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Subroutines</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Guile 1.8"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Directories"
HREF="directories.html"><LINK
REL="NEXT"
TITLE="References and Records"
HREF="referencesandrecords.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Guile 1.8</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SUBROUTINES"
>10. Subroutines</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN536"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Note: Some of the examples will show code blocks in this style:</span>
<span class="c1">;</span>
<span class="c1">;  (define</span>
<span class="c1">;    ... code here ...</span>
<span class="c1">;  )</span>
<span class="c1">;</span>
<span class="c1">; This is not generally considered good style, and is not recommended;</span>
<span class="c1">; it is only used here to more clearly highlight block scope</span>

<span class="c1">; By convention a &#39;global variable&#39; i.e. a variable that is defined at</span>
<span class="c1">; the top-level, and as such, visible within any scope, is named with</span>
<span class="c1">; beginning and ending asterisks [and one to be used as a constant</span>
<span class="c1">; with beginning and ending plus signs]</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*greeted*</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hello</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">*greeted*</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">*greeted*</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;hi there!, this procedure has been called&quot;</span> <span class="nv">*greeted*</span> <span class="s">&quot;times&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">how-many-greetings</span><span class="p">)</span> <span class="nv">*greeted*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="nf">hello</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*greetings*</span> <span class="p">(</span><span class="nf">how-many-greetings</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">&quot;bye there!, there have been&quot;</span> <span class="nv">*greetings*</span> <span class="s">&quot;greetings so far&quot;</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN539"
>Accessing Subroutine Arguments</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Subroutine parameters are named [whether directly, or indirectly in</span>
<span class="c1">; the case of variable arguments - see next example]; this is the only</span>
<span class="c1">; means of access [This contrasts with languages like Perl and REXX which</span>
<span class="c1">; allow access to arguments via array subscripting, and function calls,</span>
<span class="c1">; respectively]</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hypotenuse</span> <span class="nv">side1</span> <span class="nv">side2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">* </span><span class="nv">side1</span> <span class="nv">side1</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">side2</span> <span class="nv">side2</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*diag*</span> <span class="p">(</span><span class="nf">hypotenuse</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; &#39;other-sides&#39; is the name of a list of containing any additional</span>
<span class="c1">; parameters. Note that a name is still used to access values</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hypotenuse</span> <span class="nv">side1</span> <span class="o">.</span> <span class="nv">other-sides</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">all-sides</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">side1</span> <span class="nv">other-sides</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">for-each</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">side</span><span class="p">)</span>
        <span class="c1">;; ...</span>
        <span class="o">&#39;</span><span class="p">())</span>
      <span class="nv">all-sides</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*diag*</span> <span class="p">(</span><span class="nf">hypotenuse</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; Possible to pack parameters into a single structure [e.g. list or</span>
<span class="c1">; array], and access values contained therein</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hypotenuse</span> <span class="nv">sides</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">side1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">sides</span><span class="p">))</span> <span class="p">(</span><span class="nf">side2</span> <span class="p">(</span><span class="nb">caar </span><span class="nv">sides</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">* </span><span class="nv">side1</span> <span class="nv">side1</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">side2</span> <span class="nv">side2</span><span class="p">)))))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*args*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*diag*</span> <span class="p">(</span><span class="nf">hypotenuse</span> <span class="nv">*args*</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; Parameters passed by reference, however, whether original object is</span>
<span class="c1">; modified depends on choice of functions used to manipulate them</span>
<span class="c1">; [most functions create copies and return these; mutating versions of</span>
<span class="c1">; same functions may also exist [see next example]</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*nums*</span> <span class="p">(</span><span class="nb">vector </span><span class="mf">1.4</span> <span class="mf">3.5</span> <span class="mf">6.7</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">int-all</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">vector-map-in-order</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span> <span class="p">(</span><span class="nb">inexact-&gt;exact </span><span class="p">(</span><span class="nb">round </span><span class="nv">element</span><span class="p">)))</span>
    <span class="nv">vec</span><span class="p">))</span>

<span class="c1">; Copy created</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*ints*</span> <span class="p">(</span><span class="nf">int-all</span> <span class="nv">*nums*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*nums*</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print</span> <span class="nv">*ints*</span><span class="p">)</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*nums*</span> <span class="p">(</span><span class="nb">vector </span><span class="mf">1.4</span> <span class="mf">3.5</span> <span class="mf">6.7</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">trunc-all</span> <span class="nv">vec</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">array-map-in-order!</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">element</span><span class="p">)</span> <span class="p">(</span><span class="nb">inexact-&gt;exact </span><span class="p">(</span><span class="nb">round </span><span class="nv">element</span><span class="p">)))</span>
    <span class="nv">vec</span><span class="p">))</span>

<span class="c1">; Original modified</span>
<span class="p">(</span><span class="nf">trunc-all</span> <span class="nv">*nums*</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN542"
>Making Variables Private to a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Scheme is lexically-scoped; variables defined within a block are</span>
<span class="c1">; visible only within that block. Whilst nested / subordinate blocks</span>
<span class="c1">; have access to those variables, neither the caller, nor any called</span>
<span class="c1">; procedures have direct access to those same variables</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">some-func</span> <span class="nv">parm1</span> <span class="nv">parm2</span> <span class="nv">parm3</span><span class="p">)</span>
  <span class="c1">;; ... paramaters visible here ...</span>

  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">var1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">var2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">var3</span> <span class="mi">3</span><span class="p">))</span>
    <span class="c1">;; ... parameters also visible here, but variables, &#39;var1&#39; etc</span>
    <span class="c1">;;     only visible within this block ...</span>
  <span class="p">)</span>
  <span class="c1">;; ... paramaters also visible here, but still within procedure body ...</span>
<span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Top-level definitions - accessable globally</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*name*</span> <span class="p">(</span><span class="nb">caar </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*age*</span> <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*start*</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; Lexical binding - accessable only within this block</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">name</span> <span class="p">(</span><span class="nb">caar </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">age</span> <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">command-line</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">start</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">)))</span>
   <span class="c1">;; ... variables only visible here ...</span>
   <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*pair*</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="o">.</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1">; &#39;a&#39; and &#39;b&#39; need to be dereferenced and separately defined [Also,</span>
<span class="c1">; since globally defined, should really be named, &#39;*a*&#39;, &#39;*b*&#39;, etc]</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="nb">car </span><span class="nv">*pair*</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">*pair*</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">run-check</span><span class="p">)</span>
  <span class="c1">;; ... do something with &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">check-x</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">run-check</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;got&quot;</span> <span class="nv">x</span><span class="p">)))</span>

<span class="c1">; Calling &#39;check-x&#39;; &#39;run-check&#39; has access to &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;</span>
<span class="p">(</span><span class="nf">check-x</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">;; ----</span>

<span class="c1">; If defined within a block, variables &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; are no longer</span>
<span class="c1">; accessable anywhere except that scope. Therefore, &#39;run-check&#39; as</span>
<span class="c1">; defined above can no longer access these variables [in fact, the code</span>
<span class="c1">; will fail because variables &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; do not exist when</span>
<span class="c1">; &#39;run-check&#39; is defined]</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">car </span><span class="nv">*pair*</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">*pair*</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">)))</span>
   <span class="c1">;; ...</span>
   <span class="p">(</span><span class="nf">check-x</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
   <span class="c1">;; ...</span>
   <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">;; ----</span>

<span class="c1">; The procedures, &#39;run-check&#39; and &#39;check-x&#39; are defined within the</span>
<span class="c1">; same block as variables, &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;, so have direct access to</span>
<span class="c1">; them</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">car </span><span class="nv">*pair*</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">*pair*</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nf">fetch-time</span><span class="p">))</span>

       <span class="p">(</span><span class="nf">run-check</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
           <span class="c1">;; ... do something with &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; ...</span>
           <span class="o">&#39;</span><span class="p">()))</span>

       <span class="p">(</span><span class="nf">check-x</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
           <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">run-check</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;got&quot;</span> <span class="nv">x</span><span class="p">))))</span> <span class="p">)</span>
   <span class="c1">;; ...</span>
   <span class="p">(</span><span class="nf">check-x</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
   <span class="c1">;; ...</span>
   <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN545"
>Creating Persistent Private Variables</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Ordinarily, a variable must be initialised when it is defined,</span>
<span class="c1">; whether at the top-level:</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*variable*</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">; ... or within a &#39;let&#39; binding</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">variable</span> <span class="mi">1</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">mysub</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
           <span class="c1">;; ... accessing &#39;variable&#39; ...</span>
         <span class="o">&#39;</span><span class="p">())))</span>
  <span class="c1">;; ... do stuff ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">; However, since Scheme allows syntactic extensions via &#39;macros&#39; [of</span>
<span class="c1">; which there are two varieties: hygenic and LISP-based], it is</span>
<span class="c1">; possible to create new forms which alter this behaviour. For example,</span>
<span class="c1">; in this tutorial: http://home.comcast.net/~prunesquallor/macro.txt</span>
<span class="c1">; there is a macro implementation equivalent to &#39;let, &#39;called,</span>
<span class="c1">; &#39;bind-values&#39;, which allows variables to be defined without initial</span>
<span class="c1">; values; an example follows:</span>

<span class="c1">; Initialisation values for &#39;a&#39; and &#39;b&#39; not specified</span>
<span class="p">(</span><span class="nf">bind-values</span> <span class="p">((</span><span class="nf">a</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">*global*</span> <span class="mi">5</span><span class="p">)))</span>
  <span class="c1">;; ... do stuff ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">; In Scheme many things are possible, but not all those things are</span>
<span class="c1">; offered as standard features :) !</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">counter</span> <span class="mi">42</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">next-counter</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">counter</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">counter</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">counter</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">prev-counter</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">counter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">counter</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">counter</span><span class="p">)))</span>

  <span class="c1">;; ... do stuff with &#39;next-counter&#39; and &#39;prev-counter&#39; ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">;; ----</span>

<span class="c1">; A more complete, and practical, variation of the above code:</span>

<span class="c1">; &#39;counter&#39; constructor</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-counter</span> <span class="nv">start</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">counter</span> <span class="mi">42</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">next-counter</span>
           <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">counter</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">counter</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">counter</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">prev-counter</span>
           <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">counter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">counter</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">counter</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">op</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">&#39;prev</span><span class="p">)</span> <span class="nv">prev-counter</span><span class="p">)</span>
      <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">&#39;next</span><span class="p">)</span> <span class="nv">next-counter</span><span class="p">)</span>
      <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">display </span><span class="s">&quot;error:counter&quot;</span><span class="p">)))</span> <span class="p">))))</span>

<span class="c1">; Interface functions to &#39;counter&#39; functionality</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">prev-counter</span> <span class="nv">counter</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nf">counter</span> <span class="ss">&#39;prev</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">next-counter</span> <span class="nv">counter</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nf">counter</span> <span class="ss">&#39;next</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()))</span>

<span class="c1">; Create a &#39;counter&#39;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*counter*</span> <span class="p">(</span><span class="nf">make-counter</span> <span class="mi">42</span><span class="p">))</span>

<span class="c1">; Use the &#39;counter&#39; ...</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">prev-counter</span> <span class="nv">*counter*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">prev-counter</span> <span class="nv">*counter*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">next-counter</span> <span class="nv">*counter*</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN548"
>Determining Current Function Name</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Scheme interpreters generally provide a rich collection of procedure</span>
<span class="c1">; metadata, as well as easy access to a program&#39;s current &#39;execution</span>
<span class="c1">; state&#39;. Put simply, provision of a powerful, highly customisable</span>
<span class="c1">; debugging / tracing facility is almost taken for granted. However, using</span>
<span class="c1">; it to perform as trivial a task as obtaining the current function name</span>
<span class="c1">; is less than trivial [at least it seems so in Guile] as it appears to</span>
<span class="c1">; require quite some setup work. Additionally, the documentation talks</span>
<span class="c1">; about facilities e.g. trap installation, that don&#39;t appear to be</span>
<span class="c1">; available [at least, I couldn&#39;t find them].</span>
<span class="c1">;</span>
<span class="c1">; Example below uses in-built debugging facilities to dump a backtrace</span>
<span class="c1">; to a string port and extract the caller&#39;s name from the resulting</span>
<span class="c1">; string. Not exactly elegant ...</span>

<span class="c1">; Execute using: guile --debug ... else no useful output seen</span>
<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">debug</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">child</span> <span class="nv">num</span><span class="p">)</span>
  <span class="c1">; Create stack [i.e. activation record] object, discarding</span>
  <span class="c1">; irrelevant frames</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">s</span> <span class="p">(</span><span class="nf">make-stack</span> <span class="no">#t</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">trace-string-port</span> <span class="p">(</span><span class="nf">open-output-string</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">parent-name</span> <span class="s">&quot;&quot;</span><span class="p">))</span>

    <span class="c1">; Dump backtrace to string port</span>
    <span class="p">(</span><span class="nf">display-backtrace</span> <span class="nv">s</span> <span class="nv">trace-string-port</span><span class="p">)</span>

    <span class="c1">; Extract caller&#39;s name from backtrace data</span>
    <span class="c1">; [shamefully crude - don&#39;t do this at home !]</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">parent-name</span>
      <span class="p">(</span><span class="nb">caddr </span><span class="p">(</span><span class="nf">string-tokenize</span>
               <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">string-split</span>
                       <span class="p">(</span><span class="nf">get-output-string</span> <span class="nv">trace-string-port</span><span class="p">)</span>
                       <span class="sc">#\newline</span><span class="p">))</span>
               <span class="nv">char-set:graphic</span><span class="p">)))</span>

    <span class="c1">; Who&#39;s your daddy ?</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">parent-name</span><span class="p">)))</span>

<span class="c1">; Each invocation of &#39;child&#39; should see &#39;parent&#39; displayed as</span>
<span class="c1">; the caller</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">parent</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">child</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">child</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">child</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nf">parent</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN551"
>Passing Arrays and Hashes by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Procedure parameters are references to entities, so there is no special</span>
<span class="c1">; treatment required. If an argument represents a mutable object such</span>
<span class="c1">; as an array, then care should be taken to not mutate the object within</span>
<span class="c1">; the procedure, or a copy of the object be made and used</span>

<span class="p">(</span><span class="nf">array-diff</span> <span class="nv">*array1*</span> <span class="nv">*array2*</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-vector-pair</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nb">vector-length </span><span class="p">(</span><span class="nb">vector-length </span><span class="nv">x</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">new-vec</span> <span class="p">(</span><span class="nb">make-vector </span><span class="nv">vector-length</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">i</span> <span class="nv">vector-length</span><span class="p">)</span> <span class="nv">new-vec</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">else</span>
          <span class="p">(</span><span class="nb">vector-set! </span><span class="nv">new-vec</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">vector-ref </span><span class="nv">x</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">y</span> <span class="nv">i</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))</span> <span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*a*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*b*</span> <span class="o">&#39;#</span><span class="p">(</span><span class="mi">5</span> <span class="mi">8</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">*c*</span> <span class="p">(</span><span class="nf">add-vector-pair</span> <span class="nv">*a*</span> <span class="nv">*b*</span><span class="p">))</span>

<span class="p">(</span><span class="nf">print</span> <span class="nv">*c*</span><span class="p">)</span>

<span class="c1">;; ----</span>

  <span class="c1">;; ...</span>

  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">vector? </span><span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector? </span><span class="nv">a2</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">add-vector-pair</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">))</span>
  <span class="c1">;else</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;usage: add-vector-pair a1 a2&quot;</span><span class="p">))</span>

  <span class="c1">;; ...</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN554"
>Detecting Return Context</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; AFAIK there is no Scheme equivalent to Perl&#39;s &#39;return context&#39; where</span>
<span class="c1">; it is possible to use language primitives [e.g. &#39;wantarray&#39;] to</span>
<span class="c1">; dynamically specify the return type of a procedure. It is, however,</span>
<span class="c1">; possible to:</span>
<span class="c1">; * Return one of several types from a procedure, whether based on</span>
<span class="c1">;   processing results [e.g. &#39;false&#39; on error, numeric on success], or</span>
<span class="c1">;   perhaps specified via control argument</span>
<span class="c1">; * Check procedure return type and take appropriate action</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">my-sub</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">datatype</span> <span class="p">(</span><span class="nb">vector </span><span class="o">&#39;</span><span class="p">()</span> <span class="mi">7</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="s">&quot;abc&quot;</span> <span class="ss">&#39;sym</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">vector-ref </span><span class="nv">datatype</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">vector-length </span><span class="nv">datatype</span><span class="p">)))</span> <span class="p">))</span>

<span class="c1">;; ----</span>

<span class="c1">; &#39;*result*&#39; is bound to a randomly chosen datatype</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*result*</span> <span class="p">(</span><span class="nf">my-sub</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cond</span>
  <span class="c1">; It is common to return an empty list to represent &#39;void&#39;</span>
  <span class="p">((</span><span class="nb">null? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;void context&quot;</span><span class="p">))</span>

  <span class="p">((</span><span class="nb">list? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;list context&quot;</span><span class="p">))</span>
  <span class="p">((</span><span class="nb">number? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;scalar context&quot;</span><span class="p">))</span>
  <span class="p">((</span><span class="nb">string? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;string context&quot;</span><span class="p">))</span>
  <span class="p">((</span><span class="nb">symbol? </span><span class="nv">*result*</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;atom context&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Unknown type&quot;</span><span class="p">)))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN557"
>Passing by Named Parameter</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Keyword parameters are fully supported. Note that pairs have</span>
<span class="c1">; replaced Perl strings in the examples since they are easier to</span>
<span class="c1">; manipulate</span>

<span class="p">(</span><span class="nf">use-modules</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">optargs</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define*</span> <span class="p">(</span><span class="nf">the-func</span> <span class="o">#</span><span class="nv">:key</span> <span class="p">(</span><span class="nf">increment</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">10</span> <span class="ss">&#39;s</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">finish</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="ss">&#39;m</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">start</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="ss">&#39;m</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">increment</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">finish</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">start</span><span class="p">))</span>

<span class="p">(</span><span class="nf">the-func</span><span class="p">)</span>
<span class="p">(</span><span class="nf">the-func</span>
  <span class="o">#</span><span class="nv">:increment</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">20</span> <span class="ss">&#39;s</span><span class="p">)</span> <span class="o">#</span><span class="nv">:start</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">5</span> <span class="ss">&#39;m</span><span class="p">)</span> <span class="o">#</span><span class="nv">:finish</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">30</span> <span class="ss">&#39;m</span><span class="p">))</span>
<span class="p">(</span><span class="nf">the-func</span> <span class="o">#</span><span class="nv">:start</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">5</span> <span class="ss">&#39;m</span><span class="p">)</span> <span class="o">#</span><span class="nv">:finish</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">30</span> <span class="ss">&#39;m</span><span class="p">))</span>
<span class="p">(</span><span class="nf">the-func</span> <span class="o">#</span><span class="nv">:finish</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">30</span> <span class="ss">&#39;m</span><span class="p">))</span>
<span class="p">(</span><span class="nf">the-func</span> <span class="o">#</span><span class="nv">:start</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">5</span> <span class="ss">&#39;m</span><span class="p">)</span> <span class="o">#</span><span class="nv">:increment</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">20</span> <span class="ss">&#39;s</span><span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN560"
>Skipping Selected Return Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; @@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN563"
>Returning More Than One Array or Hash</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; The return of multiple values, whether arrays or other items, may be</span>
<span class="c1">; achieved via:</span>
<span class="c1">; * Packaging return items as a single list, structure or array, an</span>
<span class="c1">;   approach which is usable across many languages, though can be</span>
<span class="c1">;   clunky because the procedure caller must manually extract all</span>
<span class="c1">;   items</span>
<span class="c1">; * The &#39;values&#39; procedure, a more Schemish idiom, is usually used in</span>
<span class="c1">;   conjunction with the &#39;call-with-values&#39; procedure [the former combines</span>
<span class="c1">;   multiple values, the latter captures and cleanly extracts them]. It</span>
<span class="c1">;   comes into its own, however, when used to create a &#39;macro&#39; [an</span>
<span class="c1">;   extension to the Scheme language] like &#39;let-values&#39;, a variation of</span>
<span class="c1">;   the &#39;let&#39; form that allows multiple return values to be placed directly</span>
<span class="c1">;   into separate variables. Implementation shown here is from &#39;The</span>
<span class="c1">;   Scheme Programming Language, 3rd Edition&#39; by R. Kent Dybvig, though</span>
<span class="c1">;   there exists a more standard implementation in SRFI-11. There is also</span>
<span class="c1">;   the &#39;receive&#39; functionality accessable via: (use-modules (ice-9 receive))</span>

<span class="c1">; [1] Implementation of &#39;somefunc&#39; returning muliple values via packaging</span>
<span class="c1">; items within a list that is returned</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">somefunc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">5</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">h</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">5</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">list </span><span class="nv">a</span> <span class="nv">h</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">; Retrieving procedure values requires that the return list be captured</span>
<span class="c1">; and each contained item separately extracted [&#39;let*&#39; used in place of</span>
<span class="c1">; &#39;let&#39; to ensure correct retrieval order]</span>
<span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">return-list</span> <span class="p">(</span><span class="nf">somefunc</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">a</span> <span class="p">(</span><span class="nb">car </span><span class="nv">return-list</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">return-list</span><span class="p">)))</span>

  <span class="c1">;; ... do something with &#39;a&#39; and &#39;b&#39; ...</span>
  <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; [2] Implementation of &#39;somefunc&#39; returning muliple values using the</span>
<span class="c1">; &#39;values&#39; procedure</span>

<span class="p">(</span><span class="nf">use-syntax</span> <span class="p">(</span><span class="nf">ice-9</span> <span class="nv">syncase</span><span class="p">))</span>

<span class="c1">; &#39;let-values&#39; from: http://www.scheme.com/tspl3/syntax.html#fullletvalues</span>
<span class="p">(</span><span class="k">define-syntax </span><span class="nv">let-values</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">()</span> <span class="nv">f1</span> <span class="nv">f2</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="k">let </span><span class="p">()</span> <span class="nv">f1</span> <span class="nv">f2</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">((</span><span class="nf">fmls1</span> <span class="nv">expr1</span><span class="p">)</span> <span class="p">(</span><span class="nf">fmls2</span> <span class="nv">expr2</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="nv">f1</span> <span class="nv">f2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">lvhelp</span> <span class="nv">fmls1</span> <span class="p">()</span> <span class="p">()</span> <span class="nv">expr1</span> <span class="p">((</span><span class="nf">fmls2</span> <span class="nv">expr2</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nf">f1</span> <span class="nv">f2</span> <span class="o">...</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="nv">lvhelp</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">(</span><span class="nf">x1</span> <span class="o">.</span> <span class="nv">fmls</span><span class="p">)</span> <span class="p">(</span><span class="nf">x</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="o">...</span><span class="p">)</span> <span class="nv">e</span> <span class="nv">m</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">lvhelp</span> <span class="nv">fmls</span> <span class="p">(</span><span class="nf">x</span> <span class="o">...</span> <span class="nv">x1</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="o">...</span> <span class="nv">tmp</span><span class="p">)</span> <span class="nv">e</span> <span class="nv">m</span> <span class="nv">b</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">_</span> <span class="p">()</span> <span class="p">(</span><span class="nf">x</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="o">...</span><span class="p">)</span> <span class="nv">e</span> <span class="nv">m</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">call-with-values</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">e</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">t</span> <span class="o">...</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">let-values</span> <span class="nv">m</span> <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="nv">t</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)))))</span>
    <span class="p">((</span><span class="nf">_</span> <span class="nv">xr</span> <span class="p">(</span><span class="nf">x</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="o">...</span><span class="p">)</span> <span class="nv">e</span> <span class="nv">m</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">call-with-values</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">e</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">t</span> <span class="o">...</span> <span class="o">.</span> <span class="nv">tmpr</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">let-values</span> <span class="nv">m</span> <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="nv">t</span><span class="p">)</span> <span class="o">...</span> <span class="p">(</span><span class="nf">xr</span> <span class="nv">tmpr</span><span class="p">))</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)))))))</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">somefunc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">make-vector </span><span class="mi">5</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">h</span> <span class="p">(</span><span class="nf">make-hash-table</span> <span class="mi">5</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values </span><span class="nv">a</span> <span class="nv">h</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">; Multiple return items placed directly into separate variables</span>
<span class="p">(</span><span class="nf">let-values</span> <span class="p">(</span> <span class="p">((</span><span class="nf">a</span> <span class="nv">h</span><span class="p">)</span> <span class="p">(</span><span class="nf">somefunc</span><span class="p">))</span> <span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">array?</span> <span class="nv">a</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">hash-table?</span> <span class="nv">h</span><span class="p">)))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN566"
>Returning Failure</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Like most modern languages, Scheme supports exceptions for handling</span>
<span class="c1">; failure, something that will be illustrated in another section. However,</span>
<span class="c1">; conventions exist as to the choice of value used to indicate failure:</span>
<span class="c1">; * Empty list i.e. &#39;() is often used for this task, as is it&#39;s string</span>
<span class="c1">;   counterpart, &quot;&quot;, the empty string</span>
<span class="c1">; * Return false i.e. #f to indicate failed / not found etc, and a valid</span>
<span class="c1">;   value otherwise [e.g. testing set membership: if not a member, return</span>
<span class="c1">;   #f, but if a member, return the item itself rather than #t]</span>

<span class="c1">; Return empty list as indicating &#39;failure&#39;</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-failed</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">look-for-something</span><span class="p">)</span>
  <span class="o">...</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">something-found</span><span class="p">)</span>
    <span class="c1">; Item found, return the item</span>
    <span class="nv">something</span>
  <span class="c1">;else</span>
    <span class="c1">; Not found, indicate failure</span>
    <span class="no">#f</span>
  <span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">look-for-something</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Item could not be found ...&quot;</span><span class="p">)</span>
<span class="c1">;else</span>
  <span class="c1">;; do something with item ...</span>
  <span class="c1">;; ...</span>
  <span class="o">&#39;</span><span class="p">()</span>
  <span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; An interesting variation on returning #f as a failure indicator is</span>
<span class="c1">; in using the, &#39;false-if-exception&#39; procedure whereby a procedure is</span>
<span class="c1">; executed, any exceptions it may throw caught, and handled by simply</span>
<span class="c1">; returning #f. See example in section on Exception Handling below.</span>

<span class="c1">;; ------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">ioctl</span><span class="p">)</span>
  <span class="c1">;; ...</span>
  <span class="no">#f</span><span class="p">)</span>

<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nf">print</span> <span class="s">&quot;can&#39;t ioctl&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">exit</span> <span class="mi">1</span><span class="p">)))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN569"
>Prototyping Functions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Whether Scheme is seen to support prototyping depends on the definition</span>
<span class="c1">; of this term used:</span>
<span class="c1">; * Prototyping along the lines used in Ada, Modula X, and even C / C++,</span>
<span class="c1">;   in which a procedure&#39;s interface is declared separately from its</span>
<span class="c1">;   implementation, is *not* supported</span>
<span class="c1">; * Prototyping in which, as part of the procedure definition, parameter</span>
<span class="c1">;   information must be supplied. This is a requirement in Scheme in that</span>
<span class="c1">;   parameter number and names must be given, though there is no need to</span>
<span class="c1">;   supply type information [optional and keyword parameters muddy the</span>
<span class="c1">;   waters somewhat, but the general principle applies]</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func-with-no-arg</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func-with-one-arg</span> <span class="nv">arg1</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func-with-two-arg</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func-with-three-arg</span> <span class="nv">arg1</span> <span class="nv">arg2</span> <span class="nv">arg3</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN572"
>Handling Exceptions</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Not exactly like the Perl example, but a way of immediately</span>
<span class="c1">; exiting from an application</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">die</span> <span class="nv">msg</span> <span class="o">.</span> <span class="nv">error-code</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">string-append </span><span class="nv">msg</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">current-error-port</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">exit</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">error-code</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">error-code</span><span class="p">))))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="nf">die</span> <span class="s">&quot;some message&quot;</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; An exception is thrown via &#39;throw&#39;; argument must be a symbol</span>
<span class="p">(</span><span class="nf">throw</span> <span class="ss">&#39;some-exception</span><span class="p">)</span>

<span class="c1">; Invalid attempts - these, themselves force a &#39;wrong-type-arg</span>
<span class="c1">; exception to be thrown</span>
<span class="p">(</span><span class="nf">throw</span> <span class="no">#t</span><span class="p">)</span>
<span class="p">(</span><span class="nf">throw</span> <span class="s">&quot;my message&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">throw</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; Example of a &#39;catch all&#39; handler - &#39;proc&#39; is executed, and any</span>
<span class="c1">; exception thrown is handled, in this case by simply returning false</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">false-if-exception</span> <span class="nv">proc</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
    <span class="nv">proc</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="no">#f</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Starting &#39;func&#39; ...&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">throw</span> <span class="ss">&#39;myexception</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Leaving &#39;func&#39; ...&quot;</span><span class="p">))</span>

<span class="c1">;; ----</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">false-if-exception</span> <span class="nv">main</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;&#39;func&#39; raised an exception&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;&#39;func&#39; executed normally&quot;</span><span class="p">))</span>

<span class="c1">;; ------------</span>

<span class="c1">; More typical exception handling example in which:</span>
<span class="c1">; * &#39;func&#39; is executed</span>
<span class="c1">; * &#39;catch&#39; either:</span>
<span class="c1">;   - returns return value of &#39;func&#39; [if successful]</span>
<span class="c1">;   - executes handler(s)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">full-moon-exception-handler</span> <span class="nv">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;I&#39;m executing after stack unwound !&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">full-moon-exception-prewind-handler</span> <span class="nv">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;I&#39;m executing with the stack still intact !&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Starting &#39;func&#39; ...&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">throw</span> <span class="ss">&#39;full-moon-exception</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;Leaving &#39;func&#39; ...&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">catch</span> <span class="ss">&#39;full-moon-exception</span>
   <span class="nv">func</span>
   <span class="nv">full-moon-exception-handler</span>
   <span class="nv">full-moon-exception-prewind-handler</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN575"
>Saving Global Values</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Scheme is lexically-scoped, so same-name, higher-level variables</span>
<span class="c1">; are merely shadowed in lower-level blocks. Upon exit from those</span>
<span class="c1">; blocks the higher-level values are again available. Therefore, the</span>
<span class="c1">; saving of global variables, as required by Perl, is not necessary</span>

<span class="c1">; Global variable</span>
<span class="p">(</span><span class="k">define </span><span class="nv">age</span> <span class="mi">18</span><span class="p">)</span>

<span class="c1">; Procedure definition creates a closure - it captures the earlier</span>
<span class="c1">; version of, age&#39;, and will retain it</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">func</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">age</span><span class="p">))</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">condition</span><span class="p">)</span>
  <span class="c1">; New &#39;local&#39; variable created which acts to shadow the global</span>
  <span class="c1">; version</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">age</span> <span class="mi">23</span><span class="p">))</span>

    <span class="c1">; Prints 23 because the global variable is shadowed within</span>
    <span class="c1">; this block</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">age</span><span class="p">)</span>

    <span class="c1">; However, lexical-scoping ensures &#39;func&#39; still accesses the</span>
    <span class="c1">; &#39;age&#39; which was active when it was defined</span>
    <span class="p">(</span><span class="nf">func</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">; The use of &#39;fluid-let&#39; allows for similar behaviour to Perl&#39;s i.e.</span>
<span class="c1">; it mimics dynamic scope, but it does so cleanly in that once its</span>
<span class="c1">; scope ends any affected global variables are restored to previous</span>
<span class="c1">; values</span>
<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">condition</span><span class="p">)</span>

  <span class="c1">; This does not create a new &#39;local&#39; variables but temporarily</span>
  <span class="c1">; sets the global variable, &#39;age&#39; to 23</span>
  <span class="p">(</span><span class="nf">fluid-let</span> <span class="p">((</span><span class="nf">age</span> <span class="mi">23</span><span class="p">))</span>

    <span class="c1">; Prints 23 because it is accessing the global version of &#39;age&#39;</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">age</span><span class="p">)</span>

    <span class="c1">; Prints 23 because it is its lexically-scoped version of &#39;age&#39;</span>
    <span class="c1">; that has its value altered, albeit temporarily</span>
    <span class="p">(</span><span class="nf">func</span><span class="p">)</span> <span class="p">))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN578"
>Redefining a Function</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Define two procedures, bind them to identifiers</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">grow</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;grow&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">shrink</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="s">&quot;shrink&quot;</span><span class="p">))</span>

<span class="c1">; Separate procedures executed</span>
<span class="p">(</span><span class="nf">grow</span><span class="p">)</span>
<span class="p">(</span><span class="nf">shrink</span><span class="p">)</span>

<span class="c1">; Rebind identifier; now acts as alias for latter</span>
<span class="p">(</span><span class="k">define </span><span class="nv">grow</span> <span class="nv">shrink</span><span class="p">)</span>

<span class="c1">; Same procedure executed in both cases</span>
<span class="p">(</span><span class="nf">grow</span><span class="p">)</span>
<span class="p">(</span><span class="nf">shrink</span><span class="p">)</span>

<span class="c1">;; ------------</span>

<span class="c1">; As for previous except that rebinding is localised and</span>
<span class="c1">; ends once local scope exited</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">grow</span> <span class="nv">shrink</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">grow</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">shrink</span><span class="p">))</span>

<span class="c1">;; ----------------------------</span>

<span class="c1">; Example of dynamically creating [from text data] and binding</span>
<span class="c1">; procedures. The example here is conceptually similar to the Perl</span>
<span class="c1">; example in that it makes use of an &#39;eval&#39; type of facility to</span>
<span class="c1">; generate code from text. In Scheme such tasks are generally better</span>
<span class="c1">; dealt with using macros</span>

<span class="c1">; List of procedure name / first argument pairs</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*colours*</span>
  <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;red&quot;</span> <span class="o">.</span> <span class="s">&quot;baron&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;blue&quot;</span> <span class="o">.</span> <span class="s">&quot;zephyr&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;green&quot;</span> <span class="o">.</span> <span class="s">&quot;beret&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;yellow&quot;</span> <span class="o">.</span> <span class="s">&quot;ribbon&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;orange&quot;</span> <span class="o">.</span> <span class="s">&quot;county&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;purple&quot;</span> <span class="o">.</span> <span class="s">&quot;haze&quot;</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;violet&quot;</span> <span class="o">.</span> <span class="s">&quot;temper&quot;</span><span class="p">)</span> <span class="p">))</span>

<span class="c1">; Build a series of procedures dynamically by traversing the</span>
<span class="c1">; *colours* list and obtaining:</span>
<span class="c1">; * Procedure name from first item of pair</span>
<span class="c1">; * Procedure argument from second item of pair</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">colour</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc-string</span>
            <span class="p">(</span><span class="nf">string-append</span>
              <span class="s">&quot;(define &quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">colour</span><span class="p">)</span> <span class="s">&quot; (lambda () &quot;</span>
              <span class="s">&quot;\&quot;&lt;FONT COLOR=&quot;</span> <span class="p">(</span><span class="nb">car </span><span class="nv">colour</span><span class="p">)</span> <span class="s">&quot;&gt;&quot;</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">colour</span><span class="p">)</span>
              <span class="s">&quot;&lt;/FONT&gt;\&quot;))&quot;</span> <span class="p">)))</span>
      <span class="p">(</span><span class="nf">eval-string</span> <span class="nv">proc-string</span><span class="p">)))</span>
   <span class="nv">*colours*</span><span class="p">)</span>

<span class="c1">; Apply each of the dynamically-built procedures</span>
<span class="p">(</span><span class="nf">for-each</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">colour</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nb">apply </span><span class="p">(</span><span class="nf">string-&gt;procedure</span> <span class="p">(</span><span class="nb">car </span><span class="nv">colour</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())))</span>
  <span class="nv">*colours*</span><span class="p">)</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN581"
>Trapping Undefined Function Calls with AUTOLOAD</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; AFAICT Guile doesn&#39;t implement an AUTOLOAD facility in which a</span>
<span class="c1">; &#39;replacement&#39; function is available should another one fail to</span>
<span class="c1">; load [though there is an autoload feature available with modules</span>
<span class="c1">; which is a load-on-demand facility aimed at conserving memory and</span>
<span class="c1">; speeding up initial program load time].</span>
<span class="c1">;</span>
<span class="c1">; One might think it would be feasable, however, to use exception</span>
<span class="c1">; handling to provide roughly similar functionality:</span>

<span class="c1">; Catch all exceptions</span>
<span class="p">(</span><span class="nf">catch</span> <span class="no">#t</span>
  <span class="c1">; Undefined procedure, &#39;x&#39;</span>
  <span class="nv">x</span>
  <span class="c1">; Exception handler could load missing code ?</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">key</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span> <span class="o">...</span> <span class="p">))</span>

<span class="c1">; However, an undefined function call is reported as:</span>
<span class="c1">;</span>
<span class="c1">;    ERROR: Unbound variable: ...</span>
<span class="c1">;</span>
<span class="c1">; and this situation doesn&#39;t appear to be user-trappable.</span>
<span class="c1">;</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN584"
>Nesting Subroutines</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">; Both implementations below  are correct, and exhibit identical</span>
<span class="c1">; behaviour</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">outer</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">arg</span> <span class="mi">35</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">inner</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">19</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="p">(</span><span class="nf">inner</span><span class="p">))))</span>

<span class="c1">;; ----------------------------</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">outer</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">arg</span> <span class="mi">35</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">inner</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">19</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="p">(</span><span class="nf">inner</span><span class="p">))))</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN587"
>Program: Sorting Your Mail</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="c1"></span><span class="c1">;; @@INCOMPLETE@@</span>
<span class="c1">;; @@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="directories.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="referencesandrecords.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Directories</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>References and Records</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>