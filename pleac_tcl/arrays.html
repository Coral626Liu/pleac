<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Arrays</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="PLEAC-Tcl"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Dates and Times"
HREF="datesandtimes.html"><LINK
REL="NEXT"
TITLE="Hashes"
HREF="hashes.html"><style type="text/css">td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }

  </style></head
><BODY TEXT="#cecece" BGCOLOR="#4f6f6f" LINK="#f5deb3" VLINK="#d5ae83"
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PLEAC-Tcl</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="datesandtimes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="hashes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ARRAYS"
>4. Arrays</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN170"
>Introduction</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">set presidents [list Reagan Bush Clinton]</span>
<span class="s2"># =&gt; Reagan Bush Clinton</span>


<span class="s2">set nested [list this that [list the other]]</span>
<span class="s2">llength $nested</span>
<span class="s2"># =&gt; 3</span>


<span class="s2">set tune [list The Star-spangled Banner]</span>
<span class="s2">list #0 = [lindex $tune 0] #1 = [lindex $tune 1]</span>
<span class="s2"># =&gt; #0 = The #1 = Star-spangled</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN173"
>Specifying a List In Your Program</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">set a [list quick brown fox]</span>
<span class="s2"># =&gt; quick brown fox</span>

<span class="s2">set a &quot;Why are you teasing me?&quot;</span>
<span class="s2"># =&gt; Why are you teasing me?</span>

<span class="s2">set lines [list]</span>
<span class="s2">foreach {l} [split {</span>
<span class="s2">    The boy stood on the burning deck,</span>
<span class="s2">    It was as hot as glass.</span>
<span class="s2">} \n ] {</span>
<span class="s2">    set line [string trimleft $l]</span>
<span class="s2">    if {[string length $line]} {</span>
<span class="s2">        lappend lines $line</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">puts $lines</span>
<span class="s2"># =&gt; {The boy stood on the burning deck,} {It was as hot as glass.}</span>

<span class="s2">set f [open $mydatafile]          ;# Automatically raises error on failure</span>
<span class="s2">set biglist [split [read $f] \n]</span>

<span class="s2">lappend banner1 Costs only \$4.95</span>
<span class="s2">set banner2 [list Costs only \$4.95]</span>
<span class="s2">set banner3 [split {Costs only $4.95}]</span>
<span class="s2">expr {&quot;$banner1&quot; == &quot;$banner2&quot; &amp;&amp; &quot;$banner2&quot; == &quot;$banner3&quot;}</span>
<span class="s2"># =&gt; 1</span>

<span class="s2">set ships [list Niсa Pinta Santa Marнa]   ;# WRONG (4 ships)</span>
<span class="s2">llength $ships</span>
<span class="s2"># =&gt; 4</span>

<span class="s2">set ships [list Niсa Pinta {Santa Marнa}] ;# right (3 ships)</span>
<span class="s2">llength $ships</span>
<span class="s2"># =&gt; 3</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN176"
>Printing a List with Commas</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">set list [list red yellow green]</span>
<span class="s2">puts [list I have $list marbles.]</span>
<span class="s2"># =&gt; I have {red yellow green} marbles.</span>

<span class="s2">set list [list red yellow green]</span>
<span class="s2">puts &quot;I have $list marbles.&quot;</span>
<span class="s2"># =&gt; I have red yellow green marbles.</span>


<span class="s2">set lists {</span>
<span class="s2">    {{just one thing}}</span>
<span class="s2">    {Mutt Jeff}</span>
<span class="s2">    {Peter Paul Mary}</span>
<span class="s2">    {{to our parents} {Mother Theresa} God}</span>
<span class="s2">    {{pastrami} {ham and cheese} {peanut butter and jelly} {tuna}}</span>
<span class="s2">    {{recycle tired, old phrases} {ponder big, happy thoughts}}</span>
<span class="s2">    {{recycle tired, old phrases}  {ponder big, happy thoughts}  {sleep and dream peacefully}  }</span>
<span class="s2">}</span>
<span class="s2">proc commifySeries {args} {</span>
<span class="s2">    if {[regexp , $args]} {</span>
<span class="s2">        set sepchar &quot;;&quot;</span>
<span class="s2">    } else {</span>
<span class="s2">        set sepchar ,</span>
<span class="s2">    }</span>
<span class="s2">    # Tcl has a switch command, nyah nyah nyah</span>
<span class="s2">    switch [llength $args] {</span>
<span class="s2">        0 { return {} }</span>
<span class="s2">        1 { eval return $args }</span>
<span class="s2">        2 { return [join $args { and }] }</span>
<span class="s2">        default {</span>
<span class="s2">            set args [lreplace $args end end [concat and [lindex $args end]]]</span>
<span class="s2">            return [join $args &quot;$sepchar &quot;]</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># =&gt; just one thing</span>

<span class="s2"># =&gt; Mutt and Jeff</span>

<span class="s2"># =&gt; Peter, Paul, and Mary</span>

<span class="s2"># =&gt; to our parents, Mother Theresa, and God</span>

<span class="s2"># =&gt; pastrami, ham and cheese, peanut butter and jelly, and tuna</span>

<span class="s2"># =&gt; recycle tired, old phrases and ponder big, happy thoughts</span>

<span class="s2"># =&gt; recycle tired, old phrases; ponder big, happy thoughts; and sleep and dream peacefully</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN179"
>Changing Array Size</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2"># There is no equivalent to $#ARRAY in Tcl.</span>



<span class="s2">proc whatAboutThatList args {</span>
<span class="s2">    variable people</span>
<span class="s2">    append res &quot;The list now has [set len [llength $people]] elements.\n&quot;</span>
<span class="s2">    append res &quot;The index of the last element is [incr len -1].\n&quot;</span>
<span class="s2">    append res &quot;Element #3 is `[lindex $people 3]&#39;.&quot;</span>
<span class="s2">}</span>

<span class="s2">set people [list Crosby Stills Nash Young]</span>
<span class="s2">whatAboutThatList</span>
<span class="s2"># =&gt; The list now has 4 elements.</span>
<span class="s2"># =&gt; The index of the last element is 3.</span>
<span class="s2"># =&gt; Element #3 is `Young&#39;.</span>

<span class="s2">set people [lrange $people 0 end-1]</span>
<span class="s2">whatAboutThatList</span>
<span class="s2"># =&gt; The list now has 3 elements.</span>
<span class="s2"># =&gt; The index of the last element is 2.</span>
<span class="s2"># =&gt; Element #3 is `&#39;.</span>

<span class="s2"># append 10001-(length of list) null elements to the list:</span>
<span class="s2">for {set i [llength $people]} {$i &lt;= 10000} {incr i} {</span>
<span class="s2">    lappend people {}</span>
<span class="s2">}</span>
<span class="s2">whatAboutThatList</span>
<span class="s2"># =&gt; The list now has 10001 elements.</span>
<span class="s2"># =&gt; The index of the last element is 10000.</span>
<span class="s2"># =&gt; Element #3 is `&#39;.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN182"
>Doing Something with Every Element in a List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">foreach user $badUsers {</span>
<span class="s2">    complain $user</span>
<span class="s2">}</span>

<span class="s2">foreach key [lsort [array names env]] {</span>
<span class="s2">    puts $key=$env($key)</span>
<span class="s2">}</span>

<span class="s2">foreach {user} $allUsers {</span>
<span class="s2">    set diskSpace [getUsage $user]</span>
<span class="s2">    if {$diskSpace &gt; $MAXQUOTA} {</span>
<span class="s2">        complain $user</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2"># Tcl has no implicit variables like Perl&#39;s $_.</span>
<span class="s2">foreach _ [exec who] {</span>
<span class="s2">    if [regexp tchrist $_] {</span>
<span class="s2">        puts $_</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2"># Tcl does not sneak in references unexpectedly.</span>
<span class="s2"># If you need to mutate a list, this is the preferred</span>
<span class="s2"># idiom:</span>

<span class="s2">#     set mylist [mutate $mylist args]</span>

<span class="s2"># You *can* &#39;simulate&#39; manipulation by reference by</span>
<span class="s2"># using call-by-name and connecting a local variable</span>
<span class="s2"># to a variable with that name in the outer scope:</span>



<span class="s2">proc timesSeven {listname} {</span>
<span class="s2">    upvar $listname listref</span>
<span class="s2">    for {set i 0} {$i &lt; [llength $listref]} {incr i} {</span>
<span class="s2">        set listref [lreplace $listref $i $i [expr {[lindex $listref $i] * 7}]]</span>
<span class="s2">    }</span>
<span class="s2">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN185"
>Iterating Over an Array by Reference</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">variable res {}</span>
<span class="s2">set fruits [list Apple Blackberry]</span>
<span class="s2">set fruitRef fruits</span>
<span class="s2"># the variable fruitRef is now set to the name of the fruit list,</span>
<span class="s2"># which makes it a kind of reference variable</span>
<span class="s2">foreach fruit [set $fruitRef] {</span>
<span class="s2">    append res &quot;$fruit tastes good in a pie.\n&quot;</span>
<span class="s2">}</span>
<span class="s2">puts $res</span>
<span class="s2"># =&gt; Apple tastes good in a pie.</span>
<span class="s2"># =&gt; Blackberry tastes good in a pie.</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN188"
>Extracting Unique Elements from a List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">lsort -unique [list how much wood would a wood chuck chuck]</span>
<span class="s2"># =&gt; a chuck how much wood would</span>


<span class="s2"># This is an order of magnitude slower than the previous solution.</span>
<span class="s2">foreach e $list {</span>
<span class="s2">    array set unique [list $e {}]</span>
<span class="s2">}</span>
<span class="s2">array names unique</span>
<span class="s2"># =&gt; a wood much chuck how would</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN191"
>Finding Elements in One Array but Not Another</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2"># Use the TclX standard package (contained in</span>
<span class="s2"># the ActiveTcl distribution).</span>
<span class="s2">package require Tclx</span>
<span class="s2">set listA [list 1 1 2 2 3 3 3 4 5]</span>
<span class="s2">set listB [list 1 2 4]</span>
<span class="s2">set res [intersect3 $listA $listB]</span>
<span class="s2"># [intersect3] yields three result lists;</span>
<span class="s2"># we want the first one:</span>
<span class="s2">lindex $res 0</span>
<span class="s2"># =&gt; 3 5</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN194"
>Computing Union, Intersection, or Difference of Unique Lists</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>
<span class="s2"># Use the TclX standard package (contained in</span>
<span class="s2"># the ActiveTcl distribution).</span>
<span class="s2">package require Tclx</span>
<span class="s2">set listA [list 1 1 2 2 3 3 3 4 5]</span>
<span class="s2">set listB [list 1 2 4 4 6 7]</span>
<span class="s2">foreach {difference intersection -} [intersect3 $listA $listB] break</span>
<span class="s2">set union [union $listA $listB]</span>
<span class="s2">list $difference $intersection $union</span>
<span class="s2"># =&gt; {3 5} {1 2 4} {1 2 3 4 5 6 7}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN197"
>Appending One Array to Another</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">set members [list Time Flies]</span>
<span class="s2">lappend members An Arrow</span>
<span class="s2"># =&gt; Time Flies An Arrow</span>


<span class="s2">set members [list Time Flies]</span>
<span class="s2">set initiates [list An Arrow]</span>
<span class="s2">set members [concat $members $initiates]</span>
<span class="s2"># =&gt; Time Flies An Arrow</span>


<span class="s2">set members [list Time Flies An Arrow]</span>
<span class="s2">set members [linsert $members 2 Like]</span>
<span class="s2"># =&gt; Time Flies Like An Arrow</span>


<span class="s2">set members [list Time Flies Like An Arrow]</span>
<span class="s2">set members [lreplace $members 0 0 Fruit]</span>
<span class="s2">set members [lreplace $members end-1 end A Banana]</span>
<span class="s2"># =&gt; Fruit Flies Like A Banana</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN200"
>Reversing an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">set list [list 0 1 2 3 4 5 6 7 8 9]</span>
<span class="s2">set rlist [list]</span>
<span class="s2">for {set i [expr {[llength $list]-1}]} {$i &gt;= 0} {incr i -1} {</span>
<span class="s2">    lappend rlist [lindex $list $i]</span>
<span class="s2">}</span>
<span class="s2">puts $rlist</span>
<span class="s2"># =&gt; 9 8 7 6 5 4 3 2 1 0</span>


<span class="s2">set list [list 0 1 2 3 4 5 6 7 8 9]</span>
<span class="s2">lsort -decreasing $list</span>
<span class="s2"># =&gt; 9 8 7 6 5 4 3 2 1 0</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN203"
>Processing Multiple Elements of an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">proc splice-ish {listname number} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    set length [llength $list]</span>
<span class="s2">    if {$number &lt; 0} {</span>
<span class="s2">        set number [expr {abs($number)}]</span>
<span class="s2">        set res [lrange $list end-[expr {$number-1}] end]</span>
<span class="s2">        set list [lrange $list 0 end-$number]</span>
<span class="s2">    } else {</span>
<span class="s2">        set res [lrange $list 0 [expr {$number-1}]]</span>
<span class="s2">        set list [lrange $list $number end]</span>
<span class="s2">    }</span>
<span class="s2">    return $res</span>
<span class="s2">}</span>


<span class="s2">proc shift2 {listname} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    return [splice-ish list 2]</span>
<span class="s2">}</span>

<span class="s2">set friends [list Peter Paul Mary Jim Tim]</span>
<span class="s2">foreach {this that} [shift2 friends] break</span>
<span class="s2">list $this $that $friends</span>
<span class="s2"># =&gt; Peter Paul {Mary Jim Tim}</span>


<span class="s2">proc pop2 {listname} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    return [splice-ish list -2]</span>
<span class="s2">}</span>

<span class="s2">set beverages [list Dew Jolt Cola Sprite Fresca]</span>
<span class="s2">set pair [pop2 beverages]</span>
<span class="s2">list $beverages $pair</span>
<span class="s2"># =&gt; {Dew Jolt Cola} {Sprite Fresca}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN206"
>Finding the First List Element That Passes a Test</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">set matchIdx [lsearch $list $criterion]</span>
<span class="s2">if {$matchIdx &gt;= 0} {</span>
<span class="s2">    set match [lindex $list $matchIdx]</span>
<span class="s2">    ## do something with $match</span>
<span class="s2">} else {</span>
<span class="s2">    ## unfound</span>
<span class="s2">}</span>


<span class="s2">set matchIdx [lsearch $list $criterion]</span>
<span class="s2">if {$matchIdx &gt;= 0} {</span>
<span class="s2">    ## found in [lindex $list $matchIdx]</span>
<span class="s2">} else {</span>
<span class="s2">    ## unfound</span>
<span class="s2">}</span>


<span class="s2">Employee is an [incr Tcl] class with the members category,</span>
<span class="s2">name, salary, ssn, and age.</span>


<span class="s2">lappend employees [Employee #auto {manager John 120000 {}}]</span>
<span class="s2">lappend employees [Employee #auto {engineer Susie 100000 {}}]</span>
<span class="s2">lappend employees [Employee #auto {programmer Harold 90000 {}}]</span>
<span class="s2">foreach employee $employees {</span>
<span class="s2">    if {[$employee category] eq &quot;engineer&quot;} {</span>
<span class="s2">        set highestEngineer $employee</span>
<span class="s2">        break</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">$highestEngineer name</span>
<span class="s2"># =&gt; Susie</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN209"
>Finding All Elements in an Array Matching Certain Criteria</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2"># If the test is matching an element&#39;s value against</span>
<span class="s2"># an exact string, a wildcard pattern, or a regular</span>
<span class="s2"># expression, use the standard package TclX (contained</span>
<span class="s2"># in the ActiveTcl distribution).</span>



<span class="s2">package require Tclx</span>
<span class="s2">set matching [lmatch [list ab ac bc dk ab] a*]</span>
<span class="s2"># =&gt; ab ac ab</span>


<span class="s2"># If another type of test is necessary, or TclX is</span>
<span class="s2"># unavailable, a foreach loop is useful:</span>



<span class="s2"># TEST could have been a regular proc, of course</span>
<span class="s2">interp alias {} TEST {} string match a*</span>
<span class="s2">set matching [list]</span>
<span class="s2">foreach e [list ab ac bc dk ab] {</span>
<span class="s2">    if {[TEST $e]} {</span>
<span class="s2">        lappend matching $e</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">set matching</span>
<span class="s2"># =&gt; ab ac ab</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN212"
>Sorting an Array Numerically</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">set numsorted [lsort -real [list 38 388.7 1.56 279 1e7]]</span>
<span class="s2"># =&gt; 1.56 38 279 388.7 1e7</span>


<span class="s2">set descending [lsort -decreasing -real [list 38 388.7 1.56 279 1e7]]</span>
<span class="s2"># =&gt; 1e7 388.7 279 38 1.56</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN215"
>Sorting a List by Computable Field</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2"># Generic code for using a custom comparison in a list sort:</span>

<span class="s2">#     set ordered [lsort -command compare $unordered]</span>

<span class="s2"># Tcl doesn&#39;t have a standard map command as used by the following</span>
<span class="s2"># examples.</span>

<span class="s2"># Pool (&lt;URL: http://www.purl.org/NET/akupries/soft/pool/index.htm&gt;)</span>
<span class="s2"># includes a command, ::pool::list::apply, which is similar to Perl&#39;s</span>
<span class="s2"># map.</span>



<span class="s2">package require Pool_Base</span>
<span class="s2">namespace import ::pool::list::apply</span>
<span class="s2">set unordered [list 1+7 5-2 3+4]</span>
<span class="s2">proc compute e {list [expr $e] $e}</span>
<span class="s2">proc second args {lindex $args 1}</span>
<span class="s2">set precomputed [apply compute $unordered]</span>
<span class="s2">set orderedPrecomputed [lsort -integer -index 0 $precomputed]</span>
<span class="s2">set ordered [apply second $orderedPrecomputed]</span>
<span class="s2"># =&gt; 5-2 3+4 1+7</span>


<span class="s2">Employee is an [incr Tcl] class with the members category,</span>
<span class="s2">name, salary, ssn, and age.</span>



<span class="s2">apply names $employees</span>
<span class="s2"># =&gt; Betsy Ewan Fran Andy Carl Diane</span>
<span class="s2">set ordered [lsort -command Employee::compare-name $employees]</span>
<span class="s2">apply names $ordered</span>
<span class="s2"># =&gt; Andy Betsy Carl Diane Ewan Fran</span>

<span class="s2">foreach employee [lsort -command Employee::compare-name $employees] {</span>
<span class="s2">    puts &quot;[$employee name] earns \$[$employee salary]&quot;</span>
<span class="s2">}</span>
<span class="s2"># =&gt; Andy earns $110000</span>
<span class="s2"># =&gt; Betsy earns $120000</span>
<span class="s2"># =&gt; Carl earns $90000</span>
<span class="s2"># =&gt; Diane earns $80000</span>
<span class="s2"># =&gt; Ewan earns $115000</span>
<span class="s2"># =&gt; Fran earns $110000</span>

<span class="s2">set sortedEmployees [lsort -command Employee::compare-name $employees]</span>
<span class="s2">foreach employee $sortedEmployees {</span>
<span class="s2">    puts &quot;[$employee name] earns \$[$employee salary]&quot;</span>
<span class="s2">}</span>
<span class="s2"># load bonus array</span>
<span class="s2">foreach employee $sortedEmployees {</span>
<span class="s2">    if {[info exists bonus([$employee ssn])]} {</span>
<span class="s2">        puts &quot;[$employee name] got a bonus!&quot;</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2"># =&gt; Andy earns $110000</span>
<span class="s2"># =&gt; Betsy earns $120000</span>
<span class="s2"># =&gt; Carl earns $90000</span>
<span class="s2"># =&gt; Diane earns $80000</span>
<span class="s2"># =&gt; Ewan earns $115000</span>
<span class="s2"># =&gt; Fran earns $110000</span>
<span class="s2"># =&gt; Ewan got a bonus!</span>
<span class="s2"># =&gt; Fran got a bonus!</span>


<span class="s2"># The class procedure Employee::compare-name-or-age looks</span>
<span class="s2"># like this:</span>

<span class="s2">#     proc compare-name-or-age {a b} {</span>
<span class="s2">#         set cmp [string compare [[namespace parent]::$a name] [[namespace parent]::$b name]]</span>
<span class="s2">#         if {$cmp != 0} {</span>
<span class="s2">#             return $cmp</span>
<span class="s2">#         } else {</span>
<span class="s2">#             return [expr {[[namespace parent]::$a age]-[[namespace parent]::$b age]}]</span>
<span class="s2">#         }</span>
<span class="s2">#     }</span>



<span class="s2">lappend employees [Employee #auto {{} Andy  95000 28}] ;# add another Andy</span>
<span class="s2">set sorted [lsort -command Employee::compare-name-or-age $employees]</span>
<span class="s2">apply names-and-ages $sorted</span>
<span class="s2"># =&gt; {Andy 28} {Andy 30} {Betsy 43} {Carl 30} {Diane 27} {Ewan 37} {Fran 35}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN218"
>Implementing a Circular List</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">set circular [concat [lrange $list 1 end] [lindex $list 0]]</span>
<span class="s2">set circular [concat [lindex $list end] [lrange $list 0 end-1]]</span>


<span class="s2">proc grabAndRotate {listname} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    set first [lindex $list 0]</span>
<span class="s2">    set list [concat [lrange $list 1 end] $first]</span>
<span class="s2">    return $first</span>
<span class="s2">}</span>
<span class="s2">while 1 {</span>
<span class="s2">    set process [grabAndRotate processes]</span>
<span class="s2">    puts &quot;Handling process $process&quot;</span>
<span class="s2">    after 1000</span>
<span class="s2">}</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN221"
>Randomizing an Array</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">proc FisherYatesShuffle {listname} {</span>
<span class="s2">    upvar $listname list</span>
<span class="s2">    for {set i [expr {[llength $list]-1}]} {$i &gt;= 0} {incr i -1} {</span>
<span class="s2">        set j [expr {int(rand()*$i+1)}]</span>
<span class="s2">        if {$i != $j} {</span>
<span class="s2">            set temp [lindex $list $i]</span>
<span class="s2">            set list [lreplace $list $i $i [lindex $list $j]]</span>
<span class="s2">            set list [lreplace $list $j $j $temp]</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>


<span class="s2">#   Several shuffle algorithms in Tcl are compared for performance</span>
<span class="s2">#   here: &lt;URL: http://mini.net/cgi-bin/nph-wikit/941.html&gt;.</span>
<span class="s2">#   This is a very efficient algorithm for small lists:</span>


<span class="s2">proc K {x y} {return $x}</span>
<span class="s2"> </span>
<span class="s2">proc shuffle5a { list } {</span>
<span class="s2">    set n 1</span>
<span class="s2">    set slist {}</span>
<span class="s2">    foreach item $list {</span>
<span class="s2">        set index [expr {int(rand()*$n)}]</span>
<span class="s2">        set slist [linsert [K $slist [set slist {}]] $index $item]</span>
<span class="s2">        incr n</span>
<span class="s2">    }</span>
<span class="s2">    return $slist</span>
<span class="s2">} ;# Christoph Bauer</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN224"
>Program: words</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span><span class="s2"># @@INCOMPLETE@@</span>
<span class="s2"># @@INCOMPLETE@@</span></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN227"
>Program: permute</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#2F4F4F"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><font color="#f5deb3" size="+1"><span class="s2"></span>

<span class="s2">package require math 1.2</span>
<span class="s2"> </span>
<span class="s2"># n2pat N len : produce the $N-th pattern of length $len</span>
<span class="s2">proc n2pat {N len} {</span>
<span class="s2">    set i 1</span>
<span class="s2">    set pat [list]</span>
<span class="s2">    while {$i &lt;= $len + 1} {</span>
<span class="s2">        lappend pat [expr {$N % $i}]</span>
<span class="s2">        set N [expr {int($N/$i)}]</span>
<span class="s2">        incr i</span>
<span class="s2">    }</span>
<span class="s2">    return $pat</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2"># pat2perm pat : turn pattern returned by n2pat into</span>
<span class="s2"># permutation of integers.</span>
<span class="s2">proc pat2perm {args} {</span>
<span class="s2">    if {[llength $args] == 1} {</span>
<span class="s2">        set pat [lindex $args 0]</span>
<span class="s2">    } else {</span>
<span class="s2">        set pat $args</span>
<span class="s2">    }</span>
<span class="s2">    set source [list]</span>
<span class="s2">    for {set i 0} {$i &lt; [llength $pat]} {incr i} {</span>
<span class="s2">        lappend source $i</span>
<span class="s2">    }</span>
<span class="s2">    set perm [list]</span>
<span class="s2">    while {[llength $pat]} {</span>
<span class="s2">        set i [lindex $pat end]</span>
<span class="s2">        set pat [lrange $pat 0 end-1]</span>
<span class="s2">        lappend perm [lindex $source $i]</span>
<span class="s2">        set source [lreplace $source $i $i]</span>
<span class="s2">    }</span>
<span class="s2">    return $perm;</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2"># n2perm N len : generate the $Nth permutation of $len objects</span>
<span class="s2">proc n2perm {N len} {</span>
<span class="s2">    return [pat2perm [n2pat $N $len]]</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">proc main {} {</span>
<span class="s2">    while {[gets stdin _] &gt;= 0} {</span>
<span class="s2">        set data [split $_]</span>
<span class="s2">        set len [llength $data]</span>
<span class="s2">        set numPermutations [::math::factorial $len]</span>
<span class="s2">        for {set i 0} {$i &lt; $numPermutations} {incr i} {</span>
<span class="s2">            set permutation [list]</span>
<span class="s2">            foreach {p} [n2perm $i [expr {$len - 1}]] {</span>
<span class="s2">                lappend permutation [lindex $data $p]</span>
<span class="s2">            }</span>
<span class="s2">            puts $permutation</span>
<span class="s2">        }</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2"> </span>
<span class="s2">main</span></PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="datesandtimes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="hashes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Dates and Times</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Hashes</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>