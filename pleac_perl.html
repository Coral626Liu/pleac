<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=latin1">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span class="c1"># -*- perl -*-</span>

<span class="c1"># ^^PLEAC^^_NAME</span>
<span class="n">Perl</span>

<span class="c1"># ^^PLEAC^^_WEB</span>
<span class="n">http:</span><span class="sr">//</span><span class="n">www</span><span class="o">.</span><span class="n">perl</span><span class="o">.</span><span class="n">org</span><span class="o">/</span>

<span class="c1"># ^^PLEAC^^_1.0</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&#39;\n&#39;</span><span class="p">;</span>                     <span class="c1"># two characters, \ and an n</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&#39;Jon \&#39;Maddog\&#39; Orwant&#39;</span><span class="p">;</span>  <span class="c1"># literal single quotes</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span>                     <span class="c1"># a &quot;newline&quot; character</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&quot;Jon \&quot;Maddog\&quot; Orwant&quot;</span><span class="p">;</span>  <span class="c1"># literal double quotes</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="sx">q/Jon &#39;Maddog&#39; Orwant/</span><span class="p">;</span>   <span class="c1"># literal single quotes</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="sx">q[Jon &#39;Maddog&#39; Orwant]</span><span class="p">;</span>   <span class="c1"># literal single quotes</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="sx">q{Jon &#39;Maddog&#39; Orwant}</span><span class="p">;</span>   <span class="c1"># literal single quotes</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="sx">q(Jon &#39;Maddog&#39; Orwant)</span><span class="p">;</span>   <span class="c1"># literal single quotes</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="sx">q&lt;Jon &#39;Maddog&#39; Orwant&gt;</span><span class="p">;</span>   <span class="c1"># literal single quotes</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="s">&lt;&lt;&quot;EOF&quot;;</span>
<span class="s">This is a multiline here document</span>
<span class="s">terminated by EOF on a line by itself</span>
<span class="s">EOF</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.1</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$offset</span><span class="p">,</span> <span class="nv">$count</span><span class="p">);</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$offset</span><span class="p">);</span>

<span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$offset</span><span class="p">,</span> <span class="nv">$count</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$newstring</span><span class="p">;</span>
<span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$offset</span><span class="p">)</span>         <span class="o">=</span> <span class="nv">$newtail</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># get a 5-byte string, skip 3, then grab 2 8-byte strings, then the rest</span>
<span class="p">(</span><span class="nv">$leading</span><span class="p">,</span> <span class="nv">$s1</span><span class="p">,</span> <span class="nv">$s2</span><span class="p">,</span> <span class="nv">$trailing</span><span class="p">)</span> <span class="o">=</span>
    <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;A5 x3 A8 A8 A*&quot;</span><span class="p">,</span> <span class="nv">$data</span><span class="p">);</span>

<span class="c1"># split at five byte boundaries</span>
<span class="nv">@fivers</span> <span class="o">=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;A5&quot;</span> <span class="n">x</span> <span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="nv">$string</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">),</span> <span class="nv">$string</span><span class="p">);</span>

<span class="c1"># chop string into individual characters</span>
<span class="nv">@chars</span>  <span class="o">=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;A1&quot;</span> <span class="n">x</span> <span class="nb">length</span><span class="p">(</span><span class="nv">$string</span><span class="p">),</span> <span class="nv">$string</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&quot;This is what you have&quot;</span><span class="p">;</span>
<span class="c1">#         +012345678901234567890  Indexing forwards  (left to right)</span>
<span class="c1">#          109876543210987654321- Indexing backwards (right to left)</span>
<span class="c1">#           note that 0 means 10 or 20, etc. above</span>

<span class="nv">$first</span>  <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1"># &quot;T&quot;</span>
<span class="nv">$start</span>  <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1"># &quot;is&quot;</span>
<span class="nv">$rest</span>   <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>    <span class="c1"># &quot;you have&quot;</span>
<span class="nv">$last</span>   <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>    <span class="c1"># &quot;e&quot;</span>
<span class="nv">$end</span>    <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">);</span>    <span class="c1"># &quot;have&quot;</span>
<span class="nv">$piece</span>  <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1"># &quot;you&quot;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&quot;This is what you have&quot;</span><span class="p">;</span>
<span class="k">print</span> <span class="nv">$string</span><span class="p">;</span>
<span class="c1">#This is what you have</span>

<span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="s">&quot;wasn&#39;t&quot;</span><span class="p">;</span> <span class="c1"># change &quot;is&quot; to &quot;wasn&#39;t&quot;</span>
<span class="c1">#This wasn&#39;t what you have</span>

<span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">)</span>  <span class="o">=</span> <span class="s">&quot;ondrous&quot;</span><span class="p">;</span><span class="c1"># replace last 12 characters</span>
<span class="c1">#This wasn&#39;t wondrous</span>

<span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>       <span class="c1"># delete first character</span>
<span class="c1">#his wasn&#39;t wondrous</span>

<span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span>  <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>       <span class="c1"># delete last 10 characters</span>
<span class="c1">#his wasn&#39;</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># you can test substrings with =~</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span> <span class="o">=~</span><span class="sr"> /pattern/</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s">&quot;Pattern matches in last 10 characters\n&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># substitute &quot;at&quot; for &quot;is&quot;, restricted to first five characters</span>
<span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">=~</span> <span class="sr">s/is/at/g</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># exchange the first and last letters in a string</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="s">&quot;make a hat&quot;</span><span class="p">;</span>
<span class="p">(</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="k">print</span> <span class="nv">$a</span><span class="p">;</span>
<span class="c1"># take a ham</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># extract column with unpack</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="s">&quot;To be or not to be&quot;</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;x6 A6&quot;</span><span class="p">,</span> <span class="nv">$a</span><span class="p">);</span>  <span class="c1"># skip 6, grab 6</span>
<span class="k">print</span> <span class="nv">$b</span><span class="p">;</span>
<span class="c1"># or not</span>

<span class="p">(</span><span class="nv">$b</span><span class="p">,</span> <span class="nv">$c</span><span class="p">)</span> <span class="o">=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;x6 A2 X5 A2&quot;</span><span class="p">,</span> <span class="nv">$a</span><span class="p">);</span> <span class="c1"># forward 6, grab 2; backward 5, grab 2</span>
<span class="k">print</span> <span class="s">&quot;$b\n$c\n&quot;</span><span class="p">;</span>
<span class="c1"># or</span>
<span class="c1">#</span>
<span class="c1"># be</span>
<span class="c1">#-----------------------------</span>
<span class="k">sub </span><span class="nf">cut2fmt</span> <span class="p">{</span>
    <span class="k">my</span><span class="p">(</span><span class="nv">@positions</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$template</span>   <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$lastpos</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">foreach</span> <span class="nv">$place</span> <span class="p">(</span><span class="nv">@positions</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$template</span> <span class="o">.=</span> <span class="s">&quot;A&quot;</span> <span class="o">.</span> <span class="p">(</span><span class="nv">$place</span> <span class="o">-</span> <span class="nv">$lastpos</span><span class="p">)</span> <span class="o">.</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="nv">$lastpos</span>   <span class="o">=</span> <span class="nv">$place</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nv">$template</span> <span class="o">.=</span> <span class="s">&quot;A*&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$template</span><span class="p">;</span>
<span class="p">}</span>

<span class="nv">$fmt</span> <span class="o">=</span> <span class="n">cut2fmt</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="k">print</span> <span class="s">&quot;$fmt\n&quot;</span><span class="p">;</span>
<span class="c1"># A7 A6 A6 A6 A4 A*</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.2</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># use $b if $b is true, else $c</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="nv">$b</span> <span class="o">||</span> <span class="nv">$c</span><span class="p">;</span>              

<span class="c1"># set $x to $y unless $x is already true</span>
<span class="nv">$x</span> <span class="o">||=</span> <span class="nv">$y</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># use $b if $b is defined, else $c</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="nb">defined</span><span class="p">(</span><span class="nv">$b</span><span class="p">)</span> <span class="p">?</span> <span class="nv">$b</span> <span class="p">:</span> <span class="nv">$c</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$foo</span> <span class="o">=</span> <span class="nv">$bar</span> <span class="o">||</span> <span class="s">&quot;DEFAULT VALUE&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$dir</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="o">||</span> <span class="s">&quot;/tmp&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$dir</span> <span class="o">=</span> <span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="s">&quot;/tmp&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$dir</span> <span class="o">=</span> <span class="nb">defined</span><span class="p">(</span><span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">?</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="p">:</span> <span class="s">&quot;/tmp&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$dir</span> <span class="o">=</span> <span class="nv">@ARGV</span> <span class="p">?</span> <span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="s">&quot;/tmp&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$count</span><span class="p">{</span> <span class="nv">$shell</span> <span class="o">||</span> <span class="s">&quot;/bin/sh&quot;</span> <span class="p">}</span><span class="o">++</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># find the user name on Unix systems</span>
<span class="nv">$user</span> <span class="o">=</span> <span class="nv">$ENV</span><span class="p">{</span><span class="n">USER</span><span class="p">}</span>
     <span class="o">||</span> <span class="nv">$ENV</span><span class="p">{</span><span class="n">LOGNAME</span><span class="p">}</span>
     <span class="o">||</span> <span class="nb">getlogin</span><span class="p">()</span>
     <span class="o">||</span> <span class="p">(</span><span class="nb">getpwuid</span><span class="p">(</span><span class="vg">$&lt;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
     <span class="o">||</span> <span class="s">&quot;Unknown uid number $&lt;&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$starting_point</span> <span class="o">||=</span> <span class="s">&quot;Greenwich&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">@a</span> <span class="o">=</span> <span class="nv">@b</span> <span class="k">unless</span> <span class="nv">@a</span><span class="p">;</span>          <span class="c1"># copy only if empty</span>
<span class="nv">@a</span> <span class="o">=</span> <span class="nv">@b</span> <span class="p">?</span> <span class="nv">@b</span> <span class="p">:</span> <span class="nv">@c</span><span class="p">;</span>          <span class="c1"># assign @b if nonempty, else @c</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.3</span>
<span class="c1">#-----------------------------</span>
<span class="p">(</span><span class="nv">$VAR1</span><span class="p">,</span> <span class="nv">$VAR2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$VAR2</span><span class="p">,</span> <span class="nv">$VAR1</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$temp</span>    <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nv">$a</span>       <span class="o">=</span> <span class="nv">$b</span><span class="p">;</span>
<span class="nv">$b</span>       <span class="o">=</span> <span class="nv">$temp</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$a</span>       <span class="o">=</span> <span class="s">&quot;alpha&quot;</span><span class="p">;</span>
<span class="nv">$b</span>       <span class="o">=</span> <span class="s">&quot;omega&quot;</span><span class="p">;</span>
<span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$b</span><span class="p">,</span> <span class="nv">$a</span><span class="p">);</span>        <span class="c1"># the first shall be last -- and versa vice</span>
<span class="c1">#-----------------------------</span>
<span class="p">(</span><span class="nv">$alpha</span><span class="p">,</span> <span class="nv">$beta</span><span class="p">,</span> <span class="nv">$production</span><span class="p">)</span> <span class="o">=</span> <span class="sx">qw(January March August)</span><span class="p">;</span>
<span class="c1"># move beta       to alpha,</span>
<span class="c1"># move production to beta,</span>
<span class="c1"># move alpha      to production</span>
<span class="p">(</span><span class="nv">$alpha</span><span class="p">,</span> <span class="nv">$beta</span><span class="p">,</span> <span class="nv">$production</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$beta</span><span class="p">,</span> <span class="nv">$production</span><span class="p">,</span> <span class="nv">$alpha</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.4</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$num</span>  <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="nv">$char</span><span class="p">);</span>
<span class="nv">$char</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nv">$num</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$char</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="nv">$num</span><span class="p">);</span>                <span class="c1"># slower than chr($num)</span>
<span class="nb">printf</span><span class="p">(</span><span class="s">&quot;Number %d is character %c\n&quot;</span><span class="p">,</span> <span class="nv">$num</span><span class="p">,</span> <span class="nv">$num</span><span class="p">);</span>
<span class="n">Number</span> <span class="mi">101</span> <span class="n">is</span> <span class="n">character</span> <span class="n">e</span>
<span class="c1">#-----------------------------</span>
<span class="nv">@ASCII</span> <span class="o">=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;C*&quot;</span><span class="p">,</span> <span class="nv">$string</span><span class="p">);</span>
<span class="nv">$STRING</span> <span class="o">=</span> <span class="nb">pack</span><span class="p">(</span><span class="s">&quot;C*&quot;</span><span class="p">,</span> <span class="nv">@ascii</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$ascii_value</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">);</span>    <span class="c1"># now 101</span>
<span class="nv">$character</span>   <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">101</span><span class="p">);</span>    <span class="c1"># now &quot;e&quot;</span>
<span class="c1">#-----------------------------</span>
<span class="nb">printf</span><span class="p">(</span><span class="s">&quot;Number %d is character %c\n&quot;</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">101</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="nv">@ascii_character_numbers</span> <span class="o">=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;C*&quot;</span><span class="p">,</span> <span class="s">&quot;sample&quot;</span><span class="p">);</span>
<span class="k">print</span> <span class="s">&quot;@ascii_character_numbers\n&quot;</span><span class="p">;</span>
<span class="mi">115</span> <span class="mi">97</span> <span class="mi">109</span> <span class="mi">112</span> <span class="mi">108</span> <span class="mi">101</span>


<span class="nv">$word</span> <span class="o">=</span> <span class="nb">pack</span><span class="p">(</span><span class="s">&quot;C*&quot;</span><span class="p">,</span> <span class="nv">@ascii_character_numbers</span><span class="p">);</span>
<span class="nv">$word</span> <span class="o">=</span> <span class="nb">pack</span><span class="p">(</span><span class="s">&quot;C*&quot;</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">101</span><span class="p">);</span>   <span class="c1"># same</span>
<span class="k">print</span> <span class="s">&quot;$word\n&quot;</span><span class="p">;</span>
<span class="n">sample</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$hal</span> <span class="o">=</span> <span class="s">&quot;HAL&quot;</span><span class="p">;</span>
<span class="nv">@ascii</span> <span class="o">=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;C*&quot;</span><span class="p">,</span> <span class="nv">$hal</span><span class="p">);</span>
<span class="k">foreach</span> <span class="nv">$val</span> <span class="p">(</span><span class="nv">@ascii</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$val</span><span class="o">++</span><span class="p">;</span>                 <span class="c1"># add one to each ASCII value</span>
<span class="p">}</span>
<span class="nv">$ibm</span> <span class="o">=</span> <span class="nb">pack</span><span class="p">(</span><span class="s">&quot;C*&quot;</span><span class="p">,</span> <span class="nv">@ascii</span><span class="p">);</span>
<span class="k">print</span> <span class="s">&quot;$ibm\n&quot;</span><span class="p">;</span>             <span class="c1"># prints &quot;IBM&quot;</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.5</span>
<span class="c1">#-----------------------------</span>
<span class="nv">@array</span> <span class="o">=</span> <span class="nb">split</span><span class="p">(</span><span class="sr">//</span><span class="p">,</span> <span class="nv">$string</span><span class="p">);</span>

<span class="nv">@array</span> <span class="o">=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;C*&quot;</span><span class="p">,</span> <span class="nv">$string</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
    <span class="k">while</span> <span class="p">(</span><span class="sr">/(.)/g</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># . is never a newline here</span>
        <span class="c1"># do something with $1</span>
    <span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="nv">%seen</span> <span class="o">=</span> <span class="p">();</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&quot;an apple a day&quot;</span><span class="p">;</span>
<span class="k">foreach</span> <span class="nv">$byte</span> <span class="p">(</span><span class="nb">split</span> <span class="sr">//</span><span class="p">,</span> <span class="nv">$string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$seen</span><span class="p">{</span><span class="nv">$byte</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">print</span> <span class="s">&quot;unique chars are: &quot;</span><span class="p">,</span> <span class="nb">sort</span><span class="p">(</span><span class="nb">keys</span> <span class="nv">%seen</span><span class="p">),</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span>
<span class="n">unique</span> <span class="n">chars</span> <span class="n">are:</span>  <span class="n">adelnpy</span>
<span class="c1">#-----------------------------</span>
<span class="nv">%seen</span> <span class="o">=</span> <span class="p">();</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&quot;an apple a day&quot;</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nv">$string</span> <span class="o">=~</span><span class="sr"> /(.)/g</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$seen</span><span class="p">{</span><span class="nv">$1</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">print</span> <span class="s">&quot;unique chars are: &quot;</span><span class="p">,</span> <span class="nb">sort</span><span class="p">(</span><span class="nb">keys</span> <span class="nv">%seen</span><span class="p">),</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span>
<span class="n">unique</span> <span class="n">chars</span> <span class="n">are:</span>  <span class="n">adelnpy</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">foreach</span> <span class="nv">$ascval</span> <span class="p">(</span><span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;C*&quot;</span><span class="p">,</span> <span class="nv">$string</span><span class="p">))</span> <span class="p">{</span>
    <span class="nv">$sum</span> <span class="o">+=</span> <span class="nv">$ascval</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">print</span> <span class="s">&quot;sum is $sum\n&quot;</span><span class="p">;</span>
<span class="c1"># prints &quot;1248&quot; if $string was &quot;an apple a day&quot;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$sum</span> <span class="o">=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;%32C*&quot;</span><span class="p">,</span> <span class="nv">$string</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch01/sum</span>">download the following standalone program</a></font>
<span class="c1">#!/usr/bin/perl</span>
<span class="c1"># sum - compute 16-bit checksum of all input files</span>
<span class="nv">$checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$checksum</span> <span class="o">+=</span> <span class="nb">unpack</span><span class="p">(</span><span class="s">&quot;%16C*&quot;</span><span class="p">,</span> <span class="nv">$_</span><span class="p">)</span> <span class="p">}</span>
<span class="nv">$checksum</span> <span class="nv">%</span><span class="err">=</span> <span class="err">(</span><span class="nv">2</span> <span class="o">**</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">print</span> <span class="s">&quot;$checksum\n&quot;</span><span class="p">;</span>

<span class="c1">#-----------------------------</span>
<span class="c1">#% perl sum /etc/termcap</span>
<span class="c1">#1510</span>
<span class="c1">#-----------------------------</span>
<span class="c1">#% sum --sysv /etc/termcap</span>
<span class="c1">#1510 851 /etc/termcap</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch01/slowcat</span>">download the following standalone program</a></font>
<span class="c1">#!/usr/bin/perl</span>
<span class="c1"># slowcat - emulate a   s l o w   line printer</span>
<span class="c1"># usage: slowcat [-DELAY] [files ...]</span>
<span class="nv">$DELAY</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=~</span><span class="sr"> /^-([.\d]+)/</span><span class="p">)</span> <span class="p">?</span> <span class="p">(</span><span class="nb">shift</span><span class="p">,</span> <span class="nv">$1</span><span class="p">)</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="vg">$|</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">split</span><span class="p">(</span><span class="sr">//</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">print</span><span class="p">;</span>
        <span class="nb">select</span><span class="p">(</span><span class="nb">undef</span><span class="p">,</span><span class="nb">undef</span><span class="p">,</span><span class="nb">undef</span><span class="p">,</span> <span class="mf">0.005</span> <span class="o">*</span> <span class="nv">$DELAY</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.6</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$revbytes</span> <span class="o">=</span> <span class="nb">reverse</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$revwords</span> <span class="o">=</span> <span class="nb">join</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="nb">reverse</span> <span class="nb">split</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="nv">$string</span><span class="p">));</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$gnirts</span>   <span class="o">=</span> <span class="nb">reverse</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span>       <span class="c1"># reverse letters in $string</span>

<span class="nv">@sdrow</span>    <span class="o">=</span> <span class="nb">reverse</span><span class="p">(</span><span class="nv">@words</span><span class="p">);</span>        <span class="c1"># reverse elements in @words</span>

<span class="nv">$confused</span> <span class="o">=</span> <span class="nb">reverse</span><span class="p">(</span><span class="nv">@words</span><span class="p">);</span>        <span class="c1"># reverse letters in join(&quot;&quot;, @words)</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># reverse word order</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&#39;Yoda said, &quot;can you see this?&quot;&#39;</span><span class="p">;</span>
<span class="nv">@allwords</span>    <span class="o">=</span> <span class="nb">split</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="nv">$string</span><span class="p">);</span>
<span class="nv">$revwords</span>    <span class="o">=</span> <span class="nb">join</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="nb">reverse</span> <span class="nv">@allwords</span><span class="p">);</span>
<span class="k">print</span> <span class="nv">$revwords</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span>
<span class="n">this</span><span class="p">?</span><span class="s">&quot; see you &quot;</span><span class="n">can</span> <span class="n">said</span><span class="p">,</span> <span class="n">Yoda</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$revwords</span> <span class="o">=</span> <span class="nb">join</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="nb">reverse</span> <span class="nb">split</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="nv">$string</span><span class="p">));</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$revwords</span> <span class="o">=</span> <span class="nb">join</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nb">reverse</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/(\s+)/</span><span class="p">,</span> <span class="nv">$string</span><span class="p">));</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$word</span> <span class="o">=</span> <span class="s">&quot;reviver&quot;</span><span class="p">;</span>
<span class="nv">$is_palindrome</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$word</span> <span class="ow">eq</span> <span class="nb">reverse</span><span class="p">(</span><span class="nv">$word</span><span class="p">));</span>
<span class="c1">#-----------------------------</span>
<span class="c1">#% perl -nle &#39;print if $_ eq reverse &amp;&amp; length &gt; 5&#39; /usr/dict/words</span>
<span class="c1">#deedeed</span>
<span class="c1">#</span>
<span class="c1">#degged</span>
<span class="c1">#</span>
<span class="c1">#deified</span>
<span class="c1">#</span>
<span class="c1">#denned</span>
<span class="c1">#</span>
<span class="c1">#hallah</span>
<span class="c1">#</span>
<span class="c1">#kakkak</span>
<span class="c1">#</span>
<span class="c1">#murdrum</span>
<span class="c1">#</span>
<span class="c1">#redder</span>
<span class="c1">#</span>
<span class="c1">#repaper</span>
<span class="c1">#</span>
<span class="c1">#retter</span>
<span class="c1">#</span>
<span class="c1">#reviver</span>
<span class="c1">#</span>
<span class="c1">#rotator</span>
<span class="c1">#</span>
<span class="c1">#sooloos</span>
<span class="c1">#</span>
<span class="c1">#tebbet</span>
<span class="c1">#</span>
<span class="c1">#terret</span>
<span class="c1">#</span>
<span class="c1">#tut-tut</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.7</span>
<span class="c1">#-----------------------------</span>
<span class="k">while</span> <span class="p">(</span><span class="nv">$string</span> <span class="o">=~</span> <span class="sr">s/\t+/&#39; &#39; x (length($&amp;) * 8 - length($`) % 8)/e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># spin in empty loop until substitution finally fails</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span> <span class="nn">Text::</span><span class="n">Tabs</span><span class="p">;</span>
<span class="nv">@expanded_lines</span>  <span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="nv">@lines_with_tabs</span><span class="p">);</span>
<span class="nv">@tabulated_lines</span> <span class="o">=</span> <span class="n">unexpand</span><span class="p">(</span><span class="nv">@lines_without_tabs</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="k">while</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="k">while</span> <span class="sr">s/\t+/&#39; &#39; x (length($&amp;) * 8 - length($`) % 8)/e</span><span class="p">;</span>
    <span class="k">print</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span> <span class="nn">Text::</span><span class="n">Tabs</span><span class="p">;</span>
<span class="nv">$tabstop</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="k">print</span> <span class="n">expand</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span> <span class="nn">Text::</span><span class="n">Tabs</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="k">print</span> <span class="n">unexpand</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="p">}</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.8</span>
<span class="c1">#-----------------------------</span>
<span class="c1">#You owe $debt to me.</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$text</span> <span class="o">=~</span> <span class="sr">s/\$(\w+)/${$1}/g</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$text</span> <span class="o">=~</span> <span class="sr">s/(\$\w+)/$1/gee</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span> <span class="n">vars</span> <span class="sx">qw($rows $cols)</span><span class="p">;</span>
<span class="nb">no</span> <span class="n">strict</span> <span class="s">&#39;refs&#39;</span><span class="p">;</span>                   <span class="c1"># for ${$1}/g below</span>
<span class="k">my</span> <span class="nv">$text</span><span class="p">;</span>

<span class="p">(</span><span class="nv">$rows</span><span class="p">,</span> <span class="nv">$cols</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="sx">q(I am $rows high and $cols long)</span><span class="p">;</span>  <span class="c1"># like single quotes!</span>
<span class="nv">$text</span> <span class="o">=~</span> <span class="sr">s/\$(\w+)/${$1}/g</span><span class="p">;</span>
<span class="k">print</span> <span class="nv">$text</span><span class="p">;</span>
<span class="n">I</span> <span class="n">am</span> <span class="mi">24</span> <span class="n">high</span> <span class="ow">and</span> <span class="mi">80</span> <span class="n">long</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="s">&quot;I am 17 years old&quot;</span><span class="p">;</span>
<span class="nv">$text</span> <span class="o">=~</span> <span class="sr">s/(\d+)/2 * $1/eg</span><span class="p">;</span> 
<span class="c1">#-----------------------------</span>
<span class="mi">2</span> <span class="o">*</span> <span class="mi">17</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="s">&#39;I am $AGE years old&#39;</span><span class="p">;</span>      <span class="c1"># note single quotes</span>
<span class="nv">$text</span> <span class="o">=~</span> <span class="sr">s/(\$\w+)/$1/eg</span><span class="p">;</span>           <span class="c1"># WRONG</span>
<span class="c1">#-----------------------------</span>
<span class="s">&#39;$AGE&#39;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$text</span> <span class="o">=~</span> <span class="sr">s/(\$\w+)/$1/eeg</span><span class="p">;</span>          <span class="c1"># finds my() variables</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># expand variables in $text, but put an error message in</span>
<span class="c1"># if the variable isn&#39;t defined</span>
<span class="nv">$text</span> <span class="o">=~</span> <span class="sr">s{</span>
<span class="sr">     \$                         # find a literal dollar sign</span>
<span class="sr">    (\w+)                       # find a &quot;word&quot; and store it in $1</span>
<span class="sr">}{</span>
<span class="sr">    no strict &#39;refs&#39;;           # for $$1 below</span>
<span class="sr">    if (defined ${$1}</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">{</span><span class="nv">$1</span><span class="p">};</span>                  <span class="c1"># expand global variables only</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="s">&quot;[NO VARIABLE: \$$1]&quot;</span><span class="p">;</span>  <span class="c1"># error msg</span>
    <span class="p">}</span>
<span class="p">}</span><span class="n">egx</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.9</span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span> <span class="n">locale</span><span class="p">;</span>                     <span class="c1"># needed in 5.004 or above</span>

<span class="nv">$big</span> <span class="o">=</span> <span class="nb">uc</span><span class="p">(</span><span class="nv">$little</span><span class="p">);</span>             <span class="c1"># &quot;bo peep&quot; -&gt; &quot;BO PEEP&quot;</span>
<span class="nv">$little</span> <span class="o">=</span> <span class="nb">lc</span><span class="p">(</span><span class="nv">$big</span><span class="p">);</span>             <span class="c1"># &quot;JOHN&quot;    -&gt; &quot;john&quot;</span>
<span class="nv">$big</span> <span class="o">=</span> <span class="s">&quot;\U$little&quot;</span><span class="p">;</span>             <span class="c1"># &quot;bo peep&quot; -&gt; &quot;BO PEEP&quot;</span>
<span class="nv">$little</span> <span class="o">=</span> <span class="s">&quot;\L$big&quot;</span><span class="p">;</span>             <span class="c1"># &quot;JOHN&quot;    -&gt; &quot;john&quot;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$big</span> <span class="o">=</span> <span class="s">&quot;\u$little&quot;</span><span class="p">;</span>             <span class="c1"># &quot;bo&quot;      -&gt; &quot;Bo&quot;</span>
<span class="nv">$little</span> <span class="o">=</span> <span class="s">&quot;\l$big&quot;</span><span class="p">;</span>             <span class="c1"># &quot;BoPeep&quot;    -&gt; &quot;boPeep&quot; </span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span> <span class="n">locale</span><span class="p">;</span>                     <span class="c1"># needed in 5.004 or above</span>

<span class="nv">$beast</span>   <span class="o">=</span> <span class="s">&quot;dromedary&quot;</span><span class="p">;</span>
<span class="c1"># capitalize various parts of $beast</span>
<span class="nv">$capit</span>   <span class="o">=</span> <span class="nb">ucfirst</span><span class="p">(</span><span class="nv">$beast</span><span class="p">);</span>         <span class="c1"># Dromedary</span>
<span class="nv">$capit</span>   <span class="o">=</span> <span class="s">&quot;\u\L$beast&quot;</span><span class="p">;</span>            <span class="c1"># (same)</span>
<span class="nv">$capall</span>  <span class="o">=</span> <span class="nb">uc</span><span class="p">(</span><span class="nv">$beast</span><span class="p">);</span>              <span class="c1"># DROMEDARY</span>
<span class="nv">$capall</span>  <span class="o">=</span> <span class="s">&quot;\U$beast&quot;</span><span class="p">;</span>              <span class="c1"># (same)</span>
<span class="nv">$caprest</span> <span class="o">=</span> <span class="nb">lcfirst</span><span class="p">(</span><span class="nb">uc</span><span class="p">(</span><span class="nv">$beast</span><span class="p">));</span>     <span class="c1"># dROMEDARY</span>
<span class="nv">$caprest</span> <span class="o">=</span> <span class="s">&quot;\l\U$beast&quot;</span><span class="p">;</span>            <span class="c1"># (same)</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># capitalize each word&#39;s first character, downcase the rest</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="s">&quot;thIS is a loNG liNE&quot;</span><span class="p">;</span>
<span class="nv">$text</span> <span class="o">=~</span> <span class="sr">s/(\w+)/\u\L$1/g</span><span class="p">;</span>
<span class="k">print</span> <span class="nv">$text</span><span class="p">;</span>
<span class="n">This</span> <span class="n">Is</span> <span class="n">A</span> <span class="n">Long</span> <span class="n">Line</span>
<span class="c1">#-----------------------------</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">uc</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="ow">eq</span> <span class="nb">uc</span><span class="p">(</span><span class="nv">$b</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s">&quot;a and b are the same\n&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch01/randcap</span>">download the following standalone program</a></font>
<span class="c1">#!/usr/bin/perl -p</span>
<span class="c1"># randcap: filter to randomly capitalize 20% of the letters</span>
<span class="c1"># call to srand() is unnecessary in 5.004</span>
<span class="k">BEGIN</span> <span class="p">{</span> <span class="nb">srand</span><span class="p">(</span><span class="nb">time</span><span class="p">()</span> <span class="o">^</span> <span class="p">(</span><span class="vg">$$</span> <span class="o">+</span> <span class="p">(</span><span class="vg">$$</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)))</span> <span class="p">}</span>
<span class="k">sub </span><span class="nf">randcase</span> <span class="p">{</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="p">?</span> <span class="s">&quot;\u$_[0]&quot;</span> <span class="p">:</span> <span class="s">&quot;\l$_[0]&quot;</span> <span class="p">}</span>
<span class="sr">s/(\w)/randcase($1)/ge</span><span class="p">;</span>


<span class="c1">#% randcap &lt; genesis | head -9</span>
<span class="c1">#boOk 01 genesis</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#001:001 in the BEginning goD created the heaven and tHe earTh.</span>
<span class="c1">#</span>
<span class="c1">#    </span>
<span class="c1">#</span>
<span class="c1">#001:002 and the earth wAS without ForM, aND void; AnD darkneSS was</span>
<span class="c1">#</span>
<span class="c1">#	 upon The Face of the dEEp. and the spIrit of GOd movEd upOn</span>
<span class="c1">#</span>
<span class="c1">#	 tHe face of the Waters.</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#001:003 and god Said, let there be ligHt: and therE wAs LigHt.</span>
<span class="c1">#-----------------------------</span>
<span class="k">sub </span><span class="nf">randcase</span> <span class="p">{</span>
    <span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="p">?</span> <span class="p">(</span><span class="s">&quot;\040&quot;</span> <span class="o">^</span> <span class="nv">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">:</span> <span class="nv">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">&amp;=</span> <span class="s">&quot;\177&quot;</span> <span class="n">x</span> <span class="nb">length</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.10</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$answer</span> <span class="o">=</span> <span class="nv">$var1</span> <span class="o">.</span> <span class="n">func</span><span class="p">()</span> <span class="o">.</span> <span class="nv">$var2</span><span class="p">;</span>   <span class="c1"># scalar only</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$answer</span> <span class="o">=</span> <span class="s">&quot;STRING @{[ LIST EXPR ]} MORE STRING&quot;</span><span class="p">;</span>
<span class="nv">$answer</span> <span class="o">=</span> <span class="s">&quot;STRING ${\( SCALAR EXPR )} MORE STRING&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$phrase</span> <span class="o">=</span> <span class="s">&quot;I have &quot;</span> <span class="o">.</span> <span class="p">(</span><span class="nv">$n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">.</span> <span class="s">&quot; guanacos.&quot;</span><span class="p">;</span>
<span class="nv">$phrase</span> <span class="o">=</span> <span class="s">&quot;I have ${\($n + 1)} guanacos.&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="k">print</span> <span class="s">&quot;I have &quot;</span><span class="p">,</span>  <span class="nv">$n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot; guanacos.\n&quot;</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="n">some_func</span><span class="p">(</span><span class="s">&quot;What you want is @{[ split /:/, $rec ]} items&quot;</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="nb">die</span> <span class="s">&quot;Couldn&#39;t send mail&quot;</span> <span class="k">unless</span> <span class="n">send_mail</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">&quot;EOTEXT&quot;</span><span class="p">,</span> <span class="nv">$target</span><span class="p">);</span>
<span class="n">To:</span> <span class="nv">$naughty</span>
<span class="n">From:</span> <span class="n">Your</span> <span class="n">Bank</span>
<span class="n">Cc:</span> <span class="nv">@</span><span class="p">{</span> <span class="n">get_manager_list</span><span class="p">(</span><span class="nv">$naughty</span><span class="p">)</span> <span class="p">}</span>
<span class="n">Date:</span> <span class="nv">@</span><span class="p">{[</span> <span class="k">do</span> <span class="p">{</span> <span class="k">my</span> <span class="nv">$now</span> <span class="o">=</span> <span class="sb">`date`</span><span class="p">;</span> <span class="nb">chomp</span> <span class="nv">$now</span><span class="p">;</span> <span class="nv">$now</span> <span class="p">}</span> <span class="p">]}</span> <span class="p">(</span><span class="n">today</span><span class="p">)</span>

<span class="n">Dear</span> <span class="nv">$naughty</span><span class="p">,</span>

<span class="n">Today</span><span class="p">,</span> <span class="n">you</span> <span class="n">bounced</span> <span class="n">check</span> <span class="n">number</span> <span class="nv">@</span><span class="p">{[</span> <span class="mi">500</span> <span class="o">+</span> <span class="nb">int</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">]}</span> <span class="n">to</span> <span class="n">us</span><span class="o">.</span>
<span class="n">Your</span> <span class="n">account</span> <span class="n">is</span> <span class="n">now</span> <span class="n">closed</span><span class="o">.</span>

<span class="n">Sincerely</span><span class="p">,</span>
<span class="n">the</span> <span class="n">management</span>
<span class="n">EOTEXT</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.11</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># all in one</span>
<span class="p">(</span><span class="nv">$var</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="n">HERE_TARGET</span><span class="p">)</span> <span class="o">=~</span> <span class="sr">s/^\s+//gm</span><span class="p">;</span>
    <span class="n">your</span> <span class="n">text</span>
    <span class="n">goes</span> <span class="n">here</span>
<span class="n">HERE_TARGET</span>

<span class="c1"># or with two steps</span>
<span class="nv">$var</span> <span class="o">=</span> <span class="s">&lt;&lt;HERE_TARGET;</span>
<span class="s">    your text</span>
<span class="s">    goes here</span>
<span class="s">HERE_TARGET</span>
<span class="nv">$var</span> <span class="o">=~</span> <span class="sr">s/^\s+//gm</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="p">(</span><span class="nv">$definition</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="s">&#39;FINIS&#39;</span><span class="p">)</span> <span class="o">=~</span> <span class="sr">s/^\s+//gm</span><span class="p">;</span>
    <span class="n">The</span> <span class="n">five</span> <span class="n">varieties</span> <span class="n">of</span> <span class="n">camelids</span>
    <span class="n">are</span> <span class="n">the</span> <span class="n">familiar</span> <span class="n">camel</span><span class="p">,</span> <span class="n">his</span> <span class="n">friends</span>
    <span class="n">the</span> <span class="n">llama</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">alpaca</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span>
    <span class="n">rather</span> <span class="n">less</span> <span class="n">well</span><span class="o">-</span><span class="n">known</span> <span class="n">guanaco</span>
    <span class="ow">and</span> <span class="n">vicu</span><span class="err"></span><span class="n">a</span><span class="o">.</span>
<span class="n">FINIS</span>
<span class="c1">#-----------------------------</span>
<span class="k">sub </span><span class="nf">fix</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$string</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="nv">$string</span> <span class="o">=~</span> <span class="sr">s/^\s+//gm</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$string</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">print</span> <span class="n">fix</span><span class="p">(</span><span class="o">&lt;&lt;</span><span class="s">&quot;END&quot;</span><span class="p">);</span>
    <span class="n">My</span> <span class="n">stuff</span> <span class="n">goes</span> <span class="n">here</span>
<span class="k">END</span>

<span class="c1"># With function predeclaration, you can omit the parens:</span>
<span class="k">print</span> <span class="n">fix</span> <span class="s">&lt;&lt;&quot;END&quot;;</span>
<span class="s">    My stuff goes here</span>
<span class="s">END</span>
<span class="c1">#-----------------------------</span>
<span class="p">(</span><span class="nv">$quote</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="s">&#39;    FINIS&#39;</span><span class="p">)</span> <span class="o">=~</span> <span class="sr">s/^\s+//gm</span><span class="p">;</span>
        <span class="o">...</span><span class="n">we</span> <span class="n">will</span> <span class="n">have</span> <span class="n">peace</span><span class="p">,</span> <span class="n">when</span> <span class="n">you</span> <span class="ow">and</span> <span class="n">all</span> <span class="n">your</span> <span class="n">works</span> <span class="n">have</span>
        <span class="n">perished</span><span class="o">--</span><span class="ow">and</span> <span class="n">the</span> <span class="n">works</span> <span class="n">of</span> <span class="n">your</span> <span class="n">dark</span> <span class="n">master</span> <span class="n">to</span> <span class="n">whom</span> <span class="n">you</span> <span class="n">would</span>
        <span class="n">deliver</span> <span class="n">us</span><span class="o">.</span> <span class="n">You</span> <span class="n">are</span> <span class="n">a</span> <span class="n">liar</span><span class="p">,</span> <span class="n">Saruman</span><span class="p">,</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">corrupter</span> <span class="n">of</span> <span class="n">mens</span>
        <span class="n">hearts</span><span class="o">.</span>  <span class="o">--</span><span class="n">Theoden</span> <span class="n">in</span> <span class="sr">/usr/s</span><span class="n">rc</span><span class="sr">/perl/</span><span class="n">taint</span><span class="o">.</span><span class="n">c</span>
    <span class="n">FINIS</span>
<span class="nv">$quote</span> <span class="o">=~</span> <span class="sr">s/\s+--/\n--/</span><span class="p">;</span>      <span class="c1">#move attribution to line of its own</span>
<span class="c1">#-----------------------------</span>
<span class="k">if</span> <span class="p">(</span><span class="nv">$REMEMBER_THE_MAIN</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$perl_main_C</span> <span class="o">=</span> <span class="n">dequote</span><span class="o">&lt;&lt;</span><span class="s">&#39;    MAIN_INTERPRETER_LOOP&#39;</span><span class="p">;</span>
        <span class="nv">@@@</span> <span class="nv">int</span>
        <span class="nv">@@@</span> <span class="nv">runops</span><span class="p">()</span> <span class="p">{</span>
        <span class="nv">@@@</span>     <span class="nv">SAVEI32</span><span class="p">(</span><span class="n">runlevel</span><span class="p">);</span>
        <span class="nv">@@@</span>     <span class="nv">runlevel</span><span class="o">++</span><span class="p">;</span>
        <span class="nv">@@@</span>     <span class="nv">while</span> <span class="p">(</span> <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op_ppaddr</span><span class="p">)()</span> <span class="p">)</span> <span class="p">;</span>
        <span class="nv">@@@</span>     <span class="nv">TAINT_NOT</span><span class="p">;</span>
        <span class="nv">@@@</span>     <span class="nv">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nv">@@@</span> <span class="err">}</span>
    <span class="nv">MAIN_INTERPRETER_LOOP</span>
    <span class="c1"># add more code here if you want</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="k">sub </span><span class="nf">dequote</span><span class="p">;</span>
<span class="p">$poem = dequote&lt;&lt;EVER_ON_AND_ON;</span>
<span class="p">       Now far ahead the Road has gone,</span>
<span class="p">          And I must follow, if I can,</span>
<span class="p">       Pursuing it with eager feet,</span>
<span class="p">          Until it joins some larger way</span>
<span class="p">       Where many paths and errands meet.</span>
<span class="p">          And whither then? I cannot say.</span>
<span class="p">                --Bilbo in /usr/src/perl/pp_ctl.c</span>
<span class="p">EVER_ON_AND_ON</span>
<span class="p">print &quot;Here&#39;s your poem:\n\n$poem\n&quot;;</span>
<span class="p">#-----------------------------</span>
<span class="p">#Here&#39;s your poem:  </span>
<span class="p">#</span>
<span class="p">#Now far ahead the Road has gone,</span>
<span class="p">#</span>
<span class="p">#   And I must follow, if I can,</span>
<span class="p">#</span>
<span class="p">#Pursuing it with eager feet,</span>
<span class="p">#</span>
<span class="p">#   Until it joins some larger way</span>
<span class="p">#</span>
<span class="p">#Where many paths and errands meet.</span>
<span class="p">#</span>
<span class="p">#   And whither then? I cannot say.</span>
<span class="p">#</span>
<span class="p">#	  --Bilbo in /usr/src/perl/pp_ctl.c</span>
<span class="p">#-----------------------------</span>
<span class="p">sub dequote {</span>
    <span class="nb">local</span> <span class="nv">$_</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$white</span><span class="p">,</span> <span class="nv">$leader</span><span class="p">);</span>  <span class="c1"># common whitespace and common leading string</span>
    <span class="k">if</span> <span class="p">(</span><span class="sr">/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="nv">$white</span><span class="p">,</span> <span class="nv">$leader</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$2</span><span class="p">,</span> <span class="nb">quotemeta</span><span class="p">(</span><span class="nv">$1</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">(</span><span class="nv">$white</span><span class="p">,</span> <span class="nv">$leader</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="sr">/^(\s+)/</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="sr">s/^\s*?$leader(?:$white)?//gm</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$_</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>
    <span class="k">if</span> <span class="p">(</span><span class="sr">m{</span>
<span class="sr">            ^                       # start of line</span>
<span class="sr">            \s *                    # 0 or more whitespace chars</span>
<span class="sr">            (?:                     # begin first non-remembered grouping</span>
<span class="sr">                 (                  #   begin save buffer $1</span>
<span class="sr">                    [^\w\s]         #     one byte neither space nor word</span>
<span class="sr">                    +               #     1 or more of such</span>
<span class="sr">                 )                  #   end save buffer $1</span>
<span class="sr">                 ( \s* )            #   put 0 or more white in buffer $2</span>
<span class="sr">                 .* \n              #   match through the end of first line</span>
<span class="sr">             )                      # end of first grouping</span>
<span class="sr">             (?:                    # begin second non-remembered grouping</span>
<span class="sr">                \s *                #   0 or more whitespace chars</span>
<span class="sr">                \1                  #   whatever string is destined for $1</span>
<span class="sr">                \2 ?                #   what&#39;ll be in $2, but optionally</span>
<span class="sr">                .* \n               #   match through the end of the line</span>
<span class="sr">             ) +                    # now repeat that group idea 1 or more</span>
<span class="sr">             $                      # until the end of the line</span>
<span class="sr">          }x</span>
       <span class="p">)</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="nv">$white</span><span class="p">,</span> <span class="nv">$leader</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$2</span><span class="p">,</span> <span class="nb">quotemeta</span><span class="p">(</span><span class="nv">$1</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">(</span><span class="nv">$white</span><span class="p">,</span> <span class="nv">$leader</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="sr">/^(\s+)/</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="sr">s{</span>
<span class="sr">         ^                          # start of each line (due to /m)</span>
<span class="sr">         \s *                       # any amount of leading whitespace</span>
<span class="sr">            ?                       #   but minimally matched</span>
<span class="sr">         $leader                    # our quoted, saved per-line leader</span>
<span class="sr">         (?:                        # begin unremembered grouping</span>
<span class="sr">            $white                  #    the same amount</span>
<span class="sr">         ) ?                        # optionalize in case EOL after leader</span>
<span class="sr">    }{}xgm</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.12</span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span> <span class="nn">Text::</span><span class="n">Wrap</span><span class="p">;</span>
<span class="nv">@OUTPUT</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="nv">$LEADTAB</span><span class="p">,</span> <span class="nv">$NEXTTAB</span><span class="p">,</span> <span class="nv">@PARA</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch01/wrapdemo</span>">download the following standalone program</a></font>
<span class="c1">#!/usr/bin/perl -w</span>
<span class="c1"># wrapdemo - show how Text::Wrap works</span>

<span class="nv">@input</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Folding and splicing is the work of an editor,&quot;</span><span class="p">,</span>
          <span class="s">&quot;not a mere collection of silicon&quot;</span><span class="p">,</span>
          <span class="s">&quot;and&quot;</span><span class="p">,</span>
          <span class="s">&quot;mobile electrons!&quot;</span><span class="p">);</span>

<span class="k">use</span> <span class="nn">Text::</span><span class="n">Wrap</span> <span class="sx">qw($columns &amp;wrap)</span><span class="p">;</span>

<span class="nv">$columns</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">print</span> <span class="s">&quot;0123456789&quot;</span> <span class="n">x</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span>
<span class="k">print</span> <span class="n">wrap</span><span class="p">(</span><span class="s">&quot;    &quot;</span><span class="p">,</span> <span class="s">&quot;  &quot;</span><span class="p">,</span> <span class="nv">@input</span><span class="p">),</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span>

<span class="c1">#-----------------------------</span>
<span class="mo">01234567</span><span class="mi">890123456789</span>

    <span class="n">Folding</span> <span class="ow">and</span>

  <span class="n">splicing</span> <span class="n">is</span> <span class="n">the</span>

  <span class="n">work</span> <span class="n">of</span> <span class="n">an</span>

  <span class="n">editor</span><span class="p">,</span> <span class="ow">not</span> <span class="n">a</span>

  <span class="n">mere</span> <span class="n">collection</span>

  <span class="n">of</span> <span class="n">silicon</span> <span class="ow">and</span>

  <span class="n">mobile</span> <span class="n">electrons</span><span class="o">!</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># merge multiple lines into one, then wrap one long line</span>
<span class="k">use</span> <span class="nn">Text::</span><span class="n">Wrap</span><span class="p">;</span>
<span class="nb">undef</span> <span class="vg">$/</span><span class="p">;</span>
<span class="k">print</span> <span class="n">wrap</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/\s*\n\s*/</span><span class="p">,</span> <span class="o">&lt;&gt;</span><span class="p">));</span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span> <span class="nn">Text::</span><span class="n">Wrap</span>      <span class="sx">qw(&amp;wrap $columns)</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Term::</span><span class="n">ReadKey</span>   <span class="sx">qw(GetTerminalSize)</span><span class="p">;</span>
<span class="p">(</span><span class="nv">$columns</span><span class="p">)</span> <span class="o">=</span> <span class="n">GetTerminalSize</span><span class="p">();</span>
<span class="p">(</span><span class="vg">$/</span><span class="p">,</span> <span class="vg">$\</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&quot;\n\n&quot;</span><span class="p">);</span>   <span class="c1"># read by paragraph, output 2 newlines</span>
<span class="k">while</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="p">{</span>                <span class="c1"># grab a full paragraph</span>
    <span class="sr">s/\s*\n\s*/ /g</span><span class="p">;</span>         <span class="c1"># convert intervening newlines to spaces</span>
    <span class="k">print</span> <span class="n">wrap</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="nv">$_</span><span class="p">);</span> <span class="c1"># and format</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.13</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># backslash</span>
<span class="nv">$var</span> <span class="o">=~</span> <span class="sr">s/([CHARLIST])/\\$1/g</span><span class="p">;</span>

<span class="c1"># double</span>
<span class="nv">$var</span> <span class="o">=~</span> <span class="sr">s/([CHARLIST])/$1$1/g</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=~</span> <span class="sr">s/%/%%/g</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="sx">q(Mom said, &quot;Don&#39;t do that.&quot;)</span><span class="p">;</span> <span class="c1">#&#39;</span>
<span class="nv">$string</span> <span class="o">=~</span> <span class="sr">s/([&#39;&quot;])/\\$1/g</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="sx">q(Mom said, &quot;Don&#39;t do that.&quot;)</span><span class="p">;</span>
<span class="nv">$string</span> <span class="o">=~</span> <span class="sr">s/([&#39;&quot;])/$1$1/g</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=~</span> <span class="sr">s/([^A-Z])/\\$1/g</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&quot;this \Qis a test!\E&quot;</span><span class="p">;</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&quot;this is\\ a\\ test\\!&quot;</span><span class="p">;</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="s">&quot;this &quot;</span> <span class="o">.</span> <span class="nb">quotemeta</span><span class="p">(</span><span class="s">&quot;is a test!&quot;</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.14</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=~</span> <span class="sr">s/^\s+//</span><span class="p">;</span>
<span class="nv">$string</span> <span class="o">=~</span> <span class="sr">s/\s+$//</span><span class="p">;</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$string</span> <span class="o">=</span> <span class="n">trim</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span>
<span class="nv">@many</span>   <span class="o">=</span> <span class="n">trim</span><span class="p">(</span><span class="nv">@many</span><span class="p">);</span>

<span class="k">sub </span><span class="nf">trim</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">@out</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="nv">@out</span><span class="p">)</span> <span class="p">{</span>
        <span class="sr">s/^\s+//</span><span class="p">;</span>
        <span class="sr">s/\s+$//</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">wantarray</span> <span class="p">?</span> <span class="nv">@out</span> <span class="p">:</span> <span class="nv">$out</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># print what&#39;s typed, but surrounded by &gt;&lt; symbols</span>
<span class="k">while</span><span class="p">(</span><span class="sr">&lt;STDIN&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">chomp</span><span class="p">;</span>
    <span class="k">print</span> <span class="s">&quot;&gt;$_&lt;\n&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.15</span>
<span class="c1">#-----------------------------</span>
<span class="k">sub </span><span class="nf">parse_csv</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$text</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>      <span class="c1"># record containing comma-separated values</span>
    <span class="k">my</span> <span class="nv">@new</span>  <span class="o">=</span> <span class="p">();</span>
    <span class="nb">push</span><span class="p">(</span><span class="nv">@new</span><span class="p">,</span> <span class="vg">$+</span><span class="p">)</span> <span class="k">while</span> <span class="nv">$text</span> <span class="o">=~</span> <span class="sr">m{</span>
<span class="sr">        # the first part groups the phrase inside the quotes.</span>
<span class="sr">        # see explanation of this pattern in MRE</span>
<span class="sr">        &quot;([^\&quot;\\]*(?:\\.[^\&quot;\\]*)*)&quot;,?</span>
<span class="sr">           |  ([^,]+),?</span>
<span class="sr">           | ,</span>
<span class="sr">       }gx</span><span class="p">;</span>
       <span class="nb">push</span><span class="p">(</span><span class="nv">@new</span><span class="p">,</span> <span class="nb">undef</span><span class="p">)</span> <span class="k">if</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="ow">eq</span> <span class="s">&#39;,&#39;</span><span class="p">;</span>
       <span class="k">return</span> <span class="nv">@new</span><span class="p">;</span>      <span class="c1"># list of values that were comma-separated</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span>
<span class="nn">Text::</span><span class="n">ParseWords</span><span class="p">;</span>

<span class="k">sub </span><span class="nf">parse_csv</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">quoteword</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>
<span class="nv">$line</span> <span class="o">=</span> <span class="sx">q&lt;XYZZY,&quot;&quot;,&quot;O&#39;Reilly, Inc&quot;,&quot;Wall, Larry&quot;,&quot;a \&quot;glug\&quot; bit,&quot;,5,</span>
<span class="sx">    &quot;Error, Core Dumped&quot;&gt;</span><span class="p">;</span>
<span class="nv">@fields</span> <span class="o">=</span> <span class="n">parse_csv</span><span class="p">(</span><span class="nv">$line</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nv">@fields</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s">&quot;$i : $fields[$i]\n&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#0 : XYZZY</span>
<span class="c1">#</span>
<span class="c1">#1 :</span>
<span class="c1">#</span>
<span class="c1">#2 : O&#39;Reilly, Inc</span>
<span class="c1">#</span>
<span class="c1">#3 : Wall, Larry</span>
<span class="c1">#</span>
<span class="c1">#4 : a \&quot;glug\&quot; bit,</span>
<span class="c1">#</span>
<span class="c1">#5 : 5</span>
<span class="c1">#</span>
<span class="c1">#6 : Error, Core Dumped</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.16</span>
<span class="c1">#-----------------------------</span>
 <span class="k">use</span> <span class="nn">Text::</span><span class="n">Soundex</span><span class="p">;</span>

 <span class="nv">$CODE</span>  <span class="o">=</span> <span class="n">soundex</span><span class="p">(</span><span class="nv">$STRING</span><span class="p">);</span>
 <span class="nv">@CODES</span> <span class="o">=</span> <span class="n">soundex</span><span class="p">(</span><span class="nv">@LIST</span><span class="p">);</span>
<span class="c1">#-----------------------------</span>
<span class="k">use</span> <span class="nn">Text::</span><span class="n">Soundex</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">User::</span><span class="n">pwent</span><span class="p">;</span>

<span class="k">print</span> <span class="s">&quot;Lookup user: &quot;</span><span class="p">;</span>
<span class="nb">chomp</span><span class="p">(</span><span class="nv">$user</span> <span class="o">=</span> <span class="sr">&lt;STDIN&gt;</span><span class="p">);</span>
<span class="nb">exit</span> <span class="k">unless</span> <span class="nb">defined</span> <span class="nv">$user</span><span class="p">;</span>
<span class="nv">$name_code</span> <span class="o">=</span> <span class="n">soundex</span><span class="p">(</span><span class="nv">$user</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="nv">$uent</span> <span class="o">=</span> <span class="nb">getpwent</span><span class="p">())</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$firstname</span><span class="p">,</span> <span class="nv">$lastname</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$uent</span><span class="o">-&gt;</span><span class="n">gecos</span> <span class="o">=~</span><span class="sr"> /(\w+)[^,]*\b(\w+)/</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$name_code</span> <span class="ow">eq</span> <span class="n">soundex</span><span class="p">(</span><span class="nv">$uent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">||</span>
        <span class="nv">$name_code</span> <span class="ow">eq</span> <span class="n">soundex</span><span class="p">(</span><span class="nv">$lastname</span><span class="p">)</span>   <span class="o">||</span>
        <span class="nv">$name_code</span> <span class="ow">eq</span> <span class="n">soundex</span><span class="p">(</span><span class="nv">$firstname</span><span class="p">)</span>  <span class="p">)</span>
    <span class="p">{</span>
        <span class="nb">printf</span> <span class="s">&quot;%s: %s %s\n&quot;</span><span class="p">,</span> <span class="nv">$uent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="nv">$firstname</span><span class="p">,</span> <span class="nv">$lastname</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">#-----------------------------</span>

<span class="c1"># ^^PLEAC^^_1.17</span>
<span class="c1">#-----------------------------</span>
<span class="c1"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch01/fixstyle</span>">download the following standalone program</a></font>
<span class="c1">#!/usr/bin/perl -w</span>
<span class="c1"># fixstyle - switch first set of &lt;DATA&gt; strings to second set</span>
<span class="c1">#   usage: $0 [-v] [files ...]</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$verbose</span> <span class="o">=</span> <span class="p">(</span><span class="nv">@ARGV</span> <span class="o">&amp;&amp;</span> <span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">eq</span> <span class="s">&#39;-v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nb">shift</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="p">{</span>
    <span class="vg">$^I</span> <span class="o">=</span> <span class="s">&quot;.orig&quot;</span><span class="p">;</span>          <span class="c1"># preserve old files</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">warn</span> <span class="s">&quot;$0: Reading from stdin\n&quot;</span> <span class="k">if</span> <span class="o">-</span><span class="n">t</span> <span class="bp">STDIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$code</span> <span class="o">=</span> <span class="s">&quot;while (&lt;&gt;) {\n&quot;</span><span class="p">;</span>
<span class="c1"># read in config, build up code to eval</span>
<span class="k">while</span> <span class="p">(</span><span class="sr">&lt;DATA&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">chomp</span><span class="p">;</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$in</span><span class="p">,</span> <span class="nv">$out</span><span class="p">)</span> <span class="o">=</span> <span class="nb">split</span> <span class="sr">/\s*=&gt;\s*/</span><span class="p">;</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="nv">$in</span> <span class="o">&amp;&amp;</span> <span class="nv">$out</span><span class="p">;</span>
    <span class="nv">$code</span> <span class="o">.=</span> <span class="s">&quot;s{\\Q$in\\E}{$out}g&quot;</span><span class="p">;</span>
    <span class="nv">$code</span> <span class="o">.=</span> <span class="s">&quot;&amp;&amp; printf STDERR qq($in =&gt; $out at \$ARGV line \$.\\n)&quot;</span> 
                                                        <span class="k">if</span> <span class="nv">$verbose</span><span class="p">;</span>
    <span class="nv">$code</span> <span class="o">.=</span> <span class="s">&quot;;\n&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="nv">$code</span> <span class="o">.=</span> <span class="s">&quot;print;\n}\n&quot;</span><span class="p">;</span>

<span class="nb">eval</span> <span class="s">&quot;{ $code } 1&quot;</span> <span class="o">||</span> <span class="nb">die</span><span class="p">;</span>

<span class="cp">__END__</span>
<span class="cp">analysed        =&gt; analyzed</span>
<span class="cp">built-in        =&gt; builtin</span>
<span class="cp">chastized       =&gt; chastised</span>
<span class="cp">commandline     =&gt; command-line</span>
<span class="cp">de-allocate     =&gt; deallocate</span>
<span class="cp">dropin          =&gt; drop-in</span>
<span class="cp">hardcode        =&gt; hard-code</span>
<span class="cp">meta-data       =&gt; metadata</span>
<span class="cp">multicharacter  =&gt; multi-character</span>
<span class="cp">multiway        =&gt; multi-way</span>
<span class="cp">non-empty       =&gt; nonempty</span>
<span class="cp">non-profit      =&gt; nonprofit</span>
<span class="cp">non-trappable   =&gt; nontrappable</span>
<span class="cp">pre-define      =&gt; predefine</span>
<span class="cp">preextend       =&gt; pre-extend</span>
<span class="cp">re-compiling    =&gt; recompiling</span>
<span class="cp">reenter         =&gt; re-enter</span>
<span class="cp">turnkey         =&gt; turn-key</span>

<span class="cp">#analysed        =&gt; analyzed</span>
<span class="cp">#built-in        =&gt; builtin</span>
<span class="cp">#chastized       =&gt; chastised</span>
<span class="cp">#commandline     =&gt; command-line</span>
<span class="cp">#de-allocate     =&gt; deallocate</span>
<span class="cp">#dropin          =&gt; drop-in</span>
<span class="cp">#hardcode        =&gt; hard-code</span>
<span class="cp">#meta-data       =&gt; metadata</span>
<span class="cp">#multicharacter  =&gt; multi-character</span>
<span class="cp">#multiway        =&gt; multi-way</span>
<span class="cp">#non-empty       =&gt; nonempty</span>
<span class="cp">#non-profit      =&gt; nonprofit</span>
<span class="cp">#non-trappable   =&gt; nontrappable</span>
<span class="cp">#pre-define      =&gt; predefine</span>
<span class="cp">#preextend       =&gt; pre-extend</span>
<span class="cp">#re-compiling    =&gt; recompiling</span>
<span class="cp">#reenter         =&gt; re-enter</span>
<span class="cp">#turnkey         =&gt; turn-key</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch01/fixstyle2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># fixstyle2 - like fixstyle but faster for many many matches</span>
<span class="cp">use strict;</span>
<span class="cp">my $verbose = (@ARGV &amp;&amp; $ARGV[0] eq &#39;-v&#39; &amp;&amp; shift);</span>
<span class="cp">my %change = ();</span>
<span class="cp">while (&lt;DATA&gt;) { </span>
<span class="cp">    chomp;</span>
<span class="cp">    my ($in, $out) = split /\s*=&gt;\s*/;</span>
<span class="cp">    next unless $in &amp;&amp; $out;</span>
<span class="cp">    $change{$in} = $out;</span>
<span class="cp">}</span>

<span class="cp">if (@ARGV) { </span>
<span class="cp">    $^I = &quot;.orig&quot;;</span>
<span class="cp">} else { </span>
<span class="cp">    warn &quot;$0: Reading from stdin\n&quot; if -t STDIN;</span>
<span class="cp">}</span>

<span class="cp">while (&lt;&gt;) { </span>
<span class="cp">    my $i = 0;</span>
<span class="cp">    s/^(\s+)// &amp;&amp; print $1;         # emit leading whitespace</span>
<span class="cp">    for (split /(\s+)/, $_, -1) {   # preserve trailing whitespace</span>
<span class="cp">        print( ($i++ &amp; 1) ? $_ : ($change{$_} || $_));</span>
<span class="cp">    } </span>
<span class="cp">}</span>

<span class="cp">__END__</span>
<span class="cp">analysed        =&gt; analyzed</span>
<span class="cp">built-in        =&gt; builtin</span>
<span class="cp">chastized       =&gt; chastised</span>
<span class="cp">commandline     =&gt; command-line</span>
<span class="cp">de-allocate     =&gt; deallocate</span>
<span class="cp">dropin          =&gt; drop-in</span>
<span class="cp">hardcode        =&gt; hard-code</span>
<span class="cp">meta-data       =&gt; metadata</span>
<span class="cp">multicharacter  =&gt; multi-character</span>
<span class="cp">multiway        =&gt; multi-way</span>
<span class="cp">non-empty       =&gt; nonempty</span>
<span class="cp">non-profit      =&gt; nonprofit</span>
<span class="cp">non-trappable   =&gt; nontrappable</span>
<span class="cp">pre-define      =&gt; predefine</span>
<span class="cp">preextend       =&gt; pre-extend</span>
<span class="cp">re-compiling    =&gt; recompiling</span>
<span class="cp">reenter         =&gt; re-enter</span>
<span class="cp">turnkey         =&gt; turn-key</span>

<span class="cp">#analysed        =&gt; analyzed</span>
<span class="cp">#built-in        =&gt; builtin</span>
<span class="cp">#chastized       =&gt; chastised</span>
<span class="cp">#commandline     =&gt; command-line</span>
<span class="cp">#de-allocate     =&gt; deallocate</span>
<span class="cp">#dropin          =&gt; drop-in</span>
<span class="cp">#hardcode        =&gt; hard-code</span>
<span class="cp">#meta-data       =&gt; metadata</span>
<span class="cp">#multicharacter  =&gt; multi-character</span>
<span class="cp">#multiway        =&gt; multi-way</span>
<span class="cp">#non-empty       =&gt; nonempty</span>
<span class="cp">#non-profit      =&gt; nonprofit</span>
<span class="cp">#non-trappable   =&gt; nontrappable</span>
<span class="cp">#pre-define      =&gt; predefine</span>
<span class="cp">#preextend       =&gt; pre-extend</span>
<span class="cp">#re-compiling    =&gt; recompiling</span>
<span class="cp">#reenter         =&gt; re-enter</span>
<span class="cp">#turnkey         =&gt; turn-key</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># very fast, but whitespace collapse</span>
<span class="cp">while (&lt;&gt;) { </span>
<span class="cp">    for (split) { </span>
<span class="cp">        print $change{$_} || $_, &quot; &quot;;</span>
<span class="cp">    }</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $pid = open(STDOUT, &quot;|-&quot;);</span>
<span class="cp">die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">unless ($pid) {             # child</span>
<span class="cp">        while (&lt;STDIN&gt;) {</span>
<span class="cp">        s/ $//;</span>
<span class="cp">        print;</span>
<span class="cp">    }</span>
<span class="cp">    exit;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_1.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;/sh\b/&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;command =~ /sh$/&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;uid &lt; 10&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;command =~ /^-/&#39; &#39;tty ne &quot;?&quot;&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;tty =~ /^[p-t]/&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;uid &amp;&amp; tty eq &quot;?&quot;&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;size &gt; 10 * 2**10&#39; &#39;uid != 0&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN     STA TTY TIME COMMAND</span>
<span class="cp">#</span>
<span class="cp">#     0   101  9751     1   0   0  14932  9652 do_select S   p1  0:25 netscape</span>
<span class="cp">#</span>
<span class="cp">#100000   101  9752  9751   0   0  10636   812 do_select S   p1  0:00 (dns helper)</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch01/psgrep</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># psgrep - print selected lines of ps output by</span>
<span class="cp">#          compiling user queries into code</span>

<span class="cp">use strict;</span>

<span class="cp"># each field from the PS header</span>
<span class="cp">my @fieldnames = qw(FLAGS UID PID PPID PRI NICE SIZE</span>
<span class="cp">                    RSS WCHAN STAT TTY TIME COMMAND);</span>

<span class="cp"># determine the unpack format needed (hard-coded for Linux ps)</span>
<span class="cp">my $fmt = cut2fmt(8, 14, 20, 26, 30, 34, 41, 47, 59, 63, 67, 72);</span>

<span class="cp">my %fields;                         # where the data will store</span>

<span class="cp">die &lt;&lt;Thanatos unless @ARGV;</span>
<span class="cp">usage: $0 criterion ...</span>
<span class="cp">    Each criterion is a Perl expression involving:</span>
<span class="cp">     @fieldnames</span>
<span class="cp">    All criteria must be met for a line to be printed.</span>
<span class="cp">Thanatos</span>

<span class="cp"># Create function aliases for uid, size, UID, SIZE, etc.</span>
<span class="cp"># Empty parens on closure args needed for void prototyping.</span>
<span class="cp">for my $name (@fieldnames) {</span>
<span class="cp">    no strict &#39;refs&#39;;</span>
<span class="cp">    *$name = *{lc $name} = sub () { $fields{$name} };</span>
<span class="cp">}</span>

<span class="cp">my $code = &quot;sub is_desirable { &quot; . join(&quot; and &quot;, @ARGV) . &quot; } &quot;;</span>
<span class="cp">unless (eval $code.1) {</span>
<span class="cp">    die &quot;Error in code: $@\n\t$code\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">open(PS, &quot;ps wwaxl |&quot;)              || die &quot;cannot fork: $!&quot;;</span>
<span class="cp">print scalar &lt;PS&gt;;                  # emit header line</span>
<span class="cp">while (&lt;PS&gt;) {</span>
<span class="cp">    @fields{@fieldnames} = trim(unpack($fmt, $_));</span>
<span class="cp">    print if is_desirable();        # line matches their criteria</span>
<span class="cp">}</span>
<span class="cp">close(PS)                           || die &quot;ps failed!&quot;;</span>

<span class="cp"># convert cut positions to unpack format</span>
<span class="cp">sub cut2fmt {</span>
<span class="cp">    my(@positions) = @_;</span>
<span class="cp">    my $template  = &#39;&#39;;</span>
<span class="cp">    my $lastpos   = 1;</span>
<span class="cp">    for my $place (@positions) {</span>
<span class="cp">        $template .= &quot;A&quot; . ($place - $lastpos) . &quot; &quot;;</span>
<span class="cp">        $lastpos   = $place;</span>
<span class="cp">    }</span>
<span class="cp">    $template .= &quot;A*&quot;;</span>
<span class="cp">    return $template;</span>
<span class="cp">}</span>

<span class="cp">sub trim {</span>
<span class="cp">    my @strings = @_;</span>
<span class="cp">    for (@strings) {</span>
<span class="cp">        s/^\s+//;</span>
<span class="cp">        s/\s+$//;</span>
<span class="cp">    }</span>
<span class="cp">    return wantarray ? @strings : $strings[0];</span>
<span class="cp">}</span>

<span class="cp"># the following was used to determine column cut points.</span>
<span class="cp"># sample input data follows</span>
<span class="cp">#123456789012345678901234567890123456789012345678901234567890123456789012345</span>
<span class="cp">#         1         2         3         4         5         6         7</span>
<span class="cp"># Positioning:</span>
<span class="cp">#       8     14    20    26  30  34     41    47          59  63  67   72</span>
<span class="cp">#       |     |     |     |   |   |      |     |           |   |   |    |</span>
<span class="cp">__END__</span>
<span class="cp"> FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN       STA TTY TIME COMMAND</span>
<span class="cp">   100     0     1     0   0   0    760   432 do_select   S   ?   0:02 init</span>
<span class="cp">   140     0   187     1   0   0    784   452 do_select   S   ?   0:02 syslogd</span>
<span class="cp">100100   101   428     1   0   0   1436   944 do_exit     S    1  0:00 /bin/login</span>
<span class="cp">100140    99 30217   402   0   0   1552  1008 posix_lock_ S   ?   0:00 httpd</span>
<span class="cp">     0   101   593   428   0   0   1780  1260 copy_thread S    1  0:00 -tcsh</span>
<span class="cp">100000   101 30639  9562  17   0    924   496             R   p1  0:00 ps axl</span>
<span class="cp">     0   101 25145  9563   0   0   2964  2360 idetape_rea S   p2  0:06 trn</span>
<span class="cp">100100     0 10116  9564   0   0   1412   928 setup_frame T   p3  0:00 ssh -C www</span>
<span class="cp">100100     0 26560 26554   0   0   1076   572 setup_frame T   p2  0:00 less</span>
<span class="cp">100000   101 19058  9562   0   0   1396   900 setup_frame T   p1  0:02 nvi /tmp/a</span>

<span class="cp"># the following was used to determine column cut points.</span>
<span class="cp"># sample input data follows</span>
<span class="cp"># 123456789012345678901234567890123456789012345678901234567890123456789012345</span>
<span class="cp">#          1         2         3         4         5         6         7</span>
<span class="cp">#  Positioning:</span>
<span class="cp">#        8     14    20    26  30  34     41    47          59  63  67   72</span>
<span class="cp">#        |     |     |     |   |   |      |     |           |   |   |    |</span>
<span class="cp"># __END__</span>
<span class="cp">#  FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN       STA TTY TIME COMMAND</span>
<span class="cp"># </span>
<span class="cp">#    100     0     1     0   0   0    760   432 do_select   S   ?   0:02 init</span>
<span class="cp"># </span>
<span class="cp">#    140     0   187     1   0   0    784   452 do_select   S   ?   0:02 syslogd</span>
<span class="cp"># </span>
<span class="cp"># 100100   101   428     1   0   0   1436   944 do_exit     S    1  0:00 /bin/login</span>
<span class="cp"># </span>
<span class="cp"># 100140    99 30217   402   0   0   1552  1008 posix_lock_ S   ?   0:00 httpd</span>
<span class="cp"># </span>
<span class="cp">#      0   101   593   428   0   0   1780  1260 copy_thread S    1  0:00 -tcsh</span>
<span class="cp"># </span>
<span class="cp"># 100000   101 30639  9562  17   0    924   496             R   p1  0:00 ps axl</span>
<span class="cp"># </span>
<span class="cp">#      0   101 25145  9563   0   0   2964  2360 idetape_rea S   p2  0:06 trn</span>
<span class="cp"># </span>
<span class="cp"># 100100     0 10116  9564   0   0   1412   928 setup_frame T   p3  0:00 ssh -C www</span>
<span class="cp"># </span>
<span class="cp"># 100100     0 26560 26554   0   0   1076   572 setup_frame T   p2  0:00 less</span>
<span class="cp"># </span>
<span class="cp"># 100000   101 19058  9562   0   0   1396   900 setup_frame T   p1  0:02 nvi /tmp/a</span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval &quot;sub is_desirable { uid &lt; 10 } &quot; . 1;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% psgrep &#39;no strict &quot;vars&quot;;</span>
<span class="cp">#          BEGIN { $id = getpwnam(&quot;nobody&quot;) }</span>
<span class="cp">#          uid == $id &#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub id()         { $_-&gt;{ID}   }</span>
<span class="cp">sub title()      { $_-&gt;{TITLE} }</span>
<span class="cp">sub executive()  { title =~ /(?:vice-)?president/i }</span>

<span class="cp"># user search criteria go in the grep clause</span>
<span class="cp">@slowburners = grep { id &lt; 10 &amp;&amp; !executive } @employees;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($string =~ /PATTERN/) {</span>
<span class="cp">    # is a number</span>
<span class="cp">} else {</span>
<span class="cp">    # is not</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">warn &quot;has nondigits&quot;        if     /\D/;</span>
<span class="cp">warn &quot;not a natural number&quot; unless /^\d+$/;             # rejects -3</span>
<span class="cp">warn &quot;not an integer&quot;       unless /^-?\d+$/;           # rejects +3</span>
<span class="cp">warn &quot;not an integer&quot;       unless /^[+-]?\d+$/;</span>
<span class="cp">warn &quot;not a decimal number&quot; unless /^-?\d+\.?\d*$/;     # rejects .2</span>
<span class="cp">warn &quot;not a decimal number&quot; unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;</span>
<span class="cp">warn &quot;not a C float&quot;</span>
<span class="cp">       unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub getnum {</span>
<span class="cp">    use POSIX qw(strtod);</span>
<span class="cp">    my $str = shift;</span>
<span class="cp">    $str =~ s/^\s+//;</span>
<span class="cp">    $str =~ s/\s+$//;</span>
<span class="cp">    $! = 0;</span>
<span class="cp">    my($num, $unparsed) = strtod($str);</span>
<span class="cp">    if (($str eq &#39;&#39;) || ($unparsed != 0) || $!) {</span>
<span class="cp">        return;</span>
<span class="cp">    } else {</span>
<span class="cp">        return $num;</span>
<span class="cp">    } </span>
<span class="cp">} </span>

<span class="cp">sub is_numeric { defined scalar &amp;getnum } </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># equal(NUM1, NUM2, ACCURACY) : returns true if NUM1 and NUM2 are</span>
<span class="cp"># equal to ACCURACY number of decimal places</span>

<span class="cp">sub equal {</span>
<span class="cp">    my ($A, $B, $dp) = @_;</span>

<span class="cp">    return sprintf(&quot;%.${dp}g&quot;, $A) eq sprintf(&quot;%.${dp}g&quot;, $B);</span>
<span class="cp">  }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$wage = 536;                # $5.36/hour</span>
<span class="cp">$week = 40 * $wage;         # $214.40</span>
<span class="cp">printf(&quot;One week&#39;s wage is: \$%.2f\n&quot;, $week/100);</span>
<span class="cp">#</span>
<span class="cp">#One week&#39;s wage is: $214.40</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$rounded = sprintf(&quot;%FORMATf&quot;, $unrounded);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$a = 0.255;</span>
<span class="cp">$b = sprintf(&quot;%.2f&quot;, $a);</span>
<span class="cp">print &quot;Unrounded: $a\nRounded: $b\n&quot;;</span>
<span class="cp">printf &quot;Unrounded: $a\nRounded: %.2f\n&quot;, $a;</span>

<span class="cp"># Unrounded: 0.255</span>
<span class="cp"># </span>
<span class="cp"># Rounded: 0.26</span>
<span class="cp"># </span>
<span class="cp"># Unrounded: 0.255</span>
<span class="cp"># </span>
<span class="cp"># Rounded: 0.26</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX;</span>
<span class="cp">print &quot;number\tint\tfloor\tceil\n&quot;;</span>
<span class="cp">@a = ( 3.3 , 3.5 , 3.7, -3.3 );</span>
<span class="cp">foreach (@a) {</span>
<span class="cp">    printf( &quot;%.1f\t%.1f\t%.1f\t%.1f\n&quot;, </span>
<span class="cp">        $_, int($_), floor($_), ceil($_) );</span>
<span class="cp">}</span>

<span class="cp"># number  int     floor   ceil</span>
<span class="cp"># </span>
<span class="cp">#  3.3     3.0     3.0     4.0</span>
<span class="cp"># </span>
<span class="cp">#  3.5     3.0     3.0     4.0</span>
<span class="cp"># </span>
<span class="cp">#  3.7     3.0     3.0     4.0</span>
<span class="cp"># </span>
<span class="cp"># -3.3    -3.0    -4.0    -3.0</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub dec2bin {</span>
<span class="cp">    my $str = unpack(&quot;B32&quot;, pack(&quot;N&quot;, shift));</span>
<span class="cp">    $str =~ s/^0+(?=\d)//;   # otherwise you&#39;ll get leading zeros</span>
<span class="cp">    return $str;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub bin2dec {</span>
<span class="cp">    return unpack(&quot;N&quot;, pack(&quot;B32&quot;, substr(&quot;0&quot; x 32 . shift, -32)));</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$num = bin2dec(&#39;0110110&#39;);  # $num is 54</span>
<span class="cp">$binstr = dec2bin(54);      # $binstr is 110110</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach ($X .. $Y) {</span>
<span class="cp">    # $_ is set to every integer from X to Y, inclusive</span>
<span class="cp">}</span>

<span class="cp">foreach $i ($X .. $Y) {</span>
<span class="cp">    # $i is set to every integer from X to Y, inclusive</span>
<span class="cp">    }</span>

<span class="cp">for ($i = $X; $i &lt;= $Y; $i++) {</span>
<span class="cp">    # $i is set to every integer from X to Y, inclusive</span>
<span class="cp">}</span>

<span class="cp">for ($i = $X; $i &lt;= $Y; $i += 7) {</span>
<span class="cp">    # $i is set to every integer from X to Y, stepsize = 7</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;Infancy is: &quot;;</span>
<span class="cp">foreach (0 .. 2) {</span>
<span class="cp">    print &quot;$_ &quot;;</span>
<span class="cp">}</span>
<span class="cp">print &quot;\n&quot;;</span>

<span class="cp">print &quot;Toddling is: &quot;;</span>
<span class="cp">foreach $i (3 .. 4) {</span>
<span class="cp">    print &quot;$i &quot;;</span>
<span class="cp">}</span>
<span class="cp">print &quot;\n&quot;;</span>

<span class="cp">print &quot;Childhood is: &quot;;</span>
<span class="cp">for ($i = 5; $i &lt;= 12; $i++) {</span>
<span class="cp">    print &quot;$i &quot;;</span>
<span class="cp">}</span>
<span class="cp">print &quot;\n&quot;;</span>

<span class="cp"># Infancy is: 0 1 2 </span>
<span class="cp"># </span>
<span class="cp"># Toddling is: 3 4 </span>
<span class="cp"># </span>
<span class="cp"># Childhood is: 5 6 7 8 9 10 11 12 </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Roman;</span>
<span class="cp">$roman = roman($arabic);                        # convert to roman numerals</span>
<span class="cp">$arabic = arabic($roman) if isroman($roman);    # convert from roman numerals</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Roman;</span>
<span class="cp">$roman_fifteen = roman(15);                         # &quot;xv&quot;</span>
<span class="cp">print &quot;Roman for fifteen is $roman_fifteen\n&quot;;</span>
<span class="cp">$arabic_fifteen = arabic($roman_fifteen);</span>
<span class="cp">print &quot;Converted back, $roman_fifteen is $arabic_fifteen\n&quot;;</span>

<span class="cp">Roman for fifteen is xv</span>

<span class="cp">Converted back, xv is 15</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$random = int( rand( $Y-$X+1 ) ) + $X;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$random = int( rand(51)) + 25;</span>
<span class="cp">print &quot;$random\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$elt = $array[ rand @array ];</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@chars = ( &quot;A&quot; .. &quot;Z&quot;, &quot;a&quot; .. &quot;z&quot;, 0 .. 9, qw(! @ $ % ^ &amp; *) );</span>
<span class="cp">$password = join(&quot;&quot;, @chars[ map { rand @chars } ( 1 .. 8 ) ]);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">srand EXPR;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">srand( &lt;STDIN&gt; );</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Math::TrulyRandom;</span>
<span class="cp">$random = truly_random_value();</span>

<span class="cp">use Math::Random;</span>
<span class="cp">$random = random_uniform();</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub gaussian_rand {</span>
<span class="cp">    my ($u1, $u2);  # uniformly distributed random numbers</span>
<span class="cp">    my $w;          # variance, then a weight</span>
<span class="cp">    my ($g1, $g2);  # gaussian-distributed numbers</span>

<span class="cp">    do {</span>
<span class="cp">        $u1 = 2 * rand() - 1;</span>
<span class="cp">        $u2 = 2 * rand() - 1;</span>
<span class="cp">        $w = $u1*$u1 + $u2*$u2;</span>
<span class="cp">    } while ( $w &gt;= 1 );</span>

<span class="cp">    $w = sqrt( (-2 * log($w))  / $w );</span>
<span class="cp">    $g2 = $u1 * $w;</span>
<span class="cp">    $g1 = $u2 * $w;</span>
<span class="cp">    # return both if wanted, else just one</span>
<span class="cp">    return wantarray ? ($g1, $g2) : $g1;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># weight_to_dist: takes a hash mapping key to weight and returns</span>
<span class="cp"># a hash mapping key to probability</span>
<span class="cp">sub weight_to_dist {</span>
<span class="cp">    my %weights = @_;</span>
<span class="cp">    my %dist    = ();</span>
<span class="cp">    my $total   = 0;</span>
<span class="cp">    my ($key, $weight);</span>
<span class="cp">    local $_;</span>

<span class="cp">    foreach (values %weights) {</span>
<span class="cp">        $total += $_;</span>
<span class="cp">    }</span>

<span class="cp">    while ( ($key, $weight) = each %weights ) {</span>
<span class="cp">        $dist{$key} = $weight/$total;</span>
<span class="cp">    }</span>

<span class="cp">    return %dist;</span>
<span class="cp">}</span>

<span class="cp"># weighted_rand: takes a hash mapping key to probability, and</span>
<span class="cp"># returns the corresponding element</span>
<span class="cp">sub weighted_rand {</span>
<span class="cp">    my %dist = @_;</span>
<span class="cp">    my ($key, $weight);</span>

<span class="cp">    while (1) {                     # to avoid floating point inaccuracies</span>
<span class="cp">        my $rand = rand;</span>
<span class="cp">        while ( ($key, $weight) = each %dist ) {</span>
<span class="cp">            return $key if ($rand -= $weight) &lt; 0;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># gaussian_rand as above</span>
<span class="cp">$mean = 25;</span>
<span class="cp">$sdev = 2;</span>
<span class="cp">$salary = gaussian_rand() * $sdev + $mean;</span>
<span class="cp">printf(&quot;You have been hired at \$%.2f\n&quot;, $salary);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">BEGIN {</span>
<span class="cp">    use constant PI =&gt; 3.14159265358979;</span>

<span class="cp">    sub deg2rad {</span>
<span class="cp">        my $degrees = shift;</span>
<span class="cp">        return ($degrees / 180) * PI;</span>
<span class="cp">    }</span>

<span class="cp">    sub rad2deg {</span>
<span class="cp">        my $radians = shift;</span>
<span class="cp">        return ($radians / PI) * 180;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Math::Trig;</span>

<span class="cp">$radians = deg2rad($degrees);</span>
<span class="cp">$degrees = rad2deg($radians);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># deg2rad and rad2deg defined either as above or from Math::Trig</span>
<span class="cp">sub degree_sine {</span>
<span class="cp">    my $degrees = shift;</span>
<span class="cp">    my $radians = deg2rad($degrees);</span>
<span class="cp">    my $result = sin($radians);</span>

<span class="cp">    return $result;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub tan {</span>
<span class="cp">    my $theta = shift;</span>

<span class="cp">    return sin($theta)/cos($theta);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX;</span>

<span class="cp">$y = acos(3.7);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Math::Trig;</span>

<span class="cp">$y = acos(3.7);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval {</span>
<span class="cp">    $y = tan($pi/2);</span>
<span class="cp">} or return undef;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$log_e = log(VALUE);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(log10);</span>
<span class="cp">$log_10 = log10(VALUE);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub log_base {</span>
<span class="cp">    my ($base, $value) = @_;</span>
<span class="cp">    return log($value)/log($base);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># log_base defined as above</span>
<span class="cp">$answer = log_base(10, 10_000);</span>
<span class="cp">print &quot;log10(10,000) = $answer\n&quot;;</span>
<span class="cp"># log10(10,000) = 4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Math::Complex;</span>
<span class="cp">printf &quot;log2(1024) = %lf\n&quot;, logn(1024, 2); # watch out for argument order!</span>
<span class="cp"># log2(1024) = 10.000000</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use PDL;</span>
<span class="cp"># $a and $b are both pdl objects</span>
<span class="cp">$c = $a * $b;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub mmult {</span>
<span class="cp">    my ($m1,$m2) = @_;</span>
<span class="cp">    my ($m1rows,$m1cols) = matdim($m1);</span>
<span class="cp">    my ($m2rows,$m2cols) = matdim($m2);</span>

<span class="cp">    unless ($m1cols == $m2rows) {  # raise exception</span>
<span class="cp">        die &quot;IndexError: matrices don&#39;t match: $m1cols != $m2rows&quot;;</span>
<span class="cp">    }</span>

<span class="cp">    my $result = [];</span>
<span class="cp">    my ($i, $j, $k);</span>

<span class="cp">    for $i (range($m1rows)) {</span>
<span class="cp">        for $j (range($m2cols)) {</span>
<span class="cp">            for $k (range($m1cols)) {</span>
<span class="cp">                $result-&gt;[$i][$j] += $m1-&gt;[$i][$k] * $m2-&gt;[$k][$j];</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">    return $result;</span>
<span class="cp">}</span>

<span class="cp">sub range { 0 .. ($_[0] - 1) }</span>

<span class="cp">sub veclen {</span>
<span class="cp">    my $ary_ref = $_[0];</span>
<span class="cp">    my $type = ref $ary_ref;</span>
<span class="cp">    if ($type ne &quot;ARRAY&quot;) { die &quot;$type is bad array ref for $ary_ref&quot; }</span>
<span class="cp">    return scalar(@$ary_ref);</span>
<span class="cp">}</span>

<span class="cp">sub matdim {</span>
<span class="cp">    my $matrix = $_[0];</span>
<span class="cp">    my $rows = veclen($matrix);</span>
<span class="cp">    my $cols = veclen($matrix-&gt;[0]);</span>
<span class="cp">    return ($rows, $cols);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use PDL;</span>

<span class="cp">$a = pdl [</span>
<span class="cp">    [ 3, 2, 3 ],</span>
<span class="cp">    [ 5, 9, 8 ],</span>
<span class="cp">];</span>

<span class="cp">$b = pdl [</span>
<span class="cp">    [ 4, 7 ],</span>
<span class="cp">    [ 9, 3 ],</span>
<span class="cp">    [ 8, 1 ],</span>
<span class="cp">];</span>

<span class="cp">$c = $a x $b;  # x overload</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># mmult() and other subroutines as above</span>

<span class="cp">$x = [</span>
<span class="cp">       [ 3, 2, 3 ],</span>
<span class="cp">       [ 5, 9, 8 ],</span>
<span class="cp">];</span>

<span class="cp">$y = [</span>
<span class="cp">       [ 4, 7 ],</span>
<span class="cp">       [ 9, 3 ],</span>
<span class="cp">       [ 8, 1 ],</span>
<span class="cp">];</span>

<span class="cp">$z = mmult($x, $y);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># $c = $a * $b manually</span>
<span class="cp">$c_real = ( $a_real * $b_real ) - ( $a_imaginary * $b_imaginary );</span>
<span class="cp">$c_imaginary = ( $a_real * $b_imaginary ) + ( $b_real * $a_imaginary );</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># $c = $a * $b using Math::Complex</span>
<span class="cp">use Math::Complex;</span>
<span class="cp">$c = $a * $b;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$a_real = 3; $a_imaginary = 5;              # 3 + 5i;</span>
<span class="cp">$b_real = 2; $b_imaginary = -2;             # 2 - 2i;</span>
<span class="cp">$c_real = ( $a_real * $b_real ) - ( $a_imaginary * $b_imaginary );</span>
<span class="cp">$c_imaginary = ( $a_real * $b_imaginary ) + ( $b_real * $a_imaginary );</span>
<span class="cp">print &quot;c = ${c_real}+${c_imaginary}i\n&quot;;</span>

<span class="cp">c = 16+4i</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Math::Complex;</span>
<span class="cp">$a = Math::Complex-&gt;new(3,5);               # or Math::Complex-&gt;new(3,5);</span>
<span class="cp">$b = Math::Complex-&gt;new(2,-2);</span>
<span class="cp">$c = $a * $b;</span>
<span class="cp">print &quot;c = $c\n&quot;;</span>

<span class="cp">c = 16+4i</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Math::Complex;</span>
<span class="cp">$c = cplx(3,5) * cplx(2,-2);                # easier on the eye</span>
<span class="cp">$d = 3 + 4*i;                               # 3 + 4i</span>
<span class="cp">printf &quot;sqrt($d) = %s\n&quot;, sqrt($d);</span>

<span class="cp"># sqrt(3+4i) = 2+i</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$number = hex($hexadecimal);         # hexadecimal</span>
<span class="cp">$number = oct($octal);               # octal</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;Gimme a number in decimal, octal, or hex: &quot;;</span>
<span class="cp">$num = &lt;STDIN&gt;;</span>
<span class="cp">chomp $num;</span>
<span class="cp">exit unless defined $num;</span>
<span class="cp">$num = oct($num) if $num =~ /^0/; # does both oct and hex</span>
<span class="cp">printf &quot;%d %x %o\n&quot;, $num, $num, $num;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;Enter file permission in octal: &quot;;</span>
<span class="cp">$permissions = &lt;STDIN&gt;;</span>
<span class="cp">die &quot;Exiting ...\n&quot; unless defined $permissions;</span>
<span class="cp">chomp $permissions;</span>
<span class="cp">$permissions = oct($permissions);   # permissions always octal</span>
<span class="cp">print &quot;The decimal value is $permissions\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub commify {</span>
<span class="cp">    my $text = reverse $_[0];</span>
<span class="cp">    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;</span>
<span class="cp">    return scalar reverse $text;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># more reasonable web counter :-)</span>
<span class="cp">use Math::TrulyRandom;</span>
<span class="cp">$hits = truly_random_value();       # negative hits!</span>
<span class="cp">$output = &quot;Your web page received $hits accesses last month.\n&quot;;</span>
<span class="cp">print commify($output);</span>
<span class="cp">Your web page received -1,740,525,205 accesses last month.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp">printf &quot;It took %d hour%s\n&quot;, $time, $time == 1 ? &quot;&quot; : &quot;s&quot;;</span>

<span class="cp">printf &quot;%d hour%s %s enough.\n&quot;, $time, </span>
<span class="cp">        $time == 1 ? &quot;&quot;   : &quot;s&quot;,</span>
<span class="cp">        $time == 1 ? &quot;is&quot; : &quot;are&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">printf &quot;It took %d centur%s&quot;, $time, $time == 1 ? &quot;y&quot; : &quot;ies&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub noun_plural {</span>
<span class="cp">    local $_ = shift;</span>
<span class="cp">    # order really matters here!</span>
<span class="cp">    s/ss$/sses/                             ||</span>
<span class="cp">    s/([psc]h)$/${1}es/                     ||</span>
<span class="cp">    s/z$/zes/                               ||</span>
<span class="cp">    s/ff$/ffs/                              ||</span>
<span class="cp">    s/f$/ves/                               ||</span>
<span class="cp">    s/ey$/eys/                              ||</span>
<span class="cp">    s/y$/ies/                               ||</span>
<span class="cp">    s/ix$/ices/                             ||</span>
<span class="cp">    s/([sx])$/$1es/                         ||</span>
<span class="cp">    s/$/s/                                  ||</span>
<span class="cp">                die &quot;can&#39;t get here&quot;;</span>
<span class="cp">    return $_;</span>
<span class="cp">}</span>
<span class="cp">*verb_singular = \&amp;noun_plural;   # make function alias</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Lingua::EN::Inflect qw(PL classical);</span>
<span class="cp">classical(1);               # why isn&#39;t this the default?</span>
<span class="cp">while (&lt;DATA&gt;) {            # each line in the data</span>
<span class="cp">    for (split) {           # each word on the line</span>
<span class="cp">        print &quot;One $_, two &quot;, PL($_), &quot;.\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">} </span>
<span class="cp"># plus one more</span>
<span class="cp">$_ = &#39;secretary general&#39;;</span>
<span class="cp">print &quot;One $_, two &quot;, PL($_), &quot;.\n&quot;;</span>

<span class="cp">#__END__</span>
<span class="cp">#fish fly ox </span>
<span class="cp">#species genus phylum </span>
<span class="cp">#cherub radius jockey </span>
<span class="cp">#index matrix mythos</span>
<span class="cp">#phenomenon formula </span>
<span class="cp">#-----------------------------</span>
<span class="cp">#One fish, two fish.</span>
<span class="cp">#</span>
<span class="cp">#One fly, two flies.</span>
<span class="cp">#</span>
<span class="cp">#One ox, two oxen.</span>
<span class="cp">#</span>
<span class="cp">#One species, two species.</span>
<span class="cp">#</span>
<span class="cp">#One genus, two genera.</span>
<span class="cp">#</span>
<span class="cp">#One phylum, two phyla.</span>
<span class="cp">#</span>
<span class="cp">#One cherub, two cherubim.</span>
<span class="cp">#</span>
<span class="cp">#One radius, two radii.</span>
<span class="cp">#</span>
<span class="cp">#One jockey, two jockeys.</span>
<span class="cp">#</span>
<span class="cp">#One index, two indices.</span>
<span class="cp">#</span>
<span class="cp">#One matrix, two matrices.</span>
<span class="cp">#</span>
<span class="cp">#One mythos, two mythoi.</span>
<span class="cp">#</span>
<span class="cp">#One phenomenon, two phenomena.</span>
<span class="cp">#</span>
<span class="cp">#One formula, two formulae.</span>
<span class="cp">#</span>
<span class="cp">#One secretary general, two secretaries general.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_2.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% bigfact 8 9 96 2178</span>
<span class="cp">#8          2**3</span>
<span class="cp">#</span>
<span class="cp">#9          3**2</span>
<span class="cp">#</span>
<span class="cp">#96         2**5 3</span>
<span class="cp">#</span>
<span class="cp">#2178       2 3**2 11**2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% bigfact 239322000000000000000000</span>
<span class="cp">#+239322000000000000000000 2**19 3 5**18 +39887 </span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#% bigfact 25000000000000000000000000</span>
<span class="cp">#+25000000000000000000000000 2**24 5**26</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch02/bigfact</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># bigfact - calculate prime factors</span>
<span class="cp">use strict;</span>
<span class="cp">use integer;</span>

<span class="cp">use vars qw{ $opt_b $opt_d };</span>
<span class="cp">use Getopt::Std;</span>

<span class="cp">@ARGV &amp;&amp; getopts(&#39;bd&#39;)        or die &quot;usage: $0 [-b] number ...&quot;;</span>

<span class="cp">load_biglib() if $opt_b;</span>

<span class="cp">ARG: foreach my $orig ( @ARGV ) {</span>
<span class="cp">    my ($n, $root, %factors, $factor);</span>
<span class="cp">    $n = $opt_b ? Math::BigInt-&gt;new($orig) : $orig;</span>
<span class="cp">    if ($n + 0 ne $n) { # don&#39;t use -w for this</span>
<span class="cp">        printf STDERR &quot;bignum: %s would become %s\n&quot;, $n, $n+0 if $opt_d;</span>
<span class="cp">        load_biglib();</span>
<span class="cp">        $n = Math::BigInt-&gt;new($orig);</span>
<span class="cp">    }</span>
<span class="cp">    printf &quot;%-10s &quot;, $n;</span>

<span class="cp">    # Here $sqi will be the square of $i. We will take advantage</span>
<span class="cp">    # of the fact that ($i + 1) ** 2 == $i ** 2 + 2 * $i + 1.</span>
<span class="cp">    for (my ($i, $sqi) = (2, 4); $sqi &lt;= $n; $sqi += 2 * $i ++ + 1) {</span>
<span class="cp">        while ($n % $i == 0) {</span>
<span class="cp">            $n /= $i;</span>
<span class="cp">            print STDERR &quot;&lt;$i&gt;&quot; if $opt_d;</span>
<span class="cp">            $factors {$i} ++;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>

<span class="cp">    if ($n != 1 &amp;&amp; $n != $orig) { $factors{$n}++ }</span>
<span class="cp">    if (! %factors) {</span>
<span class="cp">        print &quot;PRIME\n&quot;;</span>
<span class="cp">        next ARG;</span>
<span class="cp">    }</span>
<span class="cp">    for $factor ( sort { $a &lt;=&gt; $b } keys %factors ) {</span>
<span class="cp">            print &quot;$factor&quot;;</span>
<span class="cp">        if ($factors{$factor} &gt; 1) {</span>
<span class="cp">        print &quot;**$factors{$factor}&quot;;</span>
<span class="cp">        }</span>
<span class="cp">        print &quot; &quot;;</span>
<span class="cp">    }</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">}</span>

<span class="cp"># this simulates a use, but at run time</span>
<span class="cp">sub load_biglib {</span>
<span class="cp">    require Math::BigInt;</span>
<span class="cp">    Math::BigInt-&gt;import();          #immaterial?</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$sec</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$min</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$hours</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$mday</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$month</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$year</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$wday</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$yday</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$isdst</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Fri Apr 11 09:27:08 1997</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># using arrays</span>
<span class="cp">print &quot;Today is day &quot;, (localtime)[7], &quot; of the current year.\n&quot;;</span>
<span class="cp"># Today is day 117 of the current year.</span>

<span class="cp"># using Time::tm objects</span>
<span class="cp">use Time::localtime;</span>
<span class="cp">$tm = localtime;</span>
<span class="cp">print &quot;Today is day &quot;, $tm-&gt;yday, &quot; of the current year.\n&quot;;</span>
<span class="cp"># Today is day 117 of the current year.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($DAY, $MONTH, $YEAR) = (localtime)[3,4,5];</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::localtime;</span>
<span class="cp">$tm = localtime;</span>
<span class="cp">($DAY, $MONTH, $YEAR) = ($tm-&gt;mday, $tm-&gt;mon, $tm-&gt;year);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($day, $month, $year) = (localtime)[3,4,5];</span>
<span class="cp">printf(&quot;The current date is %04d %02d %02d\n&quot;, $year+1900, $month+1, $day);</span>
<span class="cp"># The current date is 1998 04 28</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($day, $month, $year) = (localtime)[3..5];</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::localtime;</span>
<span class="cp">$tm = localtime;</span>
<span class="cp">printf(&quot;The current date is %04d-%02d-%02d\n&quot;, $tm-&gt;year+1900, </span>
<span class="cp">    ($tm-&gt;mon)+1, $tm-&gt;mday);</span>
<span class="cp"># The current date is 1998-04-28</span>
<span class="cp">#-----------------------------</span>
<span class="cp">printf(&quot;The current date is %04d-%02d-%02d\n&quot;,</span>
<span class="cp">       sub {($_[5]+1900, $_[4]+1, $_[3])}-&gt;(localtime));</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(strftime);</span>
<span class="cp">print strftime &quot;%Y-%m-%d\n&quot;, localtime;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::Local;</span>
<span class="cp">$TIME = timelocal($sec, $min, $hours, $mday, $mon, $year);</span>
<span class="cp">$TIME = timegm($sec, $min, $hours, $mday, $mon, $year);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># $hours, $minutes, and $seconds represent a time today,</span>
<span class="cp"># in the current time zone</span>
<span class="cp">use Time::Local;</span>
<span class="cp">$time = timelocal($seconds, $minutes, $hours, (localtime)[3,4,5]);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># $day is day in month (1-31)</span>
<span class="cp"># $month is month in year (1-12)</span>
<span class="cp"># $year is four-digit year e.g., 1967</span>
<span class="cp"># $hours, $minutes and $seconds represent UTC time </span>
<span class="cp">use Time::Local;</span>
<span class="cp">$time = timegm($seconds, $minutes, $hours, $day, $month-1, $year-1900);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($seconds, $minutes, $hours, $day_of_month, $month, $year,</span>
<span class="cp">    $wday, $yday, $isdst) = localtime($time);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::localtime;        # or Time::gmtime</span>
<span class="cp">$tm = localtime($TIME);     # or gmtime($TIME)</span>
<span class="cp">$seconds = $tm-&gt;sec;</span>
<span class="cp"># ...</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($seconds, $minutes, $hours, $day_of_month, $month, $year,</span>
<span class="cp">    $wday, $yday, $isdst) = localtime($time);</span>
<span class="cp">printf(&quot;Dateline: %02d:%02d:%02d-%04d/%02d/%02d\n&quot;,</span>
<span class="cp">    $hours, $minutes, $seconds, $year+1900, $month+1,</span>
<span class="cp">    $day_of_month);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::localtime;</span>
<span class="cp">$tm = localtime($time);</span>
<span class="cp">printf(&quot;Dateline: %02d:%02d:%02d-%04d/%02d/%02d\n&quot;,</span>
<span class="cp">    $tm-&gt;hour, $tm-&gt;min, $tm-&gt;sec, $tm-&gt;year+1900,</span>
<span class="cp">    $tm-&gt;mon+1, $tm-&gt;mday);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$when = $now + $difference;</span>
<span class="cp">$then = $now - $difference;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Add_Delta_Days);</span>
<span class="cp">($y2, $m2, $d2) = Add_Delta_Days($y, $m, $d, $offset);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Add_Delta_DHMS);</span>
<span class="cp">($year2, $month2, $day2, $h2, $m2, $s2) = </span>
<span class="cp">    Add_Delta_DHMS( $year, $month, $day, $hour, $minute, $second,</span>
<span class="cp">                $days_offset, $hour_offset, $minute_offset, $second_offset );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$birthtime = 96176750;                  # 18/Jan/1973, 3:45:50 am</span>
<span class="cp">$interval = 5 +                         # 5 seconds</span>
<span class="cp">            17 * 60 +                   # 17 minutes</span>
<span class="cp">            2  * 60 * 60 +              # 2 hours</span>
<span class="cp">            55 * 60 * 60 * 24;          # and 55 days</span>
<span class="cp">$then = $birthtime + $interval;</span>
<span class="cp">print &quot;Then is &quot;, scalar(localtime($then)), &quot;\n&quot;;</span>
<span class="cp"># Then is Wed Mar 14 06:02:55 1973</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Add_Delta_DHMS);</span>
<span class="cp">($year, $month, $day, $hh, $mm, $ss) = Add_Delta_DHMS(</span>
<span class="cp">    1973, 1, 18, 3, 45, 50, # 18/Jan/1973, 3:45:50 am</span>
<span class="cp">             55, 2, 17, 5); # 55 days, 2 hrs, 17 min, 5 sec</span>
<span class="cp">print &quot;To be precise: $hh:$mm:$ss, $month/$day/$year\n&quot;;</span>
<span class="cp"># To be precise: 6:2:55, 3/14/1973</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Add_Delta_Days);</span>
<span class="cp">($year, $month, $day) = Add_Delta_Days(1973, 1, 18, 55);</span>
<span class="cp">print &quot;Nat was 55 days old on: $month/$day/$year\n&quot;;</span>
<span class="cp"># Nat was 55 days old on: 3/14/1973</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$seconds = $recent - $earlier;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Delta_Days);</span>
<span class="cp">$days = Delta_Days( $year1, $month1, $day1, $year2, $month2, $day2);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Delta_DHMS);</span>
<span class="cp">($days, $hours, $minutes, $seconds) =</span>
<span class="cp">  Delta_DHMS( $year1, $month1, $day1, $hour1, $minute1, $seconds1,  # earlier</span>
<span class="cp">              $year2, $month2, $day2, $hour2, $minute2, $seconds2); # later</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$bree = 361535725;          # 16 Jun 1981, 4:35:25</span>
<span class="cp">$nat  =  96201950;          # 18 Jan 1973, 3:45:50</span>

<span class="cp">$difference = $bree - $nat;</span>
<span class="cp">print &quot;There were $difference seconds between Nat and Bree\n&quot;;</span>
<span class="cp"># There were 265333775 seconds between Nat and Bree</span>


<span class="cp">$seconds    =  $difference % 60;</span>
<span class="cp">$difference = ($difference - $seconds) / 60;</span>
<span class="cp">$minutes    =  $difference % 60;</span>
<span class="cp">$difference = ($difference - $minutes) / 60;</span>
<span class="cp">$hours      =  $difference % 24;</span>
<span class="cp">$difference = ($difference - $hours)   / 24;</span>
<span class="cp">$days       =  $difference % 7;</span>
<span class="cp">$weeks      = ($difference - $days)    /  7;</span>

<span class="cp">print &quot;($weeks weeks, $days days, $hours:$minutes:$seconds)\n&quot;;</span>
<span class="cp"># (438 weeks, 4 days, 23:49:35)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Delta_Days);</span>
<span class="cp">@bree = (1981, 6, 16);      # 16 Jun 1981</span>
<span class="cp">@nat  = (1973, 1, 18);      # 18 Jan 1973</span>
<span class="cp">$difference = Delta_Days(@nat, @bree);</span>
<span class="cp">print &quot;There were $difference days between Nat and Bree\n&quot;;</span>
<span class="cp"># There were 3071 days between Nat and Bree</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Delta_DHMS);</span>
<span class="cp">@bree = (1981, 6, 16, 4, 35, 25);   # 16 Jun 1981, 4:35:25</span>
<span class="cp">@nat  = (1973, 1, 18, 3, 45, 50);   # 18 Jan 1973, 3:45:50</span>
<span class="cp">@diff = Delta_DHMS(@nat, @bree);</span>
<span class="cp">print &quot;Bree came $diff[0] days, $diff[1]:$diff[2]:$diff[3] after Nat\n&quot;;</span>
<span class="cp"># Bree came 3071 days, 0:49:35 after Nat</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($MONTHDAY, $WEEKDAY, $YEARDAY) = (localtime $DATE)[3,6,7];</span>
<span class="cp">$WEEKNUM = int($YEARDAY / 7) + 1;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Day_of_Week Week_Number Day_of_Year);</span>
<span class="cp"># you have $year, $month, and $day</span>
<span class="cp"># $day is day of month, by definition.</span>
<span class="cp">$wday = Day_of_Week($year, $month, $day);</span>
<span class="cp">$wnum = Week_Number($year, $month, $day);</span>
<span class="cp">$dnum = Day_of_Year($year, $month, $day);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Calc qw(Day_of_Week Week_Number Day_of_Week_to_Text)</span>

<span class="cp">$year  = 1981;</span>
<span class="cp">$month = 6;         # (June)</span>
<span class="cp">$day   = 16;</span>

<span class="cp">$wday = Day_of_Week($year, $month, $day);</span>
<span class="cp">print &quot;$month/$day/$year was a &quot;, Day_of_Week_to_Text($wday), &quot;\n&quot;;</span>
<span class="cp">## see comment above</span>

<span class="cp">$wnum = Week_Number($year, $month, $day);</span>
<span class="cp">print &quot;in the $wnum week.\n&quot;;</span>
<span class="cp"># 6/16/1981 was a Tuesday</span>
<span class="cp"># </span>
<span class="cp"># in week number 25.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::Local;</span>
<span class="cp"># $date is &quot;1998-06-03&quot; (YYYY-MM-DD form).</span>
<span class="cp">($yyyy, $mm, $dd) = $date =~ /(\d+)-(\d+)-(\d+)/;</span>
<span class="cp"># calculate epoch seconds at midnight on that day in this timezone</span>
<span class="cp">$epoch_seconds = timelocal(0, 0, 0, $dd, $mm, $yyyy);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Manip qw(ParseDate UnixDate);</span>
<span class="cp">$date = ParseDate($string);</span>
<span class="cp">if (!$date) {</span>
<span class="cp">    # bad date</span>
<span class="cp">} else {</span>
<span class="cp">    @values = UnixDate($date, @formats);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Manip qw(ParseDate UnixDate);</span>

<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    $date = ParseDate($_);</span>
<span class="cp">    if (!$date) {</span>
<span class="cp">        warn &quot;Bad date string: $_\n&quot;;</span>
<span class="cp">        next;</span>
<span class="cp">    } else {</span>
<span class="cp">        ($year, $month, $day) = UnixDate($date, &quot;%Y&quot;, &quot;%m&quot;, &quot;%d&quot;);</span>
<span class="cp">        print &quot;Date was $month/$day/$year\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$STRING = localtime($EPOCH_SECONDS);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(strftime);</span>
<span class="cp">$STRING = strftime($FORMAT, $SECONDS, $MINUTES, $HOUR,</span>
<span class="cp">                   $DAY_OF_MONTH, $MONTH, $YEAR, $WEEKDAY,</span>
<span class="cp">                   $YEARDAY, $DST);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Manip qw(UnixDate);</span>
<span class="cp">$STRING = UnixDate($DATE, $FORMAT);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Sun Sep 21 15:33:36 1997</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::Local;</span>
<span class="cp">$time = timelocal(50, 45, 3, 18, 0, 73);</span>
<span class="cp">print &quot;Scalar localtime gives: &quot;, scalar(localtime($time)), &quot;\n&quot;;</span>
<span class="cp"># Scalar localtime gives: Thu Jan 18 03:45:50 1973</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(strftime);</span>
<span class="cp">use Time::Local;</span>
<span class="cp">$time = timelocal(50, 45, 3, 18, 0, 73);</span>
<span class="cp">print &quot;strftime gives: &quot;, strftime(&quot;%A %D&quot;, localtime($time)), &quot;\n&quot;;</span>
<span class="cp"># strftime gives: Thursday 01/18/73</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Manip qw(ParseDate UnixDate);</span>
<span class="cp">$date = ParseDate(&quot;18 Jan 1973, 3:45:50&quot;);</span>
<span class="cp">$datestr = UnixDate($date, &quot;%a %b %e %H:%M:%S %z %Y&quot;);    # as scalar</span>
<span class="cp">print &quot;Date::Manip gives: $datestr\n&quot;;</span>
<span class="cp"># Date::Manip gives: Thu Jan 18 03:45:50 GMT 1973</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::HiRes qw(gettimeofday);</span>
<span class="cp">$t0 = gettimeofday;</span>
<span class="cp">## do your operation here</span>
<span class="cp">$t1 = gettimeofday;</span>
<span class="cp">$elapsed = $t1 - $t0;</span>
<span class="cp"># $elapsed is a floating point value, representing number</span>
<span class="cp"># of seconds between $t0 and $t1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::HiRes qw(gettimeofday);</span>
<span class="cp">print &quot;Press return when ready: &quot;;</span>
<span class="cp">$before = gettimeofday;</span>
<span class="cp">$line = &lt;&gt;;</span>
<span class="cp">$elapsed = gettimeofday-$before;</span>
<span class="cp">print &quot;You took $elapsed seconds.\n&quot;;</span>
<span class="cp"># Press return when ready: </span>
<span class="cp"># </span>
<span class="cp"># You took 0.228149 seconds.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require &#39;sys/syscall.ph&#39;;</span>

<span class="cp"># initialize the structures returned by gettimeofday</span>
<span class="cp">$TIMEVAL_T = &quot;LL&quot;;</span>
<span class="cp">$done = $start = pack($TIMEVAL_T, ());</span>

<span class="cp"># prompt</span>
<span class="cp">print &quot;Press return when ready: &quot;;</span>

<span class="cp"># read the time into $start</span>
<span class="cp">syscall(&amp;SYS_gettimeofday, $start, 0) != -1</span>
<span class="cp">           || die &quot;gettimeofday: $!&quot;;</span>

<span class="cp"># read a line</span>
<span class="cp">$line = &lt;&gt;;</span>

<span class="cp"># read the time into $done</span>
<span class="cp">syscall(&amp;SYS_gettimeofday, $done, 0) != -1</span>
<span class="cp">       || die &quot;gettimeofday: $!&quot;;</span>

<span class="cp"># expand the structure</span>
<span class="cp">@start = unpack($TIMEVAL_T, $start);</span>
<span class="cp">@done  = unpack($TIMEVAL_T, $done);</span>

<span class="cp"># fix microseconds</span>
<span class="cp">for ($done[1], $start[1]) { $_ /= 1_000_000 }</span>
<span class="cp">    </span>
<span class="cp"># calculate time difference</span>
<span class="cp">$delta_time = sprintf &quot;%.4f&quot;, ($done[0]  + $done[1]  )</span>
<span class="cp">                                         -</span>
<span class="cp">                              ($start[0] + $start[1] );</span>

<span class="cp">print &quot;That took $delta_time seconds\n&quot;;</span>
<span class="cp"># Press return when ready: </span>
<span class="cp"># </span>
<span class="cp"># That took 0.3037 seconds</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::HiRes qw(gettimeofday);</span>
<span class="cp"># take mean sorting time</span>
<span class="cp">$size = 500;</span>
<span class="cp">$number_of_times = 100;</span>
<span class="cp">$total_time = 0;</span>

<span class="cp">for ($i = 0; $i &lt; $number_of_times; $i++) {</span>
<span class="cp">    my (@array, $j, $begin, $time);</span>
<span class="cp">    # populate array</span>
<span class="cp">    @array = ();</span>
<span class="cp">    for ($j=0; $j&lt;$size; $j++) { push(@array, rand) }</span>

<span class="cp">    # sort it</span>
<span class="cp">    $begin = gettimeofday;</span>
<span class="cp">    @array = sort { $a &lt;=&gt; $b } @array;</span>
<span class="cp">    $time = gettimeofday-$begin;</span>
<span class="cp">    $total_time += $time;</span>
<span class="cp">}</span>

<span class="cp">printf &quot;On average, sorting %d random numbers takes %.5f seconds\n&quot;,</span>
<span class="cp">    $size, ($total_time/$number_of_times);</span>
<span class="cp"># On average, sorting 500 random numbers takes 0.02821 seconds</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">select(undef, undef, undef, $time_to_sleep);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::HiRes qw(sleep);</span>
<span class="cp">sleep($time_to_sleep);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    select(undef, undef, undef, 0.25);</span>
<span class="cp">    print;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Time::HiRes qw(sleep);</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    sleep(0.25);</span>
<span class="cp">    print;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_3.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Date::Manip qw(ParseDate DateCalc);</span>
<span class="cp">$d1 = ParseDate(&quot;Tue, 26 May 1998 23:57:38 -0400&quot;);</span>
<span class="cp">$d2 = ParseDate(&quot;Wed, 27 May 1998 05:04:03 +0100&quot;);</span>
<span class="cp">print DateCalc($d1, $d2);</span>
<span class="cp"># +0:0:0:0:0:6:25</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch03/hopdelta</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># hopdelta - feed mail header, produce lines</span>
<span class="cp">#            showing delay at each hop.</span>
<span class="cp">use strict;</span>
<span class="cp">use Date::Manip qw (ParseDate UnixDate);</span>

<span class="cp"># print header; this should really use format/write due to</span>
<span class="cp"># printf complexities</span>
<span class="cp">printf &quot;%-20.20s %-20.20s %-20.20s   %s\n&quot;, </span>
<span class="cp">        &quot;Sender&quot;, &quot;Recipient&quot;, &quot;Time&quot;, &quot;Delta&quot;;</span>
<span class="cp">$/ = &#39;&#39;;                # paragraph mode</span>
<span class="cp">$_ = &lt;&gt;;                # read header</span>
<span class="cp">s/\n\s+/ /g;            # join continuation lines</span>

<span class="cp"># calculate when and where this started</span>
<span class="cp">my($start_from) = /^From.*\@([^\s&gt;]*)/m;</span>
<span class="cp">my($start_date) = /^Date:\s+(.*)/m;</span>
<span class="cp">my $then = getdate($start_date);</span>
<span class="cp">printf &quot;%-20.20s %-20.20s %s\n&quot;, &#39;Start&#39;, $start_from, fmtdate($then);</span>

<span class="cp">my $prevfrom = $start_from;</span>

<span class="cp"># now process the headers lines from the bottom up</span>
<span class="cp">for (reverse split(/\n/)) {</span>
<span class="cp">    my ($delta, $now, $from, $by, $when);</span>
<span class="cp">    next unless /^Received:/;</span>
<span class="cp">    s/\bon (.*?) (id.*)/; $1/s;         # qmail header, I think</span>
<span class="cp">    unless (($when) = /;\s+(.*)$/) {    # where the date falls</span>
<span class="cp">        warn &quot;bad received line: $_&quot;;</span>
<span class="cp">        next;</span>
<span class="cp">    }</span>
<span class="cp">    ($from) = /from\s+(\S+)/;           </span>
<span class="cp">    ($from) = /\((.*?)\)/ unless $from; # some put it here</span>
<span class="cp">    $from =~ s/\)$//;                   # someone was too greedy</span>
<span class="cp">    ($by)   = /by\s+(\S+\.\S+)/;        # who sent it on this hop</span>

<span class="cp">    # now random mungings to get their string parsable</span>
<span class="cp">    for ($when) {</span>
<span class="cp">        s/ (for|via) .*$//;</span>
<span class="cp">        s/([+-]\d\d\d\d) \(\S+\)/$1/;</span>
<span class="cp">        s/id \S+;\s*//;</span>
<span class="cp">    }</span>
<span class="cp">    next unless $now = getdate($when);          # convert to Epoch</span>
<span class="cp">    $delta = $now - $then;</span>

<span class="cp">    printf &quot;%-20.20s %-20.20s %s  &quot;, $from, $by, fmtdate($now);</span>
<span class="cp">    $prevfrom = $by;</span>
<span class="cp">    puttime($delta);</span>
<span class="cp">    $then = $now;               </span>
<span class="cp">}</span>

<span class="cp">exit;</span>

<span class="cp"># convert random date strings into Epoch seconds</span>
<span class="cp">sub getdate {</span>
<span class="cp">    my $string     =  shift;</span>
<span class="cp">    $string        =~ s/\s+\(.*\)\s*$//;        # remove nonstd tz</span>
<span class="cp">    my $date       =  ParseDate($string);</span>
<span class="cp">    my $epoch_secs =  UnixDate($date,&quot;%s&quot;);</span>
<span class="cp">    return $epoch_secs;</span>
<span class="cp">}</span>

<span class="cp"># convert Epoch seconds into a particular date string</span>
<span class="cp">sub fmtdate {</span>
<span class="cp">    my $epoch = shift;</span>
<span class="cp">    my($sec,$min,$hour,$mday,$mon,$year) = localtime($epoch);</span>
<span class="cp">    return sprintf &quot;%02d:%02d:%02d %04d/%02d/%02d&quot;,</span>
<span class="cp">    		$hour, $min, $sec,</span>
<span class="cp">    		$year + 1900, $mon + 1, $mday,</span>
<span class="cp">}</span>

<span class="cp"># take seconds and print in pleasant-to-read format</span>
<span class="cp">sub puttime {</span>
<span class="cp">    my($seconds) = shift;</span>
<span class="cp">    my($days, $hours, $minutes);</span>
<span class="cp">    $days    = pull_count($seconds, 24 * 60 * 60);</span>
<span class="cp">    $hours   = pull_count($seconds, 60 * 60);</span>
<span class="cp">    $minutes = pull_count($seconds, 60);</span>
<span class="cp">    put_field(&#39;s&#39;, $seconds);</span>
<span class="cp">    put_field(&#39;m&#39;, $minutes);</span>
<span class="cp">    put_field(&#39;h&#39;, $hours);</span>
<span class="cp">    put_field(&#39;d&#39;, $days);</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">}</span>

<span class="cp"># usage: $count = pull_count(seconds, amount)</span>
<span class="cp"># remove from seconds the amount quantity, altering caller&#39;s version.</span>
<span class="cp"># return the integral number of those amounts so removed.</span>
<span class="cp">sub pull_count {</span>
<span class="cp">    my($answer) = int($_[0] / $_[1]);</span>
<span class="cp">    $_[0] -= $answer * $_[1];</span>
<span class="cp">    return $answer;</span>
<span class="cp">}</span>

<span class="cp"># usage: put_field(char, number)</span>
<span class="cp"># output number field in 3-place decimal format, with trailing char</span>
<span class="cp"># suppress output unless char is &#39;s&#39; for seconds</span>
<span class="cp">sub put_field {</span>
<span class="cp">    my ($char, $number) = @_;</span>
<span class="cp">    printf &quot; %3d%s&quot;, $number, $char if $number || $char eq &#39;s&#39;;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># Sender               Recipient            Time                   Delta</span>
<span class="cp"># </span>
<span class="cp"># Start                wall.org             09:17:12 1998/05/23</span>
<span class="cp"># </span>
<span class="cp"># wall.org             mail.brainstorm.net  09:20:56 1998/05/23    44s   3m</span>
<span class="cp"># </span>
<span class="cp"># mail.brainstorm.net  jhereg.perl.com      09:20:58 1998/05/23     2s</span>
<span class="cp">#  </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@nested = (&quot;this&quot;, &quot;that&quot;, &quot;the&quot;, &quot;other&quot;);</span>
<span class="cp">@nested = (&quot;this&quot;, &quot;that&quot;, (&quot;the&quot;, &quot;other&quot;));</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@tune = ( &quot;The&quot;, &quot;Star-Spangled&quot;, &quot;Banner&quot; );</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@a = (&quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@a = qw(Why are you teasing me?);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = (&lt;&lt;&quot;END_OF_HERE_DOC&quot; =~ m/^\s*(.+)/gm);</span>
<span class="cp">    The boy stood on the burning deck,</span>
<span class="cp">    It was as hot as glass.</span>
<span class="cp">END_OF_HERE_DOC</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@bigarray = ();</span>
<span class="cp">open(DATA, &quot;&lt; mydatafile&quot;)       or die &quot;Couldn&#39;t read from datafile: $!\n&quot;;</span>
<span class="cp">while (&lt;DATA&gt;) {</span>
<span class="cp">    chomp;</span>
<span class="cp">    push(@bigarray, $_);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$banner = &#39;The Mines of Moria&#39;;</span>
<span class="cp">$banner = q(The Mines of Moria);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$name   =  &quot;Gandalf&quot;;</span>
<span class="cp">$banner = &quot;Speak, $name, and enter!&quot;;</span>
<span class="cp">$banner = qq(Speak, $name, and welcome!);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$his_host   = &#39;www.perl.com&#39;;</span>
<span class="cp">$host_info  = `nslookup $his_host`; # expand Perl variable</span>

<span class="cp">$perl_info  = qx(ps $$);            # that&#39;s Perl&#39;s $$</span>
<span class="cp">$shell_info = qx&#39;ps $$&#39;;            # that&#39;s the new shell&#39;s $$</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@banner = (&#39;Costs&#39;, &#39;only&#39;, &#39;$4.95&#39;);</span>
<span class="cp">@banner = qw(Costs only $4.95);</span>
<span class="cp">@banner = split(&#39; &#39;, &#39;Costs only $4.95&#39;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@brax   = qw! ( ) &lt; &gt; { } [ ] !;</span>
<span class="cp">@rings  = qw(Nenya Narya Vilya);</span>
<span class="cp">@tags   = qw&lt;LI TABLE TR TD A IMG H1 P&gt;;</span>
<span class="cp">@sample = qw(The vertical bar (|) looks and behaves like a pipe.);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@banner = qw|The vertical bar (\|) looks and behaves like a pipe.|;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ships  = qw(Nia Pinta Santa Mara);               # WRONG</span>
<span class="cp">@ships  = (&#39;Nia&#39;, &#39;Pinta&#39;, &#39;Santa Mara&#39;);         # right</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub commify_series {</span>
<span class="cp">    (@_ == 0) ? &#39;&#39;                                      :</span>
<span class="cp">    (@_ == 1) ? $_[0]                                   :</span>
<span class="cp">    (@_ == 2) ? join(&quot; and &quot;, @_)                       :</span>
<span class="cp">                join(&quot;, &quot;, @_[0 .. ($#_-1)], &quot;and $_[-1]&quot;);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@array = (&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;);</span>
<span class="cp">print &quot;I have &quot;, @array, &quot; marbles.\n&quot;;</span>
<span class="cp">print &quot;I have @array marbles.\n&quot;;</span>
<span class="cp">I have redyellowgreen marbles.</span>

<span class="cp">I have red yellow green marbles.</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch04/commify_series</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># commify_series - show proper comma insertion in list output</span>

<span class="cp">@lists = (</span>
<span class="cp">    [ &#39;just one thing&#39; ],</span>
<span class="cp">    [ qw(Mutt Jeff) ],</span>
<span class="cp">    [ qw(Peter Paul Mary) ],</span>
<span class="cp">    [ &#39;To our parents&#39;, &#39;Mother Theresa&#39;, &#39;God&#39; ],</span>
<span class="cp">    [ &#39;pastrami&#39;, &#39;ham and cheese&#39;, &#39;peanut butter and jelly&#39;, &#39;tuna&#39; ],</span>
<span class="cp">    [ &#39;recycle tired, old phrases&#39;, &#39;ponder big, happy thoughts&#39; ],</span>
<span class="cp">    [ &#39;recycle tired, old phrases&#39;, </span>
<span class="cp">      &#39;ponder big, happy thoughts&#39;, </span>
<span class="cp">      &#39;sleep and dream peacefully&#39; ],</span>
<span class="cp">    );</span>

<span class="cp">foreach $aref (@lists) {</span>
<span class="cp">    print &quot;The list is: &quot; . commify_series(@$aref) . &quot;.\n&quot;;</span>
<span class="cp">} </span>

<span class="cp">sub commify_series {</span>
<span class="cp">    my $sepchar = grep(/,/ =&gt; @_) ? &quot;;&quot; : &quot;,&quot;;</span>
<span class="cp">    (@_ == 0) ? &#39;&#39;                                      :</span>
<span class="cp">    (@_ == 1) ? $_[0]                                   :</span>
<span class="cp">    (@_ == 2) ? join(&quot; and &quot;, @_)                       :</span>
<span class="cp">                join(&quot;$sepchar &quot;, @_[0 .. ($#_-1)], &quot;and $_[-1]&quot;);</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#The list is: just one thing.</span>
<span class="cp">#</span>
<span class="cp">#The list is: Mutt and Jeff.</span>
<span class="cp">#</span>
<span class="cp">#The list is: Peter, Paul, and Mary.</span>
<span class="cp">#</span>
<span class="cp">#The list is: To our parents, Mother Theresa, and God.</span>
<span class="cp">#</span>
<span class="cp">#The list is: pastrami, ham and cheese, peanut butter and jelly, and tuna.</span>
<span class="cp">#</span>
<span class="cp">#The list is: recycle tired, old phrases and ponder big, happy thoughts.</span>
<span class="cp">#</span>
<span class="cp">#The list is: recycle tired, old phrases; ponder </span>
<span class="cp">#</span>
<span class="cp">#   big, happy thoughts; and sleep and dream peacefully.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># grow or shrink @ARRAY</span>
<span class="cp">$#ARRAY = $NEW_LAST_ELEMENT_INDEX_NUMBER;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ARRAY[$NEW_LAST_ELEMENT_INDEX_NUMBER] = $VALUE;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub what_about_that_array {</span>
<span class="cp">    print &quot;The array now has &quot;, scalar(@people), &quot; elements.\n&quot;;</span>
<span class="cp">    print &quot;The index of the last element is $#people.\n&quot;;</span>
<span class="cp">    print &quot;Element #3 is `$people[3]&#39;.\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">@people = qw(Crosby Stills Nash Young);</span>
<span class="cp">what_about_that_array();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">The array now has 4 elements.</span>

<span class="cp">The index of the last element is 3.</span>

<span class="cp">Element #3 is `Young&#39;.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$#people--;</span>
<span class="cp">what_about_that_array();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">The array now has 3 elements.</span>

<span class="cp">The index of the last element is 2.</span>

<span class="cp">Element #3 is `&#39;.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$#people = 10_000;</span>
<span class="cp">what_about_that_array();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">The array now has 10001 elements.</span>

<span class="cp">The index of the last element is 10000.</span>

<span class="cp">Element #3 is `&#39;.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$people[10_000] = undef;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $item (LIST) {</span>
<span class="cp">    # do something with $item</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $user (@bad_users) {</span>
<span class="cp">        complain($user);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $var (sort keys %ENV) {</span>
<span class="cp">    print &quot;$var=$ENV{$var}\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $user (@all_users) {</span>
<span class="cp">    $disk_space = get_usage($user);     # find out how much disk space in use</span>
<span class="cp">    if ($disk_space &gt; $MAX_QUOTA) {     # if it&#39;s more than we want ...</span>
<span class="cp">        complain($user);                # ... then object vociferously</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach (`who`) {</span>
<span class="cp">    if (/tchrist/) {</span>
<span class="cp">        print;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;FH&gt;) {              # $_ is set to the line just read</span>
<span class="cp">    chomp;                  # $_ has a trailing \n removed, if it had one</span>
<span class="cp">    foreach (split) {       # $_ is split on whitespace, into @_</span>
<span class="cp">                            # then $_ is set to each chunk in turn</span>
<span class="cp">        $_ = reverse;       # the characters in $_ are reversed</span>
<span class="cp">        print;              # $_ is printed</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach my $item (@array) {</span>
<span class="cp">    print &quot;i = $item\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@array = (1,2,3);</span>
<span class="cp">foreach $item (@array) {</span>
<span class="cp">    $item--;</span>
<span class="cp">}</span>
<span class="cp">print &quot;@array\n&quot;;</span>
<span class="cp">0 1 2</span>


<span class="cp"># multiply everything in @a and @b by seven</span>
<span class="cp">@a = ( .5, 3 ); @b =( 0, 1 );</span>
<span class="cp">foreach $item (@a, @b) {</span>
<span class="cp">    $item *= 7;</span>
<span class="cp">}</span>
<span class="cp">print &quot;@a @b\n&quot;;</span>
<span class="cp">3.5 21 0 7</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># trim whitespace in the scalar, the array, and all the values</span>
<span class="cp"># in the hash</span>
<span class="cp">foreach ($scalar, @array, @hash{keys %hash}) {</span>
<span class="cp">    s/^\s+//;</span>
<span class="cp">    s/\s+$//;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for $item (@array) {  # same as foreach $item (@array)</span>
<span class="cp">    # do something</span>
<span class="cp">}</span>

<span class="cp">for (@array)      {   # same as foreach $_ (@array)</span>
<span class="cp">    # do something</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># iterate over elements of array in $ARRAYREF</span>
<span class="cp">foreach $item (@$ARRAYREF) {</span>
<span class="cp">    # do something with $item</span>
<span class="cp">}</span>

<span class="cp">for ($i = 0; $i &lt;= $#$ARRAYREF; $i++) {</span>
<span class="cp">    # do something with $ARRAYREF-&gt;[$i]</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@fruits = ( &quot;Apple&quot;, &quot;Blackberry&quot; );</span>
<span class="cp">$fruit_ref = \@fruits;</span>
<span class="cp">foreach $fruit (@$fruit_ref) {</span>
<span class="cp">    print &quot;$fruit tastes good in a pie.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">Apple tastes good in a pie.</span>

<span class="cp">Blackberry tastes good in a pie.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for ($i=0; $i &lt;= $#$fruit_ref; $i++) {</span>
<span class="cp">    print &quot;$fruit_ref-&gt;[$i] tastes good in a pie.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$namelist{felines} = \@rogue_cats;</span>
<span class="cp">foreach $cat ( @{ $namelist{felines} } ) {</span>
<span class="cp">    print &quot;$cat purrs hypnotically..\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">print &quot;--More--\nYou are controlled.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for ($i=0; $i &lt;= $#{ $namelist{felines} }; $i++) {</span>
<span class="cp">    print &quot;$namelist{felines}[$i] purrs hypnotically.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%seen = ();</span>
<span class="cp">@uniq = ();</span>
<span class="cp">foreach $item (@list) {</span>
<span class="cp">    unless ($seen{$item}) {</span>
<span class="cp">        # if we get here, we have not seen it before</span>
<span class="cp">        $seen{$item} = 1;</span>
<span class="cp">        push(@uniq, $item);</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%seen = ();</span>
<span class="cp">foreach $item (@list) {</span>
<span class="cp">    push(@uniq, $item) unless $seen{$item}++;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%seen = ();</span>
<span class="cp">foreach $item (@list) {</span>
<span class="cp">    some_func($item) unless $seen{$item}++;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%seen = ();</span>
<span class="cp">foreach $item (@list) {</span>
<span class="cp">    $seen{$item}++;</span>
<span class="cp">}</span>
<span class="cp">@uniq = keys %seen;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%seen = ();</span>
<span class="cp">@uniqu = grep { ! $seen{$_} ++ } @list;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># generate a list of users logged in, removing duplicates</span>
<span class="cp">%ucnt = ();</span>
<span class="cp">for (`who`) {</span>
<span class="cp">    s/\s.*\n//;   # kill from first space till end-of-line, yielding username</span>
<span class="cp">    $ucnt{$_}++;  # record the presence of this user</span>
<span class="cp">}</span>
<span class="cp"># extract and print unique keys</span>
<span class="cp">@users = sort keys %ucnt;</span>
<span class="cp">print &quot;users logged in: @users\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># assume @A and @B are already loaded</span>
<span class="cp">%seen = ();                  # lookup table to test membership of B</span>
<span class="cp">@aonly = ();                 # answer</span>

<span class="cp"># build lookup table</span>
<span class="cp">foreach $item (@B) { $seen{$item} = 1 }</span>

<span class="cp"># find only elements in @A and not in @B</span>
<span class="cp">foreach $item (@A) {</span>
<span class="cp">    unless ($seen{$item}) {</span>
<span class="cp">        # it&#39;s not in %seen, so add to @aonly</span>
<span class="cp">        push(@aonly, $item);</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my %seen; # lookup table</span>
<span class="cp">my @aonly;# answer</span>

<span class="cp"># build lookup table</span>
<span class="cp">@seen{@B} = ();</span>

<span class="cp">foreach $item (@A) {</span>
<span class="cp">    push(@aonly, $item) unless exists $seen{$item};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $item (@A) {</span>
<span class="cp">    push(@aonly, $item) unless $seen{$item};</span>
<span class="cp">    $seen{$item} = 1;                       # mark as seen</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$hash{&quot;key1&quot;} = 1;</span>
<span class="cp">$hash{&quot;key2&quot;} = 2;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@hash{&quot;key1&quot;, &quot;key2&quot;} = (1,2);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@seen{@B} = ();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@seen{@B} = (1) x @B;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@a = (1, 3, 5, 6, 7, 8);</span>
<span class="cp">@b = (2, 3, 5, 7, 9);</span>

<span class="cp">@union = @isect = @diff = ();</span>
<span class="cp">%union = %isect = ();</span>
<span class="cp">%count = ();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $e (@a) { $union{$e} = 1 }</span>

<span class="cp">foreach $e (@b) {</span>
<span class="cp">    if ( $union{$e} ) { $isect{$e} = 1 }</span>
<span class="cp">    $union{$e} = 1;</span>
<span class="cp">}</span>
<span class="cp">@union = keys %union;</span>
<span class="cp">@isect = keys %isect;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $e (@a, @b) { $union{$e}++ &amp;&amp; $isect{$e}++ }</span>

<span class="cp">@union = keys %union;</span>
<span class="cp">@isect = keys %isect;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $e (@a, @b) { $count{$e}++ }</span>

<span class="cp">foreach $e (keys %count) {</span>
<span class="cp">    push(@union, $e);</span>
<span class="cp">    if ($count{$e} == 2) {</span>
<span class="cp">        push @isect, $e;</span>
<span class="cp">    } else {</span>
<span class="cp">        push @diff, $e;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@isect = @diff = @union = ();</span>

<span class="cp">foreach $e (@a, @b) { $count{$e}++ }</span>

<span class="cp">foreach $e (keys %count) {</span>
<span class="cp">    push(@union, $e);</span>
<span class="cp">    push @{ $count{$e} == 2 ? \@isect : \@diff }, $e;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># push</span>
<span class="cp">push(@ARRAY1, @ARRAY2);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ARRAY1 = (@ARRAY1, @ARRAY2);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@members = (&quot;Time&quot;, &quot;Flies&quot;);</span>
<span class="cp">@initiates = (&quot;An&quot;, &quot;Arrow&quot;);</span>
<span class="cp">push(@members, @initiates);</span>
<span class="cp"># @members is now (&quot;Time&quot;, &quot;Flies&quot;, &quot;An&quot;, &quot;Arrow&quot;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">splice(@members, 2, 0, &quot;Like&quot;, @initiates);</span>
<span class="cp">print &quot;@members\n&quot;;</span>
<span class="cp">splice(@members, 0, 1, &quot;Fruit&quot;);</span>
<span class="cp">splice(@members, -2, 2, &quot;A&quot;, &quot;Banana&quot;);</span>
<span class="cp">print &quot;@members\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">Time Flies Like An Arrow</span>

<span class="cp">Fruit Flies Like A Banana</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># reverse @ARRAY into @REVERSED</span>
<span class="cp">@REVERSED = reverse @ARRAY;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for ($i = $#ARRAY; $i &gt;= 0; $i--) {</span>
<span class="cp">    # do something with $ARRAY[$i]</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># two-step: sort then reverse</span>
<span class="cp">@ascending = sort { $a cmp $b } @users;</span>
<span class="cp">@descending = reverse @ascending;</span>

<span class="cp"># one-step: sort with reverse comparison</span>
<span class="cp">@descending = sort { $b cmp $a } @users;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># remove $N elements from front of @ARRAY (shift $N)</span>
<span class="cp">@FRONT = splice(@ARRAY, 0, $N);</span>

<span class="cp"># remove $N elements from the end of the array (pop $N)</span>
<span class="cp">@END = splice(@ARRAY, -$N);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub shift2 (\@) {</span>
<span class="cp">    return splice(@{$_[0]}, 0, 2);</span>
<span class="cp">}</span>

<span class="cp">sub pop2 (\@) {</span>
<span class="cp">    return splice(@{$_[0]}, -2);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@friends = qw(Peter Paul Mary Jim Tim);</span>
<span class="cp">($this, $that) = shift2(@friends);</span>
<span class="cp"># $this contains Peter, $that has Paul, and</span>
<span class="cp"># @friends has Mary, Jim, and Tim</span>

<span class="cp">@beverages = qw(Dew Jolt Cola Sprite Fresca);</span>
<span class="cp">@pair = pop2(@beverages);</span>
<span class="cp"># $pair[0] contains Sprite, $pair[1] has Fresca,</span>
<span class="cp"># and @beverages has (Dew, Jolt, Cola)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$line[5] = \@list;</span>
<span class="cp">@got = pop2( @{ $line[5] } );</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my($match, $found, $item);</span>
<span class="cp">foreach $item (@array) {</span>
<span class="cp">    if ($criterion) {</span>
<span class="cp">        $match = $item;  # must save</span>
<span class="cp">        $found = 1;</span>
<span class="cp">        last;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">if ($found) {</span>
<span class="cp">    ## do something with $match</span>
<span class="cp">} else {</span>
<span class="cp">    ## unfound</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my($i, $match_idx);</span>
<span class="cp">for ($i = 0; $i &lt; @array; $i++) {</span>
<span class="cp">    if ($criterion) {</span>
<span class="cp">        $match_idx = $i;    # save the index</span>
<span class="cp">        last;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">if (defined $match_idx) {</span>
<span class="cp">    ## found in $array[$match_idx]</span>
<span class="cp">} else {</span>
<span class="cp">    ## unfound</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $employee (@employees) {</span>
<span class="cp">    if ( $employee-&gt;category() eq &#39;engineer&#39; ) {</span>
<span class="cp">        $highest_engineer = $employee;</span>
<span class="cp">        last;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">print &quot;Highest paid engineer is: &quot;, $highest_engineer-&gt;name(), &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for ($i = 0; $i &lt; @ARRAY; $i++) {</span>
<span class="cp">    last if $criterion;</span>
<span class="cp">}</span>
<span class="cp">if ($i &lt; @ARRAY) {</span>
<span class="cp">    ## found and $i is the index</span>
<span class="cp">} else {</span>
<span class="cp">    ## not found</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@MATCHING = grep { TEST ($_) } @LIST;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@matching = ();</span>
<span class="cp">foreach (@list) {</span>
<span class="cp">    push(@matching, $_) if TEST ($_);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@bigs = grep { $_ &gt; 1_000_000 } @nums;</span>
<span class="cp">@pigs = grep { $users{$_} &gt; 1e7 } keys %users;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@matching = grep { /^gnat / } `who`;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@engineers = grep { $_-&gt;position() eq &#39;Engineer&#39; } @employees;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@secondary_assistance = grep { $_-&gt;income &gt;= 26_000 &amp;&amp;</span>
<span class="cp">                               $_-&gt;income &lt;  30_000 }</span>
<span class="cp">                        @applicants;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@sorted = sort { $a &lt;=&gt; $b } @unsorted;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># @pids is an unsorted array of process IDs</span>
<span class="cp">foreach my $pid (sort { $a &lt;=&gt; $b } @pids) {</span>
<span class="cp">    print &quot;$pid\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">print &quot;Select a process ID to kill:\n&quot;;</span>
<span class="cp">chomp ($pid = &lt;&gt;);</span>
<span class="cp">die &quot;Exiting ... \n&quot; unless $pid &amp;&amp; $pid =~ /^\d+$/;</span>
<span class="cp">kill(&#39;TERM&#39;,$pid);</span>
<span class="cp">sleep 2;</span>
<span class="cp">kill(&#39;KILL&#39;,$pid);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@descending = sort { $b &lt;=&gt; $a } @unsorted;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Sort_Subs;</span>
<span class="cp">sub revnum { $b &lt;=&gt; $a }</span>

<span class="cp">package Other_Pack;</span>
<span class="cp">@all = sort Sort_Subs::revnum 4, 19, 8, 3;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@all = sort { $b &lt;=&gt; $a } 4, 19, 8, 3;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ordered = sort { compare() } @unordered;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@precomputed = map { [compute(),$_] } @unordered;</span>
<span class="cp">@ordered_precomputed = sort { $a-&gt;[0] &lt;=&gt; $b-&gt;[0] } @precomputed;</span>
<span class="cp">@ordered = map { $_-&gt;[1] } @ordered_precomputed;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ordered = map { $_-&gt;[1] }</span>
<span class="cp">           sort { $a-&gt;[0] &lt;=&gt; $b-&gt;[0] }</span>
<span class="cp">           map { [compute(), $_] }</span>
<span class="cp">           @unordered;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ordered = sort { $a-&gt;name cmp $b-&gt;name } @employees;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $employee (sort { $a-&gt;name cmp $b-&gt;name } @employees) {</span>
<span class="cp">    print $employee-&gt;name, &quot; earns \$&quot;, $employee-&gt;salary, &quot;\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@sorted_employees = sort { $a-&gt;name cmp $b-&gt;name } @employees;</span>
<span class="cp">foreach $employee (@sorted_employees) {</span>
<span class="cp">    print $employee-&gt;name, &quot; earns \$&quot;, $employee-&gt;salary, &quot;\n&quot;;</span>
<span class="cp">}</span>
<span class="cp"># load %bonus</span>
<span class="cp">foreach $employee (@sorted_employees) {</span>
<span class="cp">    if ( $bonus{ $employee-&gt;ssn } ) {</span>
<span class="cp">      print $employee-&gt;name, &quot; got a bonus!\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@sorted = sort { $a-&gt;name cmp $b-&gt;name</span>
<span class="cp">                           ||</span>
<span class="cp">                  $b-&gt;age &lt;=&gt; $a-&gt;age } @employees;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use User::pwent qw(getpwent);</span>
<span class="cp">@users = ();</span>
<span class="cp"># fetch all users</span>
<span class="cp">while (defined($user = getpwent)) {</span>
<span class="cp">    push(@users, $user);</span>
<span class="cp">}</span>
<span class="cp">    @users = sort { $a-&gt;name cmp $b-&gt;name } @users;</span>
<span class="cp">foreach $user (@users) {</span>
<span class="cp">    print $user-&gt;name, &quot;\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@sorted = sort { substr($a,1,1) cmp substr($b,1,1) } @names;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@sorted = sort { length $a &lt;=&gt; length $b } @strings;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@temp   = map  { [ length $_, $_ ] } @strings;</span>
<span class="cp">@temp   = sort { $a-&gt;[0] &lt;=&gt; $b-&gt;[0] } @temp;</span>
<span class="cp">@sorted = map  { $_-&gt;[1] } @temp;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@sorted = map  { $_-&gt;[1] }</span>
<span class="cp">          sort { $a-&gt;[0] &lt;=&gt; $b-&gt;[0] }</span>
<span class="cp">          map  { [ length $_, $_ ] }</span>
<span class="cp">          @strings;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@temp          = map  { [ /(\d+)/, $_ ] } @fields;</span>
<span class="cp">@sorted_temp   = sort { $a-&gt;[0] &lt;=&gt; $b-&gt;[0] } @temp;</span>
<span class="cp">@sorted_fields = map  { $_-&gt;[1] } @sorted_temp;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@sorted_fields = map  { $_-&gt;[1] }</span>
<span class="cp">                 sort { $a-&gt;[0] &lt;=&gt; $b-&gt;[0] }</span>
<span class="cp">                 map  { [ /(\d+)/, $_ ] }</span>
<span class="cp">                 @fields;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print map  { $_-&gt;[0] }             # whole line</span>
<span class="cp">      sort {</span>
<span class="cp">              $a-&gt;[1] &lt;=&gt; $b-&gt;[1]  # gid</span>
<span class="cp">                      ||</span>
<span class="cp">              $a-&gt;[2] &lt;=&gt; $b-&gt;[2]  # uid</span>
<span class="cp">                      ||</span>
<span class="cp">              $a-&gt;[3] cmp $b-&gt;[3]  # login</span>
<span class="cp">      }</span>
<span class="cp">      map  { [ $_, (split /:/)[3,2,0] ] }</span>
<span class="cp">      `cat /etc/passwd`;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unshift(@circular, pop(@circular));  # the last shall be first</span>
<span class="cp">push(@circular, shift(@circular));   # and vice versa</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub grab_and_rotate ( \@ ) {</span>
<span class="cp">    my $listref = shift;</span>
<span class="cp">    my $element = $listref-&gt;[0];</span>
<span class="cp">    push(@$listref, shift @$listref);</span>
<span class="cp">    return $element;</span>
<span class="cp">}</span>

<span class="cp">@processes = ( 1, 2, 3, 4, 5 );</span>
<span class="cp">while (1) {</span>
<span class="cp">    $process = grab_and_rotate(@processes);</span>
<span class="cp">    print &quot;Handling process $process\n&quot;;</span>
<span class="cp">    sleep 1;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># fisher_yates_shuffle( \@array ) : generate a random permutation</span>
<span class="cp"># of @array in place</span>
<span class="cp">sub fisher_yates_shuffle {</span>
<span class="cp">    my $array = shift;</span>
<span class="cp">    my $i;</span>
<span class="cp">    for ($i = @$array; --$i; ) {</span>
<span class="cp">        my $j = int rand ($i+1);</span>
<span class="cp">        next if $i == $j;</span>
<span class="cp">        @$array[$i,$j] = @$array[$j,$i];</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">fisher_yates_shuffle( \@array );    # permutes @array in place</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$permutations = factorial( scalar @array );</span>
<span class="cp">@shuffle = @array [ n2perm( 1+int(rand $permutations), $#array ) ];</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub naive_shuffle {                             # don&#39;t do this</span>
<span class="cp">    for (my $i = 0; $i &lt; @_; $i++) {</span>
<span class="cp">        my $j = int rand @_;                    # pick random element</span>
<span class="cp">        ($_[$i], $_[$j]) = ($_[$j], $_[$i]);    # swap &#39;em</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp">awk      cp       ed       login    mount    rmdir    sum</span>
<span class="cp">basename csh      egrep    ls       mt       sed      sync</span>
<span class="cp">cat      date     fgrep    mail     mv       sh       tar</span>
<span class="cp">chgrp    dd       grep     mkdir    ps       sort     touch</span>
<span class="cp">chmod    df       kill     mknod    pwd      stty     vi</span>
<span class="cp">chown    echo     ln       more     rm       su</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch04/words</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># words - gather lines, present in columns</span>

<span class="cp">use strict;</span>

<span class="cp">my ($item, $cols, $rows, $maxlen);</span>
<span class="cp">my ($xpixel, $ypixel, $mask, @data);</span>

<span class="cp">getwinsize();</span>

<span class="cp"># first gather up every line of input,</span>
<span class="cp"># remembering the longest line length seen</span>
<span class="cp">$maxlen = 1;        </span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    my $mylen;</span>
<span class="cp">    s/\s+$//;</span>
<span class="cp">    $maxlen = $mylen if (($mylen = length) &gt; $maxlen);</span>
<span class="cp">    push(@data, $_);</span>
<span class="cp">}</span>

<span class="cp">$maxlen += 1;               # to make extra space</span>

<span class="cp"># determine boundaries of screen</span>
<span class="cp">$cols = int($cols / $maxlen) || 1;</span>
<span class="cp">$rows = int(($#data+$cols) / $cols);</span>

<span class="cp"># pre-create mask for faster computation</span>
<span class="cp">$mask = sprintf(&quot;%%-%ds &quot;, $maxlen-1);</span>

<span class="cp"># subroutine to check whether at last item on line</span>
<span class="cp">sub EOL { ($item+1) % $cols == 0 }  </span>

<span class="cp"># now process each item, picking out proper piece for this position</span>
<span class="cp">for ($item = 0; $item &lt; $rows * $cols; $item++) {</span>
<span class="cp">    my $target =  ($item % $cols) * $rows + int($item/$cols);</span>
<span class="cp">    my $piece = sprintf($mask, $target &lt; @data ? $data[$target] : &quot;&quot;);</span>
<span class="cp">    $piece =~ s/\s+$// if EOL();  # don&#39;t blank-pad to EOL</span>
<span class="cp">    print $piece;</span>
<span class="cp">    print &quot;\n&quot; if EOL();</span>
<span class="cp">}</span>

<span class="cp"># finish up if needed</span>
<span class="cp">print &quot;\n&quot; if EOL();</span>

<span class="cp"># not portable -- linux only</span>
<span class="cp">sub getwinsize {</span>
<span class="cp">    my $winsize = &quot;\0&quot; x 8;</span>
<span class="cp">    my $TIOCGWINSZ = 0x40087468;</span>
<span class="cp">    if (ioctl(STDOUT, $TIOCGWINSZ, $winsize)) {</span>
<span class="cp">        ($rows, $cols, $xpixel, $ypixel) = unpack(&#39;S4&#39;, $winsize);</span>
<span class="cp">    } else {</span>
<span class="cp">        $cols = 80;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#Wrong       Right</span>
<span class="cp">#-----       -----</span>
<span class="cp">#1 2 3       1 4 7</span>
<span class="cp">#4 5 6       2 5 8</span>
<span class="cp">#7 8 9       3 6 9</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_4.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% echo man bites dog | permute</span>
<span class="cp">#dog bites man</span>
<span class="cp">#</span>
<span class="cp">#bites dog man</span>
<span class="cp">#</span>
<span class="cp">#dog man bites</span>
<span class="cp">#</span>
<span class="cp">#man dog bites</span>
<span class="cp">#</span>
<span class="cp">#bites man dog</span>
<span class="cp">#</span>
<span class="cp">#man bites dog</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Set Size            Permutations</span>
<span class="cp">#1                   1</span>
<span class="cp">#2                   2</span>
<span class="cp">#3                   6</span>
<span class="cp">#4                   24</span>
<span class="cp">#5                   120</span>
<span class="cp">#6                   720</span>
<span class="cp">#7                   5040</span>
<span class="cp">#8                   40320</span>
<span class="cp">#9                   362880</span>
<span class="cp">#10                  3628800</span>
<span class="cp">#11                  39916800</span>
<span class="cp">#12                  479001600</span>
<span class="cp">#13                  6227020800</span>
<span class="cp">#14                  87178291200</span>
<span class="cp">#15                  1307674368000</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Math::BigInt;</span>
<span class="cp">    sub factorial {</span>
<span class="cp">    my $n = shift;</span>
<span class="cp">    my $s = 1;</span>
<span class="cp">    $s *= $n-- while $n &gt; 0;</span>
<span class="cp">    return $s;</span>
<span class="cp">}</span>
<span class="cp">print factorial(Math::BigInt-&gt;new(&quot;500&quot;));</span>
<span class="cp">+1220136... (1035 digits total)</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch04/permute</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -n</span>
<span class="cp"># tsc_permute: permute each word of input</span>
<span class="cp">permute([split], []);</span>
<span class="cp">sub permute {</span>
<span class="cp">    my @items = @{ $_[0] };</span>
<span class="cp">    my @perms = @{ $_[1] };</span>
<span class="cp">    unless (@items) {</span>
<span class="cp">        print &quot;@perms\n&quot;;</span>
<span class="cp">    } else {</span>
<span class="cp">        my(@newitems,@newperms,$i);</span>
<span class="cp">        foreach $i (0 .. $#items) {</span>
<span class="cp">            @newitems = @items;</span>
<span class="cp">            @newperms = @perms;</span>
<span class="cp">            unshift(@newperms, splice(@newitems, $i, 1));</span>
<span class="cp">            permute([@newitems], [@newperms]);</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch04/mjd_permute</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># mjd_permute: permute each word of input</span>
<span class="cp">use strict;</span>

<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    my @data = split;</span>
<span class="cp">    my $num_permutations = factorial(scalar @data);</span>
<span class="cp">    for (my $i=0; $i &lt; $num_permutations; $i++) {</span>
<span class="cp">        my @permutation = @data[n2perm($i, $#data)];</span>
<span class="cp">        print &quot;@permutation\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp"># Utility function: factorial with memorizing</span>
<span class="cp">BEGIN {</span>
<span class="cp">  my @fact = (1);</span>
<span class="cp">  sub factorial($) {</span>
<span class="cp">      my $n = shift;</span>
<span class="cp">      return $fact[$n] if defined $fact[$n];</span>
<span class="cp">      $fact[$n] = $n * factorial($n - 1);</span>
<span class="cp">  }</span>
<span class="cp">}</span>

<span class="cp"># n2pat($N, $len) : produce the $N-th pattern of length $len</span>
<span class="cp">sub n2pat {</span>
<span class="cp">    my $i   = 1;</span>
<span class="cp">    my $N   = shift;</span>
<span class="cp">    my $len = shift;</span>
<span class="cp">    my @pat;</span>
<span class="cp">    while ($i &lt;= $len + 1) {   # Should really be just while ($N) { ...</span>
<span class="cp">        push @pat, $N % $i;</span>
<span class="cp">        $N = int($N/$i);</span>
<span class="cp">        $i++;</span>
<span class="cp">    }</span>
<span class="cp">    return @pat;</span>
<span class="cp">}</span>

<span class="cp"># pat2perm(@pat) : turn pattern returned by n2pat() into</span>
<span class="cp"># permutation of integers.  XXX: splice is already O(N)</span>
<span class="cp">sub pat2perm {</span>
<span class="cp">    my @pat    = @_;</span>
<span class="cp">    my @source = (0 .. $#pat);</span>
<span class="cp">    my @perm;</span>
<span class="cp">    push @perm, splice(@source, (pop @pat), 1) while @pat;</span>
<span class="cp">    return @perm;</span>
<span class="cp">}</span>

<span class="cp"># n2perm($N, $len) : generate the Nth permutation of S objects</span>
<span class="cp">sub n2perm {</span>
<span class="cp">    pat2perm(n2pat(@_));</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%age = ( &quot;Nat&quot;,   24,</span>
<span class="cp">         &quot;Jules&quot;, 25,</span>
<span class="cp">         &quot;Josh&quot;,  17  );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$age{&quot;Nat&quot;}   = 24;</span>
<span class="cp">$age{&quot;Jules&quot;} = 25;</span>
<span class="cp">$age{&quot;Josh&quot;}  = 17;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%food_color = (</span>
<span class="cp">               &quot;Apple&quot;  =&gt; &quot;red&quot;,</span>
<span class="cp">               &quot;Banana&quot; =&gt; &quot;yellow&quot;,</span>
<span class="cp">               &quot;Lemon&quot;  =&gt; &quot;yellow&quot;,</span>
<span class="cp">               &quot;Carrot&quot; =&gt; &quot;orange&quot;</span>
<span class="cp">              );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%food_color = (</span>
<span class="cp">                Apple  =&gt; &quot;red&quot;,</span>
<span class="cp">                Banana =&gt; &quot;yellow&quot;,</span>
<span class="cp">                Lemon  =&gt; &quot;yellow&quot;,</span>
<span class="cp">                Carrot =&gt; &quot;orange&quot;</span>
<span class="cp">               );</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$HASH{$KEY} = $VALUE;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %food_color defined per the introduction</span>
<span class="cp">$food_color{Raspberry} = &quot;pink&quot;;</span>
<span class="cp">print &quot;Known foods:\n&quot;;</span>
<span class="cp">foreach $food (keys %food_color) {</span>
<span class="cp">    print &quot;$food\n&quot;;</span>
<span class="cp">}</span>

<span class="cp"># Known foods:</span>
<span class="cp"># </span>
<span class="cp"># Banana</span>
<span class="cp"># </span>
<span class="cp"># Apple</span>
<span class="cp"># </span>
<span class="cp"># Raspberry</span>
<span class="cp"># </span>
<span class="cp"># Carrot</span>
<span class="cp"># </span>
<span class="cp"># Lemon</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># does %HASH have a value for $KEY ?</span>
<span class="cp">if (exists($HASH{$KEY})) {</span>
<span class="cp">    # it exists</span>
<span class="cp">} else {</span>
<span class="cp">    # it doesn&#39;t</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %food_color per the introduction</span>
<span class="cp">foreach $name (&quot;Banana&quot;, &quot;Martini&quot;) {</span>
<span class="cp">    if (exists $food_color{$name}) {</span>
<span class="cp">        print &quot;$name is a food.\n&quot;;</span>
<span class="cp">    } else {</span>
<span class="cp">        print &quot;$name is a drink.\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp"># Banana is a food.</span>
<span class="cp"># </span>
<span class="cp"># Martini is a drink.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%age = ();</span>
<span class="cp">$age{&quot;Toddler&quot;}  = 3;</span>
<span class="cp">$age{&quot;Unborn&quot;}   = 0;</span>
<span class="cp">$age{&quot;Phantasm&quot;} = undef;</span>

<span class="cp">foreach $thing (&quot;Toddler&quot;, &quot;Unborn&quot;, &quot;Phantasm&quot;, &quot;Relic&quot;) {</span>
<span class="cp">    print &quot;$thing: &quot;;</span>
<span class="cp">    print &quot;Exists &quot; if exists $age{$thing};</span>
<span class="cp">    print &quot;Defined &quot; if defined $age{$thing};</span>
<span class="cp">    print &quot;True &quot; if $age{$thing};</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">}</span>

<span class="cp"># Toddler: Exists Defined True </span>
<span class="cp"># </span>
<span class="cp"># Unborn: Exists Defined </span>
<span class="cp"># </span>
<span class="cp"># Phantasm: Exists </span>
<span class="cp"># </span>
<span class="cp"># Relic: </span>
<span class="cp">#-----------------------------</span>
<span class="cp">%size = ();</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    chomp;</span>
<span class="cp">    next if $size{$_};              # WRONG attempt to skip</span>
<span class="cp">    $size{$_} = -s $_;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    next if exists $size{$_};</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># remove $KEY and its value from %HASH</span>
<span class="cp">delete($HASH{$KEY});</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %food_color as per Introduction</span>
<span class="cp">sub print_foods {</span>
<span class="cp">    my @foods = keys %food_color;</span>
<span class="cp">    my $food;</span>

<span class="cp">    print &quot;Keys: @foods\n&quot;;</span>
<span class="cp">    print &quot;Values: &quot;;</span>

<span class="cp">    foreach $food (@foods) {</span>
<span class="cp">        my $color = $food_color{$food};</span>

<span class="cp">        if (defined $color) {</span>
<span class="cp">            print &quot;$color &quot;;</span>
<span class="cp">        } else {</span>
<span class="cp">            print &quot;(undef) &quot;;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">print &quot;Initially:\n&quot;;</span>
<span class="cp">print_foods();</span>


<span class="cp">print &quot;\nWith Banana undef\n&quot;;</span>
<span class="cp">undef $food_color{&quot;Banana&quot;};</span>
<span class="cp">print_foods();</span>


<span class="cp">print &quot;\nWith Banana deleted\n&quot;;</span>
<span class="cp">delete $food_color{&quot;Banana&quot;};</span>
<span class="cp">print_foods();</span>


<span class="cp"># Initially:</span>
<span class="cp"># </span>
<span class="cp"># Keys: Banana Apple Carrot Lemon</span>
<span class="cp"># </span>
<span class="cp"># Values: yellow red orange yellow </span>
<span class="cp"># </span>
<span class="cp"># </span>
<span class="cp"># With Banana undef</span>
<span class="cp"># </span>
<span class="cp"># Keys: Banana Apple Carrot Lemon</span>
<span class="cp"># </span>
<span class="cp"># Values: (undef) red orange yellow </span>
<span class="cp"># </span>
<span class="cp"># </span>
<span class="cp"># With Banana deleted</span>
<span class="cp"># </span>
<span class="cp"># Keys: Apple Carrot Lemon</span>
<span class="cp"># </span>
<span class="cp"># Values: red orange yellow </span>
<span class="cp">#-----------------------------</span>
<span class="cp">delete @food_color{&quot;Banana&quot;, &quot;Apple&quot;, &quot;Cabbage&quot;};</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while(($key, $value) = each(%HASH)) {</span>
<span class="cp">    # do something with $key and $value</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $key (keys %HASH) {</span>
<span class="cp">    $value = $HASH{$key};</span>
<span class="cp">    # do something with $key and $value</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %food_color per the introduction</span>
<span class="cp">while(($food, $color) = each(%food_color)) {</span>
<span class="cp">    print &quot;$food is $color.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp"># Banana is yellow.</span>
<span class="cp"># </span>
<span class="cp"># Apple is red.</span>
<span class="cp"># </span>
<span class="cp"># Carrot is orange.</span>
<span class="cp"># </span>
<span class="cp"># Lemon is yellow.</span>

<span class="cp">foreach $food (keys %food_color) {</span>
<span class="cp">    my $color = $food_color{$food};</span>
<span class="cp">    print &quot;$food is $color.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp"># Banana is yellow.</span>
<span class="cp"># </span>
<span class="cp"># Apple is red.</span>
<span class="cp"># </span>
<span class="cp"># Carrot is orange.</span>
<span class="cp"># </span>
<span class="cp"># Lemon is yellow.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print</span>
<span class="cp"> </span>
<span class="cp">&quot;$food</span>
<span class="cp"> </span>
<span class="cp">is</span>
<span class="cp"> </span>
<span class="cp">$food_color{$food}.\n&quot;</span>
<span class="cp"> </span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $food (sort keys %food_color) {</span>
<span class="cp">    print &quot;$food is $food_color{$food}.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp"># Apple is red.</span>
<span class="cp"># </span>
<span class="cp"># Banana is yellow.</span>
<span class="cp"># </span>
<span class="cp"># Carrot is orange.</span>
<span class="cp"># </span>
<span class="cp"># Lemon is yellow.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while ( ($k,$v) = each %food_color ) {</span>
<span class="cp">    print &quot;Processing $k\n&quot;;</span>
<span class="cp">    keys %food_color;               # goes back to the start of %food_color</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch05/countfrom</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># countfrom - count number of messages from each sender</span>

<span class="cp">$filename = $ARGV[0] || &quot;-&quot;;</span>

<span class="cp">open(FILE, &quot;&lt;$filename&quot;)         or die &quot;Can&#39;t open $filename : $!&quot;;</span>

<span class="cp">while(&lt;FILE&gt;) {</span>
<span class="cp">    if (/^From: (.*)/) { $from{$1}++ }</span>
<span class="cp">}</span>

<span class="cp">foreach $person (sort keys %from) {    </span>
<span class="cp">    print &quot;$person: $from{$person}\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while ( ($k,$v) = each %hash ) {</span>
<span class="cp">    print &quot;$k =&gt; $v\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print map { &quot;$_ =&gt; $hash{$_}\n&quot; } keys %hash;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;@{[ %hash ]}\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{</span>
<span class="cp">    my @temp = %hash;</span>
<span class="cp">    print &quot;@temp&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $k (sort keys %hash) {</span>
<span class="cp">    print &quot;$k =&gt; $hash{$k}\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Tie::IxHash;</span>
<span class="cp">tie %HASH, &quot;Tie::IxHash&quot;;</span>
<span class="cp"># manipulate %HASH</span>
<span class="cp">@keys = keys %HASH;         # @keys is in insertion order</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># initialize</span>
<span class="cp">use Tie::IxHash;</span>

<span class="cp">tie %food_color, &quot;Tie::IxHash&quot;;</span>
<span class="cp">$food_color{Banana} = &quot;Yellow&quot;;</span>
<span class="cp">$food_color{Apple}  = &quot;Green&quot;;</span>
<span class="cp">$food_color{Lemon}  = &quot;Yellow&quot;;</span>

<span class="cp">print &quot;In insertion order, the foods are:\n&quot;;</span>
<span class="cp">foreach $food (keys %food_color) {</span>
<span class="cp">    print &quot;  $food\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">print &quot;Still in insertion order, the foods&#39; colors are:\n&quot;;</span>
<span class="cp">while (( $food, $color ) = each %food_color ) {</span>
<span class="cp">    print &quot;$food is colored $color.\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">#In insertion order, the foods are:</span>
<span class="cp">#</span>
<span class="cp">#  Banana</span>
<span class="cp">#</span>
<span class="cp">#  Apple</span>
<span class="cp">#</span>
<span class="cp">#  Lemon</span>
<span class="cp">#</span>
<span class="cp">#Still in insertion order, the foods&#39; colors are:</span>
<span class="cp">#</span>
<span class="cp">#Banana is colored Yellow.</span>
<span class="cp">#</span>
<span class="cp">#Apple is colored Green.</span>
<span class="cp">#</span>
<span class="cp">#Lemon is colored Yellow.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%ttys = ();</span>

<span class="cp">open(WHO, &quot;who|&quot;)                   or die &quot;can&#39;t open who: $!&quot;;</span>
<span class="cp">while (&lt;WHO&gt;) {</span>
<span class="cp">    ($user, $tty) = split;</span>
<span class="cp">    push( @{$ttys{$user}}, $tty );</span>
<span class="cp">}</span>

<span class="cp">foreach $user (sort keys %ttys) {</span>
<span class="cp">    print &quot;$user: @{$ttys{$user}}\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $user (sort keys %ttys) {</span>
<span class="cp">    print &quot;$user: &quot;, scalar( @{$ttys{$user}} ), &quot; ttys.\n&quot;;</span>
<span class="cp">    foreach $tty (sort @{$ttys{$user}}) {</span>
<span class="cp">        @stat = stat(&quot;/dev/$tty&quot;);</span>
<span class="cp">        $user = @stat ? ( getpwuid($stat[4]) )[0] : &quot;(not available)&quot;;</span>
<span class="cp">        print &quot;\t$tty (owned by $user)\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub multihash_delete {</span>
<span class="cp">    my ($hash, $key, $value) = @_;</span>
<span class="cp">    my $i;</span>

<span class="cp">    return unless ref( $hash-&gt;{$key} );</span>
<span class="cp">    for ($i = 0; $i &lt; @{ $hash-&gt;{$key} }; $i++) {</span>
<span class="cp">        if ($hash-&gt;{$key}-&gt;[$i] eq $value) {</span>
<span class="cp">            splice( @{$hash-&gt;{$key}}, $i, 1);</span>
<span class="cp">            last;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>

<span class="cp">    delete $hash-&gt;{$key} unless @{$hash-&gt;{$key}};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %LOOKUP maps keys to values</span>
<span class="cp">%REVERSE = reverse %LOOKUP;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%surname = ( &quot;Mickey&quot; =&gt; &quot;Mantle&quot;, &quot;Babe&quot; =&gt; &quot;Ruth&quot; );</span>
<span class="cp">%first_name = reverse %surname;</span>
<span class="cp">print $first_name{&quot;Mantle&quot;}, &quot;\n&quot;;</span>
<span class="cp">Mickey</span>
<span class="cp">#-----------------------------</span>
<span class="cp">(&quot;Mickey&quot;, &quot;Mantle&quot;, &quot;Babe&quot;, &quot;Ruth&quot;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">(&quot;Ruth&quot;, &quot;Babe&quot;, &quot;Mantle&quot;, &quot;Mickey&quot;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">(&quot;Ruth&quot; =&gt; &quot;Babe&quot;, &quot;Mantle&quot; =&gt; &quot;Mickey&quot;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch05/foodfind</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># foodfind - find match for food or color</span>

<span class="cp">$given = shift @ARGV or die &quot;usage: foodfind food_or_color\n&quot;;</span>

<span class="cp">%color = (</span>
<span class="cp">           &quot;Apple&quot;  =&gt; &quot;red&quot;,</span>
<span class="cp">           &quot;Banana&quot; =&gt; &quot;yellow&quot;,</span>
<span class="cp">           &quot;Lemon&quot;  =&gt; &quot;yellow&quot;,           </span>
<span class="cp">           &quot;Carrot&quot; =&gt; &quot;orange&quot;</span>
<span class="cp">         );    </span>

<span class="cp">%food = reverse %color;    </span>

<span class="cp">if (exists $color{$given}) {</span>
<span class="cp">        print &quot;$given is a food with color $color{$given}.\n&quot;;</span>
<span class="cp">}    </span>
<span class="cp">if (exists $food{$given}) {</span>
<span class="cp">        print &quot;$food{$given} is a food with color $given.\n&quot;;</span>
<span class="cp">}</span>


<span class="cp">#-----------------------------</span>
<span class="cp"># %food_color as per the introduction</span>
<span class="cp">while (($food,$color) = each(%food_color)) {</span>
<span class="cp">    push(@{$foods_with_color{$color}}, $food);</span>
<span class="cp">}</span>

<span class="cp">print &quot;@{$foods_with_color{yellow}} were yellow foods.\n&quot;;</span>
<span class="cp"># Banana Lemon were yellow foods.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %HASH is the hash to sort</span>
<span class="cp">@keys = sort { criterion() } (keys %hash);</span>
<span class="cp">foreach $key (@keys) {</span>
<span class="cp">    $value = $hash{$key};</span>
<span class="cp">    # do something with $key, $value</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $food (sort keys %food_color) {</span>
<span class="cp">    print &quot;$food is $food_color{$food}.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $food (sort { $food_color{$a} cmp $food_color{$b} }</span>
<span class="cp">                keys %food_color) </span>
<span class="cp">{</span>
<span class="cp">    print &quot;$food is $food_color{$food}.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@foods = sort { length($food_color{$a}) &lt;=&gt; length($food_color{$b}) } </span>
<span class="cp">    keys %food_color;</span>
<span class="cp">foreach $food (@foods) {</span>
<span class="cp">    print &quot;$food is $food_color{$food}.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%merged = (%A, %B);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%merged = ();</span>
<span class="cp">while ( ($k,$v) = each(%A) ) {</span>
<span class="cp">    $merged{$k} = $v;</span>
<span class="cp">}</span>
<span class="cp">while ( ($k,$v) = each(%B) ) {</span>
<span class="cp">    $merged{$k} = $v;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %food_color as per the introduction</span>
<span class="cp">%drink_color = ( Galliano  =&gt; &quot;yellow&quot;,</span>
<span class="cp">                 &quot;Mai Tai&quot; =&gt; &quot;blue&quot; );</span>

<span class="cp">%ingested_color = (%drink_color, %food_color);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %food_color per the introduction, then</span>
<span class="cp">%drink_color = ( Galliano  =&gt; &quot;yellow&quot;,</span>
<span class="cp">                 &quot;Mai Tai&quot; =&gt; &quot;blue&quot; );</span>

<span class="cp">%substance_color = ();</span>
<span class="cp">while (($k, $v) = each %food_color) {</span>
<span class="cp">    $substance_color{$k} = $v;</span>
<span class="cp">} </span>
<span class="cp">while (($k, $v) = each %drink_color) {</span>
<span class="cp">    $substance_color{$k} = $v;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $substanceref ( \%food_color, \%drink_color ) {</span>
<span class="cp">    while (($k, $v) = each %$substanceref) {</span>
<span class="cp">        $substance_color{$k} = $v;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $substanceref ( \%food_color, \%drink_color ) {</span>
<span class="cp">    while (($k, $v) = each %$substanceref) {</span>
<span class="cp">        if (exists $substance_color{$k}) {</span>
<span class="cp">            print &quot;Warning: $k seen twice.  Using the first definition.\n&quot;;</span>
<span class="cp">            next;</span>
<span class="cp">        }</span>
<span class="cp">        $substance_color{$k} = $v;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@all_colors{keys %new_colors} = values %new_colors;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my @common = ();</span>
<span class="cp">foreach (keys %hash1) {</span>
<span class="cp">    push(@common, $_) if exists $hash2{$_};</span>
<span class="cp">}</span>
<span class="cp"># @common now contains common keys</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my @this_not_that = ();</span>
<span class="cp">foreach (keys %hash1) {</span>
<span class="cp">    push(@this_not_that, $_) unless exists $hash2{$_};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %food_color per the introduction</span>

<span class="cp"># %citrus_color is a hash mapping citrus food name to its color.</span>
<span class="cp">%citrus_color = ( Lemon  =&gt; &quot;yellow&quot;,</span>
<span class="cp">                  Orange =&gt; &quot;orange&quot;,</span>
<span class="cp">                  Lime   =&gt; &quot;green&quot; );</span>

<span class="cp"># build up a list of non-citrus foods</span>
<span class="cp">@non_citrus = ();</span>

<span class="cp">foreach (keys %food_color) {</span>
<span class="cp">    push (@non_citrus, $_) unless exists $citrus_color{$_};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Tie::RefHash;</span>
<span class="cp">tie %hash, &quot;Tie::RefHash&quot;;</span>
<span class="cp"># you may now use references as the keys to %hash</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Class::Somewhere=HASH(0x72048)</span>
<span class="cp"># </span>
<span class="cp"># ARRAY(0x72048)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Tie::RefHash;</span>
<span class="cp">use IO::File;</span>

<span class="cp">tie %name, &quot;Tie::RefHash&quot;;</span>
<span class="cp">foreach $filename (&quot;/etc/termcap&quot;, &quot;/vmunix&quot;, &quot;/bin/cat&quot;) {</span>
<span class="cp">    $fh = IO::File-&gt;new(&quot;&lt; $filename&quot;) or next;</span>
<span class="cp">    $name{$fh} = $filename;</span>
<span class="cp">}</span>
<span class="cp">print &quot;open files: &quot;, join(&quot;, &quot;, values %name), &quot;\n&quot;;</span>
<span class="cp">foreach $file (keys %name) {</span>
<span class="cp">    seek($file, 0, 2);      # seek to the end</span>
<span class="cp">    printf(&quot;%s is %d bytes long.\n&quot;, $name{$file}, tell($file));</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># presize %hash to $num</span>
<span class="cp">keys(%hash) = $num;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># will have 512 users in %users</span>
<span class="cp">keys(%users) = 512;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">keys(%users) = 1000;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%count = ();</span>
<span class="cp">foreach $element (@ARRAY) {</span>
<span class="cp">    $count{$element}++;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%father = ( &#39;Cain&#39;      =&gt; &#39;Adam&#39;,</span>
<span class="cp">            &#39;Abel&#39;      =&gt; &#39;Adam&#39;,</span>
<span class="cp">            &#39;Seth&#39;      =&gt; &#39;Adam&#39;,</span>
<span class="cp">            &#39;Enoch&#39;     =&gt; &#39;Cain&#39;,</span>
<span class="cp">            &#39;Irad&#39;      =&gt; &#39;Enoch&#39;,</span>
<span class="cp">            &#39;Mehujael&#39;  =&gt; &#39;Irad&#39;,</span>
<span class="cp">            &#39;Methusael&#39; =&gt; &#39;Mehujael&#39;,</span>
<span class="cp">            &#39;Lamech&#39;    =&gt; &#39;Methusael&#39;,</span>
<span class="cp">            &#39;Jabal&#39;     =&gt; &#39;Lamech&#39;,</span>
<span class="cp">            &#39;Jubal&#39;     =&gt; &#39;Lamech&#39;,</span>
<span class="cp">            &#39;Tubalcain&#39; =&gt; &#39;Lamech&#39;,</span>
<span class="cp">            &#39;Enos&#39;      =&gt; &#39;Seth&#39; );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    chomp;</span>
<span class="cp">    do {</span>
<span class="cp">        print &quot;$_ &quot;;        # print the current name</span>
<span class="cp">        $_ = $father{$_};   # set $_ to $_&#39;s father</span>
<span class="cp">    } while defined;        # until we run out of fathers</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while ( ($k,$v) = each %father ) {</span>
<span class="cp">    push( @{ $children{$v} }, $k );</span>
<span class="cp">}</span>

<span class="cp">$&quot; = &#39;, &#39;;                  # separate output with commas</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    chomp;</span>
<span class="cp">    if ($children{$_}) {</span>
<span class="cp">        @children = @{$children{$_}};</span>
<span class="cp">    } else {</span>
<span class="cp">        @children = &quot;nobody&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    print &quot;$_ begat @children.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $file (@files) {</span>
<span class="cp">    local *F;               # just in case we want a local FH</span>
<span class="cp">    unless (open (F, &quot;&lt;$file&quot;)) {</span>
<span class="cp">        warn &quot;Couldn&#39;t read $file: $!; skipping.\n&quot;;</span>
<span class="cp">        next;</span>
<span class="cp">    }</span>
<span class="cp">    </span>
<span class="cp">    while (&lt;F&gt;) {</span>
<span class="cp">        next unless /^\s*#\s*include\s*&lt;([^&gt;]+)&gt;/;</span>
<span class="cp">        push(@{$includes{$1}}, $file);</span>
<span class="cp">    }</span>
<span class="cp">    close F;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@include_free = ();                 # list of files that don&#39;t include others</span>
<span class="cp">@uniq{map { @$_ } values %includes} = undef;</span>
<span class="cp">foreach $file (sort keys %uniq) {</span>
<span class="cp">        push( @include_free , $file ) unless $includes{$file};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_5.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% du pcb</span>
<span class="cp">#19      pcb/fix</span>
<span class="cp">#</span>
<span class="cp">#20      pcb/rev/maybe/yes</span>
<span class="cp">#</span>
<span class="cp">#10      pcb/rev/maybe/not</span>
<span class="cp">#</span>
<span class="cp">#705     pcb/rev/maybe</span>
<span class="cp">#</span>
<span class="cp">#54      pcb/rev/web</span>
<span class="cp">#</span>
<span class="cp">#1371    pcb/rev</span>
<span class="cp">#</span>
<span class="cp">#3       pcb/pending/mine</span>
<span class="cp">#</span>
<span class="cp">#1016    pcb/pending</span>
<span class="cp">#</span>
<span class="cp">#2412    pcb</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#2412 pcb</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|</span>
<span class="cp">#    1371 rev</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|       |</span>
<span class="cp">#    705 maybe</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|       |      |</span>
<span class="cp">#      675 .</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|       |      |</span>
<span class="cp">#	20 yes</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|       |      |</span>
<span class="cp">#	10 not</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|       |</span>
<span class="cp">#    612 .</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|       |</span>
<span class="cp">#     54 web</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|</span>
<span class="cp">#    1016 pending</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|       |</span>
<span class="cp">#	 1013 .</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|       |</span>
<span class="cp">#	    3 mine</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|</span>
<span class="cp">#      19 fix</span>
<span class="cp">#</span>
<span class="cp">#   </span>
<span class="cp">#|</span>
<span class="cp">#	6 .</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% dutree</span>
<span class="cp">#% dutree /usr</span>
<span class="cp">#% dutree -a </span>
<span class="cp">#% dutree -a /bin</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch05/dutree</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># dutree - print sorted indented rendition of du output</span>
<span class="cp">use strict;</span>

<span class="cp">my %Dirsize;</span>
<span class="cp">my %Kids;</span>

<span class="cp">getdots(my $topdir = input());</span>
<span class="cp">output($topdir);</span>

<span class="cp"># run du, read in input, save sizes and kids</span>
<span class="cp"># return last directory (file?) read</span>
<span class="cp">sub input { </span>
<span class="cp">    my($size, $name, $parent);</span>
<span class="cp">    @ARGV = (&quot;du @ARGV |&quot;);         # prep the arguments</span>
<span class="cp">    while (&lt;&gt;) {                    # magic open is our friend</span>
<span class="cp">        ($size, $name) = split;</span>
<span class="cp">        $Dirsize{$name} = $size;</span>
<span class="cp">        ($parent = $name) =~ s#/[^/]+$##;   # dirname</span>
<span class="cp">        push @{ $Kids{$parent} }, $name unless eof;</span>
<span class="cp">    } </span>
<span class="cp">    return $name;</span>
<span class="cp">}</span>

<span class="cp"># figure out how much is taken up in each directory</span>
<span class="cp"># that isn&#39;t stored in subdirectories.  add a new</span>
<span class="cp"># fake kid called &quot;.&quot; containing that much.</span>
<span class="cp">sub getdots {</span>
<span class="cp">    my $root = $_[0];</span>
<span class="cp">    my($size, $cursize);</span>
<span class="cp">    $size = $cursize = $Dirsize{$root};</span>
<span class="cp">    if ($Kids{$root}) {</span>
<span class="cp">        for my $kid (@{ $Kids{$root} }) { </span>
<span class="cp">            $cursize -= $Dirsize{$kid};</span>
<span class="cp">            getdots($kid);</span>
<span class="cp">        }</span>
<span class="cp">    } </span>
<span class="cp">    if ($size != $cursize) {</span>
<span class="cp">        my $dot = &quot;$root/.&quot;;</span>
<span class="cp">        $Dirsize{$dot} = $cursize;</span>
<span class="cp">        push @{ $Kids{$root} }, $dot;</span>
<span class="cp">    } </span>
<span class="cp">} </span>

<span class="cp"># recursively output everything,</span>
<span class="cp"># passing padding and number width in as well</span>
<span class="cp"># on recursive calls</span>
<span class="cp">sub output {</span>
<span class="cp">    my($root, $prefix, $width) = (shift, shift || &#39;&#39;, shift || 0);</span>
<span class="cp">    my $path;</span>
<span class="cp">    ($path = $root) =~ s#.*/##;     # basename</span>
<span class="cp">    my $size = $Dirsize{$root};</span>
<span class="cp">    my $line = sprintf(&quot;%${width}d %s&quot;, $size, $path);</span>
<span class="cp">    print $prefix, $line, &quot;\n&quot;;</span>
<span class="cp">    for ($prefix .= $line) {        # build up more output</span>
<span class="cp">        s/\d /| /;</span>
<span class="cp">        s/[^|]/ /g;</span>
<span class="cp">    }</span>
<span class="cp">    if ($Kids{$root}) {             # not a bachelor node</span>
<span class="cp">        my @Kids = @{ $Kids{$root} };</span>
<span class="cp">        @Kids = sort { $Dirsize{$b} &lt;=&gt; $Dirsize{$a} } @Kids;</span>
<span class="cp">        $Dirsize{$Kids[0]} =~ /(\d+)/;</span>
<span class="cp">        my $width = length $1;</span>
<span class="cp">        for my $kid (@Kids) { output($kid, $prefix, $width) }</span>
<span class="cp">    }</span>
<span class="cp">} </span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch05/dutree-orig</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># dutree_orig: the old version pre-perl5 (early 90s)</span>

<span class="cp">@lines = `du @ARGV`;</span>
<span class="cp">chop(@lines);</span>
<span class="cp">&amp;input($top = pop @lines);</span>
<span class="cp">&amp;output($top);</span>
<span class="cp">exit;</span>

<span class="cp">sub input {</span>
<span class="cp">    local($root, *kid, $him) = @_[0,0];</span>
<span class="cp">    while (@lines &amp;&amp; &amp;childof($root, $lines[$#lines])) {</span>
<span class="cp">        &amp;input($him = pop(@lines));</span>
<span class="cp">        push(@kid, $him);</span>
<span class="cp">    i} </span>
<span class="cp">    if (@kid) {</span>
<span class="cp">        local($mysize) = ($root =~ /^(\d+)/);</span>
<span class="cp">        for (@kid) { $mysize -= (/^(\d+)/)[0]; } </span>
<span class="cp">        push(@kid, &quot;$mysize .&quot;) if $size != $mysize;</span>
<span class="cp">    } </span>
<span class="cp">    @kid = &amp;sizesort(*kid);</span>
<span class="cp">} </span>

<span class="cp">sub output {</span>
<span class="cp">    local($root, *kid, $prefix) = @_[0,0,1];</span>
<span class="cp">    local($size, $path) = split(&#39; &#39;, $root);</span>
<span class="cp">    $path =~ s!.*/!!;</span>
<span class="cp">    $line = sprintf(&quot;%${width}d %s&quot;, $size, $path);</span>
<span class="cp">    print $prefix, $line, &quot;\n&quot;;</span>
<span class="cp">    $prefix .= $line;</span>
<span class="cp">    $prefix =~ s/\d /| /;</span>
<span class="cp">    $prefix =~ s/[^|]/ /g;</span>
<span class="cp">    local($width) = $kid[0] =~ /(\d+)/ &amp;&amp; length(&quot;$1&quot;);</span>
<span class="cp">    for (@kid) { &amp;output($_, $prefix); };</span>
<span class="cp">} </span>

<span class="cp">sub sizesort {</span>
<span class="cp">    local(*list, @index) = shift;</span>
<span class="cp">    sub bynum { $index[$b] &lt;=&gt; $index[$a]; }</span>
<span class="cp">    for (@list) { push(@index, /(\d+)/); } </span>
<span class="cp">    @list[sort bynum 0..$#list];</span>
<span class="cp">} </span>

<span class="cp">sub childof {</span>
<span class="cp">    local(@pair) = @_;</span>
<span class="cp">    for (@pair) { s/^\d+\s+//g; s/$/\//; }          </span>
<span class="cp">    index($pair[1], $pair[0]) &gt;= 0;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">match( $string, $pattern );</span>
<span class="cp">subst( $string, $pattern, $replacement );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$meadow =~ m/sheep/;   # True if $meadow contains &quot;sheep&quot;</span>
<span class="cp">$meadow !~ m/sheep/;   # True if $meadow doesn&#39;t contain &quot;sheep&quot;</span>
<span class="cp">$meadow =~ s/old/new/; # Replace &quot;old&quot; with &quot;new&quot; in $meadow</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Fine bovines demand fine toreadors.</span>
<span class="cp"># Muskoxen are a polar ovibovine species.</span>
<span class="cp"># Grooviness went out of fashion decades ago.</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Ovines are found typically in oviaries.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($meadow =~ /\bovines?\b/i) { print &quot;Here be sheep!&quot; }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$string = &quot;good food&quot;;</span>
<span class="cp">$string =~ s/o*/e/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># good food</span>
<span class="cp"># </span>
<span class="cp"># geod food</span>
<span class="cp"># </span>
<span class="cp"># geed food</span>
<span class="cp"># </span>
<span class="cp"># geed feed</span>
<span class="cp"># </span>
<span class="cp"># ged food</span>
<span class="cp"># </span>
<span class="cp"># ged fed</span>
<span class="cp"># </span>
<span class="cp"># egood food</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% echo ababacaca | perl -ne &#39;print &quot;$&amp;\n&quot; if /(a|ba|b)+(a|ac)+/&#39;</span>
<span class="cp">#ababa</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% echo ababacaca | </span>
<span class="cp">#    awk &#39;match($0,/(a|ba|b)+(a|ac)+/) { print substr($0, RSTART, RLENGTH) }&#39;</span>
<span class="cp">#ababacaca</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (m/(\d+)/g) {</span>
<span class="cp">    print &quot;Found number $1\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@numbers = m/(\d+)/g;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$digits = &quot;123456789&quot;;</span>
<span class="cp">@nonlap = $digits =~ /(\d\d\d)/g;</span>
<span class="cp">@yeslap = $digits =~ /(?=(\d\d\d))/g;</span>
<span class="cp">print &quot;Non-overlapping:  @nonlap\n&quot;;</span>
<span class="cp">print &quot;Overlapping:      @yeslap\n&quot;;</span>
<span class="cp"># Non-overlapping:  123 456 789</span>

<span class="cp"># Overlapping:      123 234 345 456 567 678 789</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$string = &quot;And little lambs eat ivy&quot;;</span>
<span class="cp">$string =~ /l[^s]*s/;</span>
<span class="cp">print &quot;($`) ($&amp;) ($&#39;)\n&quot;;</span>
<span class="cp"># (And ) (little lambs) ( eat ivy)</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$dst = $src;</span>
<span class="cp">$dst =~ s/this/that/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($dst = $src) =~ s/this/that/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># strip to basename</span>
<span class="cp">($progname = $0)        =~ s!^.*/!!;</span>

<span class="cp"># Make All Words Title-Cased</span>
<span class="cp">($capword  = $word)     =~ s/(\w+)/\u\L$1/g;</span>

<span class="cp"># /usr/man/man3/foo.1 changes to /usr/man/cat3/foo.1</span>
<span class="cp">($catpage  = $manpage)  =~ s/man(?=\d)/cat/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@bindirs = qw( /usr/bin /bin /usr/local/bin );</span>
<span class="cp">for (@libdirs = @bindirs) { s/bin/lib/ }</span>
<span class="cp">print &quot;@libdirs\n&quot;;</span>
<span class="cp"># /usr/lib /lib /usr/local/lib</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($a =  $b) =~ s/x/y/g;      # copy $b and then change $a</span>
<span class="cp"> $a = ($b  =~ s/x/y/g);     # change $b, count goes in $a</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($var =~ /^[A-Za-z]+$/) {</span>
<span class="cp">    # it is purely alphabetic</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use locale;</span>
<span class="cp">if ($var =~ /^[^\W\d_]+$/) {</span>
<span class="cp">    print &quot;var is purely alphabetic\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use locale;</span>
<span class="cp">use POSIX &#39;locale_h&#39;;</span>

<span class="cp"># the following locale string might be different on your system</span>
<span class="cp">unless (setlocale(LC_ALL, &quot;fr_CA.ISO8859-1&quot;)) {</span>
<span class="cp">    die &quot;couldn&#39;t set locale to French Canadian\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">while (&lt;DATA&gt;) {</span>
<span class="cp">    chomp;</span>
<span class="cp">    if (/^[^\W\d_]+$/) {</span>
<span class="cp">        print &quot;$_: alphabetic\n&quot;;</span>
<span class="cp">    } else {</span>
<span class="cp">        print &quot;$_: line noise\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#__END__</span>
<span class="cp">#silly</span>
<span class="cp">#faade</span>
<span class="cp">#coperate</span>
<span class="cp">#nio</span>
<span class="cp">#Rene</span>
<span class="cp">#Molire</span>
<span class="cp">#hmoglobin</span>
<span class="cp">#nave</span>
<span class="cp">#tsch</span>
<span class="cp">#random!stuff#here</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#/\S+/               # as many non-whitespace bytes as possible</span>
<span class="cp">#/[A-Za-z&#39;-]+/       # as many letters, apostrophes, and hyphens</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#/\b([A-Za-z]+)\b/            # usually best</span>
<span class="cp">#/\s([A-Za-z]+)\s/            # fails at ends or w/ punctuation</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/resname</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -p</span>
<span class="cp"># resname - change all &quot;foo.bar.com&quot; style names in the input stream</span>
<span class="cp"># into &quot;foo.bar.com [204.148.40.9]&quot; (or whatever) instead</span>

<span class="cp">use Socket;                 # load inet_addr</span>
<span class="cp">s{                          #</span>
<span class="cp">    (                       # capture the hostname in $1</span>
<span class="cp">        (?:                 # these parens for grouping only</span>
<span class="cp">            (?! [-_]  )     # lookahead for neither underscore nor dash</span>
<span class="cp">            [\w-] +         # hostname component</span>
<span class="cp">            \.              # and the domain dot</span>
<span class="cp">        ) +                 # now repeat that whole thing a bunch of times</span>
<span class="cp">        [A-Za-z]            # next must be a letter</span>
<span class="cp">        [\w-] +             # now trailing domain part</span>
<span class="cp">    )                       # end of $1 capture</span>
<span class="cp">}{                          # replace with this:</span>
<span class="cp">    &quot;$1 &quot; .                 # the original bit, plus a space</span>
<span class="cp">           ( ($addr = gethostbyname($1))   # if we get an addr</span>
<span class="cp">            ? &quot;[&quot; . inet_ntoa($addr) . &quot;]&quot; #        format it</span>
<span class="cp">            : &quot;[???]&quot;                      # else mark dubious</span>
<span class="cp">           )</span>
<span class="cp">}gex;               # /g for global</span>
<span class="cp">                    # /e for execute</span>
<span class="cp">                    # /x for nice formatting</span>

<span class="cp">#-----------------------------</span>
<span class="cp">s/                  # replace</span>
<span class="cp">  \#                #   a pound sign</span>
<span class="cp">  (\w+)             #   the variable name</span>
<span class="cp">  \#                #   another pound sign</span>
<span class="cp">/${$1}/xg;          # with the value of the global variable</span>
<span class="cp">##-----------------------------</span>
<span class="cp">s/                  # replace</span>
<span class="cp">\#                  #   a pound sign</span>
<span class="cp">(\w+)               #   the variable name</span>
<span class="cp">\#                  #   another pound sign</span>
<span class="cp">/&#39;$&#39; . $1/xeeg;     # &#39; with the value of *any* variable</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># One fish two fish red fish blue fish</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$WANT = 3;</span>
<span class="cp">$count = 0;</span>
<span class="cp">while (/(\w+)\s+fish\b/gi) {</span>
<span class="cp">    if (++$count == $WANT) {</span>
<span class="cp">        print &quot;The third fish is a $1 one.\n&quot;;</span>
<span class="cp">        # Warning: don&#39;t `last&#39; out of this loop</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp"># The third fish is a red one.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/(?:\w+\s+fish\s+){2}(\w+)\s+fish/i;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># simple way with while loop</span>
<span class="cp">$count = 0;</span>
<span class="cp">while ($string =~ /PAT/g) {</span>
<span class="cp">    $count++;               # or whatever you&#39;d like to do here</span>
<span class="cp">}</span>

<span class="cp"># same thing with trailing while</span>
<span class="cp">$count = 0;</span>
<span class="cp">$count++ while $string =~ /PAT/g;</span>

<span class="cp"># or with for loop</span>
<span class="cp">for ($count = 0; $string =~ /PAT/g; $count++) { }</span>
<span class="cp">    </span>
<span class="cp"># Similar, but this time count overlapping matches</span>
<span class="cp">$count++ while $string =~ /(?=PAT)/g;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pond  = &#39;One fish two fish red fish blue fish&#39;;</span>

<span class="cp"># using a temporary</span>
<span class="cp">@colors = ($pond =~ /(\w+)\s+fish\b/gi);      # get all matches</span>
<span class="cp">$color  = $colors[2];                         # then the one we want</span>

<span class="cp"># or without a temporary array</span>
<span class="cp">$color = ( $pond =~ /(\w+)\s+fish\b/gi )[2];  # just grab element 3</span>

<span class="cp">print &quot;The third fish in the pond is $color.\n&quot;;</span>
<span class="cp"># The third fish in the pond is red.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$count = 0;</span>
<span class="cp">$_ = &#39;One fish two fish red fish blue fish&#39;;</span>
<span class="cp">@evens = grep { $count++ % 2 == 1 } /(\w+)\s+fish\b/gi;</span>
<span class="cp">print &quot;Even numbered fish are @evens.\n&quot;;</span>
<span class="cp"># Even numbered fish are two blue.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$count = 0;</span>
<span class="cp">s{</span>
<span class="cp">   \b               # makes next \w more efficient</span>
<span class="cp">   ( \w+ )          # this is what we&#39;ll be changing</span>
<span class="cp">   (</span>
<span class="cp">     \s+ fish \b</span>
<span class="cp">   )</span>
<span class="cp">}{</span>
<span class="cp">    if (++$count == 4) {</span>
<span class="cp">        &quot;sushi&quot; . $2;</span>
<span class="cp">    } else {</span>
<span class="cp">         $1   . $2;</span>
<span class="cp">    }</span>
<span class="cp">}gex;</span>
<span class="cp"># One fish two fish red fish sushi fish</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pond = &#39;One fish two fish red fish blue fish swim here.&#39;;</span>
<span class="cp">$color = ( $pond =~ /\b(\w+)\s+fish\b/gi )[-1];</span>
<span class="cp">print &quot;Last fish is $color.\n&quot;;</span>
<span class="cp"># Last fish is blue.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m{</span>
<span class="cp">    A               # find some pattern A</span>
<span class="cp">    (?!             # mustn&#39;t be able to find</span>
<span class="cp">        .*          # something</span>
<span class="cp">        A           # and A</span>
<span class="cp">    )</span>
<span class="cp">    $               # through the end of the string</span>
<span class="cp">}x</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pond = &#39;One fish two fish red fish blue fish swim here.&#39;;</span>
<span class="cp">if ($pond =~ m{</span>
<span class="cp">                    \b  (  \w+) \s+ fish \b</span>
<span class="cp">                (?! .* \b fish \b )</span>
<span class="cp">            }six )</span>
<span class="cp">{</span>
<span class="cp">    print &quot;Last fish is $1.\n&quot;;</span>
<span class="cp">} else {</span>
<span class="cp">    print &quot;Failed!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp"># Last fish is blue.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/killtags</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># killtags - very bad html tag killer</span>
<span class="cp">undef $/;           # each read is whole file</span>
<span class="cp">while (&lt;&gt;) {        # get one whole file at a time</span>
<span class="cp">    s/&lt;.*?&gt;//gs;    # strip tags (terribly)</span>
<span class="cp">    print;          # print file to STDOUT</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/headerfy</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># headerfy: change certain chapter headers to html</span>
<span class="cp">$/ = &#39;&#39;;</span>
<span class="cp">while ( &lt;&gt; ) {              # fetch a paragraph</span>
<span class="cp">    s{</span>
<span class="cp">        \A                  # start of record</span>
<span class="cp">        (                   # capture in $1</span>
<span class="cp">            Chapter         # text string</span>
<span class="cp">            \s+             # mandatory whitespace</span>
<span class="cp">            \d+             # decimal number</span>
<span class="cp">            \s*             # optional whitespace</span>
<span class="cp">            :               # a real colon</span>
<span class="cp">            . *             # anything not a newline till end of line</span>
<span class="cp">        )</span>
<span class="cp">    }{&lt;H1&gt;$1&lt;/H1&gt;}gx;</span>
<span class="cp">    print;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -00pe &#39;s{\A(Chapter\s+\d+\s*:.*)}{&lt;H1&gt;$1&lt;/H1&gt;}gx&#39; datafile</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = &#39;&#39;;            # paragraph read mode for readline access</span>
<span class="cp">while (&lt;ARGV&gt;) {</span>
<span class="cp">    while (m#^START(.*?)^END#sm) {  # /s makes . span line boundaries</span>
<span class="cp">                                    # /m makes ^ match near newlines</span>
<span class="cp">        print &quot;chunk $. in $ARGV has &lt;&lt;$1&gt;&gt;\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">undef $/;</span>
<span class="cp">@chunks = split(/pattern/, &lt;FILEHANDLE&gt;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># .Ch, .Se and .Ss divide chunks of STDIN</span>
<span class="cp">{</span>
<span class="cp">    local $/ = undef;</span>
<span class="cp">    @chunks = split(/^\.(Ch|Se|Ss)$/m, &lt;&gt;);</span>
<span class="cp">}</span>
<span class="cp">print &quot;I read &quot;, scalar(@chunks), &quot; chunks.\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    if (/BEGIN PATTERN/ .. /END PATTERN/) {</span>
<span class="cp">        # line falls between BEGIN and END in the</span>
<span class="cp">        # text, inclusive.</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    if ($FIRST_LINE_NUM .. $LAST_LINE_NUM) {</span>
<span class="cp">        # operate only between first and last line, inclusive.</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    if (/BEGIN PATTERN/ ... /END PATTERN/) {</span>
<span class="cp">        # line is between BEGIN and END on different lines</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    if ($FIRST_LINE_NUM ... $LAST_LINE_NUM) {</span>
<span class="cp">        # operate only between first and last line, but not same</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># command-line to print lines 15 through 17 inclusive (see below)</span>
<span class="cp">perl -ne &#39;print if 15 .. 17&#39; datafile</span>

<span class="cp"># print out all &lt;XMP&gt; .. &lt;/XMP&gt; displays from HTML doc</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    print if m#&lt;XMP&gt;#i .. m#&lt;/XMP&gt;#i;</span>
<span class="cp">}</span>
<span class="cp">    </span>
<span class="cp"># same, but as shell command</span>
<span class="cp"># perl -ne &#39;print if m#&lt;XMP&gt;#i .. m#&lt;/XMP&gt;#i&#39; document.html</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># perl -ne &#39;BEGIN { $top=3; $bottom=5 }  print if $top .. $bottom&#39; /etc/passwd        # previous command FAILS</span>
<span class="cp"># perl -ne &#39;BEGIN { $top=3; $bottom=5 } \</span>
<span class="cp">#     print if $. == $top .. $. ==     $bottom&#39; /etc/passwd    # works</span>
<span class="cp"># perl -ne &#39;print if 3 .. 5&#39; /etc/passwd   # also works</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print if /begin/ .. /end/;</span>
<span class="cp">print if /begin/ ... /end/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    $in_header =   1  .. /^$/;</span>
<span class="cp">    $in_body   = /^$/ .. eof();</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%seen = ();</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    next unless /^From:?\s/i .. /^$/;</span>
<span class="cp">    while (/([^&lt;&gt;(),;\s]+\@[^&lt;&gt;(),;\s]+)/g) {</span>
<span class="cp">        print &quot;$1\n&quot; unless $seen{$1}++;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub glob2pat {</span>
<span class="cp">    my $globstr = shift;</span>
<span class="cp">    my %patmap = (</span>
<span class="cp">	 &#39;*&#39; =&gt; &#39;.*&#39;,</span>
<span class="cp">	 &#39;?&#39; =&gt; &#39;.&#39;,</span>
<span class="cp">	 &#39;[&#39; =&gt; &#39;[&#39;,</span>
<span class="cp">	 &#39;]&#39; =&gt; &#39;]&#39;,</span>
<span class="cp">    );</span>
<span class="cp">    $globstr =~ s{(.)} { $patmap{$1} || &quot;\Q$1&quot; }ge;</span>
<span class="cp">    return &#39;^&#39; . $globstr . &#39;$&#39;; #&#39;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while ($line = &lt;&gt;) {</span>
<span class="cp">    if ($line =~ /$pattern/o) {</span>
<span class="cp">        # do something</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/popgrep1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># popgrep1 - grep for abbreviations of places that say &quot;pop&quot;</span>
<span class="cp"># version 1: slow but obvious way</span>
<span class="cp">@popstates = qw(CO ON MI WI MN);</span>
<span class="cp">LINE: while (defined($line = &lt;&gt;)) {</span>
<span class="cp">    for $state (@popstates) {</span>
<span class="cp">        if ($line =~ /\b$state\b/) {</span>
<span class="cp">            print; next LINE;</span>
<span class="cp">       }</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/popgrep2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># popgrep2 - grep for abbreviations of places that say &quot;pop&quot;</span>
<span class="cp"># version 2: eval strings; fast but hard to quote</span>
<span class="cp">@popstates = qw(CO ON MI WI MN);</span>
<span class="cp">$code = &#39;while (defined($line = &lt;&gt;)) {&#39;;</span>
<span class="cp">for $state (@popstates) {</span>
<span class="cp">    $code .= &quot;\tif (\$line =~ /\\b$state\\b/) { print \$line; next; }\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">$code .= &#39;}&#39;;</span>
<span class="cp">print &quot;CODE IS\n----\n$code\n----\n&quot; if 0;  # turn on to debug</span>
<span class="cp">eval $code;</span>
<span class="cp">die if $@;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">while (defined($line = &lt;&gt;)) {</span>
<span class="cp">     if ($line =~ /\bCO\b/) { print $line; next; }</span>
<span class="cp">     if ($line =~ /\bON\b/) { print $line; next; }</span>
<span class="cp">     if ($line =~ /\bMI\b/) { print $line; next; }</span>
<span class="cp">     if ($line =~ /\bWI\b/) { print $line; next; }</span>
<span class="cp">     if ($line =~ /\bMN\b/) { print $line; next; }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/popgrep3</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># popgrep3 - grep for abbreviations of places that say &quot;pop&quot;</span>
<span class="cp"># version 3: use build_match_func algorithm</span>
<span class="cp">@popstates = qw(CO ON MI WI MN);</span>
<span class="cp">    $expr = join(&#39;||&#39;, map { &quot;m/\\b\$popstates[$_]\\b/o&quot; } 0..$#popstates);</span>
<span class="cp">$match_any = eval &quot;sub { $expr }&quot;;</span>
<span class="cp">die if $@;</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    print if &amp;$match_any;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">sub {</span>
<span class="cp">      m/\b$popstates[0]\b/o || m/\b$popstates[1]\b/o ||</span>
<span class="cp">      m/\b$popstates[2]\b/o || m/\b$popstates[3]\b/o ||</span>
<span class="cp">      m/\b$popstates[4]\b/o</span>
<span class="cp">  }</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/grepauth</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># grepauth - print lines that mention both Tom and Nat</span>

<span class="cp">$multimatch = build_match_all(q/Tom/, q/Nat/);</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    print if &amp;$multimatch;</span>
<span class="cp">}</span>
<span class="cp">exit;</span>

<span class="cp">sub build_match_any { build_match_func(&#39;||&#39;, @_) }</span>
<span class="cp">sub build_match_all { build_match_func(&#39;&amp;&amp;&#39;, @_) }</span>
<span class="cp">sub build_match_func {</span>
<span class="cp">    my $condition = shift;</span>
<span class="cp">    my @pattern = @_;  # must be lexical variable, not dynamic one</span>
<span class="cp">    my $expr = join $condition =&gt; map { &quot;m/\$pattern[$_]/o&quot; } (0..$#pattern);</span>
<span class="cp">    my $match_func = eval &quot;sub { local \$_ = shift if \@_; $expr }&quot;;</span>
<span class="cp">    die if $@;  # propagate $@; this shouldn&#39;t happen!</span>
<span class="cp">    return $match_func;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/popgrep4</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># popgrep4 - grep for abbreviations of places that say &quot;pop&quot;</span>
<span class="cp"># version 4: use Regexp module</span>
<span class="cp">use Regexp;</span>
<span class="cp">@popstates = qw(CO ON MI WI MN);</span>
<span class="cp">@poppats   = map { Regexp-&gt;new( &#39;\b&#39; . $_ . &#39;\b&#39;) } @popstates;</span>
<span class="cp">while (defined($line = &lt;&gt;)) {</span>
<span class="cp">    for $patobj (@poppats) {</span>
<span class="cp">        print $line if $patobj-&gt;match($line);</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">do {</span>
<span class="cp">    print &quot;Pattern? &quot;;</span>
<span class="cp">    chomp($pat = &lt;&gt;);</span>
<span class="cp">    eval { &quot;&quot; =~ /$pat/ };</span>
<span class="cp">    warn &quot;INVALID PATTERN $@&quot; if $@;</span>
<span class="cp">} while $@;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub is_valid_pattern {</span>
<span class="cp">    my $pat = shift;</span>
<span class="cp">    return eval { &quot;&quot; =~ /$pat/; 1 } || 0;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/paragrep</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># paragrep - trivial paragraph grepper</span>
<span class="cp">die &quot;usage: $0 pat [files]\n&quot; unless @ARGV;</span>
<span class="cp">$/ = &#39;&#39;;</span>
<span class="cp">$pat = shift;</span>
<span class="cp">eval { &quot;&quot; =~ /$pat/; 1 }      or die &quot;$0: Bad pattern $pat: $@\n&quot;;</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    print &quot;$ARGV $.: $_&quot; if /$pat/o;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">$pat = &quot;You lose @{[ system(&#39;rm -rf *&#39;)]} big here&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$safe_pat = quotemeta($pat);</span>
<span class="cp">something() if /$safe_pat/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">something() if /\Q$pat/;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use locale;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/localeg</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># localeg - demonstrate locale effects</span>

<span class="cp">use locale;</span>
<span class="cp">use POSIX &#39;locale_h&#39;;</span>

<span class="cp">$name = &quot;andreas k\xF6nig&quot;;</span>
<span class="cp">@locale{qw(German English)} = qw(de_DE.ISO_8859-1 us-ascii);</span>
<span class="cp">setlocale(LC_CTYPE, $locale{English})</span>
<span class="cp">  or die &quot;Invalid locale $locale{English}&quot;;</span>
<span class="cp">@english_names = ();</span>
<span class="cp">while ($name =~ /\b(\w+)\b/g) {</span>
<span class="cp">        push(@english_names, ucfirst($1));</span>
<span class="cp">}</span>
<span class="cp">setlocale(LC_CTYPE, $locale{German})</span>
<span class="cp">  or die &quot;Invalid locale $locale{German}&quot;;</span>
<span class="cp">@german_names = ();</span>
<span class="cp">while ($name =~ /\b(\w+)\b/g) {</span>
<span class="cp">        push(@german_names, ucfirst($1));</span>
<span class="cp">}</span>
<span class="cp">print &quot;English names: @english_names\n&quot;;</span>
<span class="cp">print &quot;German names:  @german_names\n&quot;;</span>

<span class="cp">English names: Andreas K Nig</span>

<span class="cp">German names:  Andreas Knig</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use String::Approx qw(amatch);</span>

<span class="cp">if (amatch(&quot;PATTERN&quot;, @list)) {</span>
<span class="cp">    # matched</span>
<span class="cp">}</span>

<span class="cp">@matches = amatch(&quot;PATTERN&quot;, @list);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use String::Approx qw(amatch);</span>
<span class="cp">open(DICT, &quot;/usr/dict/words&quot;)               or die &quot;Can&#39;t open dict: $!&quot;;</span>
<span class="cp">while(&lt;DICT&gt;) {</span>
<span class="cp">    print if amatch(&quot;balast&quot;);</span>
<span class="cp">}</span>

<span class="cp">ballast</span>

<span class="cp">balustrade</span>

<span class="cp">blast</span>

<span class="cp">blastula</span>

<span class="cp">sandblast</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (/(\d+)/g) {</span>
<span class="cp">    print &quot;Found $1\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$n = &quot;   49 here&quot;;</span>
<span class="cp">$n =~ s/\G /0/g;</span>
<span class="cp">print $n;</span>
<span class="cp">00049 here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (/\G,?(\d+)/g) {</span>
<span class="cp">    print &quot;Found number $1\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$_ = &quot;The year 1752 lost 10 days on the 3rd of September&quot;;</span>

<span class="cp">while (/(\d+)/gc) {</span>
<span class="cp">    print &quot;Found number $1\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">if (/\G(\S+)/g) {</span>
<span class="cp">    print &quot;Found $1 after the last number.\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">#Found number 1752</span>
<span class="cp">#</span>
<span class="cp">#Found number 10</span>
<span class="cp">#</span>
<span class="cp">#Found number 3</span>
<span class="cp">#</span>
<span class="cp">#Found rd after the last number.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;The position in \$a is &quot;, pos($a);</span>
<span class="cp">pos($a) = 30;</span>
<span class="cp">print &quot;The position in \$_ is &quot;, pos;</span>
<span class="cp">pos = 30;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># greedy pattern</span>
<span class="cp">s/&lt;.*&gt;//gs;                     # try to remove tags, very badly</span>

<span class="cp"># non-greedy pattern</span>
<span class="cp">s/&lt;.*?&gt;//gs;                    # try to remove tags, still rather badly</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&lt;b&gt;&lt;i&gt;this&lt;/i&gt; and &lt;i&gt;that&lt;/i&gt; are important&lt;/b&gt; Oh, &lt;b&gt;&lt;i&gt;me too!&lt;/i&gt;&lt;/b&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m{ &lt;b&gt;&lt;i&gt;(.*?)&lt;/i&gt;&lt;/b&gt; }sx</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/BEGIN((?:(?!BEGIN).)*)END/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m{ &lt;b&gt;&lt;i&gt;(  (?: (?!&lt;/b&gt;|&lt;/i&gt;). )*  ) &lt;/i&gt;&lt;/b&gt; }sx</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m{ &lt;b&gt;&lt;i&gt;(  (?: (?!&lt;/[ib]&gt;). )*  ) &lt;/i&gt;&lt;/b&gt; }sx</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m{</span>
<span class="cp">    &lt;b&gt;&lt;i&gt; </span>
<span class="cp">    [^&lt;]*  # stuff not possibly bad, and not possibly the end.</span>
<span class="cp">    (?:</span>
<span class="cp"> # at this point, we can have &#39;&lt;&#39; if not part of something bad</span>
<span class="cp">     (?!  &lt;/?[ib]&gt;  )   # what we can&#39;t have</span>
<span class="cp">     &lt;                  # okay, so match the &#39;&lt;&#39;</span>
<span class="cp">     [^&lt;]*              # and continue with more safe stuff</span>
<span class="cp">    ) *</span>
<span class="cp">    &lt;/i&gt;&lt;/b&gt;</span>
<span class="cp"> }sx</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = &#39;&#39;;                      # paragrep mode</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    while ( m{</span>
<span class="cp">                \b            # start at a word boundary (begin letters)</span>
<span class="cp">                (\S+)         # find chunk of non-whitespace</span>
<span class="cp">                \b            # until another word boundary (end letters)</span>
<span class="cp">                (</span>
<span class="cp">                    \s+       # separated by some whitespace</span>
<span class="cp">                    \1        # and that very same chunk again</span>
<span class="cp">                    \b        # until another word boundary</span>
<span class="cp">                ) +           # one or more sets of those</span>
<span class="cp">             }xig</span>
<span class="cp">         )</span>
<span class="cp">    {</span>
<span class="cp">        print &quot;dup word &#39;$1&#39; at paragraph $.\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">This is a test</span>
<span class="cp">test of the duplicate word finder.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$a = &#39;nobody&#39;;</span>
<span class="cp">$b = &#39;bodysnatcher&#39;;</span>
<span class="cp">if (&quot;$a $b&quot; =~ /^(\w+)(\w+) \2(\w+)$/) {</span>
<span class="cp">    print &quot;$2 overlaps in $1-$2-$3\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">body overlaps in no-body-snatcher</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/^(\w+?)(\w+) \2(\w+)$/, </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/prime-pattern</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># prime_pattern -- find prime factors of argument using pattern matching</span>
<span class="cp">for ($N = (&#39;o&#39; x shift); $N =~ /^(oo+?)\1+$/; $N =~ s/$1/o/g) {</span>
<span class="cp">    print length($1), &quot; &quot;;</span>
<span class="cp">}</span>
<span class="cp">print length ($N), &quot;\n&quot;;</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># solve for 12x + 15y + 16z = 281, maximizing x</span>
<span class="cp">if (($X, $Y, $Z)  =</span>
<span class="cp">   ((&#39;o&#39; x 281)  =~ /^(o*)\1{11}(o*)\2{14}(o*)\3{15}$/))</span>
<span class="cp">{</span>
<span class="cp">    ($x, $y, $z) = (length($X), length($Y), length($Z));</span>
<span class="cp">    print &quot;One solution is: x=$x; y=$y; z=$z.\n&quot;;</span>
<span class="cp">} else {</span>
<span class="cp">    print &quot;No solution.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#One solution is: x=17; y=3; z=2.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">(&#39;o&#39; x 281)  =~ /^(o+)\1{11}(o+)\2{14}(o+)\3{15}$/;</span>
<span class="cp">#One solution is: x=17; y=3; z=2</span>

<span class="cp">(&#39;o&#39; x 281)  =~ /^(o*?)\1{11}(o*)\2{14}(o*)\3{15}$/;</span>
<span class="cp">#One solution is: x=0; y=7; z=11.</span>

<span class="cp">(&#39;o&#39; x 281)  =~ /^(o+?)\1{11}(o*)\2{14}(o*)\3{15}$/;</span>
<span class="cp">#One solution is: x=1; y=3; z=14.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp">chomp($pattern = &lt;CONFIG_FH&gt;);</span>
<span class="cp">if ( $data =~ /$pattern/ ) { ..... }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/ALPHA|BETA/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/^(?=.*ALPHA)(?=.*BETA)/s;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/ALPHA.*BETA|BETA.*ALPHA/s;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/^(?:(?!PAT).)*$/s;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/(?=^(?:(?!BAD).)*$)GOOD/s;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if (!($string =~ /pattern/)) { something() }   # ugly</span>
<span class="cp">if (  $string !~ /pattern/)  { something() }   # preferred</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($string =~ /pat1/ &amp;&amp; $string =~ /pat2/ ) { </span>
<span class="cp">something</span>
<span class="cp">() }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($string =~ /pat1/ || $string =~ /pat2/ ) { </span>
<span class="cp">something</span>
<span class="cp">() }</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/minigrep</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># minigrep - trivial grep</span>
<span class="cp">$pat = shift;</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    print if /$pat/o;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"> &quot;labelled&quot; =~ /^(?=.*bell)(?=.*lab)/s</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$string =~ /bell/ &amp;&amp; $string =~ /lab/</span>
<span class="cp">#-----------------------------</span>
<span class="cp"> if ($murray_hill =~ m{</span>
<span class="cp">             ^              # start of string</span>
<span class="cp">            (?=             # zero-width lookahead</span>
<span class="cp">                .*          # any amount of intervening stuff</span>
<span class="cp">                bell        # the desired bell string</span>
<span class="cp">            )               # rewind, since we were only looking</span>
<span class="cp">            (?=             # and do the same thing</span>
<span class="cp">                .*          # any amount of intervening stuff</span>
<span class="cp">                lab         # and the lab part</span>
<span class="cp">            )</span>
<span class="cp">         }sx )              # /s means . can match newline</span>
<span class="cp">{</span>
<span class="cp">    print &quot;Looks like Bell Labs might be in Murray Hill!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">&quot;labelled&quot; =~ /(?:^.*bell.*lab)|(?:^.*lab.*bell)/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$brand = &quot;labelled&quot;;</span>
<span class="cp">if ($brand =~ m{</span>
<span class="cp">        (?:                 # non-capturing grouper</span>
<span class="cp">            ^ .*?           # any amount of stuff at the front</span>
<span class="cp">              bell          # look for a bell</span>
<span class="cp">              .*?           # followed by any amount of anything</span>
<span class="cp">              lab           # look for a lab</span>
<span class="cp">          )                 # end grouper</span>
<span class="cp">    |                       # otherwise, try the other direction</span>
<span class="cp">        (?:                 # non-capturing grouper</span>
<span class="cp">            ^ .*?           # any amount of stuff at the front</span>
<span class="cp">              lab           # look for a lab</span>
<span class="cp">              .*?           # followed by any amount of anything</span>
<span class="cp">              bell          # followed by a bell</span>
<span class="cp">          )                 # end grouper</span>
<span class="cp">    }sx )                   # /s means . can match newline</span>
<span class="cp">{</span>
<span class="cp">    print &quot;Our brand has bell and lab separate.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$map =~ /^(?:(?!waldo).)*$/s</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($map =~ m{</span>
<span class="cp">        ^                   # start of string</span>
<span class="cp">        (?:                 # non-capturing grouper</span>
<span class="cp">            (?!             # look ahead negation</span>
<span class="cp">                waldo       # is he ahead of us now?</span>
<span class="cp">            )               # is so, the negation failed</span>
<span class="cp">            .               # any character (cuzza /s)</span>
<span class="cp">        ) *                 # repeat that grouping 0 or more</span>
<span class="cp">        $                   # through the end of the string</span>
<span class="cp">    }sx )                   # /s means . can match newline</span>
<span class="cp">{</span>
<span class="cp">    print &quot;There&#39;s no waldo here!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"> 7:15am  up 206 days, 13:30,  4 users,  load average: 1.04, 1.07, 1.04</span>

<span class="cp">USER     TTY      FROM              LOGIN@  IDLE   JCPU   PCPU  WHAT</span>

<span class="cp">tchrist  tty1                       5:16pm 36days 24:43   0.03s  xinit</span>

<span class="cp">tchrist  tty2                       5:19pm  6days  0.43s  0.43s  -tcsh</span>

<span class="cp">tchrist  ttyp0    chthon            7:58am  3days 23.44s  0.44s  -tcsh</span>

<span class="cp">gnat     ttyS4    coprolith         2:01pm 13:36m  0.30s  0.30s  -tcsh</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% w | minigrep &#39;^(?!.*ttyp).*tchrist&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m{</span>
<span class="cp">    ^                       # anchored to the start</span>
<span class="cp">    (?!                     # zero-width look-ahead assertion</span>
<span class="cp">        .*                  # any amount of anything (faster than .*?)</span>
<span class="cp">        ttyp                # the string you don&#39;t want to find</span>
<span class="cp">    )                       # end look-ahead negation; rewind to start</span>
<span class="cp">    .*                      # any amount of anything (faster than .*?)</span>
<span class="cp">    tchrist                 # now try to find Tom</span>
<span class="cp">}x</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% w | grep tchrist | grep -v ttyp</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% grep -i &#39;pattern&#39; files</span>
<span class="cp">#% minigrep &#39;(?i)pattern&#39; files</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $eucjp = q{                 # EUC-JP encoding subcomponents:</span>
<span class="cp">    [\x00-\x7F]                # ASCII/JIS-Roman (one-byte/character)</span>
<span class="cp">  | \x8E[\xA0-\xDF]            # half-width katakana (two bytes/char)</span>
<span class="cp">  | \x8F[\xA1-\xFE][\xA1-\xFE] # JIS X 0212-1990 (three bytes/char)</span>
<span class="cp">  | [\xA1-\xFE][\xA1-\xFE]     # JIS X 0208:1997 (two bytes/char)</span>
<span class="cp">};</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/^ (?: $eucjp )*?  \xC5\xEC\xB5\xFE/ox # Trying to find Tokyo</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/^ (  (?:eucjp)*? ) $Tokyo/$1$Osaka/ox</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/\G (  (?:eucjp)*? ) $Tokyo/$1$Osaka/gox</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@chars = /$eucjp/gox; # One character per list element</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">  my @chars = /$eucjp/gox; # One character per list element</span>
<span class="cp">  for my $char (@chars) {</span>
<span class="cp">    if (length($char) == 1) {</span>
<span class="cp">      # Do something interesting with this one-byte character</span>
<span class="cp">    } else {</span>
<span class="cp">      # Do something interesting with this multiple-byte character</span>
<span class="cp">    }</span>
<span class="cp">  }</span>
<span class="cp">  my $line = join(&quot;&quot;,@chars); # Glue list back together</span>
<span class="cp">  print $line;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$is_eucjp = m/^(?:$eucjp)*$/xo;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$is_eucjp = m/^(?:$eucjp)*$/xo;</span>
<span class="cp">$is_sjis  = m/^(?:$sjis)*$/xo;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">  my @chars = /$eucjp/gox; # One character per list element</span>
<span class="cp">  for my $euc (@chars) {</span>
<span class="cp">    my $uni = $euc2uni{$char};</span>
<span class="cp">    if (defined $uni) {</span>
<span class="cp">        $euc = $uni;</span>
<span class="cp">    } else {</span>
<span class="cp">        ## deal with unknown EUC-&gt;Unicode mapping here.</span>
<span class="cp">    }</span>
<span class="cp">  }</span>
<span class="cp">  my $line = join(&quot;&quot;,@chars);</span>
<span class="cp">  print $line;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp">1 while $addr =~ s/\([^()]*\)//g;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">Dear someuser@host.com,</span>

<span class="cp">Please confirm the mail address you gave us Wed May  6 09:38:41</span>
<span class="cp">MDT 1998 by replying to this message.  Include the string</span>
<span class="cp">&quot;Rumpelstiltskin&quot; in that reply, but spelled in reverse; that is,</span>
<span class="cp">start with &quot;Nik...&quot;.  Once this is done, your confirmed address will</span>
<span class="cp">be entered into our records.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.20</span>
<span class="cp">#-----------------------------</span>
<span class="cp">chomp($answer = &lt;&gt;);</span>
<span class="cp">if    (&quot;SEND&quot;  =~ /^\Q$answer/i) { print &quot;Action is send\n&quot;  }</span>
<span class="cp">elsif (&quot;STOP&quot;  =~ /^\Q$answer/i) { print &quot;Action is stop\n&quot;  }</span>
<span class="cp">elsif (&quot;ABORT&quot; =~ /^\Q$answer/i) { print &quot;Action is abort\n&quot; }</span>
<span class="cp">elsif (&quot;LIST&quot;  =~ /^\Q$answer/i) { print &quot;Action is list\n&quot;  }</span>
<span class="cp">elsif (&quot;EDIT&quot;  =~ /^\Q$answer/i) { print &quot;Action is edit\n&quot;  }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Text::Abbrev;</span>
<span class="cp">$href = abbrev qw(send abort list edit);</span>
<span class="cp">for (print &quot;Action: &quot;; &lt;&gt;; print &quot;Action: &quot;) {</span>
<span class="cp">    chomp;</span>
<span class="cp">    my $action = $href-&gt;{ lc($_) };</span>
<span class="cp">    print &quot;Action is $action\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$name = &#39;send&#39;;</span>
<span class="cp">&amp;$name();</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># assumes that &amp;invoke_editor, &amp;deliver_message,</span>
<span class="cp"># $file and $PAGER are defined somewhere else.</span>
<span class="cp">use Text::Abbrev;</span>
<span class="cp">my($href, %actions, $errors);</span>
<span class="cp">%actions = (</span>
<span class="cp">    &quot;edit&quot;  =&gt; \&amp;invoke_editor,</span>
<span class="cp">    &quot;send&quot;  =&gt; \&amp;deliver_message,</span>
<span class="cp">    &quot;list&quot;  =&gt; sub { system($PAGER, $file) },</span>
<span class="cp">    &quot;abort&quot; =&gt; sub {</span>
<span class="cp">                    print &quot;See ya!\n&quot;;</span>
<span class="cp">                    exit;</span>
<span class="cp">               },</span>
<span class="cp">    &quot;&quot;      =&gt; sub {</span>
<span class="cp">                    print &quot;Unknown command: $cmd\n&quot;;</span>
<span class="cp">                    $errors++;</span>
<span class="cp">               },</span>
<span class="cp">);</span>

<span class="cp">$href = abbrev(keys %actions);</span>

<span class="cp">local $_;</span>
<span class="cp">for (print &quot;Action: &quot;; &lt;&gt;; print &quot;Action: &quot;) {</span>
<span class="cp">    s/^\s+//;       # trim leading  white space</span>
<span class="cp">    s/\s+$//;       # trim trailing white space</span>
<span class="cp">    next unless $_;</span>
<span class="cp">    $actions-&gt;{ $href-&gt;{ lc($_) } }-&gt;();</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$abbreviation = lc($_);</span>
<span class="cp">$expansion    = $href-&gt;{$abbreviation};</span>
<span class="cp">$coderef      = $actions-&gt;{$expansion};</span>
<span class="cp">&amp;$coderef();</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.21</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% gunzip -c ~/mail/archive.gz | urlify &gt; archive.urlified</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% urlify ~/mail/*.inbox &gt; ~/allmail.urlified</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/urlify</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># urlify - wrap HTML links around URL-like constructs</span>

<span class="cp">$urls = &#39;(http|telnet|gopher|file|wais|ftp)&#39;;</span>
<span class="cp">$ltrs = &#39;\w&#39;;</span>
<span class="cp">$gunk = &#39;/#~:.?+=&amp;%@!\-&#39;;</span>
<span class="cp">$punc = &#39;.:?\-&#39;;</span>
<span class="cp">$any  = &quot;${ltrs}${gunk}${punc}&quot;;</span>

<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    s{</span>
<span class="cp">      \b                    # start at word boundary</span>
<span class="cp">      (                     # begin $1  {</span>
<span class="cp">       $urls     :          # need resource and a colon</span>
<span class="cp">       [$any] +?            # followed by on or more</span>
<span class="cp">                            #  of any valid character, but</span>
<span class="cp">                            #  be conservative and take only</span>
<span class="cp">                            #  what you need to....</span>
<span class="cp">      )                     # end   $1  }</span>
<span class="cp">      (?=                   # look-ahead non-consumptive assertion</span>
<span class="cp">       [$punc]*             # either 0 or more punctuation</span>
<span class="cp">       [^$any]              #   followed by a non-url char</span>
<span class="cp">       |                    # or else</span>
<span class="cp">       $                    #   then end of the string</span>
<span class="cp">      )</span>
<span class="cp">     }{&lt;A HREF=&quot;$1&quot;&gt;$1&lt;/A&gt;}igox;</span>
<span class="cp">    print;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.22</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% tcgrep -ril &#39;^From: .*kate&#39; ~/mail</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch06/tcgrep</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># tcgrep: tom christiansen&#39;s rewrite of grep</span>
<span class="cp"># v1.0: Thu Sep 30 16:24:43 MDT 1993</span>
<span class="cp"># v1.1: Fri Oct  1 08:33:43 MDT 1993</span>
<span class="cp"># v1.2: Fri Jul 26 13:37:02 CDT 1996</span>
<span class="cp"># v1.3: Sat Aug 30 14:21:47 CDT 1997</span>
<span class="cp"># v1.4: Mon May 18 16:17:48 EDT 1998</span>

<span class="cp">use strict;</span>
<span class="cp">                                  # globals</span>
<span class="cp">use vars qw($Me $Errors $Grand_Total $Mult %Compress $Matches);</span>

<span class="cp">my ($matcher, $opt);              # matcher - anon. sub to check for matches</span>
<span class="cp">                                  # opt - ref to hash w/ command line options</span>

<span class="cp">init();                           # initialize globals</span>

<span class="cp">($opt, $matcher) = parse_args();  # get command line options and patterns</span>

<span class="cp">matchfile($opt, $matcher, @ARGV); # process files</span>

<span class="cp">exit(2) if $Errors;</span>
<span class="cp">exit(0) if $Grand_Total;</span>
<span class="cp">exit(1);</span>

<span class="cp">###################################</span>

<span class="cp">sub init {</span>
<span class="cp">    ($Me = $0) =~ s!.*/!!;        # get basename of program, &quot;tcgrep&quot;</span>
<span class="cp">    $Errors = $Grand_Total = 0;   # initialize global counters</span>
<span class="cp">    $Mult = &quot;&quot;;                   # flag for multiple files in @ARGV</span>
<span class="cp">    $| = 1;                       # autoflush output</span>

<span class="cp">    %Compress = (                 # file extensions and program names</span>
<span class="cp">        z  =&gt; &#39;gzcat&#39;,            # for uncompressing</span>
<span class="cp">        gz =&gt; &#39;gzcat&#39;,</span>
<span class="cp">        Z  =&gt; &#39;zcat&#39;,</span>
<span class="cp">    );</span>
<span class="cp">}</span>

<span class="cp">###################################</span>

<span class="cp">sub usage {</span>
<span class="cp">        die &lt;&lt;EOF</span>
<span class="cp">usage: $Me [flags] [files]</span>

<span class="cp">Standard grep options:</span>
<span class="cp">        i   case insensitive</span>
<span class="cp">        n   number lines</span>
<span class="cp">        c   give count of lines matching</span>
<span class="cp">        C   ditto, but &gt;1 match per line possible</span>
<span class="cp">        w   word boundaries only</span>
<span class="cp">        s   silent mode</span>
<span class="cp">        x   exact matches only</span>
<span class="cp">        v   invert search sense (lines that DON&#39;T match)</span>
<span class="cp">        h   hide filenames</span>
<span class="cp">        e   expression (for exprs beginning with -)</span>
<span class="cp">        f   file with expressions</span>
<span class="cp">        l   list filenames matching</span>

<span class="cp">Specials:</span>
<span class="cp">        1   1 match per file</span>
<span class="cp">        H   highlight matches</span>
<span class="cp">        u   underline matches</span>
<span class="cp">        r   recursive on directories or dot if none</span>
<span class="cp">        t   process directories in &#39;ls -t&#39; order</span>
<span class="cp">        p   paragraph mode (default: line mode)</span>
<span class="cp">        P   ditto, but specify separator, e.g. -P &#39;%%\\n&#39;</span>
<span class="cp">        a   all files, not just plain text files</span>
<span class="cp">        q   quiet about failed file and dir opens</span>
<span class="cp">        T   trace files as opened</span>

<span class="cp">May use a TCGREP environment variable to set default options.</span>
<span class="cp">EOF</span>
<span class="cp">}</span>

<span class="cp">###################################</span>

<span class="cp">sub parse_args {</span>
<span class="cp">    use Getopt::Std;</span>

<span class="cp">    my ($optstring, $zeros, $nulls, %opt, $pattern, @patterns, $match_code);</span>
<span class="cp">    my ($SO, $SE);</span>

<span class="cp">    if ($_ = $ENV{TCGREP}) {      # get envariable TCGREP</span>
<span class="cp">        s/^([^\-])/-$1/;          # add leading - if missing</span>
<span class="cp">        unshift(@ARGV, $_);       # add TCGREP opt string to @ARGV</span>
<span class="cp">    }</span>

<span class="cp">    $optstring = &quot;incCwsxvhe:f:l1HurtpP:aqT&quot;;</span>

<span class="cp">    $zeros = &#39;inCwxvhelut&#39;;       # options to init to 0 (prevent warnings)</span>
<span class="cp">    $nulls = &#39;pP&#39;;                # options to init to &quot;&quot; (prevent warnings)</span>

<span class="cp">    @opt{ split //, $zeros } = ( 0 )  x length($zeros);</span>
<span class="cp">    @opt{ split //, $nulls } = ( &#39;&#39; ) x length($nulls);</span>

<span class="cp">    getopts($optstring, \%opt)              or usage();</span>

<span class="cp">    if ($opt{f}) {                # -f patfile</span>
<span class="cp">        open(PATFILE, $opt{f})          or die qq($Me: Can&#39;t open &#39;$opt{f}&#39;: $!);</span>

<span class="cp">                                  # make sure each pattern in file is valid</span>
<span class="cp">        while ( defined($pattern = &lt;PATFILE&gt;) ) {</span>
<span class="cp">            chomp $pattern;</span>
<span class="cp">            eval { &#39;foo&#39; =~ /$pattern/, 1 } or</span>
<span class="cp">                die &quot;$Me: $opt{f}:$.: bad pattern: $@&quot;;</span>
<span class="cp">            push @patterns, $pattern;</span>
<span class="cp">        }</span>
<span class="cp">        close PATFILE;</span>
<span class="cp">    }</span>
<span class="cp">    else {                        # make sure pattern is valid</span>
<span class="cp">        $pattern = $opt{e} || shift(@ARGV) || usage();</span>
<span class="cp">        eval { &#39;foo&#39; =~ /$pattern/, 1 } or</span>
<span class="cp">            die &quot;$Me: bad pattern: $@&quot;;</span>
<span class="cp">        @patterns = ($pattern);</span>
<span class="cp">    }</span>

<span class="cp">    if ($opt{H} || $opt{u}) {     # highlight or underline</span>
<span class="cp">        my $term = $ENV{TERM} || &#39;vt100&#39;;</span>
<span class="cp">        my $terminal;</span>

<span class="cp">        eval {                    # try to look up escapes for stand-out</span>
<span class="cp">            require POSIX;        # or underline via Term::Cap</span>
<span class="cp">            use Term::Cap;</span>

<span class="cp">            my $termios = POSIX::Termios-&gt;new();</span>
<span class="cp">            $termios-&gt;getattr;</span>
<span class="cp">            my $ospeed = $termios-&gt;getospeed;</span>

<span class="cp">            $terminal = Tgetent Term::Cap { TERM=&gt;undef, OSPEED=&gt;$ospeed }</span>
<span class="cp">        };</span>

<span class="cp">        unless ($@) {             # if successful, get escapes for either</span>
<span class="cp">            local $^W = 0;        # stand-out (-H) or underlined (-u)</span>
<span class="cp">            ($SO, $SE) = $opt{H}</span>
<span class="cp">                ? ($terminal-&gt;Tputs(&#39;so&#39;), $terminal-&gt;Tputs(&#39;se&#39;))</span>
<span class="cp">                : ($terminal-&gt;Tputs(&#39;us&#39;), $terminal-&gt;Tputs(&#39;ue&#39;));</span>
<span class="cp">        }</span>
<span class="cp">        else {                    # if use of Term::Cap fails,</span>
<span class="cp">            ($SO, $SE) = $opt{H}  # use tput command to get escapes</span>
<span class="cp">                ? (`tput -T $term smso`, `tput -T $term rmso`)</span>
<span class="cp">                : (`tput -T $term smul`, `tput -T $term rmul`)</span>
<span class="cp">        }</span>
<span class="cp">    }</span>

<span class="cp">    if ($opt{i}) {</span>
<span class="cp">        @patterns = map {&quot;(?i)$_&quot;} @patterns;</span>
<span class="cp">    }</span>

<span class="cp">    if ($opt{p} || $opt{P}) {</span>
<span class="cp">        @patterns = map {&quot;(?m)$_&quot;} @patterns;</span>
<span class="cp">    }</span>

<span class="cp">    $opt{p}   &amp;&amp; ($/ = &#39;&#39;);</span>
<span class="cp">    $opt{P}   &amp;&amp; ($/ = eval(qq(&quot;$opt{P}&quot;)));     # for -P &#39;%%\n&#39;</span>
<span class="cp">    $opt{w}   &amp;&amp; (@patterns = map {&#39;\b&#39; . $_ . &#39;\b&#39;} @patterns);</span>
<span class="cp">    $opt{&#39;x&#39;} &amp;&amp; (@patterns = map {&quot;^$_\$&quot;} @patterns);</span>
<span class="cp">    if (@ARGV) {</span>
<span class="cp">        $Mult = 1 if ($opt{r} || (@ARGV &gt; 1) || -d $ARGV[0]) &amp;&amp; !$opt{h};</span>
<span class="cp">    }</span>
<span class="cp">    $opt{1}   += $opt{l};                   # that&#39;s a one and an ell</span>
<span class="cp">    $opt{H}   += $opt{u};</span>
<span class="cp">    $opt{c}   += $opt{C};</span>
<span class="cp">    $opt{&#39;s&#39;} += $opt{c};</span>
<span class="cp">    $opt{1}   += $opt{&#39;s&#39;} &amp;&amp; !$opt{c};     # that&#39;s a one</span>

<span class="cp">    @ARGV = ($opt{r} ? &#39;.&#39; : &#39;-&#39;) unless @ARGV;</span>
<span class="cp">    $opt{r} = 1 if !$opt{r} &amp;&amp; grep(-d, @ARGV) == @ARGV;</span>

<span class="cp">    $match_code  = &#39;&#39;;</span>
<span class="cp">    $match_code .= &#39;study;&#39; if @patterns &gt; 5; # might speed things up a bit</span>

<span class="cp">    foreach (@patterns) { s(/)(\\/)g }</span>

<span class="cp">    if ($opt{H}) {</span>
<span class="cp">        foreach $pattern (@patterns) {</span>
<span class="cp">            $match_code .= &quot;\$Matches += s/($pattern)/${SO}\$1${SE}/g;&quot;;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">    elsif ($opt{v}) {</span>
<span class="cp">        foreach $pattern (@patterns) {</span>
<span class="cp">            $match_code .= &quot;\$Matches += !/$pattern/;&quot;;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">    elsif ($opt{C}) {</span>
<span class="cp">        foreach $pattern (@patterns) {</span>
<span class="cp">            $match_code .= &quot;\$Matches++ while /$pattern/g;&quot;;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">    else {</span>
<span class="cp">        foreach $pattern (@patterns) {</span>
<span class="cp">            $match_code .= &quot;\$Matches++ if /$pattern/;&quot;;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>

<span class="cp">    $matcher = eval &quot;sub { $match_code }&quot;;</span>
<span class="cp">    die if $@;</span>

<span class="cp">    return (\%opt, $matcher);</span>
<span class="cp">}</span>

<span class="cp">###################################</span>

<span class="cp">sub matchfile {</span>
<span class="cp">    $opt = shift;                 # reference to option hash</span>
<span class="cp">    $matcher = shift;             # reference to matching sub</span>

<span class="cp">    my ($file, @list, $total, $name);</span>
<span class="cp">    local($_);</span>
<span class="cp">    $total = 0;</span>

<span class="cp">FILE: while (defined ($file = shift(@_))) {</span>

<span class="cp">        if (-d $file) {</span>
<span class="cp">            if (-l $file &amp;&amp; @ARGV != 1) {</span>
<span class="cp">                warn &quot;$Me: \&quot;$file\&quot; is a symlink to a directory\n&quot;</span>
<span class="cp">                    if $opt-&gt;{T};</span>
<span class="cp">                next FILE;</span>
<span class="cp">            }</span>
<span class="cp">            if (!$opt-&gt;{r}) {</span>
<span class="cp">                warn &quot;$Me: \&quot;$file\&quot; is a directory, but no -r given\n&quot;</span>
<span class="cp">                    if $opt-&gt;{T};</span>
<span class="cp">                next FILE;</span>
<span class="cp">            }</span>
<span class="cp">            unless (opendir(DIR, $file)) {</span>
<span class="cp">                unless ($opt-&gt;{&#39;q&#39;}) {</span>
<span class="cp">                    warn &quot;$Me: can&#39;t opendir $file: $!\n&quot;;</span>
<span class="cp">                    $Errors++;</span>
<span class="cp">                }</span>
<span class="cp">                next FILE;</span>
<span class="cp">            }</span>
<span class="cp">            @list = ();</span>
<span class="cp">            for (readdir(DIR)) {</span>
<span class="cp">                push(@list, &quot;$file/$_&quot;) unless /^\.{1,2}$/;</span>
<span class="cp">            }</span>
<span class="cp">            closedir(DIR);</span>
<span class="cp">            if ($opt-&gt;{t}) {</span>
<span class="cp">                my (@dates);</span>
<span class="cp">                for (@list) { push(@dates, -M) }</span>
<span class="cp">                @list = @list[sort { $dates[$a] &lt;=&gt; $dates[$b] } 0..$#dates];</span>
<span class="cp">            }</span>
<span class="cp">            else {</span>
<span class="cp">                @list = sort @list;</span>
<span class="cp">            }</span>
<span class="cp">            matchfile($opt, $matcher, @list);    # process files</span>
<span class="cp">            next FILE;</span>
<span class="cp">        }</span>

<span class="cp">        if ($file eq &#39;-&#39;) {</span>
<span class="cp">            warn &quot;$Me: reading from stdin\n&quot; if -t STDIN &amp;&amp; !$opt-&gt;{&#39;q&#39;};</span>
<span class="cp">            $name = &#39;&lt;STDIN&gt;&#39;;</span>
<span class="cp">        }</span>
<span class="cp">        else {</span>
<span class="cp">            $name = $file;</span>
<span class="cp">            unless (-e $file) {</span>
<span class="cp">                warn qq($Me: file &quot;$file&quot; does not exist\n) unless $opt-&gt;{&#39;q&#39;};</span>
<span class="cp">                $Errors++;</span>
<span class="cp">                next FILE;</span>
<span class="cp">            }</span>
<span class="cp">            unless (-f $file || $opt-&gt;{a}) {</span>
<span class="cp">                warn qq($Me: skipping non-plain file &quot;$file&quot;\n) if $opt-&gt;{T};</span>
<span class="cp">                next FILE;</span>
<span class="cp">            }</span>

<span class="cp">            my ($ext) = $file =~ /\.([^.]+)$/;</span>
<span class="cp">            if (defined $ext &amp;&amp; exists $Compress{$ext}) {</span>
<span class="cp">                $file = &quot;$Compress{$ext} &lt;$file |&quot;;</span>
<span class="cp">            }</span>
<span class="cp">            elsif (! (-T $file  || $opt-&gt;{a})) {</span>
<span class="cp">                warn qq($Me: skipping binary file &quot;$file&quot;\n) if $opt-&gt;{T};</span>
<span class="cp">                next FILE;</span>
<span class="cp">            }</span>
<span class="cp">        }</span>

<span class="cp">        warn &quot;$Me: checking $file\n&quot; if $opt-&gt;{T};</span>

<span class="cp">        unless (open(FILE, $file)) {</span>
<span class="cp">            unless ($opt-&gt;{&#39;q&#39;}) {</span>
<span class="cp">                warn &quot;$Me: $file: $!\n&quot;;</span>
<span class="cp">                $Errors++;</span>
<span class="cp">            }</span>
<span class="cp">            next FILE;</span>
<span class="cp">        }</span>

<span class="cp">        $total = 0;</span>

<span class="cp">        $Matches = 0;</span>

<span class="cp">LINE:  while (&lt;FILE&gt;) {</span>
<span class="cp">            $Matches = 0;</span>
<span class="cp">    </span>
<span class="cp">            ##############</span>
<span class="cp">            &amp;{$matcher}();        # do it! (check for matches)</span>
<span class="cp">            ##############</span>

<span class="cp">            next LINE unless $Matches;</span>

<span class="cp">            $total += $Matches;</span>

<span class="cp">            if ($opt-&gt;{p} || $opt-&gt;{P}) {</span>
<span class="cp">                s/\n{2,}$/\n/ if $opt-&gt;{p};</span>
<span class="cp">                chomp         if $opt-&gt;{P};</span>
<span class="cp">            }</span>

<span class="cp">            print(&quot;$name\n&quot;), next FILE if $opt-&gt;{l};</span>

<span class="cp">            $opt-&gt;{&#39;s&#39;} || print $Mult &amp;&amp; &quot;$name:&quot;,</span>
<span class="cp">                $opt-&gt;{n} ? &quot;$.:&quot; : &quot;&quot;,</span>
<span class="cp">                $_,</span>
<span class="cp">                ($opt-&gt;{p} || $opt-&gt;{P}) &amp;&amp; (&#39;-&#39; x 20) . &quot;\n&quot;;</span>

<span class="cp">            next FILE if $opt-&gt;{1};                 # that&#39;s a one</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">    continue {</span>
<span class="cp">        print $Mult &amp;&amp; &quot;$name:&quot;, $total, &quot;\n&quot; if $opt-&gt;{c};</span>
<span class="cp">    }</span>
<span class="cp">    $Grand_Total += $total;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_6.23</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m/^m*(d?c{0,3}|c[dm])(l?x{0,3}|x[lc])(v?i{0,3}|i[vx])$/i</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s/(\S+)(\s+)(\S+)/$3$2$1/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m/(\w+)\s*=\s*(.*)\s*$/             # keyword is $1, value is $2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m/.{80,}/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m|(\d+)/(\d+)/(\d+) (\d+):(\d+):(\d+)|</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s(/usr/bin)(/usr/local/bin)g</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s/%([0-9A-Fa-f][0-9A-Fa-f])/chr hex $1/ge</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s{</span>
<span class="cp">    /\*                    # Match the opening delimiter</span>
<span class="cp">    .*?                    # Match a minimal number of characters</span>
<span class="cp">    \*/                    # Match the closing delimiter</span>
<span class="cp">} []gsx;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s/^\s+//;</span>
<span class="cp">s/\s+$//;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s/\\n/\n/g;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s/^.*:://</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m/^([01]?\d\d|2[0-4]\d|25[0-5])\.([01]?\d\d|2[0-4]\d|25[0-5])\.</span>
<span class="cp">   ([01]?\d\d|2[0-4]\d|25[0-5])\.([01]?\d\d|2[0-4]\d|25[0-5])$/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s(^.*/)()</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$cols = ( ($ENV{TERMCAP} || &quot; &quot;) =~ m/:co#(\d+):/ ) ? $1 : 80;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($name = &quot; $0 @ARGV&quot;) =~ s, /\S+/, ,g;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">die &quot;This isn&#39;t Linux&quot; unless $^O =~ m/linux/i;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s/\n\s+/ /g</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@nums = m/(\d+\.?\d*|\.\d+)/g;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@capwords = m/(\b[^\Wa-z0-9_]+\b)/g;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lowords = m/(\b[^\WA-Z0-9_]+\b)/g;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@icwords = m/(\b[^\Wa-z0-9_][^\WA-Z0-9_]*\b)/;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@links = m/&lt;A[^&gt;]+?HREF\s*=\s*[&quot;&#39;]?([^&#39;&quot; &gt;]+?)[ &#39;&quot;]?&gt;/sig;   #&quot;&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($initial) = m/^\S+\s+(\S)\S*\s+\S/ ? $1 : &quot;&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">s/&quot;([^&quot;]*)&quot;/``$1&#39;&#39;/g   #&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{ local $/ = &quot;&quot;;</span>
<span class="cp">  while (&lt;&gt;) {</span>
<span class="cp">    s/\n/ /g;</span>
<span class="cp">    s/ {3,}/  /g;</span>
<span class="cp">    push @sentences, m/(\S.*?[!?.])(?=  |\Z)/g;</span>
<span class="cp">  }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m/(\d{4})-(\d\d)-(\d\d)/            # YYYY in $1, MM in $2, DD in $3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m/ ^</span>
<span class="cp">      (?:</span>
<span class="cp">       1 \s (?: \d\d\d \s)?            # 1, or 1 and area code</span>
<span class="cp">       |                               # ... or ...</span>
<span class="cp">       \(\d\d\d\) \s                   # area code with parens</span>
<span class="cp">       |                               # ... or ...</span>
<span class="cp">       (?: \+\d\d?\d? \s)?             # optional +country code</span>
<span class="cp">       \d\d\d ([\s\-])                 # and area code</span>
<span class="cp">      )</span>
<span class="cp">      \d\d\d (\s|\1)                   # prefix (and area code separator)</span>
<span class="cp">      \d\d\d\d                         # exchange</span>
<span class="cp">        $</span>
<span class="cp"> /x</span>
<span class="cp">#-----------------------------</span>
<span class="cp">m/\boh\s+my\s+gh?o(d(dess(es)?|s?)|odness|sh)\b/i</span>
<span class="cp">#-----------------------------</span>
<span class="cp">push(@lines, $1)</span>
<span class="cp">    while ($input =~ s/^([^\012\015]*)(\012\015?|\015\012?)//);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(INPUT, &quot;&lt; /usr/local/widgets/data&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open /usr/local/widgets/data for reading: $!\n&quot;;</span>

<span class="cp">while (&lt;INPUT&gt;) {</span>
<span class="cp">    print if /blue/;</span>
<span class="cp">}</span>
<span class="cp">close(INPUT);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$var = *STDIN;</span>
<span class="cp">mysub($var, *LOGFILE);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>

<span class="cp">$input = IO::File-&gt;new(&quot;&lt; /usr/local/widgets/data&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open /usr/local/widgets/data for reading: $!\n&quot;;</span>

<span class="cp">while (defined($line = $input-&gt;getline())) {</span>
<span class="cp">    chomp($line);</span>
<span class="cp">    STDOUT-&gt;print($line) if $line =~ /blue/;</span>
<span class="cp">}</span>
<span class="cp">$input-&gt;close();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;STDIN&gt;) {                   # reads from STDIN</span>
<span class="cp">    unless (/\d/) {</span>
<span class="cp">        warn &quot;No digit found.\n&quot;;   # writes to STDERR</span>
<span class="cp">    }</span>
<span class="cp">    print &quot;Read: &quot;, $_;             # writes to STDOUT</span>
<span class="cp">}</span>
<span class="cp">END { close(STDOUT)                 or die &quot;couldn&#39;t close STDOUT: $!&quot; }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(LOGFILE, &quot;&gt; /tmp/log&quot;)     or die &quot;Can&#39;t write /tmp/log: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">close(FH)           or die &quot;FH didn&#39;t close: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$old_fh = select(LOGFILE);                  # switch to LOGFILE for output</span>
<span class="cp">print &quot;Countdown initiated ...\n&quot;;</span>
<span class="cp">select($old_fh);                            # return to original output</span>
<span class="cp">print &quot;You have 30 seconds to reach minimum safety distance.\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(SOURCE, &quot;&lt; $path&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for reading: $!\n&quot;;</span>

<span class="cp">open(SINK, &quot;&gt; $path&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for writing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;</span>

<span class="cp">sysopen(SOURCE, $path, O_RDONLY)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for reading: $!\n&quot;;</span>

<span class="cp">sysopen(SINK, $path, O_WRONLY)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for writing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>

<span class="cp"># like Perl&#39;s open</span>
<span class="cp">$fh = IO::File-&gt;new(&quot;&gt; $filename&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $filename for writing: $!\n&quot;;</span>

<span class="cp"># like Perl&#39;s sysopen</span>
<span class="cp">$fh = IO::File-&gt;new($filename, O_WRONLY|O_CREAT)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $filename for writing: $!\n&quot;;</span>

<span class="cp"># like stdio&#39;s fopen(3)</span>
<span class="cp">$fh = IO::File-&gt;new($filename, &quot;r+&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $filename for read and write: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FILEHANDLE, $name, $flags)         or die &quot;Can&#39;t open $name : $!&quot;;</span>
<span class="cp">sysopen(FILEHANDLE, $name, $flags, $perms) or die &quot;Can&#39;t open $name : $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;&lt; $path&quot;)                                 or die $!;</span>
<span class="cp">sysopen(FH, $path, O_RDONLY)                        or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;&gt; $path&quot;)                                 or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT)        or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT, 0600)  or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT)         or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT, 0600)   or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;&gt;&gt; $path&quot;)                                or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT)       or die $!;</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT, 0600) or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FH, $path, O_WRONLY|O_APPEND)               or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;+&lt; $path&quot;)                                or die $!;</span>
<span class="cp">sysopen(FH, $path, O_RDWR)                          or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FH, $path, O_RDWR|O_CREAT)                  or die $!;</span>
<span class="cp">sysopen(FH, $path, O_RDWR|O_CREAT, 0600)            or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT)           or die $!;</span>
<span class="cp">sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT, 0600)     or die $!;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$filename =~ s#^(\s)#./$1#;</span>
<span class="cp">open(HANDLE, &quot;&lt; $filename\0&quot;)          or die &quot;cannot open $filename : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sysopen(HANDLE, $filename, O_RDONLY)   or die &quot;cannot open $filename: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$filename = shift @ARGV;</span>
<span class="cp">open(INPUT, $filename)               or die &quot;Couldn&#39;t open $filename : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(OUTPUT, &quot;&gt;$filename&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $filename for writing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;                          # for file constants</span>

<span class="cp">sysopen(OUTPUT, $filename, O_WRONLY|O_TRUNC)</span>
<span class="cp">    or die &quot;Can&#39;t open $filename for writing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file =~ s#^(\s)#./$1#;</span>
<span class="cp">open(OUTPUT, &quot;&gt; $file\0&quot;)</span>
<span class="cp">        or die &quot;Couldn&#39;t open $file for OUTPUT : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$filename =~ s{ ^ ~ ( [^/]* ) }</span>
<span class="cp">              { $1</span>
<span class="cp">                    ? (getpwnam($1))[7]</span>
<span class="cp">                    : ( $ENV{HOME} || $ENV{LOGDIR}</span>
<span class="cp">                         || (getpwuid($&gt;))[7]</span>
<span class="cp">                       )</span>
<span class="cp">}ex;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#    ~user</span>
<span class="cp">#    ~user/blah</span>
<span class="cp">#    ~</span>
<span class="cp">#    ~/blah</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open($path, &quot;&lt; $path&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t open $path for reading : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Argument &quot;3\n&quot; isn&#39;t numeric in multiply at tallyweb line 16, &lt;LOG&gt; chunk 17.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Argument &quot;3\n&quot; isn&#39;t numeric in multiply at tallyweb</span>
<span class="cp">#</span>
<span class="cp">#    line 16, &lt;/usr/local/data/mylog3.dat&gt; chunk 17.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>

<span class="cp">$fh = IO::File-&gt;new_tmpfile</span>
<span class="cp">        or die &quot;Unable to make new temporary file: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>
<span class="cp">use POSIX qw(tmpnam);</span>

<span class="cp"># try new temporary filenames until we get one that didn&#39;t already exist</span>
<span class="cp">do { $name = tmpnam() }</span>
<span class="cp">    until $fh = IO::File-&gt;new($name, O_RDWR|O_CREAT|O_EXCL);</span>

<span class="cp"># install atexit-style handler so that when we exit or die,</span>
<span class="cp"># we automatically delete this temporary file</span>
<span class="cp">END { unlink($name) or die &quot;Couldn&#39;t unlink $name : $!&quot; }</span>

<span class="cp"># now go on to use the file ...</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for (;;) {</span>
<span class="cp">    $name = tmpnam();</span>
<span class="cp">    sysopen(TMP, $tmpnam, O_RDWR | O_CREAT | O_EXCL) &amp;&amp; last;</span>
<span class="cp">}</span>
<span class="cp">unlink $tmpnam;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::File;</span>

<span class="cp">$fh = IO::File-&gt;new_tmpfile             or die &quot;IO::File-&gt;new_tmpfile: $!&quot;;</span>
<span class="cp">$fh-&gt;autoflush(1);</span>
<span class="cp">print $fh &quot;$i\n&quot; while $i++ &lt; 10;</span>
<span class="cp">seek($fh, 0, 0)                         or die &quot;seek: $!&quot;;</span>
<span class="cp">print &quot;Tmp file has: &quot;, &lt;$fh&gt;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;DATA&gt;) {</span>
<span class="cp">    # process the line</span>
<span class="cp">}</span>
<span class="cp">#__DATA__</span>
<span class="cp"># your data goes here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;main::DATA&gt;) {</span>
<span class="cp">    # process the line</span>
<span class="cp">}</span>
<span class="cp">#__END__</span>
<span class="cp"># your data goes here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(strftime);</span>

<span class="cp">$raw_time = (stat(DATA))[9];</span>
<span class="cp">$size     = -s DATA;</span>
<span class="cp">$kilosize = int($size / 1024) . &#39;k&#39;;</span>

<span class="cp">print &quot;&lt;P&gt;Script size is $kilosize\n&quot;;</span>
<span class="cp">print strftime(&quot;&lt;P&gt;Last script update: %c (%Z)\n&quot;, localtime($raw_time));</span>

<span class="cp">#__DATA__</span>
<span class="cp">#DO NOT REMOVE THE PRECEDING LINE.</span>
<span class="cp">#Everything else in this file will be ignored.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    # do something with the line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    # ...</span>
<span class="cp"> }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unshift(@ARGV, &#39;-&#39;) unless @ARGV;</span>
<span class="cp">while ($ARGV = shift @ARGV) {</span>
<span class="cp">    unless (open(ARGV, $ARGV)) {</span>
<span class="cp">        warn &quot;Can&#39;t open $ARGV: $!\n&quot;;</span>
<span class="cp">        next;</span>
<span class="cp">    }</span>
<span class="cp">    while (defined($_ = &lt;ARGV&gt;)) {</span>
<span class="cp">        # ...</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ARGV = glob(&quot;*.[Cch]&quot;) unless @ARGV;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># arg demo 1: Process optional -c flag </span>
<span class="cp">if (@ARGV &amp;&amp; $ARGV[0] eq &#39;-c&#39;) { </span>
<span class="cp">    $chop_first++;</span>
<span class="cp">    shift;</span>
<span class="cp">}</span>

<span class="cp"># arg demo 2: Process optional -NUMBER flag    </span>
<span class="cp">if (@ARGV &amp;&amp; $ARGV[0] =~ /^-(\d+)$/) { </span>
<span class="cp">    $columns = $1; </span>
<span class="cp">    shift;</span>
<span class="cp">}</span>

<span class="cp"># arg demo 3: Process clustering -a, -i, -n, or -u flags     </span>
<span class="cp">while (@ARGV &amp;&amp; $ARGV[0] =~ /^-(.+)/ &amp;&amp; (shift, ($_ = $1), 1)) { </span>
<span class="cp">    next if /^$/; </span>
<span class="cp">    s/a// &amp;&amp; (++$append,      redo);</span>
<span class="cp">    s/i// &amp;&amp; (++$ignore_ints, redo); </span>
<span class="cp">    s/n// &amp;&amp; (++$nostdout,    redo); </span>
<span class="cp">    s/u// &amp;&amp; (++$unbuffer,    redo); </span>
<span class="cp">    die &quot;usage: $0 [-ainu] [filenames] ...\n&quot;;    </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">undef $/;		     </span>
<span class="cp">while (&lt;&gt;) { 	</span>
<span class="cp">    # $_ now has the complete contents of 	</span>
<span class="cp">    # the file whose name is in $ARGV     </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{     # create block for local 	</span>
<span class="cp">    local $/;         # record separator now undef 	</span>
<span class="cp">    while (&lt;&gt;) { 	    </span>
<span class="cp">        # do something; called functions still have 	    </span>
<span class="cp">        # undeffed version of $/ 	</span>
<span class="cp">    }     </span>
<span class="cp">}                     # $/ restored here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) { 	</span>
<span class="cp">    print &quot;$ARGV:$.:$_&quot;; 	</span>
<span class="cp">    close ARGV if eof;     </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/findlogin1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl   </span>
<span class="cp"># findlogin1 - print all lines containing the string &quot;login&quot;   </span>
<span class="cp">while (&lt;&gt;) {		# loop over files on command line 	</span>
<span class="cp">    print if /login/;     </span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/findlogin2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -n     </span>
<span class="cp"># findlogin2 - print all lines containing the string &quot;login&quot;     </span>
<span class="cp">print if /login/;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -ne &#39;print if /login/&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/lowercase1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># lowercase - turn all lines into lowercase</span>

<span class="cp">use locale;</span>
<span class="cp">while (&lt;&gt;) {                 # loop over lines on command line</span>
<span class="cp">    s/([^\W0-9_])/\l$1/g;    # change all letters to lowercase</span>
<span class="cp">    print;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/lowercase2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -p     </span>
<span class="cp"># lowercase - turn all lines into lowercase     </span>
<span class="cp">use locale;     </span>
<span class="cp">s/([^\W0-9_])/\l$1/g;	# change all letters to lowercase</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -Mlocale -pe &#39;s/([^\W0-9_])/\l$1/g&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/countchunks</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -n    </span>
<span class="cp"># countchunks - count how many words are used.    </span>
<span class="cp"># skip comments, and bail on file if _     _END_     _   </span>
<span class="cp"># or _     _DATA_     _ seen.    </span>
<span class="cp">for (split /\W+/) { </span>
<span class="cp">    next LINE if /^#/; </span>
<span class="cp">    close ARGV if /_     _(DATA|END)_     _/; </span>
<span class="cp">    $chunks++;     </span>
<span class="cp">}     </span>
<span class="cp">END { print &quot;Found $chunks chunks\n&quot; }</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#+0894382237</span>
<span class="cp">#less /etc/motd</span>
<span class="cp">#+0894382239</span>
<span class="cp">#vi ~/.exrc</span>
<span class="cp">#+0894382242</span>
<span class="cp">#date</span>
<span class="cp">#+0894382242</span>
<span class="cp">#who</span>
<span class="cp">#+0894382288</span>
<span class="cp">#telnet home</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -pe &#39;s/^#\+(\d+)\n/localtime($1) . &quot; &quot;/e&#39; </span>
<span class="cp">#Tue May  5 09:30:37 1998     less /etc/motd </span>
<span class="cp">#</span>
<span class="cp">#Tue May  5 09:30:39 1998     vi ~/.exrc </span>
<span class="cp">#</span>
<span class="cp">#Tue May  5 09:30:42 1998     date</span>
<span class="cp">#</span>
<span class="cp">#Tue May  5 09:30:42 1998     who </span>
<span class="cp">#</span>
<span class="cp">#Tue May  5 09:31:28 1998     telnet home</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(OLD, &quot;&lt; $old&quot;)         or die &quot;can&#39;t open $old: $!&quot;;</span>
<span class="cp">open(NEW, &quot;&gt; $new&quot;)         or die &quot;can&#39;t open $new: $!&quot;;</span>
<span class="cp">while (&lt;OLD&gt;) {</span>
<span class="cp">    # change $_, then...</span>
<span class="cp">    print NEW $_            or die &quot;can&#39;t write $new: $!&quot;;</span>
<span class="cp">}</span>
<span class="cp">close(OLD)                  or die &quot;can&#39;t close $old: $!&quot;;</span>
<span class="cp">close(NEW)                  or die &quot;can&#39;t close $new: $!&quot;;</span>
<span class="cp">rename($old, &quot;$old.orig&quot;)   or die &quot;can&#39;t rename $old to $old.orig: $!&quot;;</span>
<span class="cp">rename($new, $old)          or die &quot;can&#39;t rename $new to $old: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;OLD&gt;) {</span>
<span class="cp">    if ($. == 20) {</span>
<span class="cp">        print NEW &quot;Extra line 1\n&quot;;</span>
<span class="cp">        print NEW &quot;Extra line 2\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    print NEW $_;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;OLD&gt;) {</span>
<span class="cp">    next if 20 .. 30;</span>
<span class="cp">    print NEW $_;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -i.orig -p -e &#39;FILTER COMMAND&#39; file1 file2 file3 ...</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl -i.orig -p</span>
<span class="cp"># filter commands go here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -pi.orig -e &#39;s/DATE/localtime/e&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    if ($ARGV ne $oldargv) {           # are we at the next file?</span>
<span class="cp">        rename($ARGV, $ARGV . &#39;.orig&#39;);</span>
<span class="cp">        open(ARGVOUT, &quot;&gt;$ARGV&quot;);       # plus error check</span>
<span class="cp">        select(ARGVOUT);</span>
<span class="cp">        $oldargv = $ARGV;</span>
<span class="cp">    }</span>
<span class="cp">    s/DATE/localtime/e;</span>
<span class="cp">}</span>
<span class="cp">continue{</span>
<span class="cp">    print;</span>
<span class="cp">}</span>
<span class="cp">select (STDOUT);                      # restore default output</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Dear Sir/Madam/Ravenous Beast,</span>
<span class="cp">#    As of DATE, our records show your account</span>
<span class="cp">#is overdue.  Please settle by the end of the month.</span>
<span class="cp">#Yours in cheerful usury,</span>
<span class="cp">#    --A. Moneylender</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Dear Sir/Madam/Ravenous Beast,</span>
<span class="cp">#    As of Sat Apr 25 12:28:33 1998, our records show your account</span>
<span class="cp">#is overdue.  Please settle by the end of the month.</span>
<span class="cp">#Yours in cheerful usury,</span>
<span class="cp">#    --A. Moneylender</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -i.old -pe &#39;s{\bhisvar\b}{hervar}g&#39; *.[Cchy]</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># set up to iterate over the *.c files in the current directory,</span>
<span class="cp"># editing in place and saving the old file with a .orig extension</span>
<span class="cp">local $^I   = &#39;.orig&#39;;              # emulate  -i.orig</span>
<span class="cp">local @ARGV = glob(&quot;*.c&quot;);          # initialize list of files</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    if ($. == 1) {</span>
<span class="cp">        print &quot;This line should appear at the top of each file\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    s/\b(p)earl\b/${1}erl/ig;       # Correct typos, preserving case</span>
<span class="cp">    print;</span>
<span class="cp">} continue {close ARGV if eof} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;+&lt; FILE&quot;)                 or die &quot;Opening: $!&quot;;</span>
<span class="cp">@ARRAY = &lt;FH&gt;;</span>
<span class="cp"># change ARRAY here</span>
<span class="cp">seek(FH,0,0)                        or die &quot;Seeking: $!&quot;;</span>
<span class="cp">print FH @ARRAY                     or die &quot;Printing: $!&quot;;</span>
<span class="cp">truncate(FH,tell(FH))               or die &quot;Truncating: $!&quot;;</span>
<span class="cp">close(FH)                           or die &quot;Closing: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(F, &quot;+&lt; $infile&quot;)       or die &quot;can&#39;t read $infile: $!&quot;;</span>
<span class="cp">$out = &#39;&#39;;</span>
<span class="cp">while (&lt;F&gt;) {</span>
<span class="cp">    s/DATE/localtime/eg;</span>
<span class="cp">    $out .= $_;</span>
<span class="cp">}</span>
<span class="cp">seek(F, 0, 0)               or die &quot;can&#39;t seek to start of $infile: $!&quot;;</span>
<span class="cp">print F $out                or die &quot;can&#39;t print to $infile: $!&quot;;</span>
<span class="cp">truncate(F, tell(F))        or die &quot;can&#39;t truncate $infile: $!&quot;;</span>
<span class="cp">close(F)                    or die &quot;can&#39;t close $infile: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;+&lt; $path&quot;)                or die &quot;can&#39;t open $path: $!&quot;;</span>
<span class="cp">flock(FH, 2)                        or die &quot;can&#39;t flock $path: $!&quot;;</span>
<span class="cp"># update file, then...</span>
<span class="cp">close(FH)                           or die &quot;can&#39;t close $path: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub LOCK_SH()  { 1 }     #  Shared lock (for reading)</span>
<span class="cp">sub LOCK_EX()  { 2 }     #  Exclusive lock (for writing)</span>
<span class="cp">sub LOCK_NB()  { 4 }     #  Non-blocking request (don&#39;t stall)</span>
<span class="cp">sub LOCK_UN()  { 8 }     #  Free the lock (careful!)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unless (flock(FH, LOCK_EX|LOCK_NB)) {</span>
<span class="cp">    warn &quot;can&#39;t immediately write-lock the file ($!), blocking ...&quot;;</span>
<span class="cp">    unless (flock(FH, LOCK_EX)) {</span>
<span class="cp">        die &quot;can&#39;t get write-lock on numfile: $!&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($] &lt; 5.004) {                   # test Perl version number</span>
<span class="cp">     my $old_fh = select(FH);</span>
<span class="cp">     local $| = 1;                  # enable command buffering</span>
<span class="cp">     local $\ = &#39;&#39;;                 # clear output record separator</span>
<span class="cp">     print &quot;&quot;;                      # trigger output flush</span>
<span class="cp">     select($old_fh);               # restore previous filehandle</span>
<span class="cp">}</span>
<span class="cp">flock(FH, LOCK_UN);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl qw(:DEFAULT :flock);</span>

<span class="cp">sysopen(FH, &quot;numfile&quot;, O_RDWR|O_CREAT)</span>
<span class="cp">                                    or die &quot;can&#39;t open numfile: $!&quot;;</span>
<span class="cp">flock(FH, LOCK_EX)                  or die &quot;can&#39;t write-lock numfile: $!&quot;;</span>
<span class="cp"># Now we have acquired the lock, it&#39;s safe for I/O</span>
<span class="cp">$num = &lt;FH&gt; || 0;                   # DO NOT USE &quot;or&quot; THERE!!</span>
<span class="cp">seek(FH, 0, 0)                      or die &quot;can&#39;t rewind numfile : $!&quot;;</span>
<span class="cp">truncate(FH, 0)                     or die &quot;can&#39;t truncate numfile: $!&quot;;</span>
<span class="cp">print FH $num+1, &quot;\n&quot;               or die &quot;can&#39;t write numfile: $!&quot;;</span>
<span class="cp">close(FH)                           or die &quot;can&#39;t close numfile: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$old_fh = select(OUTPUT_HANDLE);</span>
<span class="cp">$| = 1;</span>
<span class="cp">select($old_fh);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Handle;</span>
<span class="cp">OUTPUT_HANDLE-&gt;autoflush(1);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/seeme</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># seeme - demo stdio output buffering</span>
<span class="cp">$| = (@ARGV &gt; 0);      # command buffered if arguments given</span>
<span class="cp">print &quot;Now you don&#39;t see it...&quot;;</span>
<span class="cp">sleep 2;</span>
<span class="cp">print &quot;now you do\n&quot;;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">    select((select(OUTPUT_HANDLE), $| = 1)[0]);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use FileHandle;</span>

<span class="cp">STDERR-&gt;autoflush;          # already unbuffered in stdio</span>
<span class="cp">$filehandle-&gt;autoflush(0);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Handle;</span>
<span class="cp"># assume REMOTE_CONN is an interactive socket handle,</span>
<span class="cp"># but DISK_FILE is a handle to a regular file.</span>
<span class="cp">autoflush REMOTE_CONN  1;           # unbuffer for clarity</span>
<span class="cp">autoflush DISK_FILE    0;           # buffer this for speed</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/getpcomidx</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># getpcomidx - fetch www.perl.com&#39;s index.html document</span>
<span class="cp">use IO::Socket;</span>
<span class="cp">$sock = new IO::Socket::INET (PeerAddr =&gt; &#39;www.perl.com&#39;,</span>
<span class="cp">                              PeerPort =&gt; &#39;http(80)&#39;);</span>
<span class="cp">die &quot;Couldn&#39;t create socket: $@&quot; unless $sock;</span>
<span class="cp"># the library doesn&#39;t support $! setting; it uses $@</span>

<span class="cp">$sock-&gt;autoflush(1);</span>

<span class="cp"># Mac *must* have \015\012\015\012 instead of \n\n here.</span>
<span class="cp"># It&#39;s a good idea for others, too, as that&#39;s the spec,</span>
<span class="cp"># but implementations are encouraged to accept &quot;\cJ\cJ&quot; too,</span>
<span class="cp"># and as far as we&#39;re seen, they do.</span>
<span class="cp">$sock-&gt;print(&quot;GET /index.html http/1.1\n\n&quot;);</span>
<span class="cp">$document = join(&#39;&#39;, $sock-&gt;getlines());</span>
<span class="cp">print &quot;DOC IS: $document\n&quot;;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$rin = &#39;&#39;;</span>
<span class="cp"># repeat next line for all filehandles to poll</span>
<span class="cp">vec($rin, fileno(FH1), 1) = 1;</span>
<span class="cp">vec($rin, fileno(FH2), 1) = 1;</span>
<span class="cp">vec($rin, fileno(FH3), 1) = 1;</span>

<span class="cp">$nfound = select($rout=$rin, undef, undef, 0);</span>
<span class="cp">if ($nfound) {</span>
<span class="cp">  # input waiting on one or more of those 3 filehandles</span>
<span class="cp">  if (vec($rout,fileno(FH1),1)) { </span>
<span class="cp">      # do something with FH1</span>
<span class="cp">  }</span>
<span class="cp">  if (vec($rout,fileno(FH2),1)) {</span>
<span class="cp">      # do something with FH2</span>
<span class="cp">  }</span>
<span class="cp">  if (vec($rout,fileno(FH3),1)) {</span>
<span class="cp">      # do something with FH3</span>
<span class="cp">  }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Select;</span>

<span class="cp">$select = IO::Select-&gt;new();</span>
<span class="cp"># repeat next line for all filehandles to poll</span>
<span class="cp">$select-&gt;add(*FILEHANDLE);</span>
<span class="cp">if (@ready = $select-&gt;can_read(0)) {</span>
<span class="cp">    # input waiting on the filehandles in @ready</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$rin = &#39;&#39;;</span>
<span class="cp">vec($rin, fileno(FILEHANDLE), 1) = 1;</span>
<span class="cp">$nfound = select($rin, undef, undef, 0);    # just check</span>
<span class="cp">if ($nfound) {</span>
<span class="cp">    $line = &lt;FILEHANDLE&gt;;</span>
<span class="cp">    print &quot;I read $line&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;</span>

<span class="cp">sysopen(MODEM, &quot;/dev/cua0&quot;, O_NONBLOCK|O_RDWR)</span>
<span class="cp">    or die &quot;Can&#39;t open modem: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;</span>

<span class="cp">$flags = &#39;&#39;;</span>
<span class="cp">fcntl(HANDLE, F_GETFL, $flags)</span>
<span class="cp">    or die &quot;Couldn&#39;t get flags for HANDLE : $!\n&quot;;</span>
<span class="cp">$flags |= O_NONBLOCK;</span>
<span class="cp">fcntl(HANDLE, F_SETFL, $flags)</span>
<span class="cp">    or die &quot;Couldn&#39;t set flags for HANDLE: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(:errno_h);</span>

<span class="cp">$rv = syswrite(HANDLE, $buffer, length $buffer);</span>
<span class="cp">if (!defined($rv) &amp;&amp; $! == EAGAIN) {</span>
<span class="cp">    # would block</span>
<span class="cp">} elsif ($rv != length $buffer) {</span>
<span class="cp">    # incomplete write</span>
<span class="cp">} else {</span>
<span class="cp">    # successfully wrote</span>
<span class="cp">}</span>

<span class="cp">$rv = sysread(HANDLE, $buffer, $BUFSIZ);</span>
<span class="cp">if (!defined($rv) &amp;&amp; $! == EAGAIN) {</span>
<span class="cp">    # would block</span>
<span class="cp">} else {</span>
<span class="cp">    # successfully read $rv bytes from HANDLE</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$size = pack(&quot;L&quot;, 0);</span>
<span class="cp">ioctl(FH, $FIONREAD, $size)     or die &quot;Couldn&#39;t call ioctl: $!\n&quot;;</span>
<span class="cp">$size = unpack(&quot;L&quot;, $size);</span>

<span class="cp"># $size bytes can be read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require &#39;sys/ioctl.ph&#39;;</span>

<span class="cp">$size = pack(&quot;L&quot;, 0);</span>
<span class="cp">ioctl(FH, FIONREAD(), $size)    or die &quot;Couldn&#39;t call ioctl: $!\n&quot;;</span>
<span class="cp">$size = unpack(&quot;L&quot;, $size);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% grep FIONREAD /usr/include/*/*</span>
<span class="cp">#/usr/include/asm/ioctls.h:#define FIONREAD      0x541B</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% cat &gt; fionread.c</span>
<span class="cp">##include &lt;sys/ioctl.h&gt;</span>
<span class="cp">#main() {</span>
<span class="cp">#</span>
<span class="cp">#    printf(&quot;%#08x\n&quot;, FIONREAD);</span>
<span class="cp">#}</span>
<span class="cp">#^D</span>
<span class="cp">#% cc -o fionread fionread</span>
<span class="cp">#% ./fionread</span>
<span class="cp">#0x4004667f</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$FIONREAD = 0x4004667f;         # XXX: opsys dependent</span>

<span class="cp">$size = pack(&quot;L&quot;, 0);</span>
<span class="cp">ioctl(FH, $FIONREAD, $size)     or die &quot;Couldn&#39;t call ioctl: $!\n&quot;;</span>
<span class="cp">$size = unpack(&quot;L&quot;, $size);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$variable = *FILEHANDLE;        # save in variable</span>
<span class="cp">subroutine(*FILEHANDLE);        # or pass directly</span>

<span class="cp">sub subroutine {</span>
<span class="cp">    my $fh = shift;</span>
<span class="cp">    print $fh &quot;Hello, filehandle!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use FileHandle;                   # make anon filehandle</span>
<span class="cp">$fh = FileHandle-&gt;new();</span>

<span class="cp">use IO::File;                     # 5.004 or higher</span>
<span class="cp">$fh = IO::File-&gt;new();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$fh_a = IO::File-&gt;new(&quot;&lt; /etc/motd&quot;)    or die &quot;open /etc/motd: $!&quot;;</span>
<span class="cp">$fh_b = *STDIN;</span>
<span class="cp">some_sub($fh_a, $fh_b);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub return_fh {             # make anon filehandle</span>
<span class="cp">    local *FH;              # must be local, not my</span>
<span class="cp">    # now open it if you want to, then...</span>
<span class="cp">    return *FH;</span>
<span class="cp">}</span>

<span class="cp">$handle = return_fh();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub accept_fh {</span>
<span class="cp">    my $fh = shift;</span>
<span class="cp">    print $fh &quot;Sending to indirect filehandle\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub accept_fh {</span>
<span class="cp">    local *FH = shift;</span>
<span class="cp">    print  FH &quot;Sending to localized filehandle\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">accept_fh(*STDOUT);</span>
<span class="cp">accept_fh($handle);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@fd = (*STDIN, *STDOUT, *STDERR);</span>
<span class="cp">print $fd[1] &quot;Type it: &quot;;                           # WRONG</span>
<span class="cp">$got = &lt;$fd[0]&gt;                                     # WRONG</span>
<span class="cp">print $fd[2] &quot;What was that: $got&quot;;                 # WRONG</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print  { $fd[1] } &quot;funny stuff\n&quot;;</span>
<span class="cp">printf { $fd[1] } &quot;Pity the poor %x.\n&quot;, 3_735_928_559;</span>
<span class="cp">Pity the poor deadbeef.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ok = -x &quot;/bin/cat&quot;;                </span>
<span class="cp">print { $ok ? $fd[1] : $fd[2] } &quot;cat stat $ok\n&quot;;</span>
<span class="cp">print { $fd[ 1 + ($ok || 0) ]  } &quot;cat stat $ok\n&quot;;           </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$got = readline($fd[0]);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use FileCache;</span>
<span class="cp">cacheout ($path);         # each time you use a filehandle</span>
<span class="cp">print $path &quot;output&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/splitwulog</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># splitwulog - split wuftpd log by authenticated user</span>
<span class="cp">use FileCache;</span>
<span class="cp">$outdir = &#39;/var/log/ftp/by-user&#39;;</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    unless (defined ($user = (split)[-4])) {</span>
<span class="cp">       warn &quot;Invalid line: $.\n&quot;;</span>
<span class="cp">       next;</span>
<span class="cp">    }</span>
<span class="cp">    $path = &quot;$outdir/$user&quot;;</span>
<span class="cp">    cacheout $path;</span>
<span class="cp">    print $path $_;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $filehandle (@FILEHANDLES) {</span>
<span class="cp">    print $filehandle $stuff_to_print;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(MANY, &quot;| tee file1 file2 file3 &gt; /dev/null&quot;)   or die $!;</span>
<span class="cp">print MANY &quot;data\n&quot;                                 or die $!;</span>
<span class="cp">close(MANY)                                         or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># `use strict&#39; complains about this one:</span>
<span class="cp">for $fh (&#39;FH1&#39;, &#39;FH2&#39;, &#39;FH3&#39;)   { print $fh &quot;whatever\n&quot; }</span>
<span class="cp"># but not this one:</span>
<span class="cp">for $fh (*FH1, *FH2, *FH3)      { print $fh &quot;whatever\n&quot; }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open (FH, &quot;| tee file1 file2 file3 &gt;/dev/null&quot;);</span>
<span class="cp">print FH &quot;whatever\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># make STDOUT go to three files, plus original STDOUT</span>
<span class="cp">open (STDOUT, &quot;| tee file1 file2 file3&quot;) or die &quot;Teeing off: $!\n&quot;;</span>
<span class="cp">print &quot;whatever\n&quot;                       or die &quot;Writing: $!\n&quot;;</span>
<span class="cp">close(STDOUT)                            or die &quot;Closing: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FH, &quot;&lt;&amp;=$FDNUM&quot;);      # open FH to the descriptor itself</span>
<span class="cp">open(FH, &quot;&lt;&amp;$FDNUM&quot;);       # open FH to a copy of the descriptor</span>

<span class="cp">use IO::Handle;</span>

<span class="cp">$fh-&gt;fdopen($FDNUM, &quot;r&quot;);   # open file descriptor 3 for reading</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Handle;</span>
<span class="cp">$fh = IO::Handle-&gt;new();</span>

<span class="cp">$fh-&gt;fdopen(3, &quot;r&quot;);            # open fd 3 for reading</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$fd = $ENV{MHCONTEXTFD};</span>
<span class="cp">open(MHCONTEXT, &quot;&lt;&amp;=$fd&quot;)   or die &quot;couldn&#39;t fdopen $fd: $!&quot;;</span>
<span class="cp"># after processing</span>
<span class="cp">close(MHCONTEXT)            or die &quot;couldn&#39;t close context file: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.20</span>
<span class="cp">#-----------------------------</span>
<span class="cp">*ALIAS = *ORIGINAL;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(OUTCOPY, &quot;&gt;&amp;STDOUT&quot;)   or die &quot;Couldn&#39;t dup STDOUT: $!&quot;;</span>
<span class="cp">open(INCOPY,  &quot;&lt;&amp;STDIN&quot; )   or die &quot;Couldn&#39;t dup STDIN : $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(OUTALIAS, &quot;&gt;&amp;=STDOUT&quot;) or die &quot;Couldn&#39;t alias STDOUT: $!&quot;;</span>
<span class="cp">open(INALIAS,  &quot;&lt;&amp;=STDIN&quot;)  or die &quot;Couldn&#39;t alias STDIN : $!&quot;;</span>
<span class="cp">open(BYNUMBER, &quot;&gt;&amp;=5&quot;)      or die &quot;Couldn&#39;t alias file descriptor 5: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># take copies of the file descriptors</span>
<span class="cp">open(OLDOUT, &quot;&gt;&amp;STDOUT&quot;);</span>
<span class="cp">open(OLDERR, &quot;&gt;&amp;STDERR&quot;);</span>

<span class="cp"># redirect stdout and stderr</span>
<span class="cp">open(STDOUT, &quot;&gt; /tmp/program.out&quot;)  or die &quot;Can&#39;t redirect stdout: $!&quot;;</span>
<span class="cp">open(STDERR, &quot;&gt;&amp;STDOUT&quot;)            or die &quot;Can&#39;t dup stdout: $!&quot;;</span>

<span class="cp"># run the program</span>
<span class="cp">system($joe_random_program);</span>

<span class="cp"># close the redirected filehandles</span>
<span class="cp">close(STDOUT)                       or die &quot;Can&#39;t close STDOUT: $!&quot;;</span>
<span class="cp">close(STDERR)                       or die &quot;Can&#39;t close STDERR: $!&quot;;</span>

<span class="cp"># restore stdout and stderr</span>
<span class="cp">open(STDERR, &quot;&gt;&amp;OLDERR&quot;)            or die &quot;Can&#39;t restore stderr: $!&quot;;</span>
<span class="cp">open(STDOUT, &quot;&gt;&amp;OLDOUT&quot;)            or die &quot;Can&#39;t restore stdout: $!&quot;;</span>

<span class="cp"># avoid leaks by closing the independent copies</span>
<span class="cp">close(OLDOUT)                       or die &quot;Can&#39;t close OLDOUT: $!&quot;;</span>
<span class="cp">close(OLDERR)                       or die &quot;Can&#39;t close OLDERR: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.21</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/drivelock</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># drivelock - demo File::LockDir module</span>
<span class="cp">use strict;</span>
<span class="cp">use File::LockDir;</span>
<span class="cp">$SIG{INT} = sub { die &quot;outta here\n&quot; };</span>
<span class="cp">$File::LockDir::Debug = 1;</span>
<span class="cp">my $path = shift                            or die &quot;usage: $0 &lt;path&gt;\n&quot;;</span>
<span class="cp">unless (nflock($path, 2)) {</span>
<span class="cp">    die &quot;couldn&#39;t lock $path in 2 seconds\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">sleep 100;</span>
<span class="cp">nunflock($path);</span>

<span class="cp">#-----------------------------</span>
<span class="cp">package File::LockDir;</span>
<span class="cp"># module to provide very basic filename-level</span>
<span class="cp"># locks.  No fancy systems calls.  In theory,</span>
<span class="cp"># directory info is sync&#39;d over NFS.  Not</span>
<span class="cp"># stress tested.</span>

<span class="cp">use strict;</span>

<span class="cp">use Exporter;</span>
<span class="cp">use vars qw(@ISA @EXPORT);</span>
<span class="cp">@ISA      = qw(Exporter);</span>
<span class="cp">@EXPORT   = qw(nflock nunflock);</span>

<span class="cp">use vars qw($Debug $Check);</span>
<span class="cp">$Debug  ||= 0;  # may be predefined</span>
<span class="cp">$Check  ||= 5;  # may be predefined</span>

<span class="cp">use Cwd;</span>
<span class="cp">use Fcntl;</span>
<span class="cp">use Sys::Hostname;</span>
<span class="cp">use File::Basename;</span>
<span class="cp">use File::stat;</span>
<span class="cp">use Carp;</span>

<span class="cp">my %Locked_Files = ();</span>

<span class="cp"># usage: nflock(FILE; NAPTILL)</span>
<span class="cp">sub nflock($;$) {</span>
<span class="cp">    my $pathname = shift;</span>
<span class="cp">    my $naptime  = shift || 0;</span>
<span class="cp">    my $lockname = name2lock($pathname);</span>
<span class="cp">    my $whosegot = &quot;$lockname/owner&quot;;</span>
<span class="cp">    my $start    = time();</span>
<span class="cp">    my $missed   = 0;</span>
<span class="cp">    local *OWNER;</span>

<span class="cp">    # if locking what I&#39;ve already locked, return</span>
<span class="cp">    if ($Locked_Files{$pathname}) {</span>
<span class="cp">        carp &quot;$pathname already locked&quot;;</span>
<span class="cp">        return 1</span>
<span class="cp">    }</span>

<span class="cp">    if (!-w dirname($pathname)) {</span>
<span class="cp">        croak &quot;can&#39;t write to directory of $pathname&quot;;</span>
<span class="cp">    }</span>

<span class="cp">    while (1) {</span>
<span class="cp">        last if mkdir($lockname, 0777);</span>
<span class="cp">        confess &quot;can&#39;t get $lockname: $!&quot; if $missed++ &gt; 10</span>
<span class="cp">                        &amp;&amp; !-d $lockname;</span>
<span class="cp">        if ($Debug) {{</span>
<span class="cp">            open(OWNER, &quot;&lt; $whosegot&quot;) || last; # exit &quot;if&quot;!</span>
<span class="cp">            my $lockee = &lt;OWNER&gt;;</span>
<span class="cp">            chomp($lockee);</span>
<span class="cp">            printf STDERR &quot;%s $0\[$$]: lock on %s held by %s\n&quot;,</span>
<span class="cp">                scalar(localtime), $pathname, $lockee;</span>
<span class="cp">            close OWNER;</span>
<span class="cp">        }}</span>
<span class="cp">        sleep $Check;</span>
<span class="cp">        return if $naptime &amp;&amp; time &gt; $start+$naptime;</span>
<span class="cp">    }</span>
<span class="cp">    sysopen(OWNER, $whosegot, O_WRONLY|O_CREAT|O_EXCL)</span>
<span class="cp">                            or croak &quot;can&#39;t create $whosegot: $!&quot;;</span>
<span class="cp">    printf OWNER &quot;$0\[$$] on %s since %s\n&quot;,</span>
<span class="cp">            hostname(), scalar(localtime);</span>
<span class="cp">    close(OWNER)                </span>
<span class="cp">        or croak &quot;close $whosegot: $!&quot;;</span>
<span class="cp">    $Locked_Files{$pathname}++;</span>
<span class="cp">    return 1;</span>
<span class="cp">}</span>

<span class="cp"># free the locked file</span>
<span class="cp">sub nunflock($) {</span>
<span class="cp">    my $pathname = shift;</span>
<span class="cp">    my $lockname = name2lock($pathname);</span>
<span class="cp">    my $whosegot = &quot;$lockname/owner&quot;;</span>
<span class="cp">    unlink($whosegot);</span>
<span class="cp">    carp &quot;releasing lock on $lockname&quot; if $Debug;</span>
<span class="cp">    delete $Locked_Files{$pathname};</span>
<span class="cp">    return rmdir($lockname);</span>
<span class="cp">}</span>

<span class="cp"># helper function</span>
<span class="cp">sub name2lock($) {</span>
<span class="cp">    my $pathname = shift;</span>
<span class="cp">    my $dir  = dirname($pathname);</span>
<span class="cp">    my $file = basename($pathname);</span>
<span class="cp">    $dir = getcwd() if $dir eq &#39;.&#39;;</span>
<span class="cp">    my $lockname = &quot;$dir/$file.LOCKDIR&quot;;</span>
<span class="cp">    return $lockname;</span>
<span class="cp">}</span>

<span class="cp"># anything forgotten?</span>
<span class="cp">END {</span>
<span class="cp">    for my $pathname (keys %Locked_Files) {</span>
<span class="cp">        my $lockname = name2lock($pathname);</span>
<span class="cp">        my $whosegot = &quot;$lockname/owner&quot;;</span>
<span class="cp">        carp &quot;releasing forgotten $lockname&quot;;</span>
<span class="cp">        unlink($whosegot);</span>
<span class="cp">        return rmdir($lockname);</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_7.22</span>
<span class="cp">#-----------------------------</span>
<span class="cp">4: 18584 was just here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">29: 24652 ZAPPED 24656</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% lockarea 5 &amp;</span>
<span class="cp">#% rep -1 &#39;cat /tmp/lkscreen&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch07/lockarea</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># lockarea - demo record locking with fcntl</span>

<span class="cp">use strict;</span>

<span class="cp">my $FORKS = shift || 1;</span>
<span class="cp">my $SLEEP = shift || 1;</span>

<span class="cp">use Fcntl;</span>
<span class="cp">use POSIX qw(:unistd_h :errno_h);</span>

<span class="cp">my $COLS = 80;</span>
<span class="cp">my $ROWS = 23;</span>

<span class="cp"># when&#39;s the last time you saw *this* mode used correctly?</span>
<span class="cp">open(FH, &quot;+&gt; /tmp/lkscreen&quot;)            or  die $!;</span>

<span class="cp">select(FH);</span>
<span class="cp">$| = 1;</span>
<span class="cp">select STDOUT;</span>

<span class="cp"># clear screen</span>
<span class="cp">for (1 .. $ROWS) {</span>
<span class="cp">        print FH &quot; &quot; x $COLS, &quot;\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">my $progenitor = $$;</span>
<span class="cp">fork while $FORKS-- &gt; 0;</span>

<span class="cp">print &quot;hello from $$\n&quot;;</span>

<span class="cp">if ($progenitor == $$) {</span>
<span class="cp">        $SIG{INT} = \&amp;genocide;</span>
<span class="cp">} else {</span>
<span class="cp">        $SIG{INT} = sub { die &quot;goodbye from $$&quot; };</span>
<span class="cp">}</span>

<span class="cp">while (1) {</span>
<span class="cp">        my $line_num = int rand($ROWS);</span>
<span class="cp">        my $line;</span>
<span class="cp">        my $n;</span>

<span class="cp">        # move to line</span>
<span class="cp">        seek(FH, $n = $line_num * ($COLS+1), SEEK_SET)              or next;</span>

<span class="cp">        # get lock</span>
<span class="cp">        my $place = tell(FH);</span>
<span class="cp">        my $him;</span>
<span class="cp">        next unless defined($him = lock(*FH, $place, $COLS));</span>

<span class="cp">        # read line</span>
<span class="cp">        read(FH, $line, $COLS) == $COLS                             or next;</span>
<span class="cp">        my $count = ($line =~ /(\d+)/) ? $1 : 0;</span>
<span class="cp">        $count++;</span>

<span class="cp">        # update line</span>
<span class="cp">        seek(FH, $place, 0)                                         or die $!;</span>
<span class="cp">        my $update = sprintf($him</span>
<span class="cp">                            ? &quot;%6d: %d ZAPPED %d&quot;</span>
<span class="cp">                            : &quot;%6d: %d was just here&quot;,</span>
<span class="cp">                        $count, $$, $him);</span>
<span class="cp">        my $start = int(rand($COLS - length($update)));</span>
<span class="cp">        die &quot;XXX&quot; if $start + length($update) &gt; $COLS;</span>
<span class="cp">        printf FH &quot;%*.*s\n&quot;, -$COLS, $COLS, &quot; &quot; x $start . $update;</span>

<span class="cp">        # release lock and go to sleep</span>
<span class="cp">        unlock(*FH, $place, $COLS);</span>
<span class="cp">        sleep $SLEEP if $SLEEP;</span>
<span class="cp">}</span>
<span class="cp">die &quot;NOT REACHED&quot;;                              # just in case</span>

<span class="cp"># lock($handle, $offset, $timeout) - get an fcntl lock</span>
<span class="cp">sub lock {</span>
<span class="cp">        my ($fh, $start, $till) = @_;</span>
<span class="cp">        ##print &quot;$$: Locking $start, $till\n&quot;;</span>
<span class="cp">        my $lock = struct_flock(F_WRLCK, SEEK_SET, $start, $till, 0);</span>
<span class="cp">        my $blocker = 0;</span>
<span class="cp">        unless (fcntl($fh, F_SETLK, $lock)) {</span>
<span class="cp">            die &quot;F_SETLK $$ @_: $!&quot; unless $! == EAGAIN || $! == EDEADLK;</span>
<span class="cp">            fcntl($fh, F_GETLK, $lock)          or die &quot;F_GETLK $$ @_: $!&quot;;</span>
<span class="cp">            $blocker = (struct_flock($lock))[-1];</span>
<span class="cp">            ##print &quot;lock $$ @_: waiting for $blocker\n&quot;;</span>
<span class="cp">            $lock = struct_flock(F_WRLCK, SEEK_SET, $start, $till, 0);</span>
<span class="cp">            unless (fcntl($fh, F_SETLKW, $lock)) {</span>
<span class="cp">                warn &quot;F_SETLKW $$ @_: $!\n&quot;;</span>
<span class="cp">                return;  # undef</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">        return $blocker;</span>
<span class="cp">}</span>

<span class="cp"># unlock($handle, $offset, $timeout) - release an fcntl lock</span>
<span class="cp">sub unlock {</span>
<span class="cp">        my ($fh, $start, $till) = @_;</span>
<span class="cp">        ##print &quot;$$: Unlocking $start, $till\n&quot;;</span>
<span class="cp">        my $lock = struct_flock(F_UNLCK, SEEK_SET, $start, $till, 0);</span>
<span class="cp">        fcntl($fh, F_SETLK, $lock) or die &quot;F_UNLCK $$ @_: $!&quot;;</span>
<span class="cp">}</span>

<span class="cp"># OS-dependent flock structures</span>

<span class="cp"># Linux struct flock</span>
<span class="cp">#   short l_type;</span>
<span class="cp">#   short l_whence;</span>
<span class="cp">#   off_t l_start;</span>
<span class="cp">#   off_t l_len;</span>
<span class="cp">#   pid_t l_pid;</span>
<span class="cp">BEGIN {</span>
<span class="cp">        # c2ph says: typedef=&#39;s2 l2 i&#39;, sizeof=16</span>
<span class="cp">        my $FLOCK_STRUCT = &#39;s s l l i&#39;;</span>

<span class="cp">        sub linux_flock {</span>
<span class="cp">            if (wantarray) {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid) =</span>
<span class="cp">                    unpack($FLOCK_STRUCT, $_[0]);</span>
<span class="cp">                return ($type, $whence, $start, $len, $pid);</span>
<span class="cp">            } else {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid) = @_;</span>
<span class="cp">                return pack($FLOCK_STRUCT,</span>
<span class="cp">                        $type, $whence, $start, $len, $pid);</span>
<span class="cp">            }</span>
<span class="cp">        }</span>

<span class="cp">}</span>

<span class="cp"># SunOS struct flock:</span>
<span class="cp">#   short   l_type;         /* F_RDLCK, F_WRLCK, or F_UNLCK */</span>
<span class="cp">#   short   l_whence;       /* flag to choose starting offset */</span>
<span class="cp">#   long    l_start;        /* relative offset, in bytes */</span>
<span class="cp">#   long    l_len;          /* length, in bytes; 0 means lock to EOF */</span>
<span class="cp">#   short   l_pid;          /* returned with F_GETLK */</span>
<span class="cp">#   short   l_xxx;          /* reserved for future use */</span>
<span class="cp">BEGIN {</span>
<span class="cp">        # c2ph says: typedef=&#39;s2 l2 s2&#39;, sizeof=16</span>
<span class="cp">        my $FLOCK_STRUCT = &#39;s s l l s s&#39;;</span>

<span class="cp">        sub sunos_flock {</span>
<span class="cp">            if (wantarray) {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid, $xxx) =</span>
<span class="cp">                    unpack($FLOCK_STRUCT, $_[0]);</span>
<span class="cp">                return ($type, $whence, $start, $len, $pid);</span>
<span class="cp">            } else {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid) = @_;</span>
<span class="cp">                return pack($FLOCK_STRUCT,</span>
<span class="cp">                        $type, $whence, $start, $len, $pid, 0);</span>
<span class="cp">            }</span>
<span class="cp">        }</span>

<span class="cp">}</span>

<span class="cp"># (Free)BSD struct flock:</span>
<span class="cp">#   off_t   l_start;        /* starting offset */</span>
<span class="cp">#   off_t   l_len;          /* len = 0 means until end of file */</span>
<span class="cp">#   pid_t   l_pid;          /* lock owner */</span>
<span class="cp">#   short   l_type;         /* lock type: read/write, etc. */</span>
<span class="cp">#   short   l_whence;       /* type of l_start */</span>
<span class="cp">BEGIN {</span>
<span class="cp">        # c2ph says: typedef=&quot;q2 i s2&quot;, size=24</span>
<span class="cp">        my $FLOCK_STRUCT = &#39;ll ll i s s&#39;;   # XXX: q is ll</span>

<span class="cp">        sub bsd_flock {</span>
<span class="cp">            if (wantarray) {</span>
<span class="cp">                my ($xxstart, $start, $xxlen, $len, $pid, $type, $whence) =</span>
<span class="cp">                    unpack($FLOCK_STRUCT, $_[0]);</span>
<span class="cp">                return ($type, $whence, $start, $len, $pid);</span>
<span class="cp">            } else {</span>
<span class="cp">                my ($type, $whence, $start, $len, $pid) = @_;</span>
<span class="cp">                my ($xxstart, $xxlen) = (0,0);</span>
<span class="cp">                return pack($FLOCK_STRUCT,</span>
<span class="cp">                    $xxstart, $start, $xxlen, $len, $pid, $type, $whence);</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">}</span>

<span class="cp"># alias the fcntl structure at compile time</span>
<span class="cp">BEGIN {</span>
<span class="cp">        for ($^O) {</span>
<span class="cp">            *struct_flock =                do                           {</span>
<span class="cp">                                    /bsd/  &amp;&amp;  \&amp;bsd_flock</span>
<span class="cp">                                           ||</span>
<span class="cp">                                /linux/    &amp;&amp;    \&amp;linux_flock</span>
<span class="cp">                                           ||</span>
<span class="cp">                              /sunos/      &amp;&amp;      \&amp;sunos_flock</span>
<span class="cp">                                           ||</span>
<span class="cp">                      die &quot;unknown operating system $^O, bailing out&quot;;</span>
<span class="cp">            };</span>
<span class="cp">        }</span>
<span class="cp">}</span>

<span class="cp"># install signal handler for children</span>
<span class="cp">BEGIN {</span>
<span class="cp">        my $called = 0;</span>

<span class="cp">        sub genocide {</span>
<span class="cp">            exit if $called++;</span>
<span class="cp">            print &quot;$$: Time to die, kiddies.\n&quot; if $$ == $progenitor;</span>
<span class="cp">            my $job = getpgrp();</span>
<span class="cp">            $SIG{INT} = &#39;IGNORE&#39;;</span>
<span class="cp">            kill -2, $job if $job;  # killpg(SIGINT, job)</span>
<span class="cp">            1 while wait &gt; 0;</span>
<span class="cp">            print &quot;$$: My turn\n&quot; if $$ == $progenitor;</span>
<span class="cp">            exit;</span>
<span class="cp">        }</span>
<span class="cp">}</span>

<span class="cp">END { &amp;genocide }</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (defined ($line = &lt;DATAFILE&gt;)) {</span>
<span class="cp">    chomp $line;</span>
<span class="cp">    $size = length $line;</span>
<span class="cp">    print &quot;$size\n&quot;;                # output size of line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;DATAFILE&gt;) {</span>
<span class="cp">    chomp;</span>
<span class="cp">    print length, &quot;\n&quot;;             # output size of line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = &lt;DATAFILE&gt;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">undef $/;</span>
<span class="cp">$whole_file = &lt;FILE&gt;;               # &#39;slurp&#39; mode</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -040 -e &#39;$word = &lt;&gt;; print &quot;First word is $word\n&quot;;&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -ne &#39;BEGIN { $/=&quot;%%\n&quot; } chomp; print if /Unix/i&#39; fortune.dat</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print HANDLE &quot;One&quot;, &quot;two&quot;, &quot;three&quot;; # &quot;Onetwothree&quot;</span>
<span class="cp">print &quot;Baa baa black sheep.\n&quot;;     # Sent to default output handle</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$rv = read(HANDLE, $buffer, 4096)</span>
<span class="cp">        or die &quot;Couldn&#39;t read from HANDLE : $!\n&quot;;</span>
<span class="cp"># $rv is the number of bytes read,</span>
<span class="cp"># $buffer holds the data read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">truncate(HANDLE, $length)</span>
<span class="cp">    or die &quot;Couldn&#39;t truncate: $!\n&quot;;</span>
<span class="cp">truncate(&quot;/tmp/$$.pid&quot;, $length)</span>
<span class="cp">    or die &quot;Couldn&#39;t truncate: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pos = tell(DATAFILE);</span>
<span class="cp">print &quot;I&#39;m $pos bytes from the start of DATAFILE.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">seek(LOGFILE, 0, 2)         or die &quot;Couldn&#39;t seek to the end: $!\n&quot;;</span>
<span class="cp">seek(DATAFILE, $pos, 0)     or die &quot;Couldn&#39;t seek to $pos: $!\n&quot;;</span>
<span class="cp">seek(OUT, -20, 1)           or die &quot;Couldn&#39;t seek back 20 bytes: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$written = syswrite(DATAFILE, $mystring, length($mystring));</span>
<span class="cp">die &quot;syswrite failed: $!\n&quot; unless $written == length($mystring);</span>
<span class="cp">$read = sysread(INFILE, $block, 256, 5);</span>
<span class="cp">warn &quot;only read $read bytes, not 256&quot; if 256 != $read;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pos = sysseek(HANDLE, 0, 1);       # don&#39;t change position</span>
<span class="cp">die &quot;Couldn&#39;t sysseek: $!\n&quot; unless defined $pos;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (defined($line = &lt;FH&gt;) ) {</span>
<span class="cp">    chomp $line;</span>
<span class="cp">    if ($line =~ s/\\$//) {</span>
<span class="cp">        $line .= &lt;FH&gt;;</span>
<span class="cp">        redo unless eof(FH);</span>
<span class="cp">    }</span>
<span class="cp">    # process full record in $line here</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) \</span>
<span class="cp">#         $(TEXINFOS) $(INFOS) $(MANS) $(DATA)</span>
<span class="cp"># DEP_DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) \</span>
<span class="cp">#         $(TEXINFOS) $(INFO_DEPS) $(MANS) $(DATA) \</span>
<span class="cp">#         $(EXTRA_DIST)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($line =~ s/\\\s*$//) { </span>
<span class="cp">    # as before</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$count = `wc -l &lt; $file`;</span>
<span class="cp">die &quot;wc failed: $?&quot; if $?;</span>
<span class="cp">chomp($count);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FILE, &quot;&lt; $file&quot;) or die &quot;can&#39;t open $file: $!&quot;;</span>
<span class="cp">$count++ while &lt;FILE&gt;;</span>
<span class="cp"># $count now holds the number of lines read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$count += tr/\n/\n/ while sysread(FILE, $_, 2 ** 16);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FILE, &quot;&lt; $file&quot;) or die &quot;can&#39;t open $file: $!&quot;;</span>
<span class="cp">$count++ while &lt;FILE&gt;;</span>
<span class="cp"># $count now holds the number of lines read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FILE, &quot;&lt; $file&quot;) or die &quot;can&#39;t open $file: $!&quot;;</span>
<span class="cp">for ($count=0; &lt;FILE&gt;; $count++) { }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">1 while &lt;FILE&gt;;</span>
<span class="cp">$count = $.;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = &#39;&#39;;            # enable paragraph mode for all reads</span>
<span class="cp">open(FILE, $file) or die &quot;can&#39;t open $file: $!&quot;;</span>
<span class="cp">1 while &lt;FILE&gt;;</span>
<span class="cp">$para_count = $.;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    for $chunk (split) {</span>
<span class="cp">        # do something with $chunk</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    while ( /(\w[\w&#39;-]*)/g ) {  #&#39;</span>
<span class="cp">        # do something with $1</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Make a word frequency count</span>
<span class="cp">%seen = ();</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    while ( /(\w[&#39;\w-]*)/g ) {  #&#39;</span>
<span class="cp">        $seen{lc $1}++;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp"># output hash in a descending numeric sort of its values</span>
<span class="cp">foreach $word ( sort { $seen{$b} &lt;=&gt; $seen{$a} } keys %seen) {</span>
<span class="cp">    printf &quot;%5d %s\n&quot;, $seen{$word}, $word;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Line frequency count</span>
<span class="cp">%seen = ();</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    $seen{lc $_}++;</span>
<span class="cp">}</span>
<span class="cp">foreach $line ( sort { $seen{$b} &lt;=&gt; $seen{$a} } keys %seen ) {</span>
<span class="cp">    printf &quot;%5d %s&quot;, $seen{$line}, $line;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = &lt;FILE&gt;;</span>
<span class="cp">while ($line = pop @lines) {</span>
<span class="cp">    # do something with $line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = reverse &lt;FILE&gt;;</span>
<span class="cp">foreach $line (@lines) {</span>
<span class="cp">    # do something with $line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for ($i = $#lines; $i != -1; $i--) {</span>
<span class="cp">    $line = $lines[$i];</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># this enclosing block keeps local $/ temporary</span>
<span class="cp">{           </span>
<span class="cp">    local $/ = &#39;&#39;;</span>
<span class="cp">    @paragraphs = reverse &lt;FILE&gt;;</span>
<span class="cp">}</span>

<span class="cp">foreach $paragraph (@paragraphs) {</span>
<span class="cp">    # do something</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for (;;) {</span>
<span class="cp">    while (&lt;FH&gt;) { .... }</span>
<span class="cp">    sleep $SOMETIME;</span>
<span class="cp">    seek(FH, 0, 1);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Seekable;</span>

<span class="cp">for (;;) {</span>
<span class="cp">    while (&lt;FH&gt;) { .... }</span>
<span class="cp">    sleep $SOMETIME;</span>
<span class="cp">    FH-&gt;clearerr();</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$naptime = 1;</span>

<span class="cp">use IO::Handle;</span>
<span class="cp">open (LOGFILE, &quot;/tmp/logfile&quot;) or die &quot;can&#39;t open /tmp/logfile: $!&quot;;</span>
<span class="cp">for (;;) {</span>
<span class="cp">    while (&lt;LOGFILE&gt;) { print }     # or appropriate processing</span>
<span class="cp">    sleep $naptime;</span>
<span class="cp">    LOGFILE-&gt;clearerr();            # clear stdio error flag</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for (;;) {</span>
<span class="cp">    for ($curpos = tell(LOGFILE); &lt;LOGFILE&gt;; $curpos = tell(LOGFILE)) {</span>
<span class="cp">        # process $_ here</span>
<span class="cp">    }</span>
<span class="cp">    sleep $naptime;</span>
<span class="cp">    seek(LOGFILE, $curpos, 0);  # seek to where we had been</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">exit if (stat(LOGFILE))[3] == 0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::stat;</span>
<span class="cp">exit if stat(*LOGFILE)-&gt;nlink == 0;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">srand;</span>
<span class="cp">rand($.) &lt; 1 &amp;&amp; ($line = $_) while &lt;&gt;;</span>
<span class="cp"># $line is the random line</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = &quot;%%\n&quot;;</span>
<span class="cp">@ARGV = qw( /usr/share/games/fortunes );</span>
<span class="cp">srand;</span>
<span class="cp">rand($.) &lt; 1 &amp;&amp; ($adage = $_) while &lt;&gt;;</span>
<span class="cp">print $adage;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># assumes the &amp;shuffle sub from Chapter 4</span>
<span class="cp">while (&lt;INPUT&gt;) {</span>
<span class="cp">    push(@lines, $_);</span>
<span class="cp">}</span>
<span class="cp">@reordered = shuffle(@lines);</span>
<span class="cp">foreach (@reordered) {</span>
<span class="cp">    print OUTPUT $_;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># looking for line number $DESIRED_LINE_NUMBER</span>
<span class="cp">$. = 0;</span>
<span class="cp">do { $LINE = &lt;HANDLE&gt; } until $. == $DESIRED_LINE_NUMBER || eof;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = &lt;HANDLE&gt;;</span>
<span class="cp">$LINE = $lines[$DESIRED_LINE_NUMBER];</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># usage: build_index(*DATA_HANDLE, *INDEX_HANDLE)</span>
<span class="cp">sub build_index {</span>
<span class="cp">    my $data_file  = shift;</span>
<span class="cp">    my $index_file = shift;</span>
<span class="cp">    my $offset     = 0;</span>

<span class="cp">    while (&lt;$data_file&gt;) {</span>
<span class="cp">        print $index_file pack(&quot;N&quot;, $offset);</span>
<span class="cp">        $offset = tell($data_file);</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp"># usage: line_with_index(*DATA_HANDLE, *INDEX_HANDLE, $LINE_NUMBER)</span>
<span class="cp"># returns line or undef if LINE_NUMBER was out of range</span>
<span class="cp">sub line_with_index {</span>
<span class="cp">    my $data_file   = shift;</span>
<span class="cp">    my $index_file  = shift;</span>
<span class="cp">    my $line_number = shift;</span>

<span class="cp">    my $size;               # size of an index entry</span>
<span class="cp">    my $i_offset;           # offset into the index of the entry</span>
<span class="cp">    my $entry;              # index entry</span>
<span class="cp">    my $d_offset;           # offset into the data file</span>

<span class="cp">    $size = length(pack(&quot;N&quot;, 0));</span>
<span class="cp">    $i_offset = $size * ($line_number-1);</span>
<span class="cp">    seek($index_file, $i_offset, 0) or return;</span>
<span class="cp">    read($index_file, $entry, $size);</span>
<span class="cp">    $d_offset = unpack(&quot;N&quot;, $entry);</span>
<span class="cp">    seek($data_file, $d_offset, 0);</span>
<span class="cp">    return scalar(&lt;$data_file&gt;);</span>
<span class="cp">}</span>

<span class="cp"># usage:</span>
<span class="cp">open(FILE, &quot;&lt; $file&quot;)         or die &quot;Can&#39;t open $file for reading: $!\n&quot;;</span>
<span class="cp">open(INDEX, &quot;+&gt;$file.idx&quot;)</span>
<span class="cp">        or die &quot;Can&#39;t open $file.idx for read/write: $!\n&quot;;</span>
<span class="cp">build_index(*FILE, *INDEX);</span>
<span class="cp">$line = line_with_index(*FILE, *INDEX, $seeking);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DB_File;</span>
<span class="cp">use Fcntl;</span>

<span class="cp">$tie = tie(@lines, $FILE, &quot;DB_File&quot;, O_RDWR, 0666, $DB_RECNO) or die </span>
<span class="cp">    &quot;Cannot open file $FILE: $!\n&quot;;</span>
<span class="cp"># extract it</span>
<span class="cp">$line = $lines[$sought - 1];</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/print_line-v1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># print_line-v1 - linear style</span>

<span class="cp">@ARGV == 2 or die &quot;usage: print_line FILENAME LINE_NUMBER\n&quot;;</span>

<span class="cp">($filename, $line_number) = @ARGV;</span>
<span class="cp">open(INFILE, &quot;&lt; $filename&quot;) or die &quot;Can&#39;t open $filename for reading: $!\n&quot;;</span>
<span class="cp">while (&lt;INFILE&gt;) {</span>
<span class="cp">    $line = $_;</span>
<span class="cp">    last if $. == $line_number;</span>
<span class="cp">}</span>
<span class="cp">if ($. != $line_number) {</span>
<span class="cp">    die &quot;Didn&#39;t find line $line_number in $filename\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">print;</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/print_line-v2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># print_line-v2 - index style</span>
<span class="cp"># build_index and line_with_index from above</span>
<span class="cp">@ARGV == 2 or</span>
<span class="cp">    die &quot;usage: print_line FILENAME LINE_NUMBER&quot;;</span>

<span class="cp">($filename, $line_number) = @ARGV;</span>
<span class="cp">open(ORIG, &quot;&lt; $filename&quot;) </span>
<span class="cp">        or die &quot;Can&#39;t open $filename for reading: $!&quot;;</span>

<span class="cp"># open the index and build it if necessary</span>
<span class="cp"># there&#39;s a race condition here: two copies of this</span>
<span class="cp"># program can notice there&#39;s no index for the file and</span>
<span class="cp"># try to build one.  This would be easily solved with</span>
<span class="cp"># locking</span>
<span class="cp">$indexname = &quot;$filename.index&quot;;</span>
<span class="cp">sysopen(IDX, $indexname, O_CREAT|O_RDWR)</span>
<span class="cp">         or die &quot;Can&#39;t open $indexname for read/write: $!&quot;;</span>
<span class="cp">build_index(*ORIG, *IDX) if -z $indexname;  # XXX: race unless lock</span>

<span class="cp">$line = line_with_index(*ORIG, *IDX, $line_number);</span>
<span class="cp">die &quot;Didn&#39;t find line $line_number in $filename&quot; unless defined $line;</span>
<span class="cp">print $line;</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/print_line-v3</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># print_line-v3 - DB_File style</span>
<span class="cp">use DB_File;</span>
<span class="cp">use Fcntl;</span>

<span class="cp">@ARGV == 2 or</span>
<span class="cp">    die &quot;usage: print_line FILENAME LINE_NUMBER\n&quot;;</span>

<span class="cp">($filename, $line_number) = @ARGV;</span>
<span class="cp">$tie = tie(@lines, &quot;DB_File&quot;, $filename, O_RDWR, 0666, $DB_RECNO)</span>
<span class="cp">        or die &quot;Cannot open file $filename: $!\n&quot;;</span>

<span class="cp">unless ($line_number &lt; $tie-&gt;length) {</span>
<span class="cp">    die &quot;Didn&#39;t find line $line_number in $filename\n&quot;</span>
<span class="cp">}</span>

<span class="cp">print $lines[$line_number-1];                        # easy, eh?</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># given $RECORD with field separated by PATTERN,</span>
<span class="cp"># extract @FIELDS.</span>
<span class="cp">@FIELDS = split(/PATTERN/, $RECORD);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">split(/([+-])/, &quot;3+5-2&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">(3, &#39;+&#39;, 5, &#39;-&#39;, 2)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@fields = split(/:/, $RECORD);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@fields = split(/\s+/, $RECORD);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@fields = split(&quot; &quot;, $RECORD);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open (FH, &quot;+&lt; $file&quot;)               or die &quot;can&#39;t update $file: $!&quot;;</span>
<span class="cp">while ( &lt;FH&gt; ) {</span>
<span class="cp">    $addr = tell(FH) unless eof(FH);</span>
<span class="cp">}</span>
<span class="cp">truncate(FH, $addr)                 or die &quot;can&#39;t truncate $file: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">binmode(HANDLE);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$gifname = &quot;picture.gif&quot;;</span>
<span class="cp">open(GIF, $gifname)         or die &quot;can&#39;t open $gifname: $!&quot;;</span>

<span class="cp">binmode(GIF);               # now DOS won&#39;t mangle binary input from GIF</span>
<span class="cp">binmode(STDOUT);            # now DOS won&#39;t mangle binary output to STDOUT</span>

<span class="cp">while (read(GIF, $buff, 8 * 2**10)) {</span>
<span class="cp">    print STDOUT $buff;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ADDRESS = $RECSIZE * $RECNO;</span>
<span class="cp">seek(FH, $ADDRESS, 0) or die &quot;seek:$!&quot;;</span>
<span class="cp">read(FH, $BUFFER, $RECSIZE);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ADDRESS = $RECSIZE * ($RECNO-1);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl;                          # for SEEK_SET and SEEK_CUR</span>

<span class="cp">$ADDRESS = $RECSIZE * $RECNO;</span>
<span class="cp">seek(FH, $ADDRESS, SEEK_SET)        or die &quot;Seeking: $!&quot;;</span>
<span class="cp">read(FH, $BUFFER, $RECSIZE) == $RECSIZE</span>
<span class="cp">                                    or die &quot;Reading: $!&quot;;</span>
<span class="cp">@FIELDS = unpack($FORMAT, $BUFFER);</span>
<span class="cp"># update fields, then</span>
<span class="cp">$BUFFER = pack($FORMAT, @FIELDS);</span>
<span class="cp">seek(FH, -$RECSIZE, SEEK_CUR)       or die &quot;Seeking: $!&quot;;</span>
<span class="cp">print FH $BUFFER;</span>
<span class="cp">close FH                            or die &quot;Closing: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/weekearly</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># weekearly -- set someone&#39;s login date back a week</span>
<span class="cp">use User::pwent;</span>
<span class="cp">use IO::Seekable;</span>

<span class="cp">$typedef = &#39;L A12 A16&#39;;         # linux fmt; sunos is &quot;L A8 A16&quot;</span>
<span class="cp">$sizeof  = length(pack($typedef, ()));</span>
<span class="cp">$user    = shift(@ARGV) || $ENV{USER} || $ENV{LOGNAME};</span>

<span class="cp">$address = getpwnam($user)-&gt;uid * $sizeof;</span>

<span class="cp">open (LASTLOG, &quot;+&lt;/var/log/lastlog&quot;)</span>
<span class="cp">    or die &quot;can&#39;t update /usr/adm/lastlog: $!&quot;;</span>
<span class="cp">seek(LASTLOG, $address, SEEK_SET)</span>
<span class="cp">    or die &quot;seek failed: $!&quot;;</span>
<span class="cp">read(LASTLOG, $buffer, $sizeof) == $sizeof</span>
<span class="cp">    or die &quot;read failed: $!&quot;;</span>

<span class="cp">($time, $line, $host) = unpack($typedef, $buffer);</span>
<span class="cp">$time  -= 24 * 7 * 60 * 60;         # back-date a week</span>
<span class="cp">$buffer = pack($typedef, $time, $line, $time);</span>

<span class="cp">seek(LASTLOG, -$sizeof, SEEK_CUR)   # backup one record</span>
<span class="cp">    or die &quot;seek failed: $!&quot;;</span>
<span class="cp">print LASTLOG $record;</span>
<span class="cp">    </span>
<span class="cp">close(LASTLOG)</span>
<span class="cp">    or die &quot;close failed: $!&quot;;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$old_rs = $/;                       # save old $/</span>
<span class="cp">$/ = &quot;\0&quot;;                          # NULL</span>
<span class="cp">seek(FH, $addr, SEEK_SET)           or die &quot;Seek error: $!\n&quot;;</span>
<span class="cp">$string = &lt;FH&gt;;                     # read string</span>
<span class="cp">chomp $string;                      # remove NULL</span>
<span class="cp">$/ = $old_rs;                       # restore old $/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{</span>
<span class="cp">    local $/ = &quot;\0&quot;;</span>
<span class="cp">    # ...</span>
<span class="cp">}                           # $/ is automatically restored</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/bgets</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl </span>
<span class="cp"># bgets - get a string from an address in a binary file</span>
<span class="cp">use IO::Seekable;</span>
<span class="cp">($file, @addrs) = @ARGV             or die &quot;usage: $0 addr ...&quot;;</span>
<span class="cp">open(FH, $file)                     or die &quot;cannot open $file: $!&quot;;</span>
<span class="cp">$/ = &quot;\000&quot;;</span>

<span class="cp">foreach $addr (@addrs) {</span>
<span class="cp">    $addr = oct $addr if $addr =~ /^0/;</span>
<span class="cp">    seek(FH, $addr, SEEK_SET)</span>
<span class="cp">        or die &quot;can&#39;t seek to $addr in $file: $!&quot;;</span>
<span class="cp">    printf qq{%#x %#o %d &quot;%s&quot;\n}, $addr, $addr, $addr, scalar &lt;&gt;;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/strings</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># strings - pull strings out of a binary file</span>
<span class="cp">$/ = &quot;\0&quot;;</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    while (/([\040-\176\s]{4,})/g) {</span>
<span class="cp">        print $1, &quot;\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># $RECORDSIZE is the length of a record, in bytes.</span>
<span class="cp"># $TEMPLATE is the unpack template for the record</span>
<span class="cp"># FILE is the file to read from</span>
<span class="cp"># @FIELDS is an array, one element per field</span>

<span class="cp">until ( eof(FILE) ) {</span>
<span class="cp">    read(FILE, $record, $RECORDSIZE) == $RECORDSIZE</span>
<span class="cp">        or die &quot;short read\n&quot;;</span>
<span class="cp">    @FIELDS = unpack($TEMPLATE, $record);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#define UT_LINESIZE           12</span>
<span class="cp">#define UT_NAMESIZE           8</span>
<span class="cp">#define UT_HOSTSIZE           16</span>

<span class="cp">struct utmp {                       /* here are the pack template codes */</span>
<span class="cp">    short ut_type;                  /* s for short, must be padded      */</span>
<span class="cp">    pid_t ut_pid;                   /* i for integer                    */</span>
<span class="cp">    char ut_line[UT_LINESIZE];      /* A12 for 12-char string           */</span>
<span class="cp">    char ut_id[2];                  /* A2, but need x2 for alignment    */</span>
<span class="cp">    time_t ut_time;                 /* l for long                       */</span>
<span class="cp">    char ut_user[UT_NAMESIZE];      /* A8 for 8-char string             */</span>
<span class="cp">    char ut_host[UT_HOSTSIZE];      /* A16 for 16-char string           */</span>
<span class="cp">    long ut_addr;                   /* l for long                       */</span>
<span class="cp">};</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;CONFIG&gt;) {</span>
<span class="cp">    chomp;                  # no newline</span>
<span class="cp">    s/#.*//;                # no comments</span>
<span class="cp">    s/^\s+//;               # no leading white</span>
<span class="cp">    s/\s+$//;               # no trailing white</span>
<span class="cp">    next unless length;     # anything left?</span>
<span class="cp">    my ($var, $value) = split(/\s*=\s*/, $_, 2);</span>
<span class="cp">    $User_Preferences{$var} = $value;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">do &quot;$ENV{HOME}/.progrc&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># set class C net</span>
<span class="cp">NETMASK = 255.255.255.0</span>
<span class="cp">MTU     = 296</span>
<span class="cp">    </span>
<span class="cp">DEVICE  = cua1</span>
<span class="cp">RATE    = 115200</span>
<span class="cp">MODE    = adaptive</span>
<span class="cp">#-----------------------------</span>
<span class="cp">no strict &#39;refs&#39;;</span>
<span class="cp">$$var = $value;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># set class C net</span>
<span class="cp">$NETMASK = &#39;255.255.255.0&#39;;</span>
<span class="cp">$MTU     = 0x128;</span>
<span class="cp"># Brent, please turn on the modem</span>
<span class="cp">$DEVICE  = &#39;cua1&#39;;</span>
<span class="cp">$RATE    = 115_200;</span>
<span class="cp">$MODE    = &#39;adaptive&#39;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($DEVICE =~ /1$/) {</span>
<span class="cp">    $RATE =  28_800;</span>
<span class="cp">} else {</span>
<span class="cp">    $RATE = 115_200;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$APPDFLT = &quot;/usr/local/share/myprog&quot;;</span>

<span class="cp">do &quot;$APPDFLT/sysconfig.pl&quot;;</span>
<span class="cp">do &quot;$ENV{HOME}/.myprogrc&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">do &quot;$ENV{HOME}/.myprogrc&quot;;</span>
<span class="cp">    or</span>
<span class="cp">do &quot;$APPDFLT/sysconfig.pl&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{ package Settings; do &quot;$ENV{HOME}/.myprogrc&quot; }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval `cat $ENV{HOME}/.myprogrc`;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file = &quot;someprog.pl&quot;;</span>
<span class="cp">unless ($return = do $file) {</span>
<span class="cp">    warn &quot;couldn&#39;t parse $file: $@&quot;         if $@;</span>
<span class="cp">    warn &quot;couldn&#39;t do $file: $!&quot;            unless defined $return;</span>
<span class="cp">    warn &quot;couldn&#39;t run $file&quot;               unless $return;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp">( $dev, $ino, $mode, $nlink, </span>
<span class="cp">  $uid, $gid, $rdev, $size, </span>
<span class="cp">  $atime, $mtime, $ctime, </span>
<span class="cp">  $blksize, $blocks )       = stat($filename)</span>
<span class="cp">        or die &quot;no $filename: $!&quot;;</span>

<span class="cp">$mode &amp;= 07777;             # discard file type info</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$info = stat($filename)     or die &quot;no $filename: $!&quot;;</span>
<span class="cp">if ($info-&gt;uid == 0) {</span>
<span class="cp">    print &quot;Superuser owns $filename\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">if ($info-&gt;atime &gt; $info-&gt;mtime) {</span>
<span class="cp">    print &quot;$filename has been read since it was written.\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::stat;</span>

<span class="cp">sub is_safe {</span>
<span class="cp">    my $path = shift;</span>
<span class="cp">    my $info = stat($path);</span>
<span class="cp">    return unless $info;</span>

<span class="cp">    # owner neither superuser nor me </span>
<span class="cp">    # the real uid is in stored in the $&lt; variable</span>
<span class="cp">    if (($info-&gt;uid != 0) &amp;&amp; ($info-&gt;uid != $&lt;)) {</span>
<span class="cp">        return 0;</span>
<span class="cp">    }</span>

<span class="cp">    # check whether group or other can write file.</span>
<span class="cp">    # use 066 to detect either reading or writing</span>
<span class="cp">    if ($info-&gt;mode &amp; 022) {   # someone else can write this</span>
<span class="cp">        return 0 unless -d _;  # non-directories aren&#39;t safe</span>
<span class="cp">            # but directories with the sticky bit (01000) are</span>
<span class="cp">        return 0 unless $info-&gt;mode &amp; 01000;        </span>
<span class="cp">    }</span>
<span class="cp">    return 1;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Cwd;</span>
<span class="cp">use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);</span>
<span class="cp">sub is_verysafe {</span>
<span class="cp">    my $path = shift;</span>
<span class="cp">    return is_safe($path) if sysconf(_PC_CHOWN_RESTRICTED);</span>
<span class="cp">    $path = getcwd() . &#39;/&#39; . $path if $path !~ m{^/};</span>
<span class="cp">    do {</span>
<span class="cp">        return unless is_safe($path);</span>
<span class="cp">        $path =~ s#([^/]+|/)$##;               # dirname</span>
<span class="cp">        $path =~ s#/$## if length($path) &gt; 1;  # last slash</span>
<span class="cp">    } while length $path;</span>

<span class="cp">    return 1;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file = &quot;$ENV{HOME}/.myprogrc&quot;;</span>
<span class="cp">readconfig($file) if is_safe($file);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file = &quot;$ENV{HOME}/.myprogrc&quot;;</span>
<span class="cp">if (open(FILE, &quot;&lt; $file&quot;)) { </span>
<span class="cp">    readconfig(*FILE) if is_safe(*FILE);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/tailwtmp</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># tailwtmp - watch for logins and logouts; </span>
<span class="cp"># uses linux utmp structure, from utmp(5)</span>
<span class="cp">$typedef = &#39;s x2 i A12 A4 l A8 A16 l&#39;;</span>
<span class="cp">$sizeof = length pack($typedef, () );</span>
<span class="cp">use IO::File;</span>
<span class="cp">open(WTMP, &#39;/var/log/wtmp&#39;) or die &quot;can&#39;t open /var/log/wtmp: $!&quot;;</span>
<span class="cp">seek(WTMP, 0, SEEK_END);</span>
<span class="cp">for (;;) { </span>
<span class="cp">        while (read(WTMP, $buffer, $sizeof) == $sizeof) {</span>
<span class="cp">        ($type, $pid,  $line, $id, $time, $user, $host, $addr) </span>
<span class="cp">            = unpack($typedef, $buffer);</span>
<span class="cp">        next unless $user &amp;&amp; ord($user) &amp;&amp; $time;</span>
<span class="cp">        printf &quot;%1d %-8s %-12s %2s %-24s %-16s %5d %08x\n&quot;, </span>
<span class="cp">            $type,$user,$line,$id,scalar(localtime($time)), </span>
<span class="cp">            $host,$pid,$addr;</span>
<span class="cp">    } </span>
<span class="cp">    for ($size = -s WTMP; $size == -s WTMP; sleep 1) {}</span>
<span class="cp">    WTMP-&gt;clearerr();</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% someprog | tee /tmp/output | Mail -s &#39;check this&#39; user@host.org</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% someprog | tctee f1 &quot;|cat -n&quot; f2 &quot;&gt;&gt;f3&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/tctee</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># tctee - clone that groks process tees </span>
<span class="cp"># perl3 compatible, or better.</span>

<span class="cp">while ($ARGV[0] =~ /^-(.+)/ &amp;&amp; (shift, ($_ = $1), 1)) {</span>
<span class="cp">    next if /^$/;</span>
<span class="cp">    s/i// &amp;&amp; (++$ignore_ints, redo);</span>
<span class="cp">    s/a// &amp;&amp; (++$append,      redo);</span>
<span class="cp">    s/u// &amp;&amp; (++$unbuffer,    redo);</span>
<span class="cp">    s/n// &amp;&amp; (++$nostdout,    redo);</span>
<span class="cp">    die &quot;usage tee [-aiun] [filenames] ...\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">if ($ignore_ints) {</span>
<span class="cp">    for $sig (&#39;INT&#39;, &#39;TERM&#39;, &#39;HUP&#39;, &#39;QUIT&#39;) { $SIG{$sig} = &#39;IGNORE&#39;; }</span>

<span class="cp">}</span>
<span class="cp">$SIG{&#39;PIPE&#39;} = &#39;PLUMBER&#39;;</span>
<span class="cp">$mode = $append ? &#39;&gt;&gt;&#39; : &#39;&gt;&#39;;</span>
<span class="cp">$fh = &#39;FH000&#39;;</span>

<span class="cp">unless ($nostdout) {</span>
<span class="cp">    %fh = (&#39;STDOUT&#39;, &#39;standard output&#39;); # always go to stdout</span>
<span class="cp">    }</span>

<span class="cp">$| = 1 if $unbuffer;</span>

<span class="cp">for (@ARGV) {</span>
<span class="cp">    if (!open($fh, (/^[^&gt;|]/ &amp;&amp; $mode) . $_)) {</span>
<span class="cp">        warn &quot;$0: cannot open $_: $!\n&quot;; # like sun&#39;s; i prefer die</span>
<span class="cp">        $status++;</span>
<span class="cp">        next;</span>
<span class="cp">    }</span>
<span class="cp">    select((select($fh), $| = 1)[0]) if $unbuffer;</span>
<span class="cp">    $fh{$fh++} = $_;</span>
<span class="cp">}</span>

<span class="cp">while (&lt;STDIN&gt;) {</span>
<span class="cp">    for $fh (keys %fh) {</span>
<span class="cp">        print $fh $_;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">for $fh (keys %fh) {</span>
<span class="cp">    next if close($fh) || !defined $fh{$fh};</span>
<span class="cp">    warn &quot;$0: couldnt close $fh{$fh}: $!\n&quot;;</span>
<span class="cp">    $status++;</span>
<span class="cp">}</span>

<span class="cp">exit $status;</span>

<span class="cp">sub PLUMBER {</span>
<span class="cp">    warn &quot;$0: pipe to \&quot;$fh{$fh}\&quot; broke!\n&quot;;</span>
<span class="cp">    $status++;</span>
<span class="cp">    delete $fh{$fh};</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_8.20</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% laston gnat</span>
<span class="cp">#gnat  UID 314 at Mon May 25 08:32:52 1998 on ttyp0 from below.perl.com</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch08/laston</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># laston - find out when given user last logged on</span>
<span class="cp">use User::pwent;</span>
<span class="cp">use IO::Seekable qw(SEEK_SET);</span>

<span class="cp">open (LASTLOG, &quot;/var/log/lastlog&quot;) or die &quot;can&#39;t open /usr/adm/lastlog: $!&quot;;</span>

<span class="cp">$typedef = &#39;L A12 A16&#39;;  # linux fmt; sunos is &quot;L A8 A16&quot;</span>
<span class="cp">$sizeof  = length(pack($typedef, ()));</span>

<span class="cp">for $user (@ARGV) {</span>
<span class="cp">    $U = ($user =~ /^\d+$/) ? getpwuid($user) : getpwnam($user);</span>
<span class="cp">    unless ($U) { warn &quot;no such uid $user\n&quot;; next; }</span>
<span class="cp">    seek(LASTLOG, $U-&gt;uid * $sizeof, SEEK_SET) or die &quot;seek failed: $!&quot;;</span>
<span class="cp">    read(LASTLOG, $buffer, $sizeof) == $sizeof	or next;</span>
<span class="cp">    ($time, $line, $host) = unpack($typedef, $buffer);</span>
<span class="cp">    printf &quot;%-8s UID %5d %s%s%s\n&quot;, $U-&gt;name, $U-&gt;uid,</span>
<span class="cp">          $time ? (&quot;at &quot; . localtime($time)) : &quot;never logged in&quot;,</span>
<span class="cp">          $line &amp;&amp; &quot; on $line&quot;, </span>
<span class="cp">          $host &amp;&amp; &quot; from $host&quot;;</span>
<span class="cp">} </span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@entry = stat(&quot;/usr/bin/vi&quot;) or die &quot;Couldn&#39;t stat /usr/bin/vi : $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@entry = stat(&quot;/usr/bin&quot;)    or die &quot;Couldn&#39;t stat /usr/bin : $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@entry = stat(INFILE)        or die &quot;Couldn&#39;t stat INFILE : $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::stat;</span>

<span class="cp">$inode = stat(&quot;/usr/bin/vi&quot;);</span>
<span class="cp">$ctime = $inode-&gt;ctime;</span>
<span class="cp">$size  = $inode-&gt;size;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open( F, &quot;&lt; $filename&quot; )</span>
<span class="cp">    or die &quot;Opening $filename: $!\n&quot;;</span>
<span class="cp">unless (-s F &amp;&amp; -T _) {</span>
<span class="cp">    die &quot;$filename doesn&#39;t have text in it.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">opendir(DIRHANDLE, &quot;/usr/bin&quot;) or die &quot;couldn&#39;t open /usr/bin : $!&quot;;</span>
<span class="cp">while ( defined ($filename = readdir(DIRHANDLE)) ) {</span>
<span class="cp">    print &quot;Inside /usr/bin is something called $filename\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">closedir(DIRHANDLE);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($READTIME, $WRITETIME) = (stat($filename))[8,9];</span>

<span class="cp">utime($NEWREADTIME, $NEWWRITETIME, $filename);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SECONDS_PER_DAY = 60 * 60 * 24;</span>
<span class="cp">($atime, $mtime) = (stat($file))[8,9];</span>
<span class="cp">$atime -= 7 * $SECONDS_PER_DAY;</span>
<span class="cp">$mtime -= 7 * $SECONDS_PER_DAY;</span>

<span class="cp">utime($atime, $mtime, $file)</span>
<span class="cp">    or die &quot;couldn&#39;t backdate $file by a week w/ utime: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$mtime = (stat $file)[9];</span>
<span class="cp">utime(time, $mtime, $file);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::stat;</span>
<span class="cp">utime(time, stat($file)-&gt;mtime, $file);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch09/uvi</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># uvi - vi a file without changing its access times</span>

<span class="cp">$file = shift or die &quot;usage: uvi filename\n&quot;;</span>
<span class="cp">($atime, $mtime) = (stat($file))[8,9];</span>
<span class="cp">system($ENV{EDITOR} || &quot;vi&quot;, $file);</span>
<span class="cp">utime($atime, $mtime, $file)</span>
<span class="cp">    or die &quot;couldn&#39;t restore $file to orig times: $!&quot;;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unlink($FILENAME)                 or die &quot;Can&#39;t delete $FILENAME: $!\n&quot;;</span>
<span class="cp">unlink(@FILENAMES) == @FILENAMES  or die &quot;Couldn&#39;t unlink all of @FILENAMES: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unlink($file) or die &quot;Can&#39;t unlink $file: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unless (($count = unlink(@filelist)) == @filelist) {</span>
<span class="cp">    warn &quot;could only delete $count of &quot;</span>
<span class="cp">            . (@filelist) . &quot; files&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::Copy;</span>
<span class="cp">copy($oldfile, $newfile);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(IN,  &quot;&lt; $oldfile&quot;)                     or die &quot;can&#39;t open $oldfile: $!&quot;;</span>
<span class="cp">open(OUT, &quot;&gt; $newfile&quot;)                     or die &quot;can&#39;t open $newfile: $!&quot;;</span>

<span class="cp">$blksize = (stat IN)[11] || 16384;          # preferred block size?</span>
<span class="cp">while ($len = sysread IN, $buf, $blksize) {</span>
<span class="cp">    if (!defined $len) {</span>
<span class="cp">        next if $! =~ /^Interrupted/;       # ^Z and fg</span>
<span class="cp">        die &quot;System read error: $!\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    $offset = 0;</span>
<span class="cp">    while ($len) {          # Handle partial writes.</span>
<span class="cp">        defined($written = syswrite OUT, $buf, $len, $offset)</span>
<span class="cp">            or die &quot;System write error: $!\n&quot;;</span>
<span class="cp">        $len    -= $written;</span>
<span class="cp">        $offset += $written;</span>
<span class="cp">    };</span>
<span class="cp">}</span>

<span class="cp">close(IN);</span>
<span class="cp">close(OUT);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">system(&quot;cp $oldfile $newfile&quot;);       # unix</span>
<span class="cp">system(&quot;copy $oldfile $newfile&quot;);     # dos, vms</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::Copy;</span>

<span class="cp">copy(&quot;datafile.dat&quot;, &quot;datafile.bak&quot;)</span>
<span class="cp">    or die &quot;copy failed: $!&quot;;</span>

<span class="cp">move(&quot;datafile.new&quot;, &quot;datafile.dat&quot;)</span>
<span class="cp">    or die &quot;move failed: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%seen = ();</span>

<span class="cp">sub do_my_thing {</span>
<span class="cp">    my $filename = shift;</span>
<span class="cp">    my ($dev, $ino) = stat $filename;</span>

<span class="cp">    unless ($seen{$dev, $ino}++) {</span>
<span class="cp">        # do something with $filename because we haven&#39;t</span>
<span class="cp">        # seen it before</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $filename (@files) {</span>
<span class="cp">    ($dev, $ino) = stat $filename;</span>
<span class="cp">    push( @{ $seen{$dev,$ino} }, $filename);</span>
<span class="cp">}</span>

<span class="cp">foreach $devino (sort keys %seen) {</span>
<span class="cp">    ($dev, $ino) = split(/$;/o, $devino);</span>
<span class="cp">    if (@{$seen{$devino}} &gt; 1) {</span>
<span class="cp">        # @{$seen{$devino}} is a list of filenames for the same file</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">opendir(DIR, $dirname) or die &quot;can&#39;t opendir $dirname: $!&quot;;</span>
<span class="cp">while (defined($file = readdir(DIR))) {</span>
<span class="cp">    # do something with &quot;$dirname/$file&quot;</span>
<span class="cp">}</span>
<span class="cp">closedir(DIR);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$dir = &quot;/usr/local/bin&quot;;</span>
<span class="cp">print &quot;Text files in $dir are:\n&quot;;</span>
<span class="cp">opendir(BIN, $dir) or die &quot;Can&#39;t open $dir: $!&quot;;</span>
<span class="cp">while( defined ($file = readdir BIN) ) {</span>
<span class="cp">    print &quot;$file\n&quot; if -T &quot;$dir/$file&quot;;</span>
<span class="cp">}</span>
<span class="cp">closedir(BIN);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while ( defined ($file = readdir BIN) ) {</span>
<span class="cp">    next if $file =~ /^\.\.?$/;     # skip . and ..</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DirHandle;</span>

<span class="cp">sub plainfiles {</span>
<span class="cp">   my $dir = shift;</span>
<span class="cp">   my $dh = DirHandle-&gt;new($dir)   or die &quot;can&#39;t opendir $dir: $!&quot;;</span>
<span class="cp">   return sort                     # sort pathnames</span>
<span class="cp">          grep {    -f     }       # choose only &quot;plain&quot; files</span>
<span class="cp">          map  { &quot;$dir/$_&quot; }       # create full paths</span>
<span class="cp">          grep {  !/^\./   }       # filter out dot files</span>
<span class="cp">          $dh-&gt;</span>
<span class="cp">read()</span>
<span class="cp">;             # read all entries</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@list = &lt;*.c&gt;;</span>
<span class="cp">@list = glob(&quot;*.c&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">opendir(DIR, $path);</span>
<span class="cp">@files = grep { /\.c$/ } readdir(DIR);</span>
<span class="cp">closedir(DIR);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::KGlob;</span>

<span class="cp">@files = glob(&quot;*.c&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@files = grep { /\.[ch]$/i } readdir(DH);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DirHandle;</span>

<span class="cp">$dh = DirHandle-&gt;new($path)   or die &quot;Can&#39;t open $path : $!\n&quot;;</span>
<span class="cp">@files = grep { /\.[ch]$/i } $dh-&gt;read();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">opendir(DH, $dir)        or die &quot;Couldn&#39;t open $dir for reading: $!&quot;;</span>

<span class="cp">@files = ();</span>
<span class="cp">while( defined ($file = readdir(DH)) ) {</span>
<span class="cp">    next unless /\.[ch]$/i;</span>

<span class="cp">    my $filename = &quot;$dir/$file&quot;;</span>
<span class="cp">    push(@files, $filename) if -T $file;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@dirs = map  { $_-&gt;[1] }                # extract pathnames</span>
<span class="cp">        sort { $a-&gt;[0] &lt;=&gt; $b-&gt;[0] }    # sort names numeric</span>
<span class="cp">        grep { -d $_-&gt;[1] }             # path is a dir</span>
<span class="cp">        map  { [ $_, &quot;$path/$_&quot; ] }     # form (name, path)</span>
<span class="cp">        grep { /^\d+$/ }                # just numerics</span>
<span class="cp">        readdir(DIR);                   # all files</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::Find;</span>
<span class="cp">sub process_file {</span>
<span class="cp">    # do whatever;</span>
<span class="cp">}</span>
<span class="cp">find(\&amp;process_file, @DIRLIST);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ARGV = qw(.) unless @ARGV;</span>
<span class="cp">use File::Find;</span>
<span class="cp">find sub { print $File::Find::name, -d &amp;&amp; &#39;/&#39;, &quot;\n&quot; }, @ARGV;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::Find;</span>
<span class="cp">@ARGV = (&#39;.&#39;) unless @ARGV;</span>
<span class="cp">my $sum = 0;</span>
<span class="cp">find sub { $sum += -s }, @ARGV;</span>
<span class="cp">print &quot;@ARGV contains $sum bytes\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::Find;</span>
<span class="cp">@ARGV = (&#39;.&#39;) unless @ARGV;</span>
<span class="cp">my ($saved_size, $saved_name) = (-1, &#39;&#39;);</span>
<span class="cp">sub biggest {</span>
<span class="cp">    return unless -f &amp;&amp; -s _ &gt; $saved_size;</span>
<span class="cp">    $saved_size = -s _;</span>
<span class="cp">    $saved_name = $File::Find::name;</span>
<span class="cp">}</span>
<span class="cp">find(\&amp;biggest, @ARGV);</span>
<span class="cp">print &quot;Biggest file $saved_name in @ARGV is $saved_size bytes long.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::Find;</span>
<span class="cp">@ARGV = (&#39;.&#39;) unless @ARGV;</span>
<span class="cp">my ($age, $name);</span>
<span class="cp">sub youngest {</span>
<span class="cp">    return if defined $age &amp;&amp; $age &gt; (stat($_))[9];</span>
<span class="cp">    $age = (stat(_))[9];</span>
<span class="cp">    $name = $File::Find::name;</span>
<span class="cp">}</span>
<span class="cp">find(\&amp;youngest, @ARGV);</span>
<span class="cp">print &quot;$name &quot; . scalar(localtime($age)) . &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch09/fdirs</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -lw</span>
<span class="cp"># fdirs - find all directories</span>
<span class="cp">@ARGV = qw(.) unless @ARGV;</span>
<span class="cp">use File::Find ();</span>
<span class="cp">sub find(&amp;@) { &amp;File::Find::find }</span>
<span class="cp">*name = *File::Find::name;</span>
<span class="cp">find { print $name if -d } @ARGV;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">find sub { print $File::Find::name if -d }, @ARGV;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">find { print $name if -d } @ARGV;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch09/rmtree1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># rmtree1 - remove whole directory trees like rm -r</span>
<span class="cp">use File::Find qw(finddepth);</span>
<span class="cp">die &quot;usage: $0 dir ..\n&quot; unless @ARGV;</span>
<span class="cp">*name = *File::Find::name;</span>
<span class="cp">finddepth \&amp;zap, @ARGV;</span>
<span class="cp">sub zap {</span>
<span class="cp">    if (!-l &amp;&amp; -d _) {</span>
<span class="cp">        print &quot;rmdir $name\n&quot;;</span>
<span class="cp">        rmdir($name)  or warn &quot;couldn&#39;t rmdir $name: $!&quot;;</span>
<span class="cp">    } else {</span>
<span class="cp">        print &quot;unlink $name&quot;;</span>
<span class="cp">        unlink($name) or warn &quot;couldn&#39;t unlink $name: $!&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch09/rmtree2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># rmtree2 - remove whole directory trees like rm -r</span>
<span class="cp">use File::Path;</span>
<span class="cp">die &quot;usage: $0 dir ..\n&quot; unless @ARGV;</span>
<span class="cp">    foreach $dir (@ARGV) {</span>
<span class="cp">    rmtree($dir);</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $file (@NAMES) {</span>
<span class="cp">    my $newname = $file;</span>
<span class="cp">    # change $newname</span>
<span class="cp">    rename($file, $newname) or  </span>
<span class="cp">        warn &quot;Couldn&#39;t rename $file to $newname: $!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch09/rename</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># rename - Larry&#39;s filename fixer</span>
<span class="cp">$op = shift or die &quot;Usage: rename expr [files]\n&quot;;</span>
<span class="cp">chomp(@ARGV = &lt;STDIN&gt;) unless @ARGV;</span>
<span class="cp">for (@ARGV) {</span>
<span class="cp">    $was = $_;</span>
<span class="cp">    eval $op;</span>
<span class="cp">    die $@ if $@;</span>
<span class="cp">    rename($was,$_) unless $was eq $_;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% rename &#39;s/\.orig$//&#39;  *.orig</span>
<span class="cp">#% rename &#39;tr/A-Z/a-z/ unless /^Make/&#39;  *</span>
<span class="cp">#% rename &#39;$_ .= &quot;.bad&quot;&#39;  *.f</span>
<span class="cp">#% rename &#39;print &quot;$_: &quot;; s/foo/bar/ if &lt;STDIN&gt; =~ /^y/i&#39;  *</span>
<span class="cp">#% find /tmp -name &#39;*~&#39; -print | rename &#39;s/^(.+)~$/.#$1/&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% rename &#39;use locale; $_ = lc($_) unless /^Make/&#39; *</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use File::Basename;</span>

<span class="cp">$base = basename($path);</span>
<span class="cp">$dir  = dirname($path);</span>
<span class="cp">($base, $dir, $ext) = fileparse($path);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$path = &#39;/usr/lib/libc.a&#39;;</span>
<span class="cp">$file = basename($path);    </span>
<span class="cp">$dir  = dirname($path);     </span>

<span class="cp">print &quot;dir is $dir, file is $file\n&quot;;</span>
<span class="cp"># dir is /usr/lib, file is libc.a</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$path = &#39;/usr/lib/libc.a&#39;;</span>
<span class="cp">($name,$dir,$ext) = fileparse($path,&#39;\..*&#39;);</span>

<span class="cp">print &quot;dir is $dir, name is $name, extension is $ext\n&quot;;</span>
<span class="cp"># dir is /usr/lib/, name is libc, extension is .a</span>
<span class="cp">#-----------------------------</span>
<span class="cp">fileparse_set_fstype(&quot;MacOS&quot;);</span>
<span class="cp">$path = &quot;Hard%20Drive:System%20Folder:README.txt&quot;;</span>
<span class="cp">($name,$dir,$ext) = fileparse($path,&#39;\..*&#39;);</span>

<span class="cp">print &quot;dir is $dir, name is $name, extension is $ext\n&quot;;</span>
<span class="cp"># dir is Hard%20Drive:System%20Folder, name is README, extension is .txt</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub extension {</span>
<span class="cp">    my $path = shift;</span>
<span class="cp">    my $ext = (fileparse($path,&#39;\..*&#39;))[2];</span>
<span class="cp">    $ext =~ s/^\.//;</span>
<span class="cp">    return $ext;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch09/symirror</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># symirror - build spectral forest of symlinks</span>
<span class="cp">use strict;</span>
<span class="cp">use File::Find;</span>
<span class="cp">use Cwd;</span>

<span class="cp">my ($srcdir, $dstdir);</span>
<span class="cp">my $cwd = getcwd();</span>
<span class="cp">die &quot;usage: $0 realdir mirrordir&quot; unless @ARGV == 2;</span>

<span class="cp">for (($srcdir, $dstdir) = @ARGV) {</span>
<span class="cp">    my $is_dir = -d;</span>
<span class="cp">    next if $is_dir;                        # cool</span>
<span class="cp">    if (defined ($is_dir)) {</span>
<span class="cp">        die &quot;$0: $_ is not a directory\n&quot;;</span>
<span class="cp">    } else {                                # be forgiving</span>
<span class="cp">        mkdir($dstdir, 07777) or die &quot;can&#39;t mkdir $dstdir: $!&quot;;</span>
<span class="cp">    }</span>
<span class="cp">} continue {</span>
<span class="cp">    s#^(?!/)#$cwd/#;                        # fix relative paths</span>
<span class="cp">}</span>
<span class="cp">                    </span>
<span class="cp">chdir $srcdir;</span>
<span class="cp">find(\&amp;wanted, &#39;.&#39;);</span>

<span class="cp">sub wanted {</span>
<span class="cp">    my($dev, $ino, $mode) = lstat($_);</span>
<span class="cp">    my $name = $File::Find::name;</span>
<span class="cp">    $mode &amp;= 07777;                 # preserve directory permissions</span>
<span class="cp">    $name =~ s!^\./!!;              # correct name</span>
<span class="cp">    if (-d _) {                     # then make a real directory</span>
<span class="cp">        mkdir(&quot;$dstdir/$name&quot;, $mode)</span>
<span class="cp">            or die &quot;can&#39;t mkdir $dstdir/$name: $!&quot;;</span>
<span class="cp">    } else {                        # shadow everything else</span>
<span class="cp">        symlink(&quot;$srcdir/$name&quot;, &quot;$dstdir/$name&quot;)</span>
<span class="cp">            or die &quot;can&#39;t symlink $srcdir/$name to $dstdir/$name: $!&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_9.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% lst -l /etc</span>
<span class="cp">#12695 0600      1     root    wheel      512 Fri May 29 10:42:41 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/ssh_random_seed</span>
<span class="cp">#</span>
<span class="cp">#12640 0644      1     root    wheel    10104 Mon May 25  7:39:19 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/ld.so.cache</span>
<span class="cp">#</span>
<span class="cp">#12626 0664      1     root    wheel    12288 Sun May 24 19:23:08 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/psdevtab</span>
<span class="cp">#</span>
<span class="cp">#12304 0644      1     root     root      237 Sun May 24 13:59:33 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/exports</span>
<span class="cp">#</span>
<span class="cp">#12309 0644      1     root     root     3386 Sun May 24 13:24:33 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/inetd.conf</span>
<span class="cp">#</span>
<span class="cp">#12399 0644      1     root     root    30205 Sun May 24 10:08:37 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/sendmail.cf</span>
<span class="cp">#</span>
<span class="cp">#18774 0644      1     gnat  perldoc     2199 Sun May 24  9:35:57 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/X11/XMetroconfig</span>
<span class="cp">#</span>
<span class="cp">#12636 0644      1     root    wheel      290 Sun May 24  9:05:40 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/mtab</span>
<span class="cp">#</span>
<span class="cp">#12627 0640      1     root     root        0 Sun May 24  8:24:31 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/wtmplock</span>
<span class="cp">#</span>
<span class="cp">#12310 0644      1     root  tchrist       65 Sun May 24  8:23:04 1998 </span>
<span class="cp">#</span>
<span class="cp">#    /etc/issue</span>
<span class="cp">#</span>
<span class="cp">#....</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch09/lst</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># lst - list sorted directory contents (depth first)</span>

<span class="cp">use Getopt::Std;</span>
<span class="cp">use File::Find;</span>
<span class="cp">use File::stat;</span>
<span class="cp">use User::pwent;</span>
<span class="cp">use User::grent;</span>

<span class="cp">getopts(&#39;lusrcmi&#39;)    			or die &lt;&lt;DEATH;</span>
<span class="cp">Usage: $0 [-mucsril] [dirs ...]</span>
<span class="cp"> or    $0 -i [-mucsrl] &lt; filelist</span>

<span class="cp">Input format:</span>
<span class="cp">    -i  read pathnames from stdin</span>
<span class="cp">Output format:</span>
<span class="cp">    -l  long listing</span>
<span class="cp">Sort on:</span>
<span class="cp">    -m  use mtime (modify time) [DEFAULT]</span>
<span class="cp">    -u  use atime (access time)</span>
<span class="cp">    -c  use ctime (inode change time)</span>
<span class="cp">    -s  use size for sorting</span>
<span class="cp">Ordering:</span>
<span class="cp">    -r  reverse sort</span>
<span class="cp">NB: You may only use select one sorting option at a time.</span>
<span class="cp">DEATH</span>
<span class="cp">    </span>
<span class="cp">unless ($opt_i || @ARGV) { @ARGV = (&#39;.&#39;) }</span>

<span class="cp">if ($opt_c + $opt_u + $opt_s + $opt_m &gt; 1) {</span>
<span class="cp">    die &quot;can only sort on one time or size&quot;;</span>
<span class="cp">}</span>

<span class="cp">$IDX = &#39;mtime&#39;;</span>
<span class="cp">$IDX = &#39;atime&#39; if $opt_u;</span>
<span class="cp">$IDX = &#39;ctime&#39; if $opt_c;</span>
<span class="cp">$IDX = &#39;size&#39;  if $opt_s;</span>

<span class="cp">$TIME_IDX = $opt_s ? &#39;mtime&#39; : $IDX;</span>

<span class="cp">*name = *File::Find::name;  # forcibly import that variable</span>

<span class="cp"># the $opt_i flag tricks wanted into taking</span>
<span class="cp"># its filenames from ARGV instead of being</span>
<span class="cp"># called from find.</span>

<span class="cp">if ($opt_i) {</span>
<span class="cp">     *name = *_;  # $name now alias for $_</span>
<span class="cp">     while (&lt;&gt;) { chomp; &amp;wanted; }   # ok, not stdin really</span>
<span class="cp">}  else {</span>
<span class="cp">    find(\&amp;wanted, @ARGV);</span>
<span class="cp">}</span>

<span class="cp"># sort the files by their cached times, youngest first</span>
<span class="cp">@skeys = sort { $time{$b} &lt;=&gt; $time{$a} } keys %time;</span>

<span class="cp"># but flip the order if -r was supplied on command line</span>
<span class="cp">@skeys = reverse @skeys if $opt_r;</span>

<span class="cp">for (@skeys) {</span>
<span class="cp">    unless ($opt_l) {  # emulate ls -l, except for permissions</span>
<span class="cp">        print &quot;$_\n&quot;;</span>
<span class="cp">        next;</span>
<span class="cp">    }</span>
<span class="cp">    $now = localtime $stat{$_}-&gt;$TIME_IDX();</span>
<span class="cp">    printf &quot;%6d %04o %6d %8s %8s %8d %s %s\n&quot;,</span>
<span class="cp">    	$stat{$_}-&gt;ino(),</span>
<span class="cp">    	$stat{$_}-&gt;mode() &amp; 07777,</span>
<span class="cp">    	$stat{$_}-&gt;nlink(),</span>
<span class="cp">    	user($stat{$_}-&gt;uid()),</span>
<span class="cp">    	group($stat{$_}-&gt;gid()),</span>
<span class="cp">    	$stat{$_}-&gt;size(),</span>
<span class="cp">    	$now, $_;</span>
<span class="cp">}</span>

<span class="cp"># get stat info on the file, saving the desired</span>
<span class="cp"># sort criterion (mtime, atime, ctime, or size)</span>
<span class="cp"># in the %time hash indexed by filename.</span>
<span class="cp"># if they want a long list, we have to save the</span>
<span class="cp"># entire stat object in %stat.  yes, this is a</span>
<span class="cp"># hash of objects</span>
<span class="cp">sub wanted {</span>
<span class="cp">    my $sb = stat($_);  # XXX: should be stat or lstat?</span>
<span class="cp">    return unless $sb;</span>
<span class="cp">    $time{$name} = $sb-&gt;$IDX();  # indirect method call</span>
<span class="cp">    $stat{$name} = $sb if $opt_l;</span>
<span class="cp">}</span>

<span class="cp"># cache user number to name conversions</span>
<span class="cp">sub user {</span>
<span class="cp">    my $uid = shift;</span>
<span class="cp">    $user{$uid} = getpwuid($uid)-&gt;name || &quot;#$uid&quot;</span>
<span class="cp">        unless defined $user{$uid};</span>
<span class="cp">    return $user{$uid};</span>
<span class="cp">}</span>

<span class="cp"># cache group number to name conversions</span>
<span class="cp">sub group {</span>
<span class="cp">    my $gid = shift;</span>
<span class="cp">    $group{$gid} = getgrgid($gid)-&gt;name || &quot;#$gid&quot;</span>
<span class="cp">        unless defined $group{$gid};</span>
<span class="cp">    return $group{$gid};</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub hello { </span>
<span class="cp">    $greeted++;          # global variable </span>
<span class="cp">    print &quot;hi there!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">hello();                 # call subroutine hello with no arguments/parameters</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub hypotenuse {</span>
<span class="cp">    return sqrt( ($_[0] ** 2) + ($_[1] ** 2) );</span>
<span class="cp">}</span>

<span class="cp">$diag = hypotenuse(3,4);  # $diag is 5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub hypotenuse {</span>
<span class="cp">    my ($side1, $side2) = @_;</span>
<span class="cp">    return sqrt( ($side1 ** 2) + ($side2 ** 2) );</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print hypotenuse(3, 4), &quot;\n&quot;;               # prints 5</span>

<span class="cp">@a = (3, 4);</span>
<span class="cp">print hypotenuse(@a), &quot;\n&quot;;                 # prints 5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@both = (@men, @women);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@nums = (1.4, 3.5, 6.7);</span>
<span class="cp">@ints = int_all(@nums);        # @nums unchanged</span>
<span class="cp">sub int_all {</span>
<span class="cp">    my @retlist = @_;          # make safe copy for return</span>
<span class="cp">    for my $n (@retlist) { $n = int($n) } </span>
<span class="cp">    return @retlist;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">@nums = (1.4, 3.5, 6.7);</span>
<span class="cp">trunc_em(@nums);               # @nums now (1,3,6)</span>
<span class="cp">sub trunc_em {</span>
<span class="cp">    for (@_) { $_ = int($_) }  # truncate each argument</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$line = chomp(&lt;&gt;);                  # WRONG</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub somefunc {</span>
<span class="cp">    my $variable;                 # $variable is invisible outside somefunc()</span>
<span class="cp">    my ($another, @an_array, %a_hash);     # declaring many variables at once</span>

<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my ($name, $age) = @ARGV;</span>
<span class="cp">my $start        = fetch_time();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my ($a, $b) = @pair;</span>
<span class="cp">my $c = fetch_time();</span>

<span class="cp">sub check_x {</span>
<span class="cp">    my $x = $_[0];       </span>
<span class="cp">    my $y = &quot;whatever&quot;;  </span>
<span class="cp">    run_check();</span>
<span class="cp">    if ($condition) {</span>
<span class="cp">        print &quot;got $x\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub save_array {</span>
<span class="cp">    my @arguments = @_;</span>
<span class="cp">    push(@Global_Array, \@arguments);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{</span>
<span class="cp">    my $variable;</span>
<span class="cp">    sub mysub {</span>
<span class="cp">        # ... accessing $variable</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">BEGIN {</span>
<span class="cp">    my $variable = 1;                       # initial value</span>
<span class="cp">    sub othersub {                          # ... accessing $variable</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{</span>
<span class="cp">    my $counter;</span>
<span class="cp">    sub next_counter { return ++$counter }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">BEGIN {</span>
<span class="cp">    my $counter = 42;</span>
<span class="cp">    sub next_counter { return ++$counter }</span>
<span class="cp">    sub prev_counter { return --$counter }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$this_function = (caller(0))[3];</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($package, $filename, $line, $subr, $has_args, $wantarray )= caller($i);</span>
<span class="cp">#   0         1         2       3       4          5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$me  = whoami();</span>
<span class="cp">$him = whowasi();</span>

<span class="cp">sub whoami  { (caller(1))[3] }</span>
<span class="cp">sub whowasi { (caller(2))[3] }</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">array_diff( \@array1, \@array2 );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@a = (1, 2);</span>
<span class="cp">@b = (5, 8);</span>
<span class="cp">@c = add_vecpair( \@a, \@b );</span>
<span class="cp">print &quot;@c\n&quot;;</span>
<span class="cp">6 10</span>
<span class="cp"> </span>

<span class="cp">sub add_vecpair {       # assumes both vectors the same length</span>
<span class="cp">    my ($x, $y) = @_;   # copy in the array references</span>
<span class="cp">    my @result;</span>

<span class="cp">    for (my $i=0; $i &lt; @$x; $i++) {</span>
<span class="cp">      $result[$i] = $x-&gt;[$i] + $y-&gt;[$i];</span>
<span class="cp">    }</span>

<span class="cp">    return @result;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unless (@_ == 2 &amp;&amp; ref($x) eq &#39;ARRAY&#39; &amp;&amp; ref($y) eq &#39;ARRAY&#39;) {</span>
<span class="cp">    die &quot;usage: add_vecpair ARRAYREF1 ARRAYREF2&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if (wantarray()) {</span>
<span class="cp">    # list context</span>
<span class="cp">} </span>
<span class="cp">elsif (defined wantarray()) {</span>
<span class="cp">    # scalar context</span>
<span class="cp">} </span>
<span class="cp">else {</span>
<span class="cp">    # void context</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">if (wantarray()) {</span>
<span class="cp">    print &quot;In list context\n&quot;;</span>
<span class="cp">    return @many_things;</span>
<span class="cp">} elsif (defined wantarray()) {</span>
<span class="cp">    print &quot;In scalar context\n&quot;;</span>
<span class="cp">    return $one_thing;</span>
<span class="cp">} else {</span>
<span class="cp">    print &quot;In void context\n&quot;;</span>
<span class="cp">    return;  # nothing</span>
<span class="cp">}</span>

<span class="cp">mysub();                    # void context</span>

<span class="cp">$a = mysub();               # scalar context</span>
<span class="cp">if (mysub()) {  }           # scalar context</span>

<span class="cp">@a = mysub();               # list context</span>
<span class="cp">print mysub();              # list context</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">thefunc(INCREMENT =&gt; &quot;20s&quot;, START =&gt; &quot;+5m&quot;, FINISH =&gt; &quot;+30m&quot;);</span>
<span class="cp">thefunc(START =&gt; &quot;+5m&quot;, FINISH =&gt; &quot;+30m&quot;);</span>
<span class="cp">thefunc(FINISH =&gt; &quot;+30m&quot;);</span>
<span class="cp">thefunc(START =&gt; &quot;+5m&quot;, INCREMENT =&gt; &quot;15s&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub thefunc {</span>
<span class="cp">    my %args = ( </span>
<span class="cp">        INCREMENT   =&gt; &#39;10s&#39;, </span>
<span class="cp">        FINISH      =&gt; 0, </span>
<span class="cp">        START       =&gt; 0, </span>
<span class="cp">        @_,         # argument pair list goes here</span>
<span class="cp">    );</span>
<span class="cp">    if ($args{INCREMENT}  =~ /m$/ ) { ..... }</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($a, undef, $c) = func();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($a, $c) = (func())[0,2];</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($dev,$ino,$DUMMY,$DUMMY,$uid) = stat($filename);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($dev,$ino,undef,undef,$uid)   = stat($filename);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($dev,$ino,$uid,$gid)   = (stat($filename))[0,1,4,5];</span>
<span class="cp">#-----------------------------</span>
<span class="cp">() = some_function();</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($array_ref, $hash_ref) = somefunc();</span>

<span class="cp">sub somefunc {</span>
<span class="cp">    my @array;</span>
<span class="cp">    my %hash;</span>

<span class="cp">    # ...</span>

<span class="cp">    return ( \@array, \%hash );</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub fn { </span>
<span class="cp">    .....</span>
<span class="cp">    return (\%a, \%b, \%c); # or                           </span>
<span class="cp">    return \(%a,  %b,  %c); # same thing</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">(%h0, %h1, %h2)  = fn();    # WRONG!</span>
<span class="cp">@array_of_hashes = fn();    # eg: $array_of_hashes[2]-&gt;{&quot;keystring&quot;}</span>
<span class="cp">($r0, $r1, $r2)  = fn();    # eg: $r2-&gt;{&quot;keystring&quot;}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">return;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub empty_retval {</span>
<span class="cp">    return ( wantarray ? () : undef );</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if (@a = yourfunc()) { ... }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unless ($a = sfunc()) { die &quot;sfunc failed&quot; }</span>
<span class="cp">unless (@a = afunc()) { die &quot;afunc failed&quot; }</span>
<span class="cp">unless (%a = hfunc()) { die &quot;hfunc failed&quot; }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">ioctl(....) or die &quot;can&#39;t ioctl: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@results = myfunc 3, 5;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@results = myfunc(3, 5);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub myfunc($);</span>
<span class="cp">@results = myfunc 3, 5;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@results = ( myfunc(3), 5 );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub LOCK_SH () { 1 }</span>
<span class="cp">sub LOCK_EX () { 2 }</span>
<span class="cp">sub LOCK_UN () { 4 }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub mypush (\@@) {</span>
<span class="cp">  my $array_ref = shift;</span>
<span class="cp">  my @remainder = @_;</span>

<span class="cp">  # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"> mypush( $x &gt; 10 ? @a : @b , 3, 5 );          # WRONG</span>
<span class="cp">#-----------------------------</span>
<span class="cp"> mypush( @{ $x &gt; 10 ? \@a : \@b }, 3, 5 );    # RIGHT</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub hpush(\%@) {</span>
<span class="cp">    my $href = shift;</span>
<span class="cp">    while ( my ($k, $v) = splice(@_, 0, 2) ) {</span>
<span class="cp">        $href-&gt;{$k} = $v;</span>
<span class="cp">    } </span>
<span class="cp">} </span>
<span class="cp">hpush(%pieces, &quot;queen&quot; =&gt; 9, &quot;rook&quot; =&gt; 5);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">die &quot;some message&quot;;         # raise exception</span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval { func() };</span>
<span class="cp">if ($@) {</span>
<span class="cp">    warn &quot;func raised an exception: $@&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval { $val = func() };</span>
<span class="cp">warn &quot;func blew up: $@&quot; if $@;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval { $val = func() };</span>
<span class="cp">if ($@ &amp;&amp; $@ !~ /Full moon!/) {</span>
<span class="cp">    die;    # re-raise unknown errors</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if (defined wantarray()) {</span>
<span class="cp">        return;</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;pay attention to my error!&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$age = 18;          # global variable</span>
<span class="cp">if (CONDITION) {</span>
<span class="cp">    local $age = 23;</span>
<span class="cp">    func();         # sees temporary value of 23</span>
<span class="cp">} # restore old value at block exit</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$para = get_paragraph(*FH);        # pass filehandle glob </span>
<span class="cp">$para = get_paragraph(\*FH);       # pass filehandle by glob reference</span>
<span class="cp">$para = get_paragraph(*IO{FH});    # pass filehandle by IO reference</span>
<span class="cp">sub get_paragraph {</span>
<span class="cp">    my $fh = shift;  </span>
<span class="cp">    local $/ = &#39;&#39;;        </span>
<span class="cp">    my $paragraph = &lt;$fh&gt;;</span>
<span class="cp">    chomp($paragraph);</span>
<span class="cp">    return $paragraph;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$contents = get_motd();</span>
<span class="cp">sub get_motd {</span>
<span class="cp">    local *MOTD;</span>
<span class="cp">    open(MOTD, &quot;/etc/motd&quot;)        or die &quot;can&#39;t open motd: $!&quot;;</span>
<span class="cp">    local $/ = undef;  # slurp full file;</span>
<span class="cp">    local $_ = &lt;MOTD&gt;;</span>
<span class="cp">    close (MOTD);</span>
<span class="cp">    return $_;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">return *MOTD;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my @nums = (0 .. 5);</span>
<span class="cp">sub first { </span>
<span class="cp">    local $nums[3] = 3.14159;</span>
<span class="cp">    second();</span>
<span class="cp">}</span>
<span class="cp">sub second {</span>
<span class="cp">    print &quot;@nums\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">second();</span>
<span class="cp">0 1 2 3 4 5</span>

<span class="cp">first();</span>
<span class="cp">0 1 2 3.14159 4 5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub first {</span>
<span class="cp">    local $SIG{INT} = &#39;IGNORE&#39;;</span>
<span class="cp">    second();</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub func {</span>
<span class="cp">    local($x, $y) = @_;</span>
<span class="cp">    #....</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub func {</span>
<span class="cp">    my($x, $y) = @_;</span>
<span class="cp">    #....</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">&amp;func(*Global_Array);</span>
<span class="cp">sub func {</span>
<span class="cp">    local(*aliased_array) = shift;</span>
<span class="cp">    for (@aliased_array) { .... }</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">func(\@Global_Array);</span>
<span class="cp">sub func {</span>
<span class="cp">    my $array_ref  = shift;</span>
<span class="cp">    for (@$array_ref) { .... }</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">undef &amp;grow;                # silence -w complaints of redefinition</span>
<span class="cp">*grow = \&amp;expand;           </span>
<span class="cp">grow();                     # calls expand()</span>

<span class="cp">{</span>
<span class="cp">    local *grow = \&amp;shrink;         # only until this block exists</span>
<span class="cp">        grow();                 # calls shrink()</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">*one::var = \%two::Table;   # make %one::var alias for %two::Table</span>
<span class="cp">*one::big = \&amp;two::small;   # make &amp;one::big alias for &amp;two::small</span>
<span class="cp">#-----------------------------</span>
<span class="cp">local *fred = \&amp;barney;     # temporarily alias &amp;fred to &amp;barney</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$string =  red(&quot;careful here&quot;);</span>
<span class="cp">print $string;</span>
<span class="cp">&lt;FONT COLOR=&#39;red&#39;&gt;careful here&lt;/FONT&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub red { &quot;&lt;FONT COLOR=&#39;red&#39;&gt;@_&lt;/FONT&gt;&quot; }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub color_font {</span>
<span class="cp">    my $color = shift;</span>
<span class="cp">    return &quot;&lt;FONT COLOR=&#39;$color&#39;&gt;@_&lt;/FONT&gt;&quot;;</span>
<span class="cp">}</span>
<span class="cp">sub red    { color_font(&quot;red&quot;, @_)     }</span>
<span class="cp">sub green  { color_font(&quot;green&quot;, @_)   }</span>
<span class="cp">sub blue   { color_font(&quot;blue&quot;, @_)    }</span>
<span class="cp">sub purple { color_font(&quot;purple&quot;, @_)  }</span>
<span class="cp"># etc</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@colors = qw(red blue green yellow orange purple violet);</span>
<span class="cp">for my $name (@colors) {</span>
<span class="cp">    no strict &#39;refs&#39;;</span>
<span class="cp">    *$name = sub { &quot;&lt;FONT COLOR=&#39;$name&#39;&gt;@_&lt;/FONT&gt;&quot; };</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">*$name = sub ($) { &quot;&lt;FONT COLOR=&#39;$name&#39;&gt;$_[0]&lt;/FONT&gt;&quot; };</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub AUTOLOAD {</span>
<span class="cp">    use vars qw($AUTOLOAD);</span>
<span class="cp">    my $color = $AUTOLOAD;</span>
<span class="cp">    $color =~ s/.*:://;</span>
<span class="cp">    return &quot;&lt;FONT COLOR=&#39;$color&#39;&gt;@_&lt;/FONT&gt;&quot;;</span>
<span class="cp">} </span>
<span class="cp">#note: sub chartreuse isn&#39;t defined.</span>
<span class="cp">print chartreuse(&quot;stuff&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{</span>
<span class="cp">    local *yellow = \&amp;violet;  </span>
<span class="cp">    local (*red, *green) = (\&amp;green, \&amp;red);</span>
<span class="cp">    print_stuff();</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub outer {</span>
<span class="cp">    my $x = $_[0] + 35;</span>
<span class="cp">    sub inner { return $x * 19 }   # WRONG</span>
<span class="cp">    return $x + inner();</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub outer {</span>
<span class="cp">    my $x = $_[0] + 35;</span>
<span class="cp">    local *inner = sub { return $x * 19 };</span>
<span class="cp">    return $x + inner();</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_10.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch10/bysub1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl </span>
<span class="cp"># bysub1 - simple sort by subject</span>
<span class="cp">my(@msgs, @sub);</span>
<span class="cp">my $msgno = -1;</span>
<span class="cp">$/ = &#39;&#39;;                    # paragraph reads</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    if (/^From/m) {</span>
<span class="cp">        /^Subject:\s*(?:Re:\s*)*(.*)/mi;</span>
<span class="cp">        $sub[++$msgno] = lc($1) || &#39;&#39;;</span>
<span class="cp">    }</span>
<span class="cp">    $msgs[$msgno] .= $_;</span>
<span class="cp">} </span>
<span class="cp">for my $i (sort { $sub[$a] cmp $sub[$b] || $a &lt;=&gt; $b } (0 .. $#msgs)) {</span>
<span class="cp">    print $msgs[$i];</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch10/bysub2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -n00</span>
<span class="cp"># bysub2 - awkish sort-by-subject</span>
<span class="cp">BEGIN { $msgno = -1 }</span>
<span class="cp">$sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;</span>
<span class="cp">$msg[$msgno] .= $_;</span>
<span class="cp">END { print @msg[ sort { $sub[$a] cmp $sub[$b] || $a &lt;=&gt; $b } (0 .. $#msg) ] }</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch10/bysub3</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -00</span>
<span class="cp"># bysub3 - sort by subject using hash records</span>
<span class="cp">use strict;</span>
<span class="cp">my @msgs = ();</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    push @msgs, {</span>
<span class="cp">        SUBJECT =&gt; /^Subject:\s*(?:Re:\s*)*(.*)/mi,</span>
<span class="cp">        NUMBER  =&gt; scalar @msgs,   # which msgno this is</span>
<span class="cp">        TEXT    =&gt; &#39;&#39;,</span>
<span class="cp">    } if /^From/m;</span>
<span class="cp">    $msgs[-1]{TEXT} .= $_;</span>
<span class="cp">} </span>

<span class="cp">for my $msg (sort {     </span>
<span class="cp">                        $a-&gt;{SUBJECT} cmp $b-&gt;{SUBJECT} </span>
<span class="cp">                                       || </span>
<span class="cp">                        $a-&gt;{NUMBER}  &lt;=&gt; $b-&gt;{NUMBER} </span>
<span class="cp">                  } @msgs</span>
<span class="cp">         )</span>
<span class="cp">{</span>
<span class="cp">    print $msg-&gt;{TEXT};</span>
<span class="cp">} </span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch10/datesort</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -00</span>
<span class="cp"># datesort - sort mbox by subject then date</span>
<span class="cp">use strict;</span>
<span class="cp">use Date::Manip;</span>
<span class="cp">my @msgs = ();</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    next unless /^From/m;</span>
<span class="cp">    my $date = &#39;&#39;;</span>
<span class="cp">    if (/^Date:\s*(.*)/m) {</span>
<span class="cp">        ($date = $1) =~ s/\s+\(.*//;  # library hates (MST)</span>
<span class="cp">        $date = ParseDate($date);</span>
<span class="cp">    } </span>
<span class="cp">    push @msgs, {</span>
<span class="cp">        SUBJECT =&gt; /^Subject:\s*(?:Re:\s*)*(.*)/mi,</span>
<span class="cp">        DATE    =&gt; $date,</span>
<span class="cp">        NUMBER  =&gt; scalar @msgs,</span>
<span class="cp">        TEXT    =&gt; &#39;&#39;,</span>
<span class="cp">    }; </span>
<span class="cp">} continue {</span>
<span class="cp">    $msgs[-1]{TEXT} .= $_;</span>
<span class="cp">}</span>

<span class="cp">for my $msg (sort {     </span>
<span class="cp">                        $a-&gt;{SUBJECT} cmp $b-&gt;{SUBJECT} </span>
<span class="cp">                                       || </span>
<span class="cp">                        $a-&gt;{DATE}    cmp $b-&gt;{DATE} </span>
<span class="cp">                                       || </span>
<span class="cp">                        $a-&gt;{NUMBER}  &lt;=&gt; $b-&gt;{NUMBER} </span>
<span class="cp">                  } @msgs</span>
<span class="cp">         )</span>
<span class="cp">{</span>
<span class="cp">    print $msg-&gt;{TEXT};</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print $$sref;    # prints the scalar value that the reference $sref refers to</span>
<span class="cp">$$sref = 3;      # assigns to $sref&#39;s referent</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print ${$sref};             # prints the scalar $sref refers to</span>
<span class="cp">${$sref} = 3;               # assigns to $sref&#39;s referent</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$aref = \@array;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pi = \3.14159;</span>
<span class="cp">$$pi = 4;           # runtime error</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$aref = [ 3, 4, 5 ];                                # new anonymous array</span>
<span class="cp">$href = { &quot;How&quot; =&gt; &quot;Now&quot;, &quot;Brown&quot; =&gt; &quot;Cow&quot; };       # new anonymous hash</span>
<span class="cp">#-----------------------------</span>
<span class="cp">undef $aref;</span>
<span class="cp">@$aref = (1, 2, 3);</span>
<span class="cp">print $aref;</span>
<span class="cp">ARRAY(0x80c04f0)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$a[4][23][53][21] = &quot;fred&quot;;</span>
<span class="cp">print $a[4][23][53][21];</span>
<span class="cp">fred</span>

<span class="cp">print $a[4][23][53];</span>
<span class="cp">ARRAY(0x81e2494)</span>

<span class="cp">print $a[4][23];</span>
<span class="cp">ARRAY(0x81e0748)</span>

<span class="cp">print $a[4];</span>
<span class="cp">ARRAY(0x822cd40)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$op_cit = cite($ibid)       or die &quot;couldn&#39;t make a reference&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$Nat = { &quot;Name&quot;     =&gt; &quot;Leonhard Euler&quot;,</span>
<span class="cp">         &quot;Address&quot;  =&gt; &quot;1729 Ramanujan Lane\nMathworld, PI 31416&quot;,</span>
<span class="cp">         &quot;Birthday&quot; =&gt; 0x5bb5580,</span>
<span class="cp">       };</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$aref               = \@array;</span>
<span class="cp">$anon_array         = [1, 3, 5, 7, 9];</span>
<span class="cp">$anon_copy          = [ @array ];</span>
<span class="cp">@$implicit_creation = (2, 4, 6, 8, 10);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">push(@$anon_array, 11);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$two = $implicit_creation-&gt;[0];</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$last_idx  = $#$aref;</span>
<span class="cp">$num_items = @$aref;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$last_idx  = $#{ $aref };</span>
<span class="cp">$num_items = scalar @{ $aref };</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># check whether $someref contains a simple array reference</span>
<span class="cp">if (ref($someref) ne &#39;ARRAY&#39;) {</span>
<span class="cp">    die &quot;Expected an array reference, not $someref\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">print &quot;@{$array_ref}\n&quot;;        # print original data</span>

<span class="cp">@order = sort @{ $array_ref };  # sort it</span>

<span class="cp">push @{ $array_ref }, $item;    # append new element to orig array  </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub array_ref {</span>
<span class="cp">    my @array;</span>
<span class="cp">    return \@array;</span>
<span class="cp">}</span>

<span class="cp">$aref1 = array_ref();</span>
<span class="cp">$aref2 = array_ref();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print $array_ref-&gt;[$N];         # access item in position N (best)</span>
<span class="cp">print $$array_ref[$N];          # same, but confusing</span>
<span class="cp">print ${$array_ref}[$N];        # same, but still confusing, and ugly to boot</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@$pie[3..5];                    # array slice, but a little confusing to read</span>
<span class="cp">@{$pie}[3..5];                  # array slice, easier (?) to read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@{$pie}[3..5] = (&quot;blackberry&quot;, &quot;blueberry&quot;, &quot;pumpkin&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$sliceref = \@{$pie}[3..5];     # WRONG!</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $item ( @{$array_ref} ) {   </span>
<span class="cp">    # $item has data</span>
<span class="cp">}</span>

<span class="cp">for ($idx = 0; $idx &lt;= $#{ $array_ref }; $idx++) {  </span>
<span class="cp">    # $array_ref-&gt;[$idx] has data</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">push(@{ $hash{&quot;KEYNAME&quot;} }, &quot;new value&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $string (keys %hash) {</span>
<span class="cp">    print &quot;$string: @{$hash{$string}}\n&quot;; </span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$hash{&quot;a key&quot;} = [ 3, 4, 5 ];       # anonymous array</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@values = @{ $hash{&quot;a key&quot;} };</span>
<span class="cp">#-----------------------------</span>
<span class="cp">push @{ $hash{&quot;a key&quot;} }, $value;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@residents = @{ $phone2name{$number} };</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@residents = exists( $phone2name{$number} )</span>
<span class="cp">                ? @{ $phone2name{$number} }</span>
<span class="cp">                : ();</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$href = \%hash;</span>
<span class="cp">$anon_hash = { &quot;key1&quot; =&gt; &quot;value1&quot;, &quot;key2&quot; =&gt; &quot;value2&quot;, ... };</span>
<span class="cp">$anon_hash_copy = { %hash };</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%hash  = %$href;</span>
<span class="cp">$value = $href-&gt;{$key};</span>
<span class="cp">@slice = @$href{$key1, $key2, $key3};  # note: no arrow!</span>
<span class="cp">@keys  = keys %$href;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if (ref($someref) ne &#39;HASH&#39;) {</span>
<span class="cp">    die &quot;Expected a hash reference, not $someref\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $href ( \%ENV, \%INC ) {       # OR: for $href ( \(%ENV,%INC) ) {</span>
<span class="cp">    foreach $key ( keys %$href ) {</span>
<span class="cp">        print &quot;$key =&gt; $href-&gt;{$key}\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@values = @$hash_ref{&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;};</span>

<span class="cp">for $val (@$hash_ref{&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;}) {</span>
<span class="cp">    $val += 7;   # add 7 to each value in hash slice</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$cref = \&amp;func;</span>
<span class="cp">$cref = sub { ... };</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@returned = $cref-&gt;(@arguments);</span>
<span class="cp">@returned = &amp;$cref(@arguments);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$funcname = &quot;thefunc&quot;;</span>
<span class="cp">&amp;$funcname();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my %commands = (</span>
<span class="cp">    &quot;happy&quot; =&gt; \&amp;joy,</span>
<span class="cp">    &quot;sad&quot;   =&gt; \&amp;sullen,</span>
<span class="cp">    &quot;done&quot;  =&gt; sub { die &quot;See ya!&quot; },</span>
<span class="cp">    &quot;mad&quot;   =&gt; \&amp;angry,</span>
<span class="cp">);</span>

<span class="cp">print &quot;How are you? &quot;;</span>
<span class="cp">chomp($string = &lt;STDIN&gt;);</span>
<span class="cp">if ($commands{$string}) {</span>
<span class="cp">    $commands{$string}-&gt;();</span>
<span class="cp">} else {</span>
<span class="cp">    print &quot;No such command: $string\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub counter_maker {</span>
<span class="cp">    my $start = 0;</span>
<span class="cp">    return sub {                      # this is a closure</span>
<span class="cp">        return $start++;              # lexical from enclosing scope</span>
<span class="cp">    };</span>
<span class="cp">}</span>

<span class="cp">$counter = counter_maker();</span>

<span class="cp">for ($i = 0; $i &lt; 5; $i ++) {</span>
<span class="cp">    print &amp;$counter, &quot;\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$counter1 = counter_maker();</span>
<span class="cp">$counter2 = counter_maker();</span>

<span class="cp">for ($i = 0; $i &lt; 5; $i ++) {</span>
<span class="cp">    print &amp;$counter1, &quot;\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">print &amp;$counter1, &quot; &quot;, &amp;$counter2, &quot;\n&quot;;</span>
<span class="cp">0</span>

<span class="cp">1</span>

<span class="cp">2</span>

<span class="cp">3</span>

<span class="cp">4</span>

<span class="cp">5 0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub timestamp {</span>
<span class="cp">    my $start_time = time(); </span>
<span class="cp">    return sub { return time() - $start_time };</span>
<span class="cp">} </span>
<span class="cp">$early = timestamp(); </span>
<span class="cp">sleep 20; </span>
<span class="cp">$later = timestamp(); </span>
<span class="cp">sleep 10;</span>
<span class="cp">printf &quot;It&#39;s been %d seconds since early.\n&quot;, $early-&gt;();</span>
<span class="cp">printf &quot;It&#39;s been %d seconds since later.\n&quot;, $later-&gt;();</span>
<span class="cp">#It&#39;s been 30 seconds since early.</span>
<span class="cp">#</span>
<span class="cp">#It&#39;s been 10 seconds since later.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$scalar_ref = \$scalar;       # get reference to named scalar</span>
<span class="cp">#-----------------------------</span>
<span class="cp">undef $anon_scalar_ref;</span>
<span class="cp">$$anon_scalar_ref = 15;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$anon_scalar_ref = \15;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print ${ $scalar_ref };       # dereference it</span>
<span class="cp">${ $scalar_ref } .= &quot;string&quot;; # alter referent&#39;s value</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new_anon_scalar {</span>
<span class="cp">    my $temp;</span>
<span class="cp">    return \$temp;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$sref = new_anon_scalar();</span>
<span class="cp">$$sref = 3;</span>
<span class="cp">print &quot;Three = $$sref\n&quot;;</span>
<span class="cp">@array_of_srefs = ( new_anon_scalar(), new_anon_scalar() );</span>
<span class="cp">${ $array[0] } = 6.02e23;</span>
<span class="cp">${ $array[1] } = &quot;avocado&quot;;</span>
<span class="cp">print &quot;\@array contains: &quot;, join(&quot;, &quot;, map { $$_ } @array ), &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$var        = `uptime`;     # $var holds text</span>
<span class="cp">$vref       = \$var;        # $vref &quot;points to&quot; $var</span>
<span class="cp">if ($$vref =~ /load/) {}    # look at $var, indirectly</span>
<span class="cp">chomp $$vref;               # alter $var, indirectly</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># check whether $someref contains a simple scalar reference</span>
<span class="cp">if (ref($someref) ne &#39;SCALAR&#39;) {</span>
<span class="cp">    die &quot;Expected a scalar reference, not $someref\n&quot;;</span>

<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@array_of_scalar_refs = ( \$a, \$b );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@array_of_scalar_refs = \( $a, $b );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">${ $array_of_scalar_refs[1] } = 12;         # $b = 12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($a, $b, $c, $d) = (1 .. 4);        # initialize</span>
<span class="cp">@array =  (\$a, \$b, \$c, \$d);     # refs to each scalar</span>
<span class="cp">@array = \( $a,  $b,  $c,  $d);     # same thing!</span>
<span class="cp">@array = map { \my $anon } 0 .. 3;  # allocate 4 anon scalarresf</span>

<span class="cp">${ $array[2] } += 9;                # $c now 12</span>

<span class="cp">${ $array[ $#array ] } *= 5;        # $d now 20</span>
<span class="cp">${ $array[-1] }        *= 5;        # same; $d now 100</span>

<span class="cp">$tmp   = $array[-1];                # using temporary</span>
<span class="cp">$$tmp *= 5;                         # $d now 500</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Math::Trig qw(pi);              # load the constant pi</span>
<span class="cp">foreach $sref (@array) {            # prepare to change $a,$b,$c,$d</span>
<span class="cp">    ($$sref **= 3) *= (4/3 * pi);   # replace with spherical volumes</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$c1 = mkcounter(20); </span>
<span class="cp">$c2 = mkcounter(77);</span>

<span class="cp">printf &quot;next c1: %d\n&quot;, $c1-&gt;{NEXT}-&gt;();  # 21 </span>
<span class="cp">printf &quot;next c2: %d\n&quot;, $c2-&gt;{NEXT}-&gt;();  # 78 </span>
<span class="cp">printf &quot;next c1: %d\n&quot;, $c1-&gt;{NEXT}-&gt;();  # 22 </span>
<span class="cp">printf &quot;last c1: %d\n&quot;, $c1-&gt;{PREV}-&gt;();  # 21 </span>
<span class="cp">printf &quot;old  c2: %d\n&quot;, $c2-&gt;{RESET}-&gt;(); # 77</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub mkcounter {</span>
<span class="cp">    my $count  = shift; </span>
<span class="cp">    my $start  = $count; </span>
<span class="cp">    my $bundle = { </span>
<span class="cp">        &quot;NEXT&quot;   =&gt; sub { return ++$count  }, </span>
<span class="cp">        &quot;PREV&quot;   =&gt; sub { return --$count  }, </span>
<span class="cp">        &quot;GET&quot;    =&gt; sub { return $count    },</span>
<span class="cp">        &quot;SET&quot;    =&gt; sub { $count = shift   }, </span>
<span class="cp">        &quot;BUMP&quot;   =&gt; sub { $count += shift  }, </span>
<span class="cp">        &quot;RESET&quot;  =&gt; sub { $count = $start  },</span>
<span class="cp">    }; </span>
<span class="cp">    $bundle-&gt;{&quot;LAST&quot;} = $bundle-&gt;{&quot;PREV&quot;}; </span>
<span class="cp">    return $bundle;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$mref = sub { $obj-&gt;meth(@_) }; </span>
<span class="cp"># later...  </span>
<span class="cp">$mref-&gt;(&quot;args&quot;, &quot;go&quot;, &quot;here&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$sref = \$obj-&gt;meth;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$cref = $obj-&gt;can(&quot;meth&quot;);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$record = {</span>
<span class="cp">    NAME   =&gt; &quot;Jason&quot;,</span>
<span class="cp">    EMPNO  =&gt; 132,</span>
<span class="cp">    TITLE  =&gt; &quot;deputy peon&quot;,</span>
<span class="cp">    AGE    =&gt; 23,</span>
<span class="cp">    SALARY =&gt; 37_000,</span>
<span class="cp">    PALS   =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;],</span>
<span class="cp">};</span>

<span class="cp">printf &quot;I am %s, and my pals are %s.\n&quot;,</span>
<span class="cp">    $record-&gt;{NAME},</span>
<span class="cp">    join(&quot;, &quot;, @{$record-&gt;{PALS}});</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># store record</span>
<span class="cp">$byname{ $record-&gt;{NAME} } = $record;</span>

<span class="cp"># later on, look up by name</span>
<span class="cp">if ($rp = $byname{&quot;Aron&quot;}) {        # false if missing</span>
<span class="cp">    printf &quot;Aron is employee %d.\n&quot;, $rp-&gt;{EMPNO};</span>
<span class="cp">}</span>

<span class="cp"># give jason a new pal</span>
<span class="cp">push @{$byname{&quot;Jason&quot;}-&gt;{PALS}}, &quot;Theodore&quot;;</span>
<span class="cp">printf &quot;Jason now has %d pals\n&quot;, scalar @{$byname{&quot;Jason&quot;}-&gt;{PALS}};</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Go through all records</span>
<span class="cp">while (($name, $record) = each %byname) {</span>
<span class="cp">    printf &quot;%s is employee number %d\n&quot;, $name, $record-&gt;{EMPNO};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># store record</span>
<span class="cp">$employees[ $record-&gt;{EMPNO} ] = $record;</span>

<span class="cp"># lookup by id</span>
<span class="cp">if ($rp = $employee[132]) {</span>
<span class="cp">    printf &quot;employee number 132 is %s\n&quot;, $rp-&gt;{NAME};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$byname{&quot;Jason&quot;}-&gt;{SALARY} *= 1.035;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@peons   = grep { $_-&gt;{TITLE} =~ /peon/i } @employees;</span>
<span class="cp">@tsevens = grep { $_-&gt;{AGE}   == 27 }      @employees;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Go through all records</span>
<span class="cp">foreach $rp (sort { $a-&gt;{AGE} &lt;=&gt; $b-&gt;{AGE} } values %byname) {</span>
<span class="cp">    printf &quot;%s is age %d.\n&quot;, $rp-&gt;{NAME}, $rp-&gt;{AGE};</span>
<span class="cp">    # or with a hash slice on the reference</span>
<span class="cp">    printf &quot;%s is employee number %d.\n&quot;, @$rp{&#39;NAME&#39;,&#39;EMPNO&#39;};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># use @byage, an array of arrays of records</span>
<span class="cp">push @{ $byage[ $record-&gt;{AGE} ] }, $record;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for ($age = 0; $age &lt;= $#byage; $age++) {</span>
<span class="cp">    next unless $byage[$age];</span>
<span class="cp">    print &quot;Age $age: &quot;;</span>
<span class="cp">    foreach $rp (@{$byage[$age]}) {</span>
<span class="cp">        print $rp-&gt;{NAME}, &quot; &quot;;</span>
<span class="cp">    }</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">for ($age = 0; $age &lt;= $#byage; $age++) {</span>
<span class="cp">    next unless $byage[$age];</span>
<span class="cp">    printf &quot;Age %d: %s\n&quot;, $age,</span>
<span class="cp">        join(&quot;, &quot;, map {$_-&gt;{NAME}} @{$byage[$age]});</span>

<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">FieldName: Value</span>
<span class="cp">#-----------------------------</span>
<span class="cp">foreach $record (@Array_of_Records) { </span>
<span class="cp">    for $key (sort keys %$record) {</span>
<span class="cp">        print &quot;$key: $record-&gt;{$key}\n&quot;;</span>
<span class="cp">    } </span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$/ = &quot;&quot;;                # paragraph read mode</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    my @fields = split /^([^:]+):\s*/m;</span>
<span class="cp">    shift @fields;      # for leading null field</span>
<span class="cp">    push(@Array_of_Records, { map /(.*)/, @fields });</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">DB&lt;1&gt; $reference = [ { &quot;foo&quot; =&gt; &quot;bar&quot; }, 3, sub { print &quot;hello, world\n&quot; } ];</span>
<span class="cp">DB&lt;2&gt; x $reference</span>
<span class="cp">  0  ARRAY(0x1d033c)</span>

<span class="cp">    0  HASH(0x7b390)</span>

<span class="cp">       &#39;foo&#39; = &#39;bar&#39;&gt;</span>

<span class="cp">    1  3</span>

<span class="cp">    2  CODE(0x21e3e4)</span>

<span class="cp">       - &amp; in ???&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Data::Dumper;</span>
<span class="cp">print Dumper($reference);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">D&lt;1&gt; x \@INC</span>
<span class="cp">  0  ARRAY(0x807d0a8)</span>

<span class="cp">     0  &#39;/home/tchrist/perllib&#39; </span>

<span class="cp">     1  &#39;/usr/lib/perl5/i686-linux/5.00403&#39;</span>

<span class="cp">     2  &#39;/usr/lib/perl5&#39; </span>

<span class="cp">     3  &#39;/usr/lib/perl5/site_perl/i686-linux&#39; </span>

<span class="cp">     4  &#39;/usr/lib/perl5/site_perl&#39; </span>

<span class="cp">     5  &#39;.&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{ package main; require &quot;dumpvar.pl&quot; } </span>
<span class="cp">*dumpvar = \&amp;main::dumpvar if __PACKAGE__ ne &#39;main&#39;;</span>
<span class="cp">dumpvar(&quot;main&quot;, &quot;INC&quot;);             # show both @INC and %INC</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@INC = (</span>

<span class="cp">   0  &#39;/home/tchrist/perllib/i686-linux&#39;</span>

<span class="cp">   1  &#39;/home/tchrist/perllib&#39;</span>

<span class="cp">   2  &#39;/usr/lib/perl5/i686-linux/5.00404&#39;</span>

<span class="cp">   3  &#39;/usr/lib/perl5&#39;</span>

<span class="cp">   4  &#39;/usr/lib/perl5/site_perl/i686-linux&#39;</span>

<span class="cp">   5  &#39;/usr/lib/perl5/site_perl&#39;</span>

<span class="cp">   6  &#39;.&#39;</span>

<span class="cp">)</span>

<span class="cp">%INC = (</span>

<span class="cp">   &#39;dumpvar.pl&#39; = &#39;/usr/lib/perl5/i686-linux/5.00404/dumpvar.pl&#39;</span>

<span class="cp">   &#39;strict.pm&#39; = &#39;/usr/lib/perl5/i686-linux/5.00404/strict.pm&#39;</span>

<span class="cp">)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Data::Dumper; </span>
<span class="cp">print Dumper(\@INC); </span>
<span class="cp">$VAR1 = [</span>

<span class="cp">      &#39;/home/tchrist/perllib&#39;, </span>

<span class="cp">      &#39;/usr/lib/perl5/i686-linux/5.00403&#39;,</span>

<span class="cp">      &#39;/usr/lib/perl5&#39;, </span>

<span class="cp">      &#39;/usr/lib/perl5/site_perl/i686-linux&#39;,</span>

<span class="cp">      &#39;/usr/lib/perl5/site_perl&#39;, </span>

<span class="cp">      &#39;.&#39;</span>

<span class="cp">];</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Storable;</span>

<span class="cp">$r2 = dclone($r1);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@original = ( \@a, \@b, \@c );</span>
<span class="cp">@surface = @original;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@deep = map { [ @$_ ] } @original;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Storable qw(dclone); </span>
<span class="cp">$r2 = dclone($r1);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%newhash = %{ dclone(\%oldhash) };</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Storable; </span>
<span class="cp">store(\%hash, &quot;filename&quot;);</span>

<span class="cp"># later on...  </span>
<span class="cp">$href = retrieve(&quot;filename&quot;);        # by ref</span>
<span class="cp">%hash = %{ retrieve(&quot;filename&quot;) };   # direct to hash</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Storable qw(nstore); </span>
<span class="cp">nstore(\%hash, &quot;filename&quot;); </span>
<span class="cp"># later ...  </span>
<span class="cp">$href = retrieve(&quot;filename&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Storable qw(nstore_fd);</span>
<span class="cp">use Fcntl qw(:DEFAULT :flock);</span>
<span class="cp">sysopen(DF, &quot;/tmp/datafile&quot;, O_RDWR|O_CREAT, 0666) </span>
<span class="cp">    or die &quot;can&#39;t open /tmp/datafile: $!&quot;;</span>
<span class="cp">flock(DF, LOCK_EX)           or die &quot;can&#39;t lock /tmp/datafile: $!&quot;;</span>
<span class="cp">nstore_fd(\%hash, *DF)</span>
<span class="cp">    or die &quot;can&#39;t store hash\n&quot;;</span>
<span class="cp">truncate(DF, tell(DF));</span>
<span class="cp">close(DF);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Storable;</span>
<span class="cp">use Fcntl qw(:DEFAULT :flock);</span>
<span class="cp">open(DF, &quot;&lt; /tmp/datafile&quot;)      or die &quot;can&#39;t open /tmp/datafile: $!&quot;;</span>
<span class="cp">flock(DF, LOCK_SH)               or die &quot;can&#39;t lock /tmp/datafile: $!&quot;;</span>
<span class="cp">$href = retrieve(*DF);</span>
<span class="cp">close(DF);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use MLDBM qw(DB_File);</span>
<span class="cp">use Fcntl;                            </span>

<span class="cp">tie(%hash, &#39;MLDBM&#39;, &#39;testfile.db&#39;, O_CREAT|O_RDWR, 0666)</span>
<span class="cp">    or die &quot;can&#39;t open tie to testfile.db: $!&quot;;</span>

<span class="cp"># ... act on %hash</span>

<span class="cp">untie %hash;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use MLDBM qw(DB_File);</span>
<span class="cp">use Fcntl;                            </span>
<span class="cp">tie(%hash, &#39;MLDBM&#39;, &#39;testfile.db&#39;, O_CREAT|O_RDWR, 0666)</span>
<span class="cp">    or die &quot;can&#39;t open tie to testfile.db: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># this doesn&#39;t work!</span>
<span class="cp">$hash{&quot;some key&quot;}[4] = &quot;fred&quot;;</span>

<span class="cp"># RIGHT</span>
<span class="cp">$aref = $hash{&quot;some key&quot;};</span>
<span class="cp">$aref-&gt;[4] = &quot;fred&quot;;</span>
<span class="cp">$hash{&quot;some key&quot;} = $aref;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_11.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch11/bintree</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># bintree - binary tree demo program</span>
<span class="cp">use strict;</span>
<span class="cp">my($root, $n);</span>

<span class="cp"># first generate 20 random inserts</span>
<span class="cp">while ($n++ &lt; 20) { insert($root, int(rand(1000)) }</span>

<span class="cp"># now dump out the tree all three ways</span>
<span class="cp">print &quot;Pre order:  &quot;;  pre_order($root);  print &quot;\n&quot;;</span>
<span class="cp">print &quot;In order:   &quot;;  in_order($root);   print &quot;\n&quot;;</span>
<span class="cp">print &quot;Post order: &quot;;  post_order($root); print &quot;\n&quot;;</span>

<span class="cp"># prompt until EOF</span>
<span class="cp">for (print &quot;Search? &quot;; &lt;&gt;; print &quot;Search? &quot;) { </span>
<span class="cp">    chomp;</span>
<span class="cp">    my $found = search($root, $_);</span>
<span class="cp">    if ($found) { print &quot;Found $_ at $found, $found-&gt;{VALUE}\n&quot; }</span>
<span class="cp">    else        { print &quot;No $_ in tree\n&quot; }</span>
<span class="cp">}</span>

<span class="cp">exit;</span>

<span class="cp">#########################################</span>

<span class="cp"># insert given value into proper point of</span>
<span class="cp"># provided tree.  If no tree provided, </span>
<span class="cp"># use implicit pass by reference aspect of @_</span>
<span class="cp"># to fill one in for our caller.</span>
<span class="cp">sub insert {</span>
<span class="cp">    my($tree, $value) = @_;</span>
<span class="cp">    unless ($tree) {</span>
<span class="cp">        $tree = {};                         # allocate new node</span>
<span class="cp">        $tree-&gt;{VALUE}  = $value;</span>
<span class="cp">        $tree-&gt;{LEFT}   = undef;</span>
<span class="cp">        $tree-&gt;{RIGHT}  = undef;</span>
<span class="cp">        $_[0] = $tree;              # $_[0] is reference param!</span>
<span class="cp">        return;</span>
<span class="cp">    }</span>
<span class="cp">    if    ($tree-&gt;{VALUE} &gt; $value) { insert($tree-&gt;{LEFT},  $value) }</span>
<span class="cp">    elsif ($tree-&gt;{VALUE} &lt; $value) { insert($tree-&gt;{RIGHT}, $value) }</span>
<span class="cp">    else                            { warn &quot;dup insert of $value\n&quot;  }</span>
<span class="cp">                                    # XXX: no dups</span>
<span class="cp">}</span>

<span class="cp"># recurse on left child, </span>
<span class="cp"># then show current value, </span>
<span class="cp"># then recurse on right child.</span>
<span class="cp">sub in_order {</span>
<span class="cp">    my($tree) = @_;</span>
<span class="cp">    return unless $tree;</span>
<span class="cp">    in_order($tree-&gt;{LEFT});</span>
<span class="cp">    print $tree-&gt;{VALUE}, &quot; &quot;;</span>
<span class="cp">    in_order($tree-&gt;{RIGHT});</span>
<span class="cp">}</span>

<span class="cp"># show current value, </span>
<span class="cp"># then recurse on left child, </span>
<span class="cp"># then recurse on right child.</span>
<span class="cp">sub pre_order {</span>
<span class="cp">    my($tree) = @_;</span>
<span class="cp">    return unless $tree;</span>
<span class="cp">    print $tree-&gt;{VALUE}, &quot; &quot;;</span>
<span class="cp">    pre_order($tree-&gt;{LEFT});</span>
<span class="cp">    pre_order($tree-&gt;{RIGHT});</span>
<span class="cp">}</span>

<span class="cp"># recurse on left child, </span>
<span class="cp"># then recurse on right child,</span>
<span class="cp"># then show current value. </span>
<span class="cp">sub post_order {</span>
<span class="cp">    my($tree) = @_;</span>
<span class="cp">    return unless $tree;</span>
<span class="cp">    post_order($tree-&gt;{LEFT});</span>
<span class="cp">    post_order($tree-&gt;{RIGHT});</span>
<span class="cp">    print $tree-&gt;{VALUE}, &quot; &quot;;</span>
<span class="cp">}</span>

<span class="cp"># find out whether provided value is in the tree.</span>
<span class="cp"># if so, return the node at which the value was found.</span>
<span class="cp"># cut down search time by only looking in the correct</span>
<span class="cp"># branch, based on current value.</span>
<span class="cp">sub search {</span>
<span class="cp">    my($tree, $value) = @_;</span>
<span class="cp">    return unless $tree;</span>
<span class="cp">    if ($tree-&gt;{VALUE} == $value) {</span>
<span class="cp">        return $tree;</span>
<span class="cp">    }</span>
<span class="cp">    search($tree-&gt;{ ($value &lt; $tree-&gt;{VALUE}) ? &quot;LEFT&quot; : &quot;RIGHT&quot;}, $value)</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Alpha;</span>
<span class="cp">$name = &quot;first&quot;;</span>

<span class="cp">package Omega;</span>
<span class="cp">$name = &quot;last&quot;;</span>

<span class="cp">package main;</span>
<span class="cp">print &quot;Alpha is $Alpha::name, Omega is $Omega::name.\n&quot;;</span>
<span class="cp">Alpha is first, Omega is last.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require &quot;FileHandle.pm&quot;;            # run-time load</span>
<span class="cp">require FileHandle;                 # &quot;.pm&quot; assumed; same as previous</span>
<span class="cp">use FileHandle;                     # compile-time load</span>

<span class="cp">require &quot;Cards/Poker.pm&quot;;           # run-time load</span>
<span class="cp">require Cards::Poker;               # &quot;.pm&quot; assumed; same as previous</span>
<span class="cp">use Cards::Poker;                   # compile-time load</span>
<span class="cp">#-----------------------------</span>
<span class="cp">1    package Cards::Poker;</span>
<span class="cp">2    use Exporter;</span>
<span class="cp">3    @ISA = (&#39;Exporter&#39;);</span>
<span class="cp">4    @EXPORT = qw(&amp;shuffle @card_deck);</span>
<span class="cp">5    @card_deck = ();                       # initialize package global</span>
<span class="cp">6    sub shuffle { }                        # fill-in definition later</span>
<span class="cp">7    1;                                     # don&#39;t forget this</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package YourModule;</span>
<span class="cp">use strict;</span>
<span class="cp">use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);</span>

<span class="cp">use Exporter;</span>
<span class="cp">$VERSION = 1.00;              # Or higher</span>
<span class="cp">@ISA = qw(Exporter);</span>

<span class="cp">@EXPORT      = qw(...);       # Symbols to autoexport (:DEFAULT tag)</span>
<span class="cp">@EXPORT_OK   = qw(...);       # Symbols to export on request</span>
<span class="cp">%EXPORT_TAGS = (              # Define names for sets of symbols</span>
<span class="cp">    TAG1 =&gt; [...],</span>
<span class="cp">    TAG2 =&gt; [...],</span>
<span class="cp">    ...</span>
<span class="cp">);</span>

<span class="cp">########################</span>
<span class="cp"># your code goes here</span>
<span class="cp">########################</span>

<span class="cp">1;                            # this should be your last line</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use YourModule;               # Import default symbols into my package.</span>
<span class="cp">use YourModule qw(...);       # Import listed symbols into my package.</span>
<span class="cp">use YourModule ();            # Do not import any symbols</span>
<span class="cp">use YourModule qw(:TAG1);     # Import whole tag set</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    @EXPORT = qw(&amp;F1 &amp;F2 @List);</span>
<span class="cp">    @EXPORT = qw( F1  F2 @List);        # same thing</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    @EXPORT_OK = qw(Op_Func %Table);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    use YourModule qw(Op_Func %Table F1);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    use YourModule qw(:DEFAULT %Table);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    %EXPORT_TAGS = (</span>
<span class="cp">        Functions =&gt; [ qw(F1 F2 Op_Func) ],</span>
<span class="cp">        Variables =&gt; [ qw(@List %Table)  ],</span>
<span class="cp">);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    use YourModule qw(:Functions %Table);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    @{</span>
<span class="cp"> </span>
<span class="cp">$YourModule::EXPORT_TAGS{Functions}</span>
<span class="cp"> </span>
<span class="cp">}</span>
<span class="cp">, </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># no import</span>
<span class="cp">BEGIN {</span>
<span class="cp">    unless (eval &quot;require $mod&quot;) {</span>
<span class="cp">        warn &quot;couldn&#39;t load $mod: $@&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp"># imports into current package</span>
<span class="cp">BEGIN {</span>
<span class="cp">    unless (eval &quot;use $mod&quot;) {</span>
<span class="cp">        warn &quot;couldn&#39;t load $mod: $@&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">BEGIN {</span>
<span class="cp">    my($found, @DBs, $mod);</span>
<span class="cp">    $found = 0;</span>
<span class="cp">    @DBs = qw(Giant::Eenie Giant::Meanie Mouse::Mynie Moe);</span>
<span class="cp">    for $mod (@DBs) {</span>
<span class="cp">        if (eval &quot;require $mod&quot;) {</span>
<span class="cp">            $mod-&gt;</span>
<span class="cp">import</span>
<span class="cp">();         # if needed</span>
<span class="cp">            $found = 1;</span>
<span class="cp">            last;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">    die &quot;None of @DBs loaded&quot; unless $found;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">BEGIN {</span>
<span class="cp">    unless (@ARGV == 2 &amp;&amp; (2 == grep {/^\d+$/} @ARGV)) {</span>
<span class="cp">        die &quot;usage: $0 num1 num2\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">use Some::Module;</span>
<span class="cp">use More::Modules;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($opt_b) {</span>
<span class="cp">    require Math::BigInt;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl qw(O_EXCL O_CREAT O_RDWR);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require Fcntl;</span>
<span class="cp">Fcntl-&gt;import(qw(O_EXCL O_CREAT O_RDWR));</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub load_module {</span>
<span class="cp">    require $_[0];  #WRONG</span>
<span class="cp">    import  $_[0];  #WRONG</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">load_module(&#39;Fcntl&#39;, qw(O_EXCL O_CREAT O_RDWR));</span>

<span class="cp">sub load_module {</span>
<span class="cp">    eval &quot;require $_[0]&quot;;</span>
<span class="cp">    die if $@;</span>
<span class="cp">    $_[0]-&gt;import(@_[1 .. $#_]);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use autouse Fcntl =&gt; qw( O_EXCL() O_CREAT() O_RDWR() );</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Alpha;</span>
<span class="cp">my $aa = 10;</span>
<span class="cp">   $x = &quot;azure&quot;;</span>

<span class="cp">package Beta;</span>
<span class="cp">my $bb = 20;</span>
<span class="cp">   $x = &quot;blue&quot;;</span>

<span class="cp">package main;</span>
<span class="cp">print &quot;$aa, $bb, $x, $Alpha::x, $Beta::x\n&quot;;</span>
<span class="cp">10, 20, , azure, blue</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Flipper.pm</span>
<span class="cp">package Flipper;</span>
<span class="cp">use strict;</span>

<span class="cp">require Exporter;</span>
<span class="cp">use vars qw(@ISA @EXPORT $VERSION);</span>
<span class="cp">@ISA     = qw(Exporter);</span>
<span class="cp">@EXPORT  = qw(flip_words flip_boundary);</span>
<span class="cp">$VERSION = 1.0;</span>

<span class="cp">my $Separatrix = &#39; &#39;;  # default to blank; must precede functions</span>

<span class="cp">sub flip_boundary {</span>
<span class="cp">    my $prev_sep = $Separatrix;</span>
<span class="cp">    if (@_) { $Separatrix = $_[0] }</span>
<span class="cp">    return $prev_sep;</span>
<span class="cp">}</span>
<span class="cp">sub flip_words {</span>
<span class="cp">    my $line  = $_[0];</span>
<span class="cp">    my @words = split($Separatrix, $line);</span>
<span class="cp">    return join($Separatrix, reverse @words);</span>
<span class="cp">}</span>
<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$this_pack = __PACKAGE__;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$that_pack = caller();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;I am in package __PACKAGE__\n&quot;;              # WRONG!</span>
<span class="cp">I am in package __PACKAGE__</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Alpha;</span>
<span class="cp">runit(&#39;$line = &lt;TEMP&gt;&#39;);</span>

<span class="cp">package Beta;</span>
<span class="cp">sub runit {</span>
<span class="cp">    my $codestr = shift;</span>
<span class="cp">    eval $codestr;</span>
<span class="cp">    die if $@;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Beta;</span>
<span class="cp">sub runit {</span>
<span class="cp">    my $codestr = shift;</span>
<span class="cp">    my $hispack = caller;</span>
<span class="cp">    eval &quot;package $hispack; $codestr&quot;;</span>
<span class="cp">    die if $@;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Alpha;</span>
<span class="cp">runit( sub { $line = &lt;TEMP&gt; } );</span>

<span class="cp">package Beta;</span>
<span class="cp">sub runit {</span>
<span class="cp">    my $coderef = shift;</span>
<span class="cp">    &amp;$coderef();</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open (FH, &quot;&lt; /etc/termcap&quot;)</span>
<span class="cp">    or die &quot;can&#39;t open /etc/termcap: $!&quot;;</span>
<span class="cp">($a, $b, $c) = nreadline(3, &#39;FH&#39;);</span>

<span class="cp">use Symbol ();</span>
<span class="cp">use Carp;</span>
<span class="cp">sub nreadline {</span>
<span class="cp">    my ($count, $handle) = @_;</span>
<span class="cp">    my(@retlist,$line);</span>

<span class="cp">    croak &quot;count must be &gt; 0&quot; unless $count &gt; 0;</span>
<span class="cp">    $handle = Symbol::qualify($handle, (</span>
<span class="cp">caller()</span>
<span class="cp">)[0]);</span>
<span class="cp">    croak &quot;need open filehandle&quot; unless defined fileno($handle);</span>

<span class="cp">    push(@retlist, $line) while defined($line = &lt;$handle&gt;) &amp;&amp; $count--;</span>
<span class="cp">    return @retlist;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$Logfile = &quot;/tmp/mylog&quot; unless defined $Logfile;</span>
<span class="cp">open(LF, &quot;&gt;&gt;$Logfile&quot;)</span>
<span class="cp">    or die &quot;can&#39;t append to $Logfile: $!&quot;;</span>
<span class="cp">select(((select(LF), $|=1))[0]);  # unbuffer LF</span>
<span class="cp">logmsg(&quot;startup&quot;);</span>

<span class="cp">sub logmsg {</span>
<span class="cp">    my $now = scalar gmtime;</span>
<span class="cp">    print LF &quot;$0 $$ $now: @_\n&quot;</span>
<span class="cp">        or die &quot;write to $Logfile failed: $!&quot;;</span>
<span class="cp">}</span>

<span class="cp">END {</span>
<span class="cp">    logmsg(&quot;shutdown&quot;);</span>
<span class="cp">    close(LF)                     </span>
<span class="cp">        or die &quot;close $Logfile failed: $!&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use sigtrap qw(die normal-signals error-signals);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -e &#39;for (@INC) { printf &quot;%d %s\n&quot;, $i++, $_ }&#39;</span>
<span class="cp">#0 /usr/local/perl/lib/i686-linux/5.004</span>
<span class="cp">#</span>
<span class="cp">#1 /usr/local/perl/lib</span>
<span class="cp">#</span>
<span class="cp">#2 /usr/local/perl/lib/site_perl/i686-linux</span>
<span class="cp">#</span>
<span class="cp">#3 /usr/local/perl/lib/site_perl</span>
<span class="cp">#</span>
<span class="cp">#4 .</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># syntax for sh, bash, ksh, or zsh</span>
<span class="cp">#$ export PERL5LIB=$HOME/perllib</span>

<span class="cp"># syntax for csh or tcsh</span>
<span class="cp">#% setenv PERL5LIB ~/perllib</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use lib &quot;/projects/spectre/lib&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use FindBin;</span>
<span class="cp">use lib $FindBin::Bin;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use FindBin qw($Bin);</span>
<span class="cp">use lib &quot;$Bin/../lib&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% h2xs -XA -n Planets</span>
<span class="cp">#% h2xs -XA -n Astronomy::Orbits</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Astronomy::Orbits;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require Exporter;</span>
<span class="cp">require AutoLoader;</span>
<span class="cp">@ISA = qw(Exporter AutoLoader);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require Exporter;</span>
<span class="cp">require DynaLoader;</span>
<span class="cp">@ISA = qw(Exporter DynaLoader);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% make dist</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">require Exporter;</span>
<span class="cp">require SelfLoader;</span>
<span class="cp">@ISA = qw(Exporter SelfLoader);</span>
<span class="cp">#</span>
<span class="cp"># other initialization or declarations here</span>
<span class="cp">#</span>
<span class="cp">#__DATA__</span>
<span class="cp">#sub abc { .... }</span>
<span class="cp">#sub def { .... }</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% h2xs -Xn Sample</span>
<span class="cp">#% cd Sample</span>
<span class="cp">#% perl Makefile.PL LIB=~/perllib</span>
<span class="cp">#% (edit Sample.pm)</span>
<span class="cp">#% make install</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package FineTime;</span>
<span class="cp">use strict;</span>
<span class="cp">require Exporter;</span>
<span class="cp">use vars qw(@ISA @EXPORT_OK);</span>
<span class="cp">@ISA = qw(Exporter);</span>
<span class="cp">@EXPORT_OK = qw(time);</span>

<span class="cp">sub time() { ..... }  # TBA</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use FineTime qw(time);</span>
<span class="cp">$start = time();</span>
<span class="cp">1 while print time() - $start, &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub even_only {</span>
<span class="cp">    my $n = shift;</span>
<span class="cp">    die &quot;$n is not even&quot; if $n &amp; 1;  # one way to test</span>
<span class="cp">    #....</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Carp;</span>
<span class="cp">sub even_only {</span>
<span class="cp">    my $n = shift;</span>
<span class="cp">    croak &quot;$n is not even&quot; if $n % 2;  # here&#39;s another</span>
<span class="cp">    #....</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Carp;</span>
<span class="cp">sub even_only {</span>
<span class="cp">    my $n = shift;</span>
<span class="cp">    if ($n &amp; 1) {         # test whether odd number</span>
<span class="cp">        carp &quot;$n is not even, continuing&quot;;</span>
<span class="cp">        ++$n;</span>
<span class="cp">    }</span>
<span class="cp">    #....</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">carp &quot;$n is not even, continuing&quot; if $^W;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{</span>
<span class="cp">    no strict &#39;refs&#39;;</span>
<span class="cp">    $val  = ${ $packname . &quot;::&quot; . $varname };</span>
<span class="cp">    @vals = @{ $packname . &quot;::&quot; . $aryname };</span>
<span class="cp">    &amp;{ $packname . &quot;::&quot; . $funcname }(&quot;args&quot;);</span>
<span class="cp">    ($packname . &quot;::&quot; . $funcname) -&gt; (&quot;args&quot;);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval &quot;package $packname; \$&#39;$val = \$$varname&quot;; # set $main&#39;val</span>
<span class="cp">die if $@;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">printf &quot;log2  of 100 is %.2f\n&quot;, log2(100);</span>
<span class="cp">printf &quot;log10 of 100 is %.2f\n&quot;, log10(100);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$packname = &#39;main&#39;;</span>
<span class="cp">for ($i = 2; $i &lt; 1000; $i++) {</span>
<span class="cp">    $logN = log($i);</span>
<span class="cp">    eval &quot;sub ${packname}::log$i { log(shift) / $logN }&quot;;</span>
<span class="cp">    die if $@;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$packname = &#39;main&#39;;</span>
<span class="cp">for ($i = 2; $i &lt; 1000; $i++) {</span>
<span class="cp">    my $logN = log($i);</span>
<span class="cp">    no strict &#39;refs&#39;;</span>
<span class="cp">    *{&quot;${packname}::log$i&quot;} = sub { log(shift) / $logN };</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">*blue       = \&amp;Colors::blue;</span>
<span class="cp">*main::blue = \&amp;Colors::azure;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Can&#39;t locate sys/syscall.ph in @INC (did you run h2ph?)</span>
<span class="cp">#</span>
<span class="cp">#(@INC contains: /usr/lib/perl5/i686-linux/5.00404 /usr/lib/perl5</span>
<span class="cp">#</span>
<span class="cp">#/usr/lib/perl5/site_perl/i686-linux /usr/lib/perl5/site_perl .)</span>
<span class="cp">#</span>
<span class="cp">#at some_program line 7.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% cd /usr/include; h2ph sys/syscall.h</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% cd /usr/include; h2ph *.h */*.h</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% cd /usr/include; find . -name &#39;*.h&#39; -print | xargs h2ph</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># file FineTime.pm</span>
<span class="cp">package main;</span>
<span class="cp">require &#39;sys/syscall.ph&#39;;</span>
<span class="cp">die &quot;No SYS_gettimeofday in sys/syscall.ph&quot;</span>
<span class="cp">    unless defined &amp;SYS_gettimeofday;</span>

<span class="cp">package FineTime;</span>
<span class="cp">    use strict;</span>
<span class="cp">require Exporter;</span>
<span class="cp">use vars qw(@ISA @EXPORT_OK);</span>
<span class="cp">@ISA = qw(Exporter);</span>
<span class="cp">@EXPORT_OK = qw(time);</span>

<span class="cp">sub time() {</span>
<span class="cp">    my $tv = pack(&quot;LL&quot;, ());  # presize buffer to two longs</span>
<span class="cp">    syscall(&amp;main::SYS_gettimeofday, $tv, undef) &gt;= 0</span>
<span class="cp">        or die &quot;gettimeofday: $!&quot;;</span>
<span class="cp">    my($seconds, $microseconds) = unpack(&quot;LL&quot;, $tv);</span>
<span class="cp">    return $seconds + ($microseconds / 1_000_000);</span>
<span class="cp">}</span>

<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch12/jam</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># jam - stuff characters down STDIN&#39;s throat</span>
<span class="cp">require &#39;sys/ioctl.ph&#39;;</span>
<span class="cp">die &quot;no TIOCSTI&quot; unless defined &amp;TIOCSTI;</span>
<span class="cp">sub jam {</span>
<span class="cp">    local $SIG{TTOU} = &quot;IGNORE&quot;; # &quot;Stopped for tty output&quot;</span>
<span class="cp">    local *TTY;  # make local filehandle</span>
<span class="cp">    open(TTY, &quot;+&lt;/dev/tty&quot;)                 or die &quot;no tty: $!&quot;;</span>
<span class="cp">    for (split(//, $_[0])) {</span>
<span class="cp">        ioctl(TTY, &amp;TIOCSTI, $_)            or die &quot;bad TIOCSTI: $!&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    close(TTY);</span>
<span class="cp">}</span>
<span class="cp">jam(&quot;@ARGV\n&quot;);</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% cat &gt; tio.c &lt;&lt;EOF &amp;&amp; cc tio.c &amp;&amp; a.out</span>
<span class="cp">##include &lt;sys/ioctl.h&gt;</span>
<span class="cp">#main() { printf(&quot;%#08x\n&quot;, TIOCSTI); }</span>
<span class="cp">#EOF</span>
<span class="cp">#0x005412</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch12/winsz</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># winsz - find x and y for chars and pixels</span>
<span class="cp">require &#39;sys/ioctl.ph&#39;;</span>
<span class="cp">die &quot;no TIOCGWINSZ &quot; unless defined &amp;TIOCGWINSZ;</span>
<span class="cp">open(TTY, &quot;+&lt;/dev/tty&quot;)                     or die &quot;No tty: $!&quot;;</span>
<span class="cp">unless (ioctl(TTY, &amp;TIOCGWINSZ, $winsize=&#39;&#39;)) {</span>
<span class="cp">    die sprintf &quot;$0: ioctl TIOCGWINSZ (%08x: $!)\n&quot;, &amp;TIOCGWINSZ;</span>
<span class="cp">}</span>
<span class="cp">($row, $col, $xpixel, $ypixel) = unpack(&#39;S4&#39;, $winsize);</span>
<span class="cp">print &quot;(row,col) = ($row,$col)&quot;;</span>
<span class="cp">print &quot;  (xpixel,ypixel) = ($xpixel,$ypixel)&quot; if $xpixel || $ypixel;</span>
<span class="cp">print &quot;\n&quot;;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl Makefile.PL</span>
<span class="cp">#% make</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% h2xs -cn FineTime</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl Makefile.PL</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&#39;LIBS&#39;      =&gt; [&#39;&#39;],   # e.g., &#39;-lm&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&#39;LIBS&#39;      =&gt; [&#39;-L/usr/redhat/lib -lrpm&#39;],</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl Makefile.PL LIB=~/perllib</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package FineTime;</span>
<span class="cp">use strict;</span>
<span class="cp">use vars qw($VERSION @ISA @EXPORT_OK);</span>
<span class="cp">require Exporter;</span>
<span class="cp">require DynaLoader;</span>
<span class="cp">@ISA = qw(Exporter DynaLoader);</span>
<span class="cp">@EXPORT_OK = qw(time);</span>
<span class="cp">$VERSION = &#39;0.01&#39;;</span>
<span class="cp">bootstrap FineTime $VERSION;</span>
<span class="cp">1;</span>
<span class="cp">##-----------------------------</span>
<span class="cp">##include &lt;unistd.h&gt;</span>
<span class="cp">##include &lt;sys/time.h&gt;</span>
<span class="cp">##include &quot;EXTERN.h&quot;</span>
<span class="cp">##include &quot;perl.h&quot;</span>
<span class="cp">##include &quot;XSUB.h&quot;</span>
<span class="cp">#</span>
<span class="cp">#MODULE = FineTime           PACKAGE = FineTime</span>
<span class="cp">#</span>
<span class="cp">#double</span>
<span class="cp">#time()</span>
<span class="cp">#    CODE:</span>
<span class="cp">#        struct timeval tv;</span>
<span class="cp">#        gettimeofday(&amp;tv,0);</span>
<span class="cp">#        RETVAL = tv.tv_sec + ((double) tv.tv_usec) / 1000000;</span>
<span class="cp">#    OUTPUT:</span>
<span class="cp">#        RETVAL</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% make install</span>
<span class="cp">#mkdir ./blib/lib/auto/FineTime</span>
<span class="cp">#cp FineTime.pm ./blib/lib/FineTime.pm</span>
<span class="cp">#/usr/local/bin/perl -I/usr/lib/perl5/i686-linux/5.00403  -I/usr/lib/perl5</span>
<span class="cp">#/usr/lib/perl5/ExtUtils/xsubpp -typemap </span>
<span class="cp">#    /usr/lib/perl5/ExtUtils/typemap FineTime.xs</span>
<span class="cp">#FineTime.tc &amp;&amp; mv FineTime.tc FineTime.ccc -c -Dbool=char -DHAS_BOOL </span>
<span class="cp">#    -O2-DVERSION=\&quot;0.01\&quot; -DXS_VERSION=\&quot;0.01\&quot; -fpic </span>
<span class="cp">#    -I/usr/lib/perl5/i686-linux/5.00403/CORE  </span>
<span class="cp">#FineTime.cRunning Mkbootstrap for FineTime ()</span>
<span class="cp">#chmod 644 FineTime.bs</span>
<span class="cp">#LD_RUN_PATH=&quot;&quot; cc -o blib/arch/auto/FineTime/FineTime.so </span>
<span class="cp">#    -shared -L/usr/local/lib FineTime.o</span>
<span class="cp">#chmod 755 blib/arch/auto/FineTime/FineTime.so</span>
<span class="cp">#cp FineTime.bs ./blib/arch/auto/FineTime/FineTime.bs</span>
<span class="cp">#chmod 644 blib/arch/auto/FineTime/FineTime.bs</span>
<span class="cp">#Installing /home/tchrist/perllib/i686-linux/./auto/FineTime/FineTime.so</span>
<span class="cp">#Installing /home/tchrist/perllib/i686-linux/./auto/FineTime/FineTime.bs</span>
<span class="cp">#Installing /home/tchrist/perllib/./FineTime.pm</span>
<span class="cp">#Writing /home/tchrist/perllib/i686-linux/auto/FineTime/.packlist</span>
<span class="cp">#Appending installation info to /home/tchrist/perllib/i686-linux/perllocal.pod</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -I ~/perllib -MFineTime=time -le &#39;1 while print time()&#39; | head</span>
<span class="cp">#888177070.090978</span>
<span class="cp">#</span>
<span class="cp">#888177070.09132</span>
<span class="cp">#</span>
<span class="cp">#888177070.091389</span>
<span class="cp">#</span>
<span class="cp">#888177070.091453</span>
<span class="cp">#</span>
<span class="cp">#888177070.091515</span>
<span class="cp">#</span>
<span class="cp">#888177070.091577</span>
<span class="cp">#</span>
<span class="cp">#888177070.091639</span>
<span class="cp">#</span>
<span class="cp">#888177070.0917</span>
<span class="cp">#</span>
<span class="cp">#888177070.091763</span>
<span class="cp">#</span>
<span class="cp">#888177070.091864</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#=head2 Discussion</span>
<span class="cp">#</span>
<span class="cp">#If we had a I&lt;.h&gt; file with function prototype declarations, we</span>
<span class="cp">#could include that, but since we&#39;re writing this one from scratch,</span>
<span class="cp">#we&#39;ll use the B&lt;-c&gt; flag to omit building code to translate any</span>
<span class="cp">#C&lt;#define&gt; symbols. The B&lt;-n&gt; flag says to create a module directory</span>
<span class="cp">#named I&lt;FineTime/&gt;, which will have the following files.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#=for troff</span>
<span class="cp">#.EQ</span>
<span class="cp">#log sub n (x) = { {log sub e (x)} over {log sub e (n)} }</span>
<span class="cp">#.EN</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#=for later</span>
<span class="cp">#next if 1 .. ?^$?;</span>
<span class="cp">#s/^(.)/&gt;$1/;</span>
<span class="cp">#s/(.{73})........*/$1&lt;SNIP&gt;/;</span>
<span class="cp">#</span>
<span class="cp">#=cut back to perl</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#=begin comment</span>
<span class="cp">#</span>
<span class="cp">#if (!open(FILE, $file)) {</span>
<span class="cp">#    unless ($opt_q) {  #)</span>
<span class="cp">#        warn &quot;$me: $file: $!\n&quot;;</span>
<span class="cp">#        $Errors++;</span>
<span class="cp">#    }</span>
<span class="cp">#    next FILE;</span>
<span class="cp">#}</span>
<span class="cp">#</span>
<span class="cp">#$total = 0;</span>
<span class="cp">#$matches = 0;</span>
<span class="cp">#</span>
<span class="cp">#=end comment</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% gunzip Some-Module-4.54.tar.gz</span>
<span class="cp">#% tar xf Some-Module-4.54</span>
<span class="cp">#% cd Some-Module-4.54</span>
<span class="cp">#% perl Makefile.PL</span>
<span class="cp">#% make</span>
<span class="cp">#% make test</span>
<span class="cp">#% make install</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% gunzip MD5-1.7.tar.gz</span>
<span class="cp">#% tar xf MD5-1.7.tar</span>
<span class="cp">#% cd MD5-1.7</span>
<span class="cp">#% perl Makefile.PL </span>
<span class="cp">#Checking if your kit is complete...</span>
<span class="cp">#</span>
<span class="cp">#Looks good</span>
<span class="cp">#</span>
<span class="cp">#Writing Makefile for MD5</span>
<span class="cp">#</span>
<span class="cp">#% make</span>
<span class="cp">#mkdir ./blib</span>
<span class="cp">#</span>
<span class="cp">#mkdir ./blib/lib</span>
<span class="cp">#</span>
<span class="cp">#cp MD5.pm ./blib/lib/MD5.pm</span>
<span class="cp">#</span>
<span class="cp">#AutoSplitting MD5 (./blib/lib/auto/MD5)</span>
<span class="cp">#</span>
<span class="cp">#/usr/bin/perl -I/usr/local/lib/perl5/i386 ...</span>
<span class="cp">#</span>
<span class="cp">#...</span>
<span class="cp">#</span>
<span class="cp">#cp MD5.bs ./blib/arch/auto/MD5/MD5.bs</span>
<span class="cp">#</span>
<span class="cp">#chmod 644 ./blib/arch/auto/MD5/MD5.bsmkdir ./blib/man3</span>
<span class="cp">#</span>
<span class="cp">#Manifying ./blib/man3/MD5.3</span>
<span class="cp">#</span>
<span class="cp">#% make test</span>
<span class="cp">#PERL_DL_NONLAZY=1 /usr/bin/perl -I./blib/arch -I./blib/lib</span>
<span class="cp">#</span>
<span class="cp">#-I/usr/local/lib/perl5/i386-freebsd/5.00404 -I/usr/local/lib/perl5 test.pl</span>
<span class="cp">#</span>
<span class="cp">#1..14</span>
<span class="cp">#</span>
<span class="cp">#ok 1</span>
<span class="cp">#</span>
<span class="cp">#ok 2</span>
<span class="cp">#</span>
<span class="cp">#...</span>
<span class="cp">#</span>
<span class="cp">#ok 13</span>
<span class="cp">#</span>
<span class="cp">#ok 14</span>
<span class="cp">#</span>
<span class="cp">#% sudo make install</span>
<span class="cp">#Password:</span>
<span class="cp">#</span>
<span class="cp">#Installing /usr/local/lib/perl5/site_perl/i386-freebsd/./auto/MD5/</span>
<span class="cp">#</span>
<span class="cp">#    MD5.so</span>
<span class="cp">#</span>
<span class="cp">#Installing /usr/local/lib/perl5/site_perl/i386-freebsd/./auto/MD5/</span>
<span class="cp">#</span>
<span class="cp">#    MD5.bs</span>
<span class="cp">#</span>
<span class="cp">#Installing /usr/local/lib/perl5/site_perl/./auto/MD5/autosplit.ix</span>
<span class="cp">#</span>
<span class="cp">#Installing /usr/local/lib/perl5/site_perl/./MD5.pm</span>
<span class="cp">#</span>
<span class="cp">#Installing /usr/local/lib/perl5/man/man3/./MD5.3</span>
<span class="cp">#</span>
<span class="cp">#Writing /usr/local/lib/perl5/site_perl/i386-freebsd/auto/MD5/.packlist</span>
<span class="cp">#</span>
<span class="cp">#Appending installation info to /usr/local/lib/perl5/i386-freebsd/</span>
<span class="cp">#</span>
<span class="cp">#5.00404/perllocal.pod</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># if you just want the modules installed in your own directory</span>
<span class="cp">#% perl Makefile.PL LIB=~/lib</span>
<span class="cp">#</span>
<span class="cp"># if you have your own a complete distribution</span>
<span class="cp">#% perl Makefile.PL PREFIX=~/perl5-private</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Some::Module;  # must live in Some/Module.pm</span>

<span class="cp">use strict;</span>

<span class="cp">require Exporter;</span>
<span class="cp">use vars       qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);</span>

<span class="cp"># set the version for version checking</span>
<span class="cp">$VERSION     = 0.01;</span>

<span class="cp">@ISA         = qw(Exporter);</span>
<span class="cp">@EXPORT      = qw(&amp;func1 &amp;func2 &amp;func4);</span>
<span class="cp">%EXPORT_TAGS = ( );     # eg: TAG =&gt; [ qw!name1 name2! ],</span>

<span class="cp"># your exported package globals go here,</span>
<span class="cp"># as well as any optionally exported functions</span>
<span class="cp">@EXPORT_OK   = qw($Var1 %Hashit &amp;func3);</span>

<span class="cp">use vars qw($Var1 %Hashit);</span>
<span class="cp"># non-exported package globals go here</span>
<span class="cp">use vars      qw(@more $stuff);</span>

<span class="cp"># initialize package globals, first exported ones</span>
<span class="cp">$Var1   = &#39;&#39;;</span>
<span class="cp">%Hashit = ();</span>

<span class="cp"># then the others (which are still accessible as $Some::Module::stuff)</span>
<span class="cp">$stuff  = &#39;&#39;;</span>
<span class="cp">@more   = ();</span>

<span class="cp"># all file-scoped lexicals must be created before</span>
<span class="cp"># the functions below that use them.</span>

<span class="cp"># file-private lexicals go here</span>
<span class="cp">my $priv_var    = &#39;&#39;;</span>
<span class="cp">my %secret_hash = ();</span>

<span class="cp"># here&#39;s a file-private function as a closure,</span>
<span class="cp"># callable as &amp;$priv_func.</span>
<span class="cp">my $priv_func = sub {</span>
<span class="cp">    # stuff goes here.</span>
<span class="cp">};</span>

<span class="cp"># make all your functions, whether exported or not;</span>
<span class="cp"># remember to put something interesting in the {} stubs</span>
<span class="cp">sub func1      { .... }    # no prototype</span>
<span class="cp">sub func2()    { .... }    # proto&#39;d void</span>
<span class="cp">sub func3($$)  { .... }    # proto&#39;d to 2 scalars</span>

<span class="cp"># this one isn&#39;t auto-exported, but could be called!</span>
<span class="cp">sub func4(\%)  { .... }    # proto&#39;d to 1 hash ref</span>

<span class="cp">END { }       # module clean-up code here (global destructor)</span>

<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_12.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% pmdesc</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#FileHandle (2.00) - supply object methods for filehandles</span>
<span class="cp">#</span>
<span class="cp">#IO::File (1.06021) - supply object methods for filehandles</span>
<span class="cp">#</span>
<span class="cp">#IO::Select (1.10) - OO interface to the select system call</span>
<span class="cp">#</span>
<span class="cp">#IO::Socket (1.1603) - Object interface to socket communications</span>
<span class="cp">#</span>
<span class="cp">#...</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% pmdesc -v</span>
<span class="cp">#</span>
<span class="cp">#&lt;&lt;&lt;Modules from /usr/lib/perl5/i686-linux/5.00404&gt;&gt;&gt;</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#FileHandle (2.00) - supply object methods for filehandles</span>
<span class="cp">#</span>
<span class="cp">#    ...</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch12/pmdesc</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># pmdesc - describe pm files</span>
<span class="cp"># tchrist@perl.com</span>

<span class="cp">use strict;</span>
<span class="cp">use File::Find      qw(find);</span>
<span class="cp">use Getopt::Std     qw(getopts);</span>
<span class="cp">use Carp;</span>

<span class="cp">use vars (</span>
<span class="cp">    q!$opt_v!,              # give debug info</span>
<span class="cp">    q!$opt_w!,              # warn about missing descs on modules</span>
<span class="cp">    q!$opt_a!,              # include relative paths</span>
<span class="cp">    q!$opt_s!,              # sort output within each directory</span>
<span class="cp">);</span>

<span class="cp">$| = 1;</span>

<span class="cp">getopts(&#39;wvas&#39;)             or die &quot;bad usage&quot;;</span>

<span class="cp">@ARGV = @INC unless @ARGV;</span>

<span class="cp"># Globals.  wish I didn&#39;t really have to do this.</span>
<span class="cp">use vars (</span>
<span class="cp">    q!$Start_Dir!,          # The top directory find was called with</span>
<span class="cp">    q!%Future!,             # topdirs find will handle later</span>
<span class="cp">);</span>

<span class="cp">my $Module;</span>

<span class="cp"># install an output filter to sort my module list, if wanted.</span>
<span class="cp">if ($opt_s) {</span>
<span class="cp">    if (open(ME, &quot;-|&quot;)) {</span>
<span class="cp">        $/ = &#39;&#39;;</span>
<span class="cp">        while (&lt;ME&gt;) {</span>
<span class="cp">            chomp;</span>
<span class="cp">            print join(&quot;\n&quot;, sort split /\n/), &quot;\n&quot;;</span>
<span class="cp">        }</span>
<span class="cp">        exit;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">MAIN: {</span>
<span class="cp">    my %visited;</span>
<span class="cp">    my ($dev,$ino);</span>

<span class="cp">    @Future{@ARGV} = (1) x @ARGV;</span>

<span class="cp">    foreach $Start_Dir (@ARGV) {</span>
<span class="cp">        delete $Future{$Start_Dir};</span>

<span class="cp">        print &quot;\n&lt;&lt;Modules from $Start_Dir&gt;&gt;\n\n&quot;</span>
<span class="cp">            if $opt_v;</span>

<span class="cp">        next unless ($dev,$ino) = stat($Start_Dir);</span>
<span class="cp">        next if $visited{$dev,$ino}++;</span>
<span class="cp">        next unless $opt_a || $Start_Dir =~ m!^/!;</span>

<span class="cp">        find(\&amp;wanted, $Start_Dir);</span>
<span class="cp">    }</span>
<span class="cp">    exit;</span>
<span class="cp">}</span>

<span class="cp"># calculate module name from file and directory</span>
<span class="cp">sub modname {</span>
<span class="cp">    local $_ = $File::Find::name;</span>

<span class="cp">    if (index($_, $Start_Dir . &#39;/&#39;) == 0) {</span>
<span class="cp">        substr($_, 0, 1+length($Start_Dir)) = &#39;&#39;;</span>
<span class="cp">    }</span>

<span class="cp">    s { /              }    {::}gx;</span>
<span class="cp">    s { \.p(m|od)$     }    {}x;</span>

<span class="cp">    return $_;</span>
<span class="cp">}</span>

<span class="cp"># decide if this is a module we want</span>
<span class="cp">sub wanted {</span>
<span class="cp">    if ( $Future{$File::Find::name} ) {</span>
<span class="cp">        warn &quot;\t(Skipping $File::Find::name, qui venit in futuro.)\n&quot;</span>
<span class="cp">            if 0 and $opt_v;</span>
<span class="cp">        $File::Find::prune = 1;</span>
<span class="cp">        return;</span>
<span class="cp">    }</span>
<span class="cp">    return unless /\.pm$/ &amp;&amp; -f;</span>
<span class="cp">    $Module = &amp;modname;</span>
<span class="cp">    # skip obnoxious modules</span>
<span class="cp">    if ($Module =~ /^CPAN(\Z|::)/) {</span>
<span class="cp">        warn(&quot;$Module -- skipping because it misbehaves\n&quot;);</span>
<span class="cp">        return;</span>
<span class="cp">    }</span>

<span class="cp">    my    $file = $_;</span>

<span class="cp">    unless (open(POD, &quot;&lt; $file&quot;)) {</span>
<span class="cp">        warn &quot;\tcannot open $file: $!&quot;;</span>
<span class="cp">            # if $opt_w;</span>
<span class="cp">        return 0;</span>
<span class="cp">    }</span>

<span class="cp">    $: = &quot; -:&quot;;</span>

<span class="cp">    local $/ = &#39;&#39;;</span>
<span class="cp">    local $_;</span>
<span class="cp">    while (&lt;POD&gt;) {</span>
<span class="cp">        if (/=head\d\s+NAME/) {</span>
<span class="cp">            chomp($_ = &lt;POD&gt;);</span>
<span class="cp">            s/^.*?-\s+//s;</span>
<span class="cp">            s/\n/ /g;</span>
<span class="cp">            #write;</span>
<span class="cp">            my $v;</span>
<span class="cp">            if (defined ($v = getversion($Module))) {</span>
<span class="cp">                print &quot;$Module ($v) &quot;;</span>
<span class="cp">            } else {</span>
<span class="cp">                print &quot;$Module &quot;;</span>
<span class="cp">            }</span>
<span class="cp">            print &quot;- $_\n&quot;;</span>
<span class="cp">            return 1;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>

<span class="cp">    warn &quot;\t(MISSING DESC FOR $File::Find::name)\n&quot;</span>
<span class="cp">        if $opt_w;</span>

<span class="cp">    return 0;</span>
<span class="cp">}</span>

<span class="cp"># run Perl to load the module and print its verson number, redirecting</span>
<span class="cp"># errors to /dev/null</span>
<span class="cp">sub getversion {</span>
<span class="cp">    my $mod = shift;</span>

<span class="cp">    my $vers = `$^X -m$mod -e &#39;print \$${mod}::VERSION&#39; 2&gt;/dev/null`;</span>
<span class="cp">    $vers =~ s/^\s*(.*?)\s*$/$1/; # remove stray whitespace</span>
<span class="cp">    return ($vers || undef);</span>
<span class="cp">}</span>

<span class="cp">format  =</span>
<span class="cp">^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;~~^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="cp">$Module,        $_</span>
<span class="cp">.</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$object = {};                       # hash reference</span>
<span class="cp">bless($object, &quot;Data::Encoder&quot;);    # bless $object into Data::Encoder class</span>
<span class="cp">bless($object);                     # bless $object into current package</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj = [3,5];</span>
<span class="cp">print ref($obj), &quot; &quot;, $obj-&gt;[1], &quot;\n&quot;;</span>
<span class="cp">bless($obj, &quot;Human::Cannibal&quot;);</span>
<span class="cp">print ref($obj), &quot; &quot;, $obj-&gt;[1], &quot;\n&quot;;</span>

<span class="cp">ARRAY 5</span>

<span class="cp">Human::Cannibal 5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;{Stomach} = &quot;Empty&quot;;   # directly accessing an object&#39;s contents</span>
<span class="cp">$obj-&gt;{NAME}    = &quot;Thag&quot;;        # uppercase field name to make it stand out (optional)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$encoded = $object-&gt;encode(&quot;data&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$encoded = Data::Encoder-&gt;encode(&quot;data&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $self  = {};         # allocate new hash for object</span>
<span class="cp">    bless($self, $class);</span>
<span class="cp">    return $self;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$object = Class-&gt;new();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$object = Class::new(&quot;Class&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub class_only_method {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    die &quot;class method called on object&quot; if ref $class;</span>
<span class="cp">    # more code here</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub instance_only_method {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    die &quot;instance method called on class&quot; unless ref $self;</span>
<span class="cp">    # more code here</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$lector = new Human::Cannibal;</span>
<span class="cp">feed $lector &quot;Zak&quot;;</span>
<span class="cp">move $lector &quot;New York&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$lector = Human::Cannibal-&gt;</span>
<span class="cp">new();</span>

<span class="cp">$lector-&gt;feed(&quot;Zak&quot;);</span>
<span class="cp">$lector-&gt;move(&quot;New York&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">printf STDERR &quot;stuff here\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">move $obj-&gt;{FIELD};                 # probably wrong</span>
<span class="cp">move $ary[$i];                      # probably wrong</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;move-&gt;{FIELD};                # Surprise!</span>
<span class="cp">$ary-&gt;move-&gt;[$i];                   # Surprise!</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;{FIELD}-&gt;</span>
<span class="cp">move()</span>
<span class="cp">;              # Nope, you wish</span>
<span class="cp">$ary[$i]-&gt;</span>
<span class="cp">move;</span>
<span class="cp">                     # Nope, you wish</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $self  = { };</span>
<span class="cp">    bless($self, $class);</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new { bless( { }, shift ) }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new { bless({}) }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $self = { };  # allocate anonymous hash</span>
<span class="cp">    bless($self);</span>
<span class="cp">    # init two sample attributes/data members/fields</span>
<span class="cp">    $self-&gt;{START} = time();  </span>
<span class="cp">    $self-&gt;{AGE}   = 0;</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $classname  = shift;         # What class are we constructing?</span>
<span class="cp">    my $self      = {};             # Allocate new memory</span>
<span class="cp">    bless($self, $classname);       # Mark it of the right type</span>
<span class="cp">    $self-&gt;{START}  = </span>
<span class="cp">time();</span>
<span class="cp">       # init data fields</span>
<span class="cp">    $self-&gt;{AGE}    = </span>
<span class="cp">0;</span>

<span class="cp">    return $self;                   # And give it back</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $classname  = shift;         # What class are we constructing?</span>
<span class="cp">    my $self      = {};             # Allocate new memory</span>
<span class="cp">    bless($self, $classname);       # Mark it of the right type</span>
<span class="cp">    $self-&gt;_init(@_);               # Call _init with remaining args</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>

<span class="cp"># &quot;private&quot; method to initialize fields.  It always sets START to</span>
<span class="cp"># the current time, and AGE to 0.  If called with arguments, _init</span>
<span class="cp"># interprets them as key+value pairs to initialize the object with.</span>
<span class="cp">sub _init {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{START} = </span>
<span class="cp">time();</span>

<span class="cp">    $self-&gt;{AGE}   = 0;</span>
<span class="cp">    if (@_) {</span>
<span class="cp">        my %extra = @_;</span>
<span class="cp">        @$self{keys %extra} = values %extra;</span>
<span class="cp">    } </span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub DESTROY {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    printf(&quot;$self dying at %s\n&quot;, scalar localtime);</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$self-&gt;{WHATEVER} = $self;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub get_name {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return $self-&gt;{NAME};</span>
<span class="cp">} </span>

<span class="cp">sub set_name {</span>
<span class="cp">    my $self      = shift;</span>
<span class="cp">    $self-&gt;{NAME} = shift;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub name {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    if (@_) { $self-&gt;{NAME} = shift } </span>
<span class="cp">    return $self-&gt;{NAME};</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub age {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    my $prev = $self-&gt;{AGE};</span>
<span class="cp">    if (@_) { $self-&gt;{AGE} = shift } </span>
<span class="cp">    return $prev;</span>
<span class="cp">} </span>
<span class="cp"># sample call of get and set: happy birthday!</span>
<span class="cp">$obj-&gt;age( 1 + $obj-&gt;age );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$him = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$him-&gt;{NAME} = &quot;Sylvester&quot;;</span>
<span class="cp">$him-&gt;{AGE}  = 23;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Carp;</span>
<span class="cp">sub name {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return $self-&gt;{NAME} unless @_;</span>
<span class="cp">    local $_ = shift;</span>
<span class="cp">    croak &quot;too many arguments&quot; if @_;</span>
<span class="cp">    if ($^W) {</span>
<span class="cp">        /[^\s\w&#39;-]/         &amp;&amp; carp &quot;funny characters in name&quot;; #&#39;</span>
<span class="cp">        /\d/                &amp;&amp; carp &quot;numbers in name&quot;;</span>
<span class="cp">        /\S+(\s+\S+)+/      || carp &quot;prefer multiword name&quot;;</span>
<span class="cp">        /\S/                || carp &quot;name is blank&quot;;</span>
<span class="cp">    } </span>
<span class="cp">    s/(\w+)/\u\L$1/g;       # enforce capitalization</span>
<span class="cp">    $self-&gt;{NAME} = $_;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>

<span class="cp"># this is the same as before...</span>
<span class="cp">sub new {</span>
<span class="cp">     my $that  = shift;</span>
<span class="cp">     my $class = ref($that) || $that;</span>
<span class="cp">     my $self = {</span>
<span class="cp">           NAME  =&gt; undef,</span>
<span class="cp">           AGE   =&gt; undef,</span>
<span class="cp">           PEERS =&gt; [],</span>
<span class="cp">    };</span>
<span class="cp">    bless($self, $class);</span>
<span class="cp">    return $self;</span>
<span class="cp">}</span>

<span class="cp">use Alias qw(attr);</span>
<span class="cp">use vars qw($NAME $AGE @PEERS);</span>

<span class="cp">sub name {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    if (@_) { $NAME = shift; }</span>
<span class="cp">    return    $NAME;</span>
<span class="cp">};</span>

<span class="cp">sub age {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    if (@_) { $AGE = shift; }</span>
<span class="cp">    return    $AGE;</span>
<span class="cp">}</span>

<span class="cp">sub peers {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    if (@_) { @PEERS = @_; }</span>
<span class="cp">    return    @PEERS;</span>
<span class="cp">}</span>

<span class="cp">sub exclaim {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    return sprintf &quot;Hi, I&#39;m %s, age %d, working with %s&quot;,</span>
<span class="cp">            $NAME, $AGE, join(&quot;, &quot;, @PEERS);</span>
<span class="cp">}</span>

<span class="cp">sub happy_birthday {</span>
<span class="cp">    my $self = attr shift;</span>
<span class="cp">    return ++$AGE;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>

<span class="cp">$Body_Count = 0; </span>

<span class="cp">sub population { return $Body_Count }</span>

<span class="cp">sub new {                                   # constructor</span>
<span class="cp">    $Body_Count++;</span>
<span class="cp">    return bless({}, shift);</span>
<span class="cp">}</span>

<span class="cp">sub DESTROY { --$BodyCount }                # destructor</span>

<span class="cp"># later, the user can say this:</span>
<span class="cp">package main;</span>

<span class="cp">for (1..10) { push @people, Person-&gt;new }</span>
<span class="cp">printf &quot;There are %d people alive.\n&quot;, Person-&gt;population();</span>

<span class="cp">There are 10 people alive.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$him = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$him-&gt;gender(&quot;male&quot;);</span>

<span class="cp">$her = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$her-&gt;gender(&quot;female&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">FixedArray-&gt;Max_Bounds(100);                # set for whole class</span>
<span class="cp">$alpha = FixedArray-&gt;new();</span>
<span class="cp">printf &quot;Bound on alpha is %d\n&quot;, $alpha-&gt;Max_Bounds();</span>
<span class="cp">100</span>

<span class="cp">$beta = FixedArray-&gt;new();</span>
<span class="cp">$beta-&gt;Max_Bounds(50);                      # still sets for whole class</span>
<span class="cp">printf &quot;Bound on alpha is %d\n&quot;, $alpha-&gt;Max_Bounds();</span>
<span class="cp">50</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package FixedArray;</span>
<span class="cp">$Bounds = 7;  # default</span>
<span class="cp">sub new { bless( {}, shift ) }</span>
<span class="cp">sub Max_Bounds {</span>
<span class="cp">    my $proto  = shift;</span>
<span class="cp">    $Bounds    = shift if @_;          # allow updates</span>
<span class="cp">    return $Bounds;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub Max_Bounds { $Bounds }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $self = bless({}, $class);</span>
<span class="cp">    $self-&gt;{Max_Bounds_ref} = \$Bounds;</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Class::Struct;          # load struct-building module</span>

<span class="cp">struct Person =&gt; {          # create a definition for a &quot;Person&quot;</span>
<span class="cp">    name   =&gt; &#39;$&#39;,          #    name field is a scalar</span>
<span class="cp">    age    =&gt; &#39;$&#39;,          #    age field is also a scalar</span>
<span class="cp">    peers  =&gt; &#39;@&#39;,          #    but peers field is an array (reference)</span>
<span class="cp">};</span>

<span class="cp">my $p = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;      # allocate an empty Person struct</span>

<span class="cp">$p-&gt;name(&quot;Jason Smythe&quot;);                   # set its name field</span>
<span class="cp">$p-&gt;age(13);                                # set its age field</span>
<span class="cp">$p-&gt;peers( [&quot;Wilbur&quot;, &quot;Ralph&quot;, &quot;Fred&quot; ] );  # set its peers field</span>

<span class="cp"># or this way:</span>
<span class="cp">@{$p-&gt;peers} = (&quot;Wilbur&quot;, &quot;Ralph&quot;, &quot;Fred&quot;);</span>

<span class="cp"># fetch various values, including the zeroth friend</span>
<span class="cp">printf &quot;At age %d, %s&#39;s first friend is %s.\n&quot;,</span>
<span class="cp">    $p-&gt;age, $p-&gt;name, $p-&gt;peers(0);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Class::Struct;</span>

<span class="cp">struct Person =&gt; {name =&gt; &#39;$&#39;,      age  =&gt; &#39;$&#39;};  #&#39;</span>
<span class="cp">struct Family =&gt; {head =&gt; &#39;Person&#39;, address =&gt; &#39;$&#39;, members =&gt; &#39;@&#39;};  #&#39;</span>

<span class="cp">$folks  = Family-&gt;</span>
<span class="cp">new();</span>

<span class="cp">$dad    = $folks-&gt;head;</span>
<span class="cp">$dad-&gt;name(&quot;John&quot;);</span>
<span class="cp">$dad-&gt;age(34);</span>

<span class="cp">printf(&quot;%s&#39;s age is %d\n&quot;, $folks-&gt;head-&gt;name, $folks-&gt;head-&gt;age);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub Person::age {</span>
<span class="cp">    use Carp;</span>
<span class="cp">    my ($self, $age) = @_;</span>
<span class="cp">    if    (@_  &gt; 2) {  confess &quot;too many arguments&quot; } </span>
<span class="cp">    elsif (@_ == 1) {  return $struct-&gt;{&#39;age&#39;}      }</span>
<span class="cp">    elsif (@_ == 2) {</span>
<span class="cp">        carp &quot;age `$age&#39; isn&#39;t numeric&quot;   if $age !~ /^\d+/;</span>
<span class="cp">        carp &quot;age `$age&#39; is unreasonable&quot; if $age &gt; 150;</span>
<span class="cp">        $self-&gt;{&#39;age&#39;} = $age;</span>
<span class="cp">    } </span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($^W) { </span>
<span class="cp">    carp &quot;age `$age&#39; isn&#39;t numeric&quot;   if $age !~ /^\d+/;</span>
<span class="cp">    carp &quot;age `$age&#39; is unreasonable&quot; if $age &gt; 150;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $gripe = $^W ? \&amp;carp : \&amp;croak;</span>
<span class="cp">$gripe-&gt;(&quot;age `$age&#39; isn&#39;t numeric&quot;)   if $age !~ /^\d+/;</span>
<span class="cp">$gripe-&gt;(&quot;age `$age&#39; is unreasonable&quot;) if $age &gt; 150;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">struct Family =&gt; [head =&gt; &#39;Person&#39;, address =&gt; &#39;$&#39;, members =&gt; &#39;@&#39;];  #&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">struct Card =&gt; { </span>
<span class="cp">    name    =&gt; &#39;$&#39;,</span>
<span class="cp">    color   =&gt; &#39;$&#39;,</span>
<span class="cp">    cost    =&gt; &#39;$&#39;,</span>
<span class="cp">    type    =&gt; &#39;$&#39;,</span>
<span class="cp">    release =&gt; &#39;$&#39;,</span>
<span class="cp">    text    =&gt; &#39;$&#39;,</span>
<span class="cp">};</span>
<span class="cp">#-----------------------------</span>
<span class="cp">struct Card =&gt; map { $_ =&gt; &#39;$&#39; } qw(name color cost type release text); #&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">struct hostent =&gt; { reverse qw{</span>
<span class="cp">    $ name</span>
<span class="cp">    @ aliases</span>
<span class="cp">    $ addrtype</span>
<span class="cp">    $ length</span>
<span class="cp">    @ addr_list</span>
<span class="cp">}};</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#define h_type h_addrtype</span>
<span class="cp">#define h_addr h_addr_list[0]</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># make (hostent object)-&gt;</span>
<span class="cp">type()</span>
<span class="cp"> same as (hostent object)-&gt;</span>
<span class="cp">addrtype()</span>

<span class="cp">*hostent::type = \&amp;hostent::addrtype;</span>

<span class="cp"># make (hostenv object)-&gt;</span>
<span class="cp">addr()</span>
<span class="cp"> same as (hostenv object)-&gt;addr_list(0)</span>
<span class="cp">sub hostent::addr { shift-&gt;addr_list(0,@_) }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Extra::hostent;</span>
<span class="cp">use Net::hostent;</span>
<span class="cp">@ISA = qw(hostent);</span>
<span class="cp">sub addr { shift-&gt;addr_list(0,@_) } </span>
<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $proto  = shift;</span>
<span class="cp">my $class  = ref($proto) || $proto;</span>
<span class="cp">my $parent = ref($proto) &amp;&amp; $proto;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ob1 = SomeClass-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp"># later on</span>
<span class="cp">$ob2 = (ref $ob1)-&gt;</span>
<span class="cp">new();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ob1 = Widget-&gt;new();</span>
<span class="cp">$ob2 = $ob1-&gt;new();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $proto  = shift;</span>
<span class="cp">    my $class  = ref($proto) || $proto;</span>
<span class="cp">    my $parent = ref($proto) &amp;&amp; $proto;</span>

<span class="cp">    my $self;</span>
<span class="cp">    # check whether we&#39;re shadowing a new from @ISA</span>
<span class="cp">    if (@ISA &amp;&amp; $proto-&gt;SUPER::can(&#39;new&#39;) ) {</span>
<span class="cp">        $self = $proto-&gt;SUPER::new(@_);</span>
<span class="cp">    } else { </span>
<span class="cp">        $self = {};</span>
<span class="cp">        bless ($self, $proto);</span>
<span class="cp">    }</span>
<span class="cp">    bless($self, $class);</span>

<span class="cp">    $self-&gt;{PARENT}  = $parent;</span>
<span class="cp">    $self-&gt;{START}   = time();   # init data fields</span>
<span class="cp">    $self-&gt;{AGE}     = 0;</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$methname = &quot;flicker&quot;;</span>
<span class="cp">$obj-&gt;$methname(10);         # calls $obj-&gt;flicker(10);</span>

<span class="cp"># call three methods on the object, by name</span>
<span class="cp">foreach $m ( qw(start run stop) ) {</span>
<span class="cp">    $obj-&gt;</span>
<span class="cp">$m();</span>

<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">@methods = qw(name rank serno);</span>
<span class="cp">%his_info = map { $_ =&gt; $ob-&gt;$_() } @methods;</span>

<span class="cp"># same as this:</span>

<span class="cp">%his_info = (</span>
<span class="cp">    &#39;name&#39;  =&gt; $ob-&gt;</span>
<span class="cp">name()</span>
<span class="cp">,</span>
<span class="cp">    &#39;rank&#39;  =&gt; $ob-&gt;</span>
<span class="cp">rank()</span>
<span class="cp">,</span>
<span class="cp">    &#39;serno&#39; =&gt; $ob-&gt;</span>
<span class="cp">serno()</span>
<span class="cp">,</span>
<span class="cp">);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $fnref = sub { $ob-&gt;method(@_) };</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$fnref-&gt;(10, &quot;fred&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;method(10, &quot;fred&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;can(&#39;method_name&#39;)-&gt;($obj_target, @arguments)</span>
<span class="cp">   if $obj_target-&gt;isa( ref $obj );</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;isa(&quot;HTTP::Message&quot;);                  # as object method</span>
<span class="cp">HTTP::Response-&gt;isa(&quot;HTTP::Message&quot;);       # as class method</span>

<span class="cp">if ($obj-&gt;can(&quot;method_name&quot;)) { .... }       # check method validity</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$has_io = $fd-&gt;isa(&quot;IO::Handle&quot;);</span>
<span class="cp">$itza_handle = IO::Socket-&gt;isa(&quot;IO::Handle&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$his_print_method = $obj-&gt;can(&#39;as_string&#39;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">Some_Module-&gt;VERSION(3.0);</span>
<span class="cp">$his_vers = $obj-&gt;</span>
<span class="cp">VERSION()</span>
<span class="cp">;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Some_Module 3.0;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use vars qw($VERSION);</span>
<span class="cp">$VERSION = &#39;1.01&#39;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $self  = { };</span>
<span class="cp">    return bless $self, $class;</span>
<span class="cp">} </span>
<span class="cp">sub name {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{NAME} = shift if @_;</span>
<span class="cp">    return $self-&gt;{NAME};</span>
<span class="cp">} </span>
<span class="cp">sub age {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{AGE} = shift if @_;</span>
<span class="cp">    return $self-&gt;{AGE};</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Person;</span>
<span class="cp">my $dude = Person-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$dude-&gt;name(&quot;Jason&quot;);</span>
<span class="cp">$dude-&gt;age(23);</span>
<span class="cp">printf &quot;%s is age %d.\n&quot;, $dude-&gt;name, $dude-&gt;age;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Employee;</span>
<span class="cp">use Person;</span>
<span class="cp">@ISA = (&quot;Person&quot;);</span>
<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Employee;</span>
<span class="cp">my $empl = Employee-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">$empl-&gt;name(&quot;Jason&quot;);</span>
<span class="cp">$empl-&gt;age(23);</span>
<span class="cp">printf &quot;%s is age %d.\n&quot;, $empl-&gt;name, $empl-&gt;age;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$him = Person::</span>
<span class="cp">new()</span>
<span class="cp">;               # WRONG</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub meth { </span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;SUPER::</span>
<span class="cp">meth()</span>
<span class="cp">;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$self-&gt;</span>
<span class="cp">meth();</span>
<span class="cp">                # Call wherever first meth is found</span>
<span class="cp">$self-&gt;Where::</span>
<span class="cp">meth();</span>
<span class="cp">         # Start looking in package &quot;Where&quot;</span>
<span class="cp">$self-&gt;SUPER::</span>
<span class="cp">meth(); </span>
<span class="cp">        # Call overridden version</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub new {</span>
<span class="cp">    my $classname  = shift;         # What class are we constructing?</span>
<span class="cp">    my $self       = $classname-&gt;SUPER::new(@_);</span>
<span class="cp">    $self-&gt;_init(@_);</span>
<span class="cp">    return $self;                   # And give it back</span>
<span class="cp">} </span>

<span class="cp">sub _init {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{START}   = time();   # init data fields</span>
<span class="cp">    $self-&gt;{AGE}     = 0;</span>
<span class="cp">    $self-&gt;{EXTRA}   = { @_ };   # anything extra</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj = Widget-&gt;new( haircolor =&gt; red, freckles =&gt; 121 );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $self = bless {}, $class;</span>
<span class="cp">for my $class (@ISA) {</span>
<span class="cp">    my $meth = $class . &quot;::_init&quot;;</span>
<span class="cp">    $self-&gt;$meth(@_) if $class-&gt;can(&quot;_init&quot;);</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>
<span class="cp">use strict;</span>
<span class="cp">use Carp;</span>
<span class="cp">use vars qw($AUTOLOAD %ok_field);</span>

<span class="cp"># Authorize four attribute fields</span>
<span class="cp">for my $attr ( qw(name age peers parent) ) { $ok_field{$attr}++; } </span>

<span class="cp">sub AUTOLOAD {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    my $attr = $AUTOLOAD;</span>
<span class="cp">    $attr =~ s/.*:://;</span>
<span class="cp">    return unless $attr =~ /[^A-Z]/;  # skip DESTROY and all-cap methods</span>
<span class="cp">    croak &quot;invalid attribute method: -&gt;</span>
<span class="cp">$attr()&quot;</span>
<span class="cp"> unless $ok_field{$attr};</span>
<span class="cp">    $self-&gt;{uc $attr} = shift if @_;</span>
<span class="cp">    return $self-&gt;{uc $attr};</span>
<span class="cp">}</span>
<span class="cp">sub new {</span>
<span class="cp">    my $proto  = shift;</span>
<span class="cp">    my $class  = ref($proto) || $proto;</span>
<span class="cp">    my $parent = ref($proto) &amp;&amp; $proto;</span>
<span class="cp">    my $self = {};</span>
<span class="cp">    bless($self, $class);</span>
<span class="cp">    $self-&gt;parent($parent);</span>
<span class="cp">    return $self;</span>
<span class="cp">} </span>
<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Person;</span>
<span class="cp">my ($dad, $kid);</span>
<span class="cp">$dad = Person-&gt;new;</span>
<span class="cp">$dad-&gt;name(&quot;Jason&quot;);</span>
<span class="cp">$dad-&gt;age(23);</span>
<span class="cp">$kid = $dad-&gt;new;</span>
<span class="cp">$kid-&gt;name(&quot;Rachel&quot;);</span>
<span class="cp">$kid-&gt;age(2);</span>
<span class="cp">printf &quot;Kid&#39;s parent is %s\n&quot;, $kid-&gt;parent-&gt;name;</span>
<span class="cp">#Kid&#39;s parent is Jason</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub AUTOLOAD {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    my $attr = $AUTOLOAD;</span>
<span class="cp">    $attr =~ s/.*:://;</span>
<span class="cp">    return if $attr eq &#39;DESTROY&#39;;   </span>

<span class="cp">    if ($ok_field{$attr}) {</span>
<span class="cp">        $self-&gt;{uc $attr} = shift if @_;</span>
<span class="cp">        return $self-&gt;{uc $attr};</span>
<span class="cp">    } else {</span>
<span class="cp">        my $superior = &quot;SUPER::$attr&quot;;</span>
<span class="cp">        $self-&gt;$superior(@_);</span>
<span class="cp">    } </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub Employee::age {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $self-&gt;{Employee_age} = shift if @_;</span>
<span class="cp">    return $self-&gt;{Employee_age};</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Person;</span>
<span class="cp">use Class::Attributes;  # see explanation below</span>
<span class="cp">mkattr qw(name age peers parent);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Employee;</span>
<span class="cp">@ISA = qw(Person);</span>
<span class="cp">use Class::Attributes;</span>
<span class="cp">mkattr qw(salary age boss);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Class::Attributes;</span>
<span class="cp">use strict;</span>
<span class="cp">use Carp;</span>
<span class="cp">use Exporter ();</span>
<span class="cp">use vars qw(@ISA @EXPORT);</span>
<span class="cp">@ISA = qw(Exporter);</span>
<span class="cp">@EXPORT = qw(mkattr);</span>
<span class="cp">sub mkattr {</span>
<span class="cp">    my $hispack = caller();</span>
<span class="cp">    for my $attr (@_) {</span>
<span class="cp">        my($field, $method);</span>
<span class="cp">        $method = &quot;${hispack}::$attr&quot;;</span>
<span class="cp">        ($field = $method) =~ s/:/_/g; </span>
<span class="cp">        no strict &#39;refs&#39;; # here comes the kluglich bit</span>
<span class="cp">        *$method = sub {</span>
<span class="cp">            my $self = shift;</span>
<span class="cp">            confess &quot;too many arguments&quot; if @_ &gt; 1;</span>
<span class="cp">            $self-&gt;{$field} = shift if @_;</span>
<span class="cp">            return $self-&gt;{$field};   </span>
<span class="cp">        };</span>
<span class="cp">    } </span>
<span class="cp">} </span>
<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$node-&gt;{NEXT} = $node;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package Ring;</span>

<span class="cp"># return an empty ring structure</span>
<span class="cp">sub new {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $node  = { };</span>
<span class="cp">    $node-&gt;{NEXT} = $node-&gt;{PREV} = $node;</span>
<span class="cp">    my $self  = { DUMMY =&gt; $node, COUNT =&gt; 0 };</span>
<span class="cp">    bless $self, $class;</span>
<span class="cp">    return $self;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Ring;</span>

<span class="cp">$COUNT = 1000;</span>
<span class="cp">for (1 .. 20) { </span>
<span class="cp">    my $r = Ring-&gt;</span>
<span class="cp">new()</span>
<span class="cp">;</span>
<span class="cp">    for ($i = 0; $i &lt; $COUNT; $i++) { $r-&gt;insert($i) } </span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># when a Ring is destroyed, destroy the ring structure it contains </span>
<span class="cp">sub DESTROY {</span>
<span class="cp">    my $ring = shift;</span>
<span class="cp">    my $node;</span>
<span class="cp">    for ( $node  =  $ring-&gt;{DUMMY}-&gt;{NEXT};</span>
<span class="cp">          $node !=  $ring-&gt;{DUMMY}; </span>
<span class="cp">          $node  =  $node-&gt;{NEXT} )</span>
<span class="cp">    {</span>
<span class="cp">             $ring-&gt;delete_node($node);</span>
<span class="cp">    } </span>
<span class="cp">    $node-&gt;{PREV} = $node-&gt;{NEXT} = undef;</span>
<span class="cp">} </span>

<span class="cp"># delete a node from the ring structure</span>
<span class="cp">sub delete_node {</span>
<span class="cp">    my ($ring, $node) = @_;</span>
<span class="cp">    $node-&gt;{PREV}-&gt;{NEXT} = $node-&gt;{NEXT};</span>
<span class="cp">    $node-&gt;{NEXT}-&gt;{PREV} = $node-&gt;{PREV};</span>
<span class="cp">    --$ring-&gt;{COUNT};</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># $node = $ring-&gt;search( $value ) : find $value in the ring</span>
<span class="cp"># structure in $node</span>
<span class="cp">sub search {</span>
<span class="cp">    my ($ring, $value) = @_;</span>
<span class="cp">    my $node = $ring-&gt;{DUMMY}-&gt;{NEXT};</span>
<span class="cp">    while ($node != $ring-&gt;{DUMMY} &amp;&amp; $node-&gt;{VALUE} != $value) {</span>
<span class="cp">          $node = $node-&gt;{NEXT};</span>
<span class="cp">    }</span>
<span class="cp">    return $node;</span>
<span class="cp">} </span>

<span class="cp"># $ring-&gt;insert( $value ) : insert $value into the ring structure</span>
<span class="cp">sub insert {</span>
<span class="cp">    my ($ring, $value) = @_;</span>
<span class="cp">    my $node = { VALUE =&gt; $value };</span>
<span class="cp">    $node-&gt;{NEXT} = $ring-&gt;{DUMMY}-&gt;{NEXT};</span>
<span class="cp">    $ring-&gt;{DUMMY}-&gt;{NEXT}-&gt;{PREV} = $node;</span>
<span class="cp">    $ring-&gt;{DUMMY}-&gt;{NEXT} = $node;</span>
<span class="cp">    $node-&gt;{PREV} = $ring-&gt;{DUMMY};</span>
<span class="cp">    ++$ring-&gt;{COUNT};</span>
<span class="cp">} </span>

<span class="cp"># $ring-&gt;delete_value( $value ) : delete a node from the ring</span>
<span class="cp"># structure by value</span>
<span class="cp">sub delete_value {</span>
<span class="cp">    my ($ring, $value) = @_;</span>
<span class="cp">    my $node = $ring-&gt;search($value);</span>
<span class="cp">    return if $node == $ring-&gt;{DUMMY};</span>
<span class="cp">    $ring-&gt;delete_node($node);</span>
<span class="cp">}</span>


<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use overload (&#39;&lt;=&gt;&#39; =&gt; \&amp;threeway_compare);</span>
<span class="cp">sub threeway_compare {</span>
<span class="cp">    my ($s1, $s2) = @_;</span>
<span class="cp">    return uc($s1-&gt;{NAME}) cmp uc($s2-&gt;{NAME});</span>
<span class="cp">} </span>

<span class="cp">use overload ( &#39;&quot;&quot;&#39;  =&gt; \&amp;stringify );</span>
<span class="cp">sub stringify {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return sprintf &quot;%s (%05d)&quot;, </span>
<span class="cp">            ucfirst(lc($self-&gt;{NAME})),</span>
<span class="cp">            $self-&gt;{IDNUM};</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package TimeNumber;</span>
<span class="cp">use overload &#39;+&#39; =&gt; \&amp;my_plus,</span>
<span class="cp">             &#39;-&#39; =&gt; \&amp;my_minus,</span>
<span class="cp">             &#39;*&#39; =&gt; \&amp;my_star,</span>
<span class="cp">             &#39;/&#39; =&gt; \&amp;my_slash;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub my_plus {</span>
<span class="cp">    my($left, $right) = @_;</span>
<span class="cp">    my $answer = $left-&gt;</span>
<span class="cp">new();</span>

<span class="cp">    $answer-&gt;{SECONDS} = $left-&gt;{SECONDS} + $right-&gt;{SECONDS};</span>
<span class="cp">    $answer-&gt;{MINUTES} = $left-&gt;{MINUTES} + $right-&gt;{MINUTES};</span>
<span class="cp">    $answer-&gt;{HOURS}   = $left-&gt;{HOURS}   + $right-&gt;{HOURS};</span>

<span class="cp">    if ($answer-&gt;{SECONDS} &gt;= 60) {</span>
<span class="cp">        $answer-&gt;{SECONDS} %= 60;</span>
<span class="cp">        $answer-&gt;{MINUTES} ++;</span>
<span class="cp">    } </span>

<span class="cp">    if ($answer-&gt;{MINUTES} &gt;= 60) {</span>
<span class="cp">        $answer-&gt;{MINUTES} %= 60;</span>
<span class="cp">        $answer-&gt;{HOURS}   ++;</span>
<span class="cp">    } </span>

<span class="cp">    return $answer;</span>

<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># show_strnum - demo operator overloading</span>
<span class="cp">use StrNum;           </span>
<span class="cp">    </span>
<span class="cp">$x = StrNum(&quot;Red&quot;); $y = StrNum(&quot;Black&quot;);</span>
<span class="cp">$z = $x + $y; $r = $z * 3;</span>
<span class="cp">print &quot;values are $x, $y, $z, and $r\n&quot;;</span>
<span class="cp">print &quot;$x is &quot;, $x &lt; $y ? &quot;LT&quot; : &quot;GE&quot;, &quot; $y\n&quot;;</span>

<span class="cp"># values are Red, Black, RedBlack, and RedBlackRedBlackRedBlack</span>
<span class="cp"># Red is GE Black</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/StrNum</span>">download the following standalone program</a></font>
<span class="cp">package StrNum;</span>

<span class="cp">use Exporter ();</span>
<span class="cp">@ISA = &#39;Exporter&#39;;</span>
<span class="cp">@EXPORT = qw(StrNum);  # unusual</span>

<span class="cp">use overload        (</span>
<span class="cp">        &#39;&lt;=&gt;&#39;   =&gt; \&amp;spaceship,</span>
<span class="cp">        &#39;cmp&#39;   =&gt; \&amp;spaceship,</span>
<span class="cp">        &#39;&quot;&quot;&#39;    =&gt; \&amp;stringify,</span>
<span class="cp">        &#39;bool&#39;  =&gt; \&amp;boolify,</span>
<span class="cp">        &#39;0+&#39;    =&gt; \&amp;numify,</span>
<span class="cp">        &#39;+&#39;     =&gt; \&amp;concat,</span>
<span class="cp">        &#39;*&#39;     =&gt; \&amp;repeat,</span>
<span class="cp">);</span>

<span class="cp"># constructor</span>
<span class="cp">sub StrNum($) { </span>
<span class="cp">    my ($value) = @_; </span>
<span class="cp">    return bless \$value; </span>
<span class="cp">} </span>

<span class="cp">sub stringify { ${ $_[0] } } </span>
<span class="cp">sub numify    { ${ $_[0] } } </span>
<span class="cp">sub boolify   { ${ $_[0] } } </span>

<span class="cp"># providing &lt;=&gt; gives us &lt;, ==, etc. for free.</span>
<span class="cp">sub spaceship { </span>
<span class="cp">    my ($s1, $s2, $inverted) = @_;</span>
<span class="cp">    return $inverted ? $$s2 cmp $$s1 : $$s1 cmp $$s2;</span>
<span class="cp">} </span>

<span class="cp"># this uses stringify</span>
<span class="cp">sub concat { </span>
<span class="cp">    my ($s1, $s2, $inverted) = @_;</span>
<span class="cp">    return StrNum $inverted ? ($s2 . $s1) : ($s1 . $s2);</span>
<span class="cp">} </span>

<span class="cp"># this uses stringify</span>
<span class="cp">sub repeat { </span>
<span class="cp">    my ($s1, $s2, $inverted) = @_;</span>
<span class="cp">    return StrNum $inverted ? ($s2 x $s1) : ($s1 x $s2);</span>
<span class="cp">}</span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># demo_fixnum - show operator overloading</span>
<span class="cp">use FixNum;</span>

<span class="cp">FixNum-&gt;places(5);</span>

<span class="cp">$x = FixNum-&gt;new(40);</span>
<span class="cp">$y = FixNum-&gt;new(12);</span>

<span class="cp">print &quot;sum of $x and $y is &quot;, $x + $y, &quot;\n&quot;;</span>
<span class="cp">print &quot;product of $x and $y is &quot;, $x * $y, &quot;\n&quot;;</span>

<span class="cp">$z = $x / $y;</span>
<span class="cp">printf &quot;$z has %d places\n&quot;, $z-&gt;places;</span>
<span class="cp">$z-&gt;places(2) unless $z-&gt;places;</span>
<span class="cp">print &quot;div of $x by $y is $z\n&quot;;</span>
<span class="cp">print &quot;square of that is &quot;, $z * $z, &quot;\n&quot;;</span>

<span class="cp">sum of STRFixNum: 40 and STRFixNum: 12 is STRFixNum: 52</span>

<span class="cp">product of STRFixNum: 40 and STRFixNum: 12 is STRFixNum: 480</span>

<span class="cp">STRFixNum: 3 has 0 places</span>

<span class="cp">div of STRFixNum: 40 by STRFixNum: 12 is STRFixNum: 3.33</span>

<span class="cp">square of that is STRFixNum: 11.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/FixNum</span>">download the following standalone program</a></font>
<span class="cp">package FixNum;</span>

<span class="cp">use strict;</span>

<span class="cp">my $PLACES = 0;</span>

<span class="cp">sub new {</span>
<span class="cp">    my $proto   = shift;</span>
<span class="cp">    my $class   = ref($proto) || $proto;</span>
<span class="cp">    my $parent  = ref($proto) &amp;&amp; $proto;</span>

<span class="cp">    my $v = shift;</span>
<span class="cp">    my $self = {</span>
<span class="cp">        VALUE  =&gt; $v,</span>
<span class="cp">        PLACES =&gt; undef,</span>
<span class="cp">    }; </span>
<span class="cp">    if ($parent &amp;&amp; defined $parent-&gt;{PLACES}) {</span>
<span class="cp">        $self-&gt;{PLACES} = $parent-&gt;{PLACES};</span>
<span class="cp">    } elsif ($v =~ /(\.\d*)/) {</span>
<span class="cp">        $self-&gt;{PLACES} = length($1) - 1;</span>
<span class="cp">    }  else {</span>
<span class="cp">        $self-&gt;{PLACES} = 0;</span>
<span class="cp">    } </span>
<span class="cp">    return bless $self, $class;</span>
<span class="cp">} </span>

<span class="cp">sub places {</span>
<span class="cp">    my $proto = shift;</span>
<span class="cp">    my $self  = ref($proto) &amp;&amp; $proto;</span>
<span class="cp">    my $type  = ref($proto) || $proto;</span>

<span class="cp">    if (@_) {</span>
<span class="cp">        my $places = shift;</span>
<span class="cp">        ($self ? $self-&gt;{PLACES} : $PLACES) = $places;</span>
<span class="cp">    } </span>
<span class="cp">    return $self ? $self-&gt;{PLACES} : $PLACES;</span>
<span class="cp">} </span>

<span class="cp">sub _max { $_[0] &gt; $_[1] ? $_[0] : $_[1] } </span>

<span class="cp">use overload &#39;+&#39;    =&gt; \&amp;add,</span>
<span class="cp">             &#39;*&#39;    =&gt; \&amp;multiply,</span>
<span class="cp">             &#39;/&#39;    =&gt; \&amp;divide,</span>
<span class="cp">             &#39;&lt;=&gt;&#39;  =&gt; \&amp;spaceship,</span>
<span class="cp">             &#39;&quot;&quot;&#39;   =&gt; \&amp;as_string,</span>
<span class="cp">             &#39;0+&#39;   =&gt; \&amp;as_number;</span>

<span class="cp">sub add {</span>
<span class="cp">    my ($this, $that, $flipped) = @_;</span>
<span class="cp">    my $result = $this-&gt;new( $this-&gt;{VALUE} + $that-&gt;{VALUE} );</span>
<span class="cp">    $result-&gt;places( _max($this-&gt;{PLACES}, $that-&gt;{PLACES} ));</span>
<span class="cp">    return $result;</span>
<span class="cp">} </span>

<span class="cp">sub multiply {</span>
<span class="cp">    my ($this, $that, $flipped) = @_;</span>
<span class="cp">    my $result = $this-&gt;new( $this-&gt;{VALUE} * $that-&gt;{VALUE} );</span>
<span class="cp">    $result-&gt;places( _max($this-&gt;{PLACES}, $that-&gt;{PLACES} ));</span>
<span class="cp">    return $result;</span>
<span class="cp">} </span>

<span class="cp">sub divide {</span>
<span class="cp">    my ($this, $that, $flipped) = @_;</span>
<span class="cp">    my $result = $this-&gt;new( $this-&gt;{VALUE} / $that-&gt;{VALUE} );</span>
<span class="cp">    $result-&gt;places( _max($this-&gt;{PLACES}, $that-&gt;{PLACES} ));</span>
<span class="cp">    return $result;</span>
<span class="cp">} </span>

<span class="cp">sub as_string {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return sprintf(&quot;STR%s: %.*f&quot;, ref($self), </span>
<span class="cp">        defined($self-&gt;{PLACES}) ? $self-&gt;{PLACES} : $PLACES, </span>
<span class="cp">            $self-&gt;{VALUE});</span>
<span class="cp">} </span>

<span class="cp">sub as_number {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return $self-&gt;{VALUE};</span>
<span class="cp">} </span>
<span class="cp">    </span>
<span class="cp">sub spaceship {</span>
<span class="cp">    my ($this, $that, $flipped) = @_;</span>
<span class="cp">    $this-&gt;{VALUE} &lt;=&gt; $that-&gt;{VALUE};</span>
<span class="cp">} </span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_13.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">tie $s, &quot;SomeClass&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">SomeClass-&gt;</span>
<span class="cp">TIESCALAR()</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$p = $s</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$p = $obj-&gt;</span>
<span class="cp">FETCH()</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$s = 10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$obj-&gt;STORE(10)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># demo_valuering - show tie class</span>
<span class="cp">use ValueRing;</span>
<span class="cp">tie $color, &#39;ValueRing&#39;, qw(red blue);</span>
<span class="cp">print &quot;$color $color $color $color $color $color\n&quot;;</span>
<span class="cp">red blue red blue red blue</span>


<span class="cp">$color = &#39;green&#39;;</span>
<span class="cp">print &quot;$color $color $color $color $color $color\n&quot;;</span>
<span class="cp">green red blue green red blue</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/ValueRing</span>">download the following standalone program</a></font>
<span class="cp">package ValueRing;</span>

<span class="cp"># this is the constructor for scalar ties</span>
<span class="cp">sub TIESCALAR {</span>
<span class="cp">    my ($class, @values) = @_;</span>
<span class="cp">    bless  \@values, $class;</span>
<span class="cp">    return \@values;</span>
<span class="cp">} </span>

<span class="cp"># this intercepts read accesses</span>
<span class="cp">sub FETCH {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    push(@$self, shift(@$self));</span>
<span class="cp">    return $self-&gt;[-1];</span>
<span class="cp">} </span>

<span class="cp"># this intercepts write accesses</span>
<span class="cp">sub STORE {</span>
<span class="cp">    my ($self, $value) = @_;</span>
<span class="cp">    unshift @$self, $value;</span>
<span class="cp">    return $value;</span>
<span class="cp">} </span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">no UnderScore;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># nounder_demo - show how to ban $_ from your program</span>
<span class="cp">no UnderScore;</span>
<span class="cp">@tests = (</span>
<span class="cp">    &quot;Assignment&quot;  =&gt; sub { $_ = &quot;Bad&quot; },</span>
<span class="cp">    &quot;Reading&quot;     =&gt; sub { print }, </span>
<span class="cp">    &quot;Matching&quot;    =&gt; sub { $x = /badness/ },</span>
<span class="cp">    &quot;Chop&quot;        =&gt; sub { chop },</span>
<span class="cp">    &quot;Filetest&quot;    =&gt; sub { -x }, </span>
<span class="cp">    &quot;Nesting&quot;     =&gt; sub { for (1..3) { print } },</span>
<span class="cp">);</span>

<span class="cp">while ( ($name, $code) = splice(@tests, 0, 2) ) {</span>
<span class="cp">    print &quot;Testing $name: &quot;;</span>
<span class="cp">    eval { &amp;$code };</span>
<span class="cp">    print $@ ? &quot;detected&quot; : &quot;missed!&quot;;</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">Testing Assignment: detected</span>

<span class="cp">Testing Reading: detected</span>

<span class="cp">Testing Matching: detected</span>

<span class="cp">Testing Chop: detected</span>

<span class="cp">Testing Filetest: detected</span>

<span class="cp">Testing Nesting: 123missed!</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/UnderScore</span>">download the following standalone program</a></font>
<span class="cp">package UnderScore;</span>
<span class="cp">use Carp;</span>
<span class="cp">sub TIESCALAR {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $dummy;</span>
<span class="cp">    return bless \$dummy =&gt; $class;</span>
<span class="cp">} </span>
<span class="cp">sub FETCH { croak &quot;Read access to \$_ forbidden&quot;  } </span>
<span class="cp">sub STORE { croak &quot;Write access to \$_ forbidden&quot; } </span>
<span class="cp">sub unimport { tie($_, _     _PACKAGE_     _) }</span>
<span class="cp">sub import { untie $_ } </span>
<span class="cp">tie($_, _     _PACKAGE_     _) unless tied $_;</span>
<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl </span>
<span class="cp"># appendhash_demo - show magic hash that autoappends</span>
<span class="cp">use Tie::AppendHash;</span>
<span class="cp">tie %tab, &#39;Tie::AppendHash&#39;;</span>

<span class="cp">$tab{beer} = &quot;guinness&quot;;</span>
<span class="cp">$tab{food} = &quot;potatoes&quot;;</span>
<span class="cp">$tab{food} = &quot;peas&quot;;</span>

<span class="cp">while (my($k, $v) = each %tab) {</span>
<span class="cp">    print &quot;$k =&gt; [@$v]\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">food =&gt; [potatoes peas]</span>

<span class="cp">beer =&gt; [guinness]</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Tie/AppendHash.pm</span>">download the following standalone program</a></font>
<span class="cp">package Tie::AppendHash;</span>
<span class="cp">use strict;</span>
<span class="cp">use Tie::Hash;</span>
<span class="cp">use Carp;</span>
<span class="cp">use vars qw(@ISA);</span>
<span class="cp">@ISA = qw(Tie::StdHash);</span>
<span class="cp">sub STORE {</span>
<span class="cp">    my ($self, $key, $value) = @_;</span>
<span class="cp">    push @{$self-&gt;{key}}, $value;</span>
<span class="cp">} </span>
<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl </span>
<span class="cp"># folded_demo - demo hash that magically folds case</span>
<span class="cp">use Tie::Folded;</span>
<span class="cp">tie %tab, &#39;Tie::Folded&#39;;</span>

<span class="cp">$tab{VILLAIN}  = &quot;big &quot;; </span>
<span class="cp">$tab{herOine}  = &quot;red riding hood&quot;;</span>
<span class="cp">$tab{villain} .= &quot;bad wolf&quot;;   </span>

<span class="cp">while ( my($k, $v) = each %tab ) {</span>
<span class="cp">    print &quot;$k is $v\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">heroine is red riding hood</span>

<span class="cp">villain is big bad wolf</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Tie/Folded.pm</span>">download the following standalone program</a></font>
<span class="cp">package Tie::Folded;</span>
<span class="cp">use strict;</span>
<span class="cp">use Tie::Hash;</span>
<span class="cp">use vars qw(@ISA);</span>
<span class="cp">@ISA = qw(Tie::StdHash);</span>
<span class="cp">sub STORE {</span>
<span class="cp">    my ($self, $key, $value) = @_;</span>
<span class="cp">    return $self-&gt;{lc $key} = $value;</span>
<span class="cp">    } </span>
<span class="cp">sub FETCH {</span>
<span class="cp">    my ($self, $key) = @_;</span>
<span class="cp">    return $self-&gt;{lc $key};</span>
<span class="cp">} </span>
<span class="cp">sub EXISTS {</span>
<span class="cp">    my ($self, $key) = @_;</span>
<span class="cp">    return exists $self-&gt;{lc $key};</span>
<span class="cp">} </span>
<span class="cp">sub DEFINED {</span>
<span class="cp">    my ($self, $key) = @_;</span>
<span class="cp">    return defined $self-&gt;{lc $key};</span>
<span class="cp">} </span>
<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># revhash_demo - show hash that permits key *or* value lookups</span>
<span class="cp">use strict;</span>
<span class="cp">use Tie::RevHash;</span>
<span class="cp">my %tab;</span>
<span class="cp">tie %tab, &#39;Tie::RevHash&#39;;</span>
<span class="cp">%tab = qw{</span>
<span class="cp">    Red         Rojo</span>
<span class="cp">    Blue        Azul</span>
<span class="cp">    Green       Verde</span>
<span class="cp">};</span>
<span class="cp">$tab{EVIL} = [ &quot;No way!&quot;, &quot;Way!!&quot; ];</span>

<span class="cp">while ( my($k, $v) = each %tab ) {</span>
<span class="cp">    print ref($k) ? &quot;[@$k]&quot; : $k, &quot; =&gt; &quot;,</span>
<span class="cp">        ref($v) ? &quot;[@$v]&quot; : $v, &quot;\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">[No way! Way!!] =&gt; EVIL</span>

<span class="cp">EVIL =&gt; [No way! Way!!]</span>

<span class="cp">Blue =&gt; Azul</span>

<span class="cp">Green =&gt; Verde</span>

<span class="cp">Rojo =&gt; Red</span>

<span class="cp">Red =&gt; Rojo</span>

<span class="cp">Azul =&gt; Blue</span>

<span class="cp">Verde =&gt; Green</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Tie/RevHash.pm</span>">download the following standalone program</a></font>
<span class="cp">package Tie::RevHash;</span>
<span class="cp">use Tie::RefHash;</span>
<span class="cp">use vars qw(@ISA);</span>
<span class="cp">@ISA = qw(Tie::RefHash);</span>
<span class="cp">sub STORE {</span>
<span class="cp">    my ($self, $key, $value) = @_;</span>
<span class="cp">    $self-&gt;SUPER::STORE($key, $value);</span>
<span class="cp">    $self-&gt;SUPER::STORE($value, $key);</span>
<span class="cp">}</span>

<span class="cp">sub DELETE {</span>
<span class="cp">    my ($self, $key) = @_;</span>
<span class="cp">    my $value = $self-&gt;SUPER::FETCH($key);</span>
<span class="cp">    $self-&gt;SUPER::DELETE($key);</span>
<span class="cp">    $self-&gt;SUPER::DELETE($value);</span>
<span class="cp">}</span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">use Counter;</span>
<span class="cp">tie *CH, &#39;Counter&#39;;</span>
<span class="cp">while (&lt;CH&gt;) {</span>
<span class="cp">    print &quot;Got $_\n&quot;;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Counter</span>">download the following standalone program</a></font>
<span class="cp">package Counter;</span>
<span class="cp">sub TIEHANDLE {</span>
<span class="cp">    my $class = shift;</span>
<span class="cp">    my $start = shift;</span>
<span class="cp">    return bless \$start =&gt; $class;</span>
<span class="cp">} </span>
<span class="cp">sub READLINE {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    return ++$$self;</span>
<span class="cp">} </span>
<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">use Tie::Tee;</span>
<span class="cp">tie *TEE, &#39;Tie::Tee&#39;, *STDOUT, *STDERR;</span>
<span class="cp">print TEE &quot;This line goes both places.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># demo_tietee</span>
<span class="cp">use Tie::Tee;</span>
<span class="cp">use Symbol;</span>

<span class="cp">@handles = (*STDOUT);</span>
<span class="cp">for $i ( 1 .. 10 ) {</span>
<span class="cp">    push(@handles, $handle = gensym());</span>
<span class="cp">    open($handle, &quot;&gt;/tmp/teetest.$i&quot;);</span>
<span class="cp">} </span>

<span class="cp">tie *TEE, &#39;Tie::Tee&#39;, @handles;</span>
<span class="cp">print TEE &quot;This lines goes many places.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch13/Tie/Tee.pm</span>">download the following standalone program</a></font>
<span class="cp">package Tie::Tee;</span>

<span class="cp">sub TIEHANDLE {</span>
<span class="cp">    my $class   = shift;</span>
<span class="cp">    my $handles = [@_];</span>

<span class="cp">    bless $handles, $class;</span>
<span class="cp">    return $handles;</span>
<span class="cp">}</span>

<span class="cp">sub PRINT {</span>
<span class="cp">    my $href = shift;</span>
<span class="cp">    my $handle;</span>
<span class="cp">    my $success = 0;</span>

<span class="cp">    foreach $handle (@$href) {</span>
<span class="cp">        $success += print $handle @_;</span>
<span class="cp">    }</span>

<span class="cp">    return $success == @$href;</span>
<span class="cp">}                                     </span>

<span class="cp">1;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">AsciiDB   DBI Db     MLDBM    OLE    Pg        Sybase</span>

<span class="cp">CDB_File  DBZ_ File  Fame     Msql   ObjStore  Postgres  XBase</span>

<span class="cp">DBD       DB_File    Ingperl  MySQL  Oraperl   Sprite</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DB_File;                      # optional; overrides default</span>
<span class="cp">dbmopen %HASH, $FILENAME, 0666    # open database, accessed through %HASH</span>
<span class="cp">    or die &quot;Can&#39;t open $FILENAME: $!\n&quot;;</span>

<span class="cp">$V = $HASH{$KEY};                 # retrieve from database</span>
<span class="cp">$HASH{$KEY} = $VALUE;             # put value into database</span>
<span class="cp">if (exists $HASH{$KEY}) {         # check whether in database</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">delete $HASH{$KEY};               # remove from database</span>
<span class="cp">dbmclose %HASH;                   # close the database</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DB_File;                      # load database module</span>

<span class="cp">tie %HASH, &quot;DB_File&quot;, $FILENAME   # open database, to be accessed</span>
<span class="cp">    or die &quot;Can&#39;t open $FILENAME:$!\n&quot;;    # through %HASH</span>

<span class="cp">$V = $HASH{$KEY};                 # retrieve from database</span>
<span class="cp">$HASH{$KEY} = $VALUE;             # put value into database</span>
<span class="cp">if (exists $HASH{$KEY}) {         # check whether in database</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">delete $HASH{$KEY};               # delete from database</span>
<span class="cp">untie %hash;                      # close the database</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch14/userstats</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># userstats - generates statistics on who is logged in.</span>
<span class="cp"># call with an argument to display totals</span>

<span class="cp">use DB_File;</span>

<span class="cp">$db = &#39;/tmp/userstats.db&#39;;       # where data is kept between runs</span>

<span class="cp">tie(%db, &#39;DB_File&#39;, $db)         or die &quot;Can&#39;t open DB_File $db : $!\n&quot;;</span>

<span class="cp">if (@ARGV) {</span>
<span class="cp">    if (&quot;@ARGV&quot; eq &quot;ALL&quot;) {</span>
<span class="cp">        @ARGV = sort keys %db;</span>
<span class="cp">    }</span>
<span class="cp">    foreach $user (@ARGV) {</span>
<span class="cp">            print &quot;$user\t$db{$user}\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">} else {</span>
<span class="cp">    @who = `who`;                                   # run who(1)</span>
<span class="cp">    if ($?) {</span>
<span class="cp">        die &quot;Couldn&#39;t run who: $?\n&quot;;               # exited abnormally</span>
<span class="cp">    }</span>
<span class="cp">    # extract username (first thing on the line) and update</span>
<span class="cp">    foreach $line (@who) {</span>
<span class="cp">        $line =~ /^(\S+)/;</span>
<span class="cp">        die &quot;Bad line from who: $line\n&quot; unless $1;</span>
<span class="cp">        $db{$1}++;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">untie %db;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">gnat     ttyp1   May 29 15:39   (coprolith.frii.com)</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">dbmopen(%HASH, $FILENAME, 0666)         or die &quot;Can&#39;t open FILENAME: $!\n&quot;;</span>
<span class="cp">%HASH = ();</span>
<span class="cp">dbmclose %HASH;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DB_File;</span>

<span class="cp">tie(%HASH, &quot;DB_File&quot;, $FILENAME)        or die &quot;Can&#39;t open FILENAME: $!\n&quot;;</span>
<span class="cp">%HASH = ();</span>
<span class="cp">untie %hash;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unlink $FILENAME</span>
<span class="cp">    or die &quot;Couldn&#39;t unlink $FILENAME to empty the database: $!\n&quot;;</span>
<span class="cp">dbmopen(%HASH, $FILENAME, 0666)</span>
<span class="cp">    or die &quot;Couldn&#39;t create $FILENAME database: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch14/db2gdbm</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># db2gdbm: converts DB to GDBM</span>

<span class="cp">use strict;</span>

<span class="cp">use DB_File;</span>
<span class="cp">use GDBM_File;</span>

<span class="cp">unless (@ARGV == 2) {</span>
<span class="cp">    die &quot;usage: db2gdbm infile outfile\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">my ($infile, $outfile) = @ARGV;                     </span>
<span class="cp">my (%db_in, %db_out);                               </span>

<span class="cp"># open the files</span>
<span class="cp">tie(%db_in, &#39;DB_File&#39;, $infile)</span>
<span class="cp">    or die &quot;Can&#39;t tie $infile: $!&quot;;</span>
<span class="cp">tie(%db_out, &#39;GDBM_File&#39;, $outfile, GDBM_WRCREAT, 0666)</span>
<span class="cp">    or die &quot;Can&#39;t tie $outfile: $!&quot;;</span>

<span class="cp"># copy (don&#39;t use %db_out = %db_in because it&#39;s slow on big databases)</span>
<span class="cp">while (my($k, $v) = each %db_in) {</span>
<span class="cp">    $db_out{$k} = $v;</span>
<span class="cp">}</span>

<span class="cp"># these unties happen automatically at program exit</span>
<span class="cp">untie %db_in;</span>
<span class="cp">untie %db_out;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% db2gdbm /tmp/users.db /tmp/users.gdbm</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%OUTPUT = (%INPUT1, %INPUT2);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%OUTPUT = ();</span>
<span class="cp">foreach $href ( \%INPUT1, \%INPUT2 ) {</span>
<span class="cp">    while (my($key, $value) = each(%$href)) {</span>
<span class="cp">        if (exists $OUTPUT{$key}) {</span>
<span class="cp">            # decide which value to use and set $OUTPUT{$key} if necessary</span>
<span class="cp">        } else {</span>
<span class="cp">            $OUTPUT{$key} = $value;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch14/dblockdemo</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># dblockdemo - demo locking dbm databases</span>
<span class="cp">use DB_File;</span>
<span class="cp">use strict;</span>

<span class="cp">sub LOCK_SH { 1 }                   # In case you don&#39;t have</span>
<span class="cp">sub LOCK_EX { 2 }                   # the standard Fcntl module.  You</span>
<span class="cp">sub LOCK_NB { 4 }                   # should, but who can tell</span>
<span class="cp">sub LOCK_UN { 8 }                   # how those chips fall?</span>

<span class="cp">my($oldval, $fd, $db, %db, $value, $key);</span>

<span class="cp">$key    = shift || &#39;default&#39;;</span>
<span class="cp">$value  = shift || &#39;magic&#39;;</span>
<span class="cp">$value .= &quot; $$&quot;;</span>

<span class="cp">$db = tie(%db, &#39;DB_File&#39;, &#39;/tmp/foo.db&#39;, O_CREAT|O_RDWR, 0666)</span>
<span class="cp">    or die &quot;dbcreat /tmp/foo.db $!&quot;;</span>
<span class="cp">$fd = $db-&gt;fd;                      # need this for locking</span>
<span class="cp">print &quot;$$: db fd is $fd\n&quot;;</span>
<span class="cp">open(DB_FH, &quot;+&lt;&amp;=$fd&quot;)</span>
<span class="cp">    or die &quot;dup $!&quot;;</span>

<span class="cp">unless (flock (DB_FH, LOCK_SH | LOCK_NB)) {</span>
<span class="cp">    print &quot;$$: CONTENTION; can&#39;t read during write update!</span>
<span class="cp">                Waiting for read lock ($!) ....&quot;;</span>
<span class="cp">    unless (flock (DB_FH, LOCK_SH)) { die &quot;flock: $!&quot; }</span>
<span class="cp">}</span>
<span class="cp">print &quot;$$: Read lock granted\n&quot;;</span>

<span class="cp">$oldval = $db{$key};</span>
<span class="cp">print &quot;$$: Old value was $oldval\n&quot;;</span>
<span class="cp">flock(DB_FH, LOCK_UN);</span>

<span class="cp">unless (flock (DB_FH, LOCK_EX | LOCK_NB)) {</span>
<span class="cp">    print &quot;$$: CONTENTION; must have exclusive lock!</span>
<span class="cp">                Waiting for write lock ($!) ....&quot;;</span>
<span class="cp">    unless (flock (DB_FH, LOCK_EX)) { die &quot;flock: $!&quot; }</span>
<span class="cp">}</span>

<span class="cp">print &quot;$$: Write lock granted\n&quot;;</span>
<span class="cp">$db{$key} = $value;</span>
<span class="cp">$db-&gt;sync;  # to flush</span>
<span class="cp">sleep 10;</span>

<span class="cp">flock(DB_FH, LOCK_UN);</span>
<span class="cp">undef $db;</span>
<span class="cp">untie %db;</span>
<span class="cp">close(DB_FH);</span>
<span class="cp">print &quot;$$: Updated db to $key=$value\n&quot;;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DB_File;</span>

<span class="cp"># specify the Perl sub to do key comparison using the</span>
<span class="cp"># exported $DB_BTREE hash reference</span>
<span class="cp">$DB_BTREE-&gt;{&#39;compare&#39;} = sub {</span>
<span class="cp">    my ($key1, $key2) = @_ ;</span>
<span class="cp">    return &quot;\L$key1&quot; cmp &quot;\L$key2&quot;;</span>
<span class="cp">};</span>

<span class="cp">tie(%hash, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE)</span>
<span class="cp">    or die &quot;can&#39;t tie $filename: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch14/sortdemo</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># sortdemo - show auto dbm sorting</span>
<span class="cp">use strict;</span>
<span class="cp">use DB_File;</span>

<span class="cp">$DB_BTREE-&gt;{&#39;compare&#39;} = sub {</span>
<span class="cp">    my ($key1, $key2) = @_ ;</span>
<span class="cp">    &quot;\L$key1&quot; cmp &quot;\L$key2&quot; ;</span>
<span class="cp">};</span>

<span class="cp">my %hash;</span>
<span class="cp">my $filename = &#39;/tmp/sorthash.db&#39;;</span>
<span class="cp">tie(%hash, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE)</span>
<span class="cp">    or die &quot;can&#39;t tie $filename: $!&quot;;</span>

<span class="cp">my $i = 0;</span>
<span class="cp">for my $word (qw(Can&#39;t you go camp down by Gibraltar)) {</span>
<span class="cp">    $hash{$word} = ++$i;</span>
<span class="cp">}</span>

<span class="cp">while (my($word, $number) = each %hash) {</span>
<span class="cp">    printf &quot;%-12s %d\n&quot;, $word, $number;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#by           6</span>
<span class="cp">#</span>
<span class="cp">#camp         4</span>
<span class="cp">#</span>
<span class="cp">#Can&#39;t        1</span>
<span class="cp">#</span>
<span class="cp">#down         5</span>
<span class="cp">#</span>
<span class="cp">#Gibraltar    7</span>
<span class="cp">#</span>
<span class="cp">#go           3</span>
<span class="cp">#</span>
<span class="cp">#you          2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">tie(%hash, &quot;DB_File&quot;, undef, O_RDWR|O_CREAT, 0666, $DB_BTREE)</span>
<span class="cp">        or die &quot;can&#39;t tie: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DB_File;</span>

<span class="cp">tie(@array, &quot;DB_File&quot;, &quot;/tmp/textfile&quot;, O_RDWR|O_CREAT, 0666, $DB_RECNO)</span>
<span class="cp">    or die &quot;Cannot open file &#39;text&#39;: $!\n&quot; ;</span>

<span class="cp">$array[4] = &quot;a new line&quot;;</span>
<span class="cp">untie @array;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch14/recno_demo</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># recno_demo - show how to use the raw API on recno bindings</span>
<span class="cp">use strict;</span>
<span class="cp">use vars qw(@lines $dbobj $file $i);</span>
<span class="cp">use DB_File;</span>

<span class="cp">$file = &quot;/tmp/textfile&quot;;</span>
<span class="cp">unlink $file;               # just in case</span>

<span class="cp">$dbobj = tie(@lines, &quot;DB_File&quot;, $file, O_RDWR|O_CREAT, 0666, $DB_RECNO)</span>
<span class="cp">    or die &quot;Cannot open file $file: $!\n&quot;;</span>

<span class="cp"># first create a text file to play with</span>
<span class="cp">$lines[0] = &quot;zero&quot;;</span>
<span class="cp">$lines[1] = &quot;one&quot;;</span>
<span class="cp">$lines[2] = &quot;two&quot;;</span>
<span class="cp">$lines[3] = &quot;three&quot;;</span>
<span class="cp">$lines[4] = &quot;four&quot;;</span>

<span class="cp"># Print the records in order.</span>
<span class="cp">#</span>
<span class="cp"># The length method is needed here because evaluating a tied</span>
<span class="cp"># array in a scalar context does not return the number of</span>
<span class="cp"># elements in the array.</span>

<span class="cp">print &quot;\nORIGINAL\n&quot;;</span>
<span class="cp">foreach $i (0 .. $dbobj-&gt;length - 1) {</span>
<span class="cp">    print &quot;$i: $lines[$i]\n&quot;;</span>
<span class="cp">}</span>

<span class="cp"># use the push &amp; pop methods</span>
<span class="cp">$a = $dbobj-&gt;pop;</span>
<span class="cp">$dbobj-&gt;push(&quot;last&quot;);</span>
<span class="cp">print &quot;\nThe last record was [$a]\n&quot;;</span>

<span class="cp"># and the shift &amp; unshift methods</span>
<span class="cp">$a = $dbobj-&gt;shift;</span>
<span class="cp">$dbobj-&gt;unshift(&quot;first&quot;);</span>
<span class="cp">print &quot;The first record was [$a]\n&quot;;</span>

<span class="cp"># Use the API to add a new record after record 2.</span>
<span class="cp">$i = 2;</span>
<span class="cp">$dbobj-&gt;put($i, &quot;Newbie&quot;, R_IAFTER);</span>
<span class="cp">    </span>
<span class="cp"># and a new record before record 1.</span>
<span class="cp">$i = 1;</span>
<span class="cp">$dbobj-&gt;put($i, &quot;New One&quot;, R_IBEFORE);</span>

<span class="cp"># delete record 3</span>
<span class="cp">$dbobj-&gt;del(3);</span>

<span class="cp"># now print the records in reverse order</span>
<span class="cp">print &quot;\nREVERSE\n&quot;;</span>
<span class="cp">for ($i = $dbobj-&gt;length - 1; $i &gt;= 0; -- $i) {</span>
<span class="cp">    print &quot;$i: $lines[$i]\n&quot;;</span>
<span class="cp">}</span>

<span class="cp"># same again, but use the API functions instead</span>
<span class="cp">print &quot;\nREVERSE again\n&quot;;</span>
<span class="cp">my ($s, $k, $v)  = (0, 0, 0);</span>
<span class="cp">for ($s = $dbobj-&gt;seq($k, $v, R_LAST);</span>
<span class="cp">     $s == 0;</span>
<span class="cp">     $s = $dbobj-&gt;seq($k, $v, R_PREV))</span>
<span class="cp">{</span>
<span class="cp">    print &quot;$k: $v\n&quot;</span>
<span class="cp">}</span>

<span class="cp">undef $dbobj;</span>
<span class="cp">untie @lines;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#ORIGINAL</span>
<span class="cp">#</span>
<span class="cp">#0: zero</span>
<span class="cp">#</span>
<span class="cp">#1: one</span>
<span class="cp">#</span>
<span class="cp">#2: two</span>
<span class="cp">#</span>
<span class="cp">#3: three</span>
<span class="cp">#</span>
<span class="cp">#4: four</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#The last record was [four]</span>
<span class="cp">#</span>
<span class="cp">#The first record was [zero]</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#REVERSE</span>
<span class="cp">#</span>
<span class="cp">#5: last</span>
<span class="cp">#</span>
<span class="cp">#4: three</span>
<span class="cp">#</span>
<span class="cp">#3: Newbie</span>
<span class="cp">#</span>
<span class="cp">#2: one</span>
<span class="cp">#</span>
<span class="cp">#1: New One</span>
<span class="cp">#</span>
<span class="cp">#0: first</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#REVERSE again</span>
<span class="cp">#</span>
<span class="cp">#5: last</span>
<span class="cp">#</span>
<span class="cp">#4: three</span>
<span class="cp">#</span>
<span class="cp">#3: Newbie</span>
<span class="cp">#</span>
<span class="cp">#2: one</span>
<span class="cp">#</span>
<span class="cp">#1: New One</span>
<span class="cp">#</span>
<span class="cp">#0: first</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    foreach $item (@lines) { }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    foreach $i (0 .. $dbobj-&gt;length - 1) { }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    for ($done_yet = $dbobj-&gt;get($k, $v, R_FIRST);</span>
<span class="cp">         not $done_yet;</span>
<span class="cp">         $done_yet = $dbobj-&gt;get($k, $v, R_NEXT) )</span>
<span class="cp">    {</span>
<span class="cp">        # process key or value</span>
<span class="cp">    }</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use MLDBM &#39;DB_File&#39;;</span>
<span class="cp">tie(%HASH, &#39;MLDBM&#39;, [... other DBM arguments]) or die $!;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># %hash is a tied hash</span>
<span class="cp">$hash{&quot;Tom Christiansen&quot;} = [ &quot;book author&quot;, &#39;tchrist@perl.com&#39; ];          </span>
<span class="cp">$hash{&quot;Tom Boutell&quot;} = [ &quot;shareware author&quot;, &#39;boutell@boutell.com&#39; ];</span>

<span class="cp"># names to compare</span>
<span class="cp">$name1 = &quot;Tom Christiansen&quot;;</span>
<span class="cp">$name2 = &quot;Tom Boutell&quot;;</span>

<span class="cp">$tom1 = $hash{$name1};      # snag local pointer</span>
<span class="cp">$tom2 = $hash{$name2};      # and another           </span>

<span class="cp">print &quot;Two Toming: $tom1 $tom2\n&quot;;</span>

<span class="cp">Tom Toming: ARRAY(0x73048) ARRAY(0x73e4c)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($tom1-&gt;[0] eq $tom2-&gt;[0] &amp;&amp;</span>
<span class="cp">    $tom1-&gt;[1] eq $tom2-&gt;[1]) {</span>
<span class="cp">    print &quot;You&#39;re having runtime fun with one Tom made two.\n&quot;;</span>
<span class="cp">} else {</span>
<span class="cp">    print &quot;No two Toms are ever alike.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($hash{$name1}-&gt;[0] eq $hash{$name2}-&gt;[0] &amp;&amp;     # INEFFICIENT</span>
<span class="cp">    $hash{$name1}-&gt;[1] eq $hash{$name2}-&gt;[1]) {</span>
<span class="cp">    print &quot;You&#39;re having runtime fun with one Tom made two.\n&quot;;</span>
<span class="cp">} else {</span>
<span class="cp">    print &quot;No two Toms are ever alike.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$hash{&quot;Tom Boutell&quot;}-&gt;[0] = &quot;Poet Programmer&quot;;      # WRONG</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$entry = $hash{&quot;Tom Boutell&quot;};                      # RIGHT</span>
<span class="cp">$entry-&gt;[0] = &quot;Poet Programmer&quot;;</span>
<span class="cp">$hash{&quot;Tom Boutell&quot;} = $entry;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use MLDBM &#39;DB_File&#39;;</span>

<span class="cp">my ($VARIABLE1,$VARIABLE2);</span>
<span class="cp">my $Persistent_Store = &#39;/projects/foo/data&#39;;</span>
<span class="cp">BEGIN {</span>
<span class="cp">    my %data;</span>
<span class="cp">    tie(%data, &#39;MLDBM&#39;, $Persistent_Store)</span>
<span class="cp">        or die &quot;Can&#39;t tie to $Persistent_Store : $!&quot;;</span>
<span class="cp">    $VARIABLE1 = $data{VARIABLE1};</span>
<span class="cp">    $VARIABLE2 = $data{VARIABLE2};</span>
<span class="cp">    # ...</span>
<span class="cp">    untie %data;</span>
<span class="cp">}</span>
<span class="cp">END {</span>
<span class="cp">    my %data;</span>
<span class="cp">    tie (%data, &#39;MLDBM&#39;, $Persistent_Store)</span>
<span class="cp">        or die &quot;Can&#39;t tie to $Persistent_Store : $!&quot;;</span>
<span class="cp">    $data{VARIABLE1} = $VARIABLE1;</span>
<span class="cp">    $data{VARIABLE2} = $VARIABLE2;</span>
<span class="cp">    # ...</span>
<span class="cp">    untie %data;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">push(@{$db{$user}}, $duration);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch14/mldbm_demo</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># mldbm_demo - show how to use MLDBM with DB_File</span>

<span class="cp">use MLDBM &quot;DB_File&quot;;</span>

<span class="cp">$db = &quot;/tmp/mldbm-array&quot;;</span>

<span class="cp">tie %db, &#39;MLDBM&#39;, $db</span>
<span class="cp">  or die &quot;Can&#39;t open $db : $!&quot;;</span>

<span class="cp">while(&lt;DATA&gt;) {</span>
<span class="cp">    chomp;</span>
<span class="cp">    ($user, $duration) = split(/\s+/, $_);</span>
<span class="cp">    $array_ref = exists $db{$user} ? $db{$user} : [];</span>
<span class="cp">    push(@$array_ref, $duration);</span>
<span class="cp">    $db{$user} = $array_ref;</span>
<span class="cp">}</span>

<span class="cp">foreach $user (sort keys %db) {</span>
<span class="cp">    print &quot;$user: &quot;;</span>
<span class="cp">    $total = 0;</span>
<span class="cp">    foreach $duration (@{ $db{$user} }) {</span>
<span class="cp">        print &quot;$duration &quot;;</span>
<span class="cp">        $total += $duration;</span>
<span class="cp">    }</span>
<span class="cp">        print &quot;($total)\n&quot;;</span>
<span class="cp">    }</span>

<span class="cp">__END__</span>

<span class="cp">#gnat        15.3</span>
<span class="cp">#tchrist     2.5</span>
<span class="cp">#jules       22.1</span>
<span class="cp">#tchrist     15.9</span>
<span class="cp">#gnat        8.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use MLDBM qw(DB_File Storable);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use DBI;</span>


<span class="cp">$dbh = DBI-&gt;connect(&#39;DBI:driver:database&#39;, &#39;username&#39;, &#39;auth&#39;,</span>

<span class="cp">            { RaiseError =&gt; 1, AutoCommit =&gt; 1});</span>

<span class="cp">$dbh-&gt;do($sql);</span>

<span class="cp">$sth = $dbh-&gt;prepare($sql);</span>

<span class="cp">$sth-&gt;execute();</span>

<span class="cp">while (@row = $sth-&gt;fetchrow_array) {</span>

<span class="cp">    # ...</span>

<span class="cp">}</span>

<span class="cp">$sth-&gt;finish();</span>

<span class="cp">$dbh-&gt;disconnect();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#disconnect(DBI::db=HASH(0x9df84)) invalidates 1 active cursor(s) </span>
<span class="cp">#    at -e line 1.</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch14/dbusers</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># dbusers - manage MySQL user table</span>
<span class="cp">use DBI;</span>
<span class="cp">use User::pwent;</span>

<span class="cp">$dbh = DBI-&gt;connect(&#39;DBI:mysql:dbname:mysqlserver.domain.com:3306&#39;,</span>
<span class="cp">                    &#39;user&#39;, &#39;password&#39;,</span>
<span class="cp">                    { RaiseError =&gt; 1 })</span>
<span class="cp">  or die &quot;connecting : $DBI::errstr\n&quot;;</span>

<span class="cp">$dbh-&gt;do(&quot;CREATE TABLE users (uid INT, login CHAR(8))&quot;);</span>

<span class="cp">$sql_fmt = &quot;INSERT INTO users VALUES( %d, %s )&quot;;</span>
<span class="cp">while ($user = getpwent) {</span>
<span class="cp">    $sql = sprintf($sql_fmt, $user-&gt;uid, $dbh-&gt;quote($user-&gt;name));</span>
<span class="cp">    $dbh-&gt;do($sql);</span>
<span class="cp">}</span>

<span class="cp">$sth = $dbh-&gt;prepare(&quot;SELECT * FROM users WHERE uid &lt; 50&quot;);</span>
<span class="cp">$sth-&gt;execute;</span>

<span class="cp">while ((@row) = $sth-&gt;fetchrow) {</span>
<span class="cp">    print join(&quot;, &quot;, map {defined $_ ? $_ : &quot;(null)&quot;} @row), &quot;\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">$sth-&gt;finish;</span>

<span class="cp">$dbh-&gt;do(&quot;DROP TABLE users&quot;);</span>

<span class="cp">$dbh-&gt;disconnect;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_14.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ggh http://www.perl.com/index.html</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ggh perl</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ggh mailto:</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ggh -regexp &#39;(?i)\bfaq\b&#39;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ggh -epoch http://www.perl.com/perl/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ggh -gmtime http://www.perl.com/perl/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ggh | less</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ggh -epoch | sort -rn | less</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% ggh -epoch | sort -rn | perl -pe &#39;s/\d+/localtime $&amp;/e&#39; | less</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch14/ggh</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># ggh - grovel global history in netscape logs</span>
<span class="cp">$USAGE = &lt;&lt;EO_COMPLAINT;</span>
<span class="cp">usage: $0 [-database dbfilename] [-help]</span>
<span class="cp">           [-epochtime | -localtime | -gmtime]</span>
<span class="cp">           [ [-regexp] pattern] | href ... ]</span>
<span class="cp">EO_COMPLAINT</span>

<span class="cp">use Getopt::Long;</span>

<span class="cp">($opt_database, $opt_epochtime, $opt_localtime,</span>
<span class="cp"> $opt_gmtime,   $opt_regexp,    $opt_help,</span>
<span class="cp"> $pattern,                                  )      = (0) x 7;</span>

<span class="cp">usage() unless GetOptions qw{ database=s</span>
<span class="cp">                              regexp=s</span>
<span class="cp">                              epochtime localtime gmtime</span>
<span class="cp">                              help</span>
<span class="cp">                            };</span>

<span class="cp">if ($opt_help) { print $USAGE; exit; }</span>

<span class="cp">usage(&quot;only one of localtime, gmtime, and epochtime allowed&quot;)</span>
<span class="cp">    if $opt_localtime + $opt_gmtime + $opt_epochtime &gt; 1;</span>

<span class="cp">if ( $opt_regexp ) {</span>
<span class="cp">    $pattern = $opt_regexp;</span>
<span class="cp">} elsif (@ARGV &amp;&amp; $ARGV[0] !~ m(://)) {</span>
<span class="cp">    $pattern = shift;</span>
<span class="cp">}</span>

<span class="cp">usage(&quot;can&#39;t mix URLs and explicit patterns&quot;)</span>
<span class="cp">    if $pattern &amp;&amp; @ARGV;</span>

<span class="cp">if ($pattern &amp;&amp; !eval { &#39;&#39; =~ /$pattern/; 1 } ) {</span>
<span class="cp">    $@ =~ s/ at \w+ line \d+\.//;</span>
<span class="cp">    die &quot;$0: bad pattern $@&quot;;</span>
<span class="cp">}</span>

<span class="cp">require DB_File; DB_File-&gt;import();  # delay loading until runtime</span>
<span class="cp">$| = 1;                              # feed the hungry PAGERs</span>

<span class="cp">$dotdir  = $ENV{HOME}    || $ENV{LOGNAME};</span>
<span class="cp">$HISTORY = $opt_database || &quot;$dotdir/.netscape/history.db&quot;;</span>

<span class="cp">die &quot;no netscape history dbase in $HISTORY: $!&quot; unless -e $HISTORY;</span>
<span class="cp">die &quot;can&#39;t dbmopen $HISTORY: $!&quot; unless dbmopen %hist_db, $HISTORY, 0666;</span>

<span class="cp"># the next line is a hack because the C programmers who did this</span>
<span class="cp"># didn&#39;t understand strlen vs strlen+1.  jwz told me so. :-)</span>
<span class="cp">$add_nulls   = (ord(substr(each %hist_db, -1)) == 0);</span>

<span class="cp"># XXX: should now do scalar keys to reset but don&#39;t </span>
<span class="cp">#      want cost of full traverse, required on tied hashes.</span>
<span class="cp">#   better to close and reopen?</span>

<span class="cp">$nulled_href = &quot;&quot;;  </span>
<span class="cp">$byte_order  = &quot;V&quot;;         # PC people don&#39;t grok &quot;N&quot; (network order)</span>
<span class="cp">    </span>
<span class="cp">if (@ARGV) {</span>
<span class="cp">    foreach $href (@ARGV) {</span>
<span class="cp">        $nulled_href = $href . ($add_nulls &amp;&amp; &quot;\0&quot;);</span>
<span class="cp">        unless ($binary_time = $hist_db{$nulled_href}) {</span>
<span class="cp">            warn &quot;$0: No history entry for HREF $href\n&quot;;</span>
<span class="cp">            next;</span>
<span class="cp">        }</span>
<span class="cp">        $epoch_secs = unpack($byte_order, $binary_time);</span>
<span class="cp">        $stardate   = $opt_epochtime ? $epoch_secs</span>
<span class="cp">                                     : $opt_gmtime ? gmtime    $epoch_secs</span>
<span class="cp">                                                   : localtime $epoch_secs;</span>
<span class="cp">        print &quot;$stardate $href\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">} else {</span>
<span class="cp">    while ( ($href, $binary_time) = each %hist_db ) {</span>
<span class="cp">        chop $href if $add_nulls;</span>
<span class="cp">        # gnat reports some binary times are missing</span>
<span class="cp">        $binary_time = pack($byte_order, 0) unless $binary_time;</span>
<span class="cp">        $epoch_secs = unpack($byte_order, $binary_time);</span>
<span class="cp">        $stardate   = $opt_epochtime ? $epoch_secs</span>
<span class="cp">                                     : $opt_gmtime ? gmtime    $epoch_secs</span>
<span class="cp">                                                   : localtime $epoch_secs;</span>
<span class="cp">        print &quot;$stardate $href\n&quot; unless $pattern &amp;&amp; $href !~ /$pattern/o;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">sub usage {</span>
<span class="cp">    print STDERR &quot;@_\n&quot; if @_;</span>
<span class="cp">    die $USAGE;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Getopt::Std;</span>

<span class="cp"># -v ARG, -D ARG, -o ARG, sets $opt_v, $opt_D, $opt_o</span>
<span class="cp">getopt(&quot;vDo&quot;);              </span>
<span class="cp"># -v ARG, -D ARG, -o ARG, sets $args{v}, $args{D}, $args{o}</span>
<span class="cp">getopt(&quot;vDo&quot;, \%args);</span>

<span class="cp">getopts(&quot;vDo:&quot;);         # -v, -D, -o ARG, sets $opt_v, $opt_D, $opt_o</span>
<span class="cp">getopts(&quot;vDo:&quot;, \%args); # -v, -D, -o ARG, sets $args{v}, $args{D}, $args{o}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Getopt::Long;</span>

<span class="cp">GetOptions( &quot;verbose&quot;  =&gt; \$verbose,     # --verbose</span>
<span class="cp">            &quot;Debug&quot;    =&gt; \$debug,       # --Debug</span>
<span class="cp">            &quot;output=s&quot; =&gt; \$output );    # --output=string or --output=string</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% rm -r -f /tmp/testdir</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% rm -rf /tmp/testdir</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Getopt::Std;</span>
<span class="cp">getopts(&quot;o:&quot;);</span>
<span class="cp">if ($opt_o) {</span>
<span class="cp">    print &quot;Writing output to $opt_o&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Getopt::Std;</span>

<span class="cp">%option = ();</span>
<span class="cp">getopts(&quot;Do:&quot;, \%option);</span>

<span class="cp">if ($option{D}) {</span>
<span class="cp">    print &quot;Debugging mode enabled.\n&quot;;</span>
<span class="cp">}</span>

<span class="cp"> # if not set, set output to &quot;-&quot;.  opening &quot;-&quot; for writing</span>
<span class="cp"> # means STDOUT</span>
<span class="cp"> $option{o} = &quot;-&quot; unless defined $option{o};</span>
<span class="cp">                             </span>
<span class="cp">print &quot;Writing output to file $option{o}\n&quot; unless $option{o} eq &quot;-&quot;;</span>
<span class="cp">open(STDOUT, &quot;&gt; $option{o}&quot;)</span>
<span class="cp">     or die &quot;Can&#39;t open $option{o} for output: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% gnutar --extract --file latest.tar</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% gnutar --extract --file=latest.tar</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Getopt::Long;</span>

<span class="cp">GetOptions( &quot;extract&quot; =&gt; \$extract,</span>
<span class="cp">            &quot;file=s&quot;  =&gt; \$file );</span>

<span class="cp">if ($extract) {</span>
<span class="cp">    print &quot;I&#39;m extracting.\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">die &quot;I wish I had a file&quot; unless defined $file;</span>
<span class="cp">print &quot;Working on the file $file\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub I_am_interactive {</span>
<span class="cp">    return -t STDIN &amp;&amp; -t STDOUT;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw/getpgrp tcgetpgrp/;</span>

<span class="cp">sub I_am_interactive {</span>
<span class="cp">    local *TTY;  # local file handle</span>
<span class="cp">    open(TTY, &quot;/dev/tty&quot;) or die &quot;can&#39;t open /dev/tty: $!&quot;;</span>
<span class="cp">    my $tpgrp = tcgetpgrp(fileno(TTY));</span>
<span class="cp">    my $pgrp  = getpgrp();</span>
<span class="cp">    close TTY;</span>
<span class="cp">    return ($tpgrp == $pgrp);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (1) {</span>
<span class="cp">    if (I_am_interactive()) {</span>
<span class="cp">        print &quot;Prompt: &quot;;</span>
<span class="cp">    }</span>
<span class="cp">    $line = &lt;STDIN&gt;;</span>
<span class="cp">    last unless defined $line; </span>
<span class="cp">    # do something with the line</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub prompt { print &quot;Prompt: &quot; if I_am_interactive() }</span>
<span class="cp">for (prompt(); $line = &lt;STDIN&gt;; prompt()) {</span>
<span class="cp">    # do something with the line</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::Cap;</span>

<span class="cp">$OSPEED = 9600;</span>
<span class="cp">eval {</span>
<span class="cp">    require POSIX;</span>
<span class="cp">    my $termios = POSIX::Termios-&gt;new();</span>
<span class="cp">    $termios-&gt;getattr;</span>
<span class="cp">    $OSPEED = $termios-&gt;getospeed;</span>
<span class="cp">};</span>

<span class="cp">$terminal = Term::Cap-&gt;Tgetent({OSPEED=&gt;$OSPEED});</span>
<span class="cp">$terminal-&gt;Tputs(&#39;cl&#39;, 1, STDOUT);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">system(&quot;clear&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$clear = $terminal-&gt;Tputs(&#39;cl&#39;);</span>
<span class="cp">$clear = `clear`;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print $clear;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::ReadKey;</span>

<span class="cp">($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::ReadKey;</span>

<span class="cp">($width) = GetTerminalSize();</span>
<span class="cp">die &quot;You must have at least 10 characters&quot; unless $width &gt;= 10;</span>

<span class="cp">$max = 0;</span>
<span class="cp">foreach (@values) {</span>
<span class="cp">    $max = $_ if $max &lt; $_;</span>
<span class="cp">}</span>

<span class="cp">$ratio = ($width-10)/$max;          # chars per unit</span>
<span class="cp">foreach (@values) {</span>
<span class="cp">    printf(&quot;%8.1f %s\n&quot;, $_, &quot;*&quot; x ($ratio*$_));</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::ANSIColor;</span>

<span class="cp">print color(&quot;red&quot;), &quot;Danger, Will Robinson!\n&quot;, color(&quot;reset&quot;);</span>
<span class="cp">print &quot;This is just normal text.\n&quot;;</span>
<span class="cp">print colored(&quot;&lt;BLINK&gt;Do you hurt yet?&lt;/BLINK&gt;&quot;, &quot;blink&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::ANSIColor qw(:constants);</span>

<span class="cp">print RED, &quot;Danger, Will Robinson!\n&quot;, RESET;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># rhyme for the deadly coral snake</span>
<span class="cp">print color(&quot;red on_black&quot;),  &quot;venom lack\n&quot;;</span>
<span class="cp">print color(&quot;red on_yellow&quot;), &quot;kill that fellow\n&quot;;</span>

<span class="cp">print color(&quot;green on_cyan blink&quot;), &quot;garish!\n&quot;;</span>
<span class="cp">print color(&quot;reset&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print colored(&quot;venom lack\n&quot;, &quot;red&quot;, &quot;on_black&quot;);</span>
<span class="cp">print colored(&quot;kill that fellow\n&quot;, &quot;red&quot;, &quot;on_yellow&quot;);</span>

<span class="cp">print colored(&quot;garish!\n&quot;, &quot;green&quot;, &quot;on_cyan&quot;, &quot;blink&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::ANSIColor qw(:constants);</span>

<span class="cp">print BLACK, ON_WHITE, &quot;black on white\n&quot;;</span>
<span class="cp">print WHITE, ON_BLACK, &quot;white on black\n&quot;;</span>
<span class="cp">print GREEN, ON_CYAN, BLINK, &quot;garish!\n&quot;;</span>
<span class="cp">print RESET;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">END { print color(&quot;reset&quot;) }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$Term::ANSIColor::EACHLINE = $/;</span>
<span class="cp">print colored(&lt;&lt;EOF, RED, ON_WHITE, BOLD, BLINK);</span>
<span class="cp">This way</span>
<span class="cp">each line</span>
<span class="cp">has its own</span>
<span class="cp">attribute set.</span>
<span class="cp">EOF</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::ReadKey;</span>

<span class="cp">ReadMode(&#39;cbreak&#39;);</span>
<span class="cp">$key = ReadKey(0);</span>
<span class="cp">ReadMode(&#39;normal&#39;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/sascii</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># sascii - Show ASCII values for keypresses</span>

<span class="cp">use Term::ReadKey;</span>
<span class="cp">ReadMode(&#39;cbreak&#39;);</span>
<span class="cp">print &quot;Press keys to see their ASCII values.  Use Ctrl-C to quit.\n&quot;;</span>

<span class="cp">while (1) {</span>
<span class="cp">    $char = ReadKey(0);</span>
<span class="cp">    last unless defined $char;</span>
<span class="cp">    printf(&quot; Decimal: %d\tHex: %x\n&quot;, ord($char), ord($char));</span>
<span class="cp">}</span>

<span class="cp">ReadMode(&#39;normal&#39;);</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;\aWake up!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::Cap;</span>

<span class="cp">$OSPEED = 9600;</span>
<span class="cp">eval {</span>
<span class="cp">    require POSIX;</span>
<span class="cp">    my $termios = POSIX::Termios-&gt;new();</span>
<span class="cp">    $termios-&gt;getattr;</span>
<span class="cp">    $OSPEED = $termios-&gt;getospeed;</span>
<span class="cp">};</span>

<span class="cp">$terminal = Term::Cap-&gt;Tgetent({OSPEED=&gt;$OSPEED});</span>
<span class="cp">$vb = &quot;&quot;;</span>
<span class="cp">eval {</span>
<span class="cp">    $terminal-&gt;Trequire(&quot;vb&quot;);</span>
<span class="cp">    $vb = $terminal-&gt;Tputs(&#39;vb&#39;, 1);</span>
<span class="cp">};</span>

<span class="cp">print $vb;                                  # ring visual bell</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/demo</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># demo POSIX termios</span>

<span class="cp">use POSIX qw(:termios_h);</span>

<span class="cp">$term = POSIX::Termios-&gt;new;</span>
<span class="cp">$term-&gt;getattr(fileno(STDIN));</span>

<span class="cp">$erase = $term-&gt;getcc(VERASE);</span>
<span class="cp">$kill = $term-&gt;getcc(VKILL);</span>
<span class="cp">printf &quot;Erase is character %d, %s\n&quot;, $erase, uncontrol(chr($erase));</span>
<span class="cp">printf &quot;Kill is character %d, %s\n&quot;, $kill, uncontrol(chr($kill));</span>

<span class="cp">$term-&gt;setcc(VERASE, ord(&#39;#&#39;));</span>
<span class="cp">$term-&gt;setcc(VKILL, ord(&#39;@&#39;));</span>
<span class="cp">$term-&gt;setattr(1, TCSANOW);</span>

<span class="cp">print(&quot;erase is #, kill is @; type something: &quot;);</span>
<span class="cp">$line = &lt;STDIN&gt;;</span>
<span class="cp">print &quot;You typed: $line&quot;;</span>

<span class="cp">$term-&gt;setcc(VERASE, $erase);</span>
<span class="cp">$term-&gt;setcc(VKILL, $kill);</span>
<span class="cp">$term-&gt;setattr(1, TCSANOW);</span>

<span class="cp">sub uncontrol {</span>
<span class="cp">    local $_ = shift;</span>
<span class="cp">    s/([\200-\377])/sprintf(&quot;M-%c&quot;,ord($1) &amp; 0177)/eg;</span>
<span class="cp">    s/([\0-\37\177])/sprintf(&quot;^%c&quot;,ord($1) ^ 0100)/eg;</span>
<span class="cp">    return $_;</span>
<span class="cp">} </span>

<span class="cp">#-----------------------------</span>
<span class="cp"># HotKey.pm</span>
<span class="cp">package HotKey;</span>

<span class="cp">@ISA = qw(Exporter);</span>
<span class="cp">@EXPORT = qw(cbreak cooked readkey);</span>

<span class="cp">use strict;</span>
<span class="cp">use POSIX qw(:termios_h);</span>
<span class="cp">my ($term, $oterm, $echo, $noecho, $fd_stdin);</span>

<span class="cp">$fd_stdin = fileno(STDIN);</span>
<span class="cp">$term     = POSIX::Termios-&gt;new();</span>
<span class="cp">$term-&gt;getattr($fd_stdin);</span>
<span class="cp">$oterm     = $term-&gt;getlflag();</span>

<span class="cp">$echo     = ECHO | ECHOK | ICANON;</span>
<span class="cp">$noecho   = $oterm &amp; ~$echo;</span>

<span class="cp">sub cbreak {</span>
<span class="cp">    $term-&gt;setlflag($noecho);  # ok, so i don&#39;t want echo either</span>
<span class="cp">    $term-&gt;setcc(VTIME, 1);</span>
<span class="cp">    $term-&gt;setattr($fd_stdin, TCSANOW);</span>
<span class="cp">}</span>

<span class="cp">sub cooked {</span>
<span class="cp">    $term-&gt;setlflag($oterm);</span>
<span class="cp">    $term-&gt;setcc(VTIME, 0);</span>
<span class="cp">    $term-&gt;setattr($fd_stdin, TCSANOW);</span>
<span class="cp">}</span>

<span class="cp">sub readkey {</span>
<span class="cp">    my $key = &#39;&#39;;</span>
<span class="cp">    cbreak();</span>
<span class="cp">    sysread(STDIN, $key, 1);</span>
<span class="cp">    cooked();</span>
<span class="cp">    return $key;</span>
<span class="cp">}</span>

<span class="cp">END { cooked() }</span>

<span class="cp">1;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::ReadKey;</span>

<span class="cp">ReadMode (&#39;cbreak&#39;);</span>

<span class="cp">if (defined ($char = ReadKey(-1)) ) {</span>
<span class="cp">    # input was waiting and it was $char</span>
<span class="cp">} else {</span>
<span class="cp">    # no input was waiting</span>
<span class="cp">}</span>

<span class="cp">ReadMode (&#39;normal&#39;);                  # restore normal tty settings</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::ReadKey;</span>

<span class="cp">ReadMode(&#39;noecho&#39;);</span>
<span class="cp">$password = ReadLine(0);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/checkuser</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># checkuser - demonstrates reading and checking a user&#39;s password</span>

<span class="cp">use Term::ReadKey;</span>

<span class="cp">print &quot;Enter your password: &quot;;</span>
<span class="cp">ReadMode &#39;noecho&#39;;</span>
<span class="cp">$password = ReadLine 0;</span>
<span class="cp">chomp $password;</span>
<span class="cp">ReadMode &#39;normal&#39;;</span>

<span class="cp">print &quot;\n&quot;;</span>

<span class="cp">($username, $encrypted) = ( getpwuid $&lt; )[0,1];</span>

<span class="cp">if (crypt($password, $encrypted) ne $encrypted) {</span>
<span class="cp">    die &quot;You are not $username\n&quot;;</span>
<span class="cp">} else {</span>
<span class="cp">    print &quot;Welcome, $username\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Term::ReadLine;</span>

<span class="cp">$term = Term::ReadLine-&gt;new(&quot;APP DESCRIPTION&quot;);</span>
<span class="cp">$OUT = $term-&gt;OUT || *STDOUT;</span>

<span class="cp">$term-&gt;addhistory($fake_line);</span>
<span class="cp">$line = $term-&gt;readline(PROMPT);</span>

<span class="cp">print $OUT &quot;Any program output\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/vbsh</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># vbsh -  very bad shell</span>
<span class="cp">use strict;</span>

<span class="cp">use Term::ReadLine;</span>
<span class="cp">use POSIX qw(:sys_wait_h);</span>

<span class="cp">my $term = Term::ReadLine-&gt;new(&quot;Simple Shell&quot;);</span>
<span class="cp">my $OUT = $term-&gt;OUT() || *STDOUT;</span>
<span class="cp">my $cmd;</span>

<span class="cp">while (defined ($cmd = $term-&gt;readline(&#39;$ &#39;) )) {</span>
<span class="cp">    my @output = `$cmd`;</span>
<span class="cp">    my $exit_value  = $? &gt;&gt; 8;</span>
<span class="cp">    my $signal_num  = $? &amp; 127;</span>
<span class="cp">    my $dumped_core = $? &amp; 128;</span>
<span class="cp">    printf $OUT &quot;Program terminated with status %d from signal %d%s\n&quot;,</span>
<span class="cp">           $exit_value, $signal_num, </span>
<span class="cp">           $dumped_core ? &quot; (core dumped)&quot; : &quot;&quot;;</span>
<span class="cp">    print @output;</span>
<span class="cp">    $term-&gt;addhistory($seed_line);</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">$term-&gt;addhistory($seed_line);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$term-&gt;remove_history($line_number);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@history = $term-&gt;GetHistory;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% rep ps aux</span>
<span class="cp">#% rep netstat</span>
<span class="cp">#% rep -2.5 lpq</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/rep</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># rep - screen repeat command</span>
<span class="cp">use strict;</span>
<span class="cp">use Curses;</span>

<span class="cp">my $timeout = 10;</span>
<span class="cp">if (@ARGV &amp;&amp; $ARGV[0] =~ /^-(\d+\.?\d*)$/) { </span>
<span class="cp">    $timeout = $1; </span>
<span class="cp">    shift; </span>
<span class="cp">} </span>

<span class="cp">die &quot;usage: $0 [ -timeout ] cmd args\n&quot; unless @ARGV;</span>
<span class="cp">    </span>
<span class="cp">initscr();          # start screen</span>
<span class="cp">noecho();           </span>
<span class="cp">cbreak(); </span>
<span class="cp">nodelay(1);         # so getch() is non-blocking</span>

<span class="cp">$SIG{INT} = sub { done(&quot;Ouch!&quot;) };</span>
<span class="cp">sub done { endwin(); print &quot;@_\n&quot;; exit; }</span>

<span class="cp">while (1) {</span>
<span class="cp">    while ((my $key = getch()) ne ERR) {    # maybe multiple keys</span>
<span class="cp">        done(&quot;See ya&quot;) if $key eq &#39;q&#39; </span>
<span class="cp">    }</span>
<span class="cp">    my @data = `(@ARGV) 2&gt;&amp;1`;              # gather output+errors</span>
<span class="cp">    for (my $i = 0; $i &lt; $LINES; $i++) {</span>
<span class="cp">        addstr($i, 0, $data[$i] || &#39; &#39; x $COLS);</span>
<span class="cp">    } </span>

<span class="cp">    standout();</span>
<span class="cp">    addstr($LINES-1, $COLS - 24, scalar localtime);</span>
<span class="cp">    standend();</span>

<span class="cp">    move(0,0); </span>
<span class="cp">    refresh();                              # flush new output to display</span>

<span class="cp">    my ($in, $out) = (&#39;&#39;, &#39;&#39;);</span>
<span class="cp">    vec($in,fileno(STDIN),1) = 1;           # look for key on stdin </span>
<span class="cp">    select($out = $in,undef,undef,$timeout);# wait up to this long</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">keypad(1);                  # enable keypad mode</span>
<span class="cp">$key = getch();</span>
<span class="cp">if ($key eq &#39;k&#39;     ||      # vi mode</span>
<span class="cp">    $key eq &quot;\cP&quot;   ||      # emacs mode</span>
<span class="cp">    $key eq KEY_UP)         # arrow mode</span>
<span class="cp">{</span>
<span class="cp">    # do something</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">#		       Template Entry Demonstration </span>
<span class="cp">#</span>
<span class="cp">#   Address Data Example                                     Record # ___</span>
<span class="cp">#</span>
<span class="cp">#   Name: [________________________________________________]</span>
<span class="cp">#   Addr: [________________________________________________]</span>
<span class="cp">#   City: [__________________]          State: [__]       Zip: [\\\\\] </span>
<span class="cp">#</span>
<span class="cp">#   Phone: (\\\) \\\-\\\\                            Password: [^^^^^^^^]</span>
<span class="cp">#</span>
<span class="cp">#   Enter all information available.</span>
<span class="cp">#   Edit fields with left/right arrow keys or &quot;delete&quot;.</span>
<span class="cp">#   Switch fields with &quot;Tab&quot; or up/down arrow keys.</span>
<span class="cp">#   Indicate completion by pressing &quot;Return&quot;.</span>
<span class="cp">#   Refresh screen with &quot;Control-L&quot;.</span>
<span class="cp">#   Abort this demo here with &quot;Control-X&quot;.</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Expect;</span>

<span class="cp">$command = Expect-&gt;spawn(&quot;program to run&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t start program: $!\n&quot;;</span>

<span class="cp"># prevent the program&#39;s output from being shown on our STDOUT</span>
<span class="cp">$command-&gt;log_stdout(0);</span>

<span class="cp"># wait 10 seconds for &quot;Password:&quot; to appear</span>
<span class="cp">unless ($command-&gt;expect(10, &quot;Password&quot;)) {</span>
<span class="cp">    # timed out</span>
<span class="cp">}</span>

<span class="cp"># wait 20 seconds for something that matches /[lL]ogin: ?/</span>
<span class="cp">unless ($command-&gt;expect(20, -re =&gt; &#39;[lL]ogin: ?&#39;)) {</span>
<span class="cp">    # timed out</span>
<span class="cp">}</span>

<span class="cp"># wait forever for &quot;invalid&quot; to appear</span>
<span class="cp">unless ($command-&gt;expect(undef, &quot;invalid&quot;)) {</span>
<span class="cp">    # error occurred; the program probably went away</span>
<span class="cp">}</span>

<span class="cp"># send &quot;Hello, world&quot; and a carriage return to the program</span>
<span class="cp">print $command &quot;Hello, world\r&quot;;</span>

<span class="cp"># if the program will terminate by itself, finish up with</span>
<span class="cp">$command-&gt;soft_close();</span>
<span class="cp">    </span>
<span class="cp"># if the program must be explicitly killed, finish up with</span>
<span class="cp">$command-&gt;hard_close();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$which = $command-&gt;expect(30, &quot;invalid&quot;, &quot;succes&quot;, &quot;error&quot;, &quot;boom&quot;);</span>
<span class="cp">if ($which) {</span>
<span class="cp">    # found one of those strings</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Tk;</span>

<span class="cp">$main = MainWindow-&gt;new();</span>

<span class="cp"># Create a horizontal space at the top of the window for the</span>
<span class="cp"># menu to live in.</span>
<span class="cp">$menubar = $main-&gt;Frame(-relief              =&gt; &quot;raised&quot;,</span>
<span class="cp">                        -borderwidth         =&gt; 2)</span>
<span class="cp">                -&gt;pack (-anchor              =&gt; &quot;nw&quot;,</span>
<span class="cp">                        -fill                =&gt; &quot;x&quot;);</span>

<span class="cp"># Create a button labeled &quot;File&quot; that brings up a menu</span>
<span class="cp">$file_menu = $menubar-&gt;Menubutton(-text      =&gt; &quot;File&quot;,</span>
<span class="cp">                                  -underline =&gt; 1)</span>
<span class="cp">                     -&gt;pack      (-side      =&gt; &quot;left&quot; );</span>
<span class="cp"># Create entries in the &quot;File&quot; menu</span>
<span class="cp">$file_menu-&gt;command(-label   =&gt; &quot;Print&quot;,</span>
<span class="cp">                    -command =&gt; \&amp;Print);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file_menu = $menubar-&gt;Menubutton(-text     =&gt; &quot;File&quot;,</span>
<span class="cp">                                 -underline =&gt; 1,</span>
<span class="cp">                                 -menuitems =&gt; [</span>
<span class="cp">              [ Button =&gt; &quot;Print&quot;,-command  =&gt; \&amp;Print ],</span>
<span class="cp">               [ Button =&gt; &quot;Save&quot;,-command  =&gt; \&amp;Save  ] ])</span>
<span class="cp">                           -&gt;pack(-side     =&gt; &quot;left&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    $file_menu-&gt;command(-label   =&gt; &quot;Quit Immediately&quot;,</span>
<span class="cp">                        -command =&gt; sub { exit } );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file_menu-&gt;separator();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$options_menu-&gt;checkbutton(-label    =&gt; &quot;Create Debugging File&quot;,</span>
<span class="cp">                           -variable =&gt; \$debug,</span>
<span class="cp">                           -onvalue  =&gt; 1,</span>
<span class="cp">                           -offvalue =&gt; 0);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$debug_menu-&gt;radiobutton(-label    =&gt; &quot;Level 1&quot;,</span>
<span class="cp">                         -variable =&gt; \$log_level,</span>
<span class="cp">                         -value    =&gt; 1);</span>

<span class="cp">$debug_menu-&gt;radiobutton(-label    =&gt; &quot;Level 2&quot;,</span>
<span class="cp">                         -variable =&gt; \$log_level,</span>
<span class="cp">                         -value    =&gt; 2);</span>

<span class="cp">$debug_menu-&gt;radiobutton(-label    =&gt; &quot;Level 3&quot;,</span>
<span class="cp">                         -variable =&gt; \$log_level,</span>
<span class="cp">                         -value    =&gt; 3);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># step 1: create the cascading menu entry</span>
<span class="cp">$format_menu-&gt;cascade          (-label    =&gt; &quot;Font&quot;);</span>

<span class="cp"># step 2: get the new Menu we just made</span>
<span class="cp">$font_menu = $format_menu-&gt;cget(&quot;-menu&quot;);</span>

<span class="cp"># step 3: populate that Menu</span>
<span class="cp">$font_menu-&gt;radiobutton        (-label    =&gt; &quot;Courier&quot;,</span>
<span class="cp">                                -variable =&gt; \$font_name,</span>
<span class="cp">                                -value    =&gt; &quot;courier&quot;);</span>
<span class="cp">$font_menu-&gt;radiobutton        (-label    =&gt; &quot;Times Roman&quot;,</span>
<span class="cp">                                -variable =&gt; \$font_name,</span>
<span class="cp">                                -value    =&gt; &quot;times&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$format_menu = $menubar-&gt;Menubutton(-text      =&gt; &quot;Format&quot;,</span>
<span class="cp">                                    -underline =&gt; 1</span>
<span class="cp">                                    -tearoff   =&gt; 0)</span>
<span class="cp">                       -&gt;pack;</span>

<span class="cp">$font_menu  = $format_menu-&gt;cascade(-label     =&gt; &quot;Font&quot;,</span>
<span class="cp">                                    -tearoff   =&gt; 0);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $f = $menubar-&gt;Menubutton(-text =&gt; &quot;Edit&quot;, -underline =&gt; 0,</span>
<span class="cp">                              -menuitems =&gt;</span>
<span class="cp">    [</span>
<span class="cp">     [Button =&gt; &#39;Copy&#39;,        -command =&gt; \&amp;edit_copy ],</span>
<span class="cp">     [Button =&gt; &#39;Cut&#39;,         -command =&gt; \&amp;edit_cut ],</span>
<span class="cp">     [Button =&gt; &#39;Paste&#39;,       -command =&gt; \&amp;edit_paste  ],</span>
<span class="cp">     [Button =&gt; &#39;Delete&#39;,      -command =&gt; \&amp;edit_delete ],</span>
<span class="cp">     [Separator =&gt; &#39;&#39;],</span>
<span class="cp">     [Cascade =&gt; &#39;Object ...&#39;, -tearoff =&gt; 0,</span>
<span class="cp">                               -menuitems =&gt; [</span>
<span class="cp">        [ Button =&gt; &quot;Circle&quot;,  -command =&gt; \&amp;edit_circle ],</span>
<span class="cp">        [ Button =&gt; &quot;Square&quot;,  -command =&gt; \&amp;edit_square ],</span>
<span class="cp">        [ Button =&gt; &quot;Point&quot;,   -command =&gt; \&amp;edit_point ] ] ],</span>
<span class="cp">    ])-&gt;grid(-row =&gt; 0, -column =&gt; 0, -sticky =&gt; &#39;w&#39;);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Tk::DialogBox;</span>

<span class="cp">$dialog = $main-&gt;DialogBox( -title   =&gt; &quot;Register This Program&quot;,</span>
<span class="cp">                            -buttons =&gt; [ &quot;Register&quot;, &quot;Cancel&quot; ] );</span>

<span class="cp"># add widgets to the dialog box with $dialog-&gt;Add()</span>

<span class="cp"># later, when you need to display the dialog box</span>
<span class="cp">$button = $dialog-&gt;Show();</span>
<span class="cp">if ($button eq &quot;Register&quot;) {</span>
<span class="cp">    # ...</span>
<span class="cp">} elsif ($button eq &quot;Cancel&quot;) {</span>
<span class="cp">    # ...</span>
<span class="cp">} else {</span>
<span class="cp">    # this shouldn&#39;t happen</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/tksample3</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># tksample3 - demonstrate dialog boxes</span>

<span class="cp">use Tk;</span>
<span class="cp">use Tk::DialogBox;</span>

<span class="cp">$main = MainWindow-&gt;new();</span>

<span class="cp">$dialog = $main-&gt;DialogBox( -title   =&gt; &quot;Register&quot;,</span>
<span class="cp">                            -buttons =&gt; [ &quot;Register&quot;, &quot;Cancel&quot; ],</span>
<span class="cp">                           );</span>

<span class="cp"># the top part of the dialog box will let people enter their names,</span>
<span class="cp"># with a Label as a prompt</span>

<span class="cp">$dialog-&gt;add(&quot;Label&quot;, -text =&gt; &quot;Name&quot;)-&gt;pack();</span>
<span class="cp">$entry = $dialog-&gt;add(&quot;Entry&quot;, -width =&gt; 35)-&gt;pack();</span>

<span class="cp"># we bring up the dialog box with a button</span>
<span class="cp">$main-&gt;Button( -text    =&gt; &quot;Click Here For Registration Form&quot;,</span>
<span class="cp">               -command =&gt; \&amp;register)    -&gt;pack(-side =&gt; &quot;left&quot;);</span>
<span class="cp">$main-&gt;Button( -text    =&gt; &quot;Quit&quot;,</span>
<span class="cp">               -command =&gt; sub { exit } ) -&gt;pack(-side =&gt; &quot;left&quot;);</span>

<span class="cp">MainLoop;</span>

<span class="cp">#</span>
<span class="cp"># register</span>
<span class="cp">#</span>
<span class="cp"># Called to pop up the registration dialog box</span>
<span class="cp">#</span>

<span class="cp">sub register {</span>
<span class="cp">    my $button;</span>
<span class="cp">    my $done = 0;</span>

<span class="cp">    do {    </span>
<span class="cp">        # show the dialog</span>
<span class="cp">        $button = $dialog-&gt;Show;</span>

<span class="cp">        # act based on what button they pushed</span>
<span class="cp">        if ($button eq &quot;Register&quot;) {</span>
<span class="cp">                my $name = $entry-&gt;get;</span>

<span class="cp">            if (defined($name) &amp;&amp; length($name)) {</span>
<span class="cp">                print &quot;Welcome to the fold, $name\n&quot;;</span>
<span class="cp">                $done = 1;</span>
<span class="cp">            } else {</span>
<span class="cp">                print &quot;You didn&#39;t give me your name!\n&quot;;</span>
<span class="cp">            }</span>
<span class="cp">        } else {</span>
<span class="cp">            print &quot;Sorry you decided not to register.\n&quot;;</span>
<span class="cp">            $done = 1;</span>
<span class="cp">        }</span>
<span class="cp">    } until $done;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/tksample4</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># tksample4 - popup dialog boxes for warnings</span>

<span class="cp">use Tk;</span>
<span class="cp">use Tk::DialogBox;</span>

<span class="cp">my $main;</span>

<span class="cp"># set up a warning handler that displays the warning in a Tk dialog box</span>

<span class="cp">BEGIN {</span>
<span class="cp">    $SIG{_     _WARN_     _} = sub {</span>
<span class="cp">        if (defined $main) {</span>
<span class="cp">            my $dialog = $main-&gt;DialogBox( -title   =&gt; &quot;Warning&quot;,</span>
<span class="cp">                                           -buttons =&gt; [ &quot;Acknowledge&quot; ]);</span>
<span class="cp">            $dialog-&gt;add(&quot;Label&quot;, -text =&gt; $_[0])-&gt;pack;</span>
<span class="cp">            $dialog-&gt;Show;</span>
<span class="cp">        } else {</span>
<span class="cp">            print STDOUT join(&quot;\n&quot;, @_), &quot;n&quot;;</span>
<span class="cp">        }</span>
<span class="cp">    };</span>
<span class="cp">}</span>

<span class="cp"># your program goes here</span>

<span class="cp">$main = MainWindow-&gt;new();</span>

<span class="cp">$main-&gt;Button( -text   =&gt; &quot;Make A Warning&quot;,</span>
<span class="cp">               -command =&gt; \&amp;make_warning) -&gt;pack(-side =&gt; &quot;left&quot;);</span>
<span class="cp">$main-&gt;Button( -text   =&gt; &quot;Quit&quot;,</span>
<span class="cp">               -command =&gt; sub { exit } )  -&gt;pack(-side =&gt; &quot;left&quot;);</span>

<span class="cp">MainLoop;</span>

<span class="cp"># dummy subroutine to generate a warning</span>
<span class="cp">    </span>
<span class="cp">sub make_warning {</span>
<span class="cp">    my $a;</span>
<span class="cp">    my $b = 2 * $a;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Tk;</span>

<span class="cp">$main = MainWindow-&gt;new();</span>

<span class="cp">$main-&gt;bind(&#39;&lt;Configure&gt;&#39; =&gt; sub {</span>
<span class="cp">    $xe = $main-&gt;XEvent;</span>
<span class="cp">    $main-&gt;maxsize($xe-&gt;w, $xe-&gt;h);</span>
<span class="cp">    $main-&gt;minsize($xe-&gt;w, $xe-&gt;h);</span>
<span class="cp">});</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$widget-&gt;pack( -fill =&gt; &quot;both&quot;, -expand =&gt; 1 );</span>
<span class="cp">$widget-&gt;pack( -fill =&gt; &quot;x&quot;,    -expand =&gt; 1 );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$mainarea-&gt;pack( -fill =&gt; &quot;both&quot;, -expand =&gt; 1);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$menubar-&gt;pack( -fill =&gt; &quot;x&quot;, -expand =&gt; 1 );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$menubar-&gt;pack (-fill     =&gt; &quot;x&quot;,</span>
<span class="cp">                -expand   =&gt; 1,</span>
<span class="cp">                -anchor   =&gt; &quot;nw&quot; );</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/loader</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># loader - starts Perl scripts without the annoying DOS window</span>
<span class="cp">use strict;</span>
<span class="cp">use Win32;</span>
<span class="cp">use Win32::Process;</span>

<span class="cp"># Create the process object.</span>

<span class="cp">Win32::Process::Create($Win32::Process::Create::ProcessObj,</span>
<span class="cp">    &#39;C:/perl5/bin/perl.exe&#39;,            # Whereabouts of Perl</span>
<span class="cp">    &#39;perl realprogram&#39;,                 #</span>
<span class="cp">    0,                                  # Don&#39;t inherit.</span>
<span class="cp">    DETACHED_PROCESS,                   #</span>
<span class="cp">    &quot;.&quot;) or                             # current dir.</span>
<span class="cp">die print_error();</span>

<span class="cp">sub print_error() {</span>
<span class="cp">    return Win32::FormatMessage( Win32::GetLastError() );</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/tcapdemo</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># tcapdemo - show off direct cursor placement</span>

<span class="cp">use POSIX;</span>
<span class="cp">use Term::Cap;</span>
<span class="cp">    </span>
<span class="cp">init();                     # Initialize Term::Cap.</span>
<span class="cp">zip();                      # Bounce lines around the screen.</span>
<span class="cp">finish();                   # Clean up afterward.</span>
<span class="cp">exit();</span>

<span class="cp"># Two convenience functions.  clear_screen is obvious, and</span>
<span class="cp"># clear_end clears to the end of the screen.</span>
<span class="cp">sub clear_screen { $tcap-&gt;Tputs(&#39;cl&#39;, 1, *STDOUT) } </span>
<span class="cp">sub clear_end    { $tcap-&gt;Tputs(&#39;cd&#39;, 1, *STDOUT) } </span>

<span class="cp"># Move the cursor to a particular location.</span>
<span class="cp">sub gotoxy {</span>
<span class="cp">    my($x, $y) = @_;</span>
<span class="cp">    $tcap-&gt;Tgoto(&#39;cm&#39;, $x, $y, *STDOUT);</span>
<span class="cp">} </span>

<span class="cp"># Get the terminal speed through the POSIX module and use that</span>
<span class="cp"># to initialize Term::Cap.</span>
<span class="cp">sub init { </span>
<span class="cp">    $| = 1;</span>
<span class="cp">    $delay = (shift() || 0) * 0.005;</span>
<span class="cp">    my $termios = POSIX::Termios-&gt;new();</span>
<span class="cp">    $termios-&gt;getattr;</span>
<span class="cp">    my $ospeed = $termios-&gt;getospeed;</span>
<span class="cp">    $tcap = Term::Cap-&gt;Tgetent ({ TERM =&gt; undef, OSPEED =&gt; $ospeed });</span>
<span class="cp">    $tcap-&gt;Trequire(qw(cl cm cd));</span>
<span class="cp">}</span>

<span class="cp"># Bounce lines around the screen until the user interrupts with</span>
<span class="cp"># Ctrl-C.</span>
<span class="cp">sub zip { </span>
<span class="cp">    clear_screen();</span>
<span class="cp">    ($maxrow, $maxcol) = ($tcap-&gt;{_li} - 1, $tcap-&gt;{_co} - 1);</span>

<span class="cp">    @chars = qw(* - / | \ _ );</span>
<span class="cp">    sub circle { push(@chars, shift @chars); }</span>

<span class="cp">    $interrupted = 0;</span>
<span class="cp">    $SIG{INT} = sub { ++$interrupted };</span>

<span class="cp">    $col = $row = 0;</span>
<span class="cp">    ($row_sign, $col_sign) = (1,1);</span>

<span class="cp">    do {</span>
<span class="cp">        gotoxy($col, $row);</span>
<span class="cp">        print $chars[0];</span>
<span class="cp">        select(undef, undef, undef, $delay);</span>

<span class="cp">        $row += $row_sign;</span>
<span class="cp">        $col += $col_sign;</span>

<span class="cp">        if    ($row == $maxrow) { $row_sign = -1; circle; } </span>
<span class="cp">        elsif ($row == 0 )      { $row_sign = +1; circle; }</span>

<span class="cp">        if    ($col == $maxcol) { $col_sign = -1; circle; } </span>
<span class="cp">        elsif ($col == 0 )      { $col_sign = +1; circle; }</span>
<span class="cp">    </span>
<span class="cp">    } until $interrupted;</span>

<span class="cp">}</span>

<span class="cp"># Clean up the screen.</span>
<span class="cp">sub finish { </span>
<span class="cp">    gotoxy(0, $maxrow);</span>
<span class="cp">    clear_end();</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#*     _                       /     |                       \     -</span>
<span class="cp"># *   _ \                     - /   | /                     | \   - *</span>
<span class="cp">#  * _   \                   -   / |   /                   |   \ -   *</span>
<span class="cp">#   *     \                 -     |     /                 |     -     *</span>
<span class="cp">#  _ *     \               -     | /     /               |     - \     *</span>
<span class="cp"># _   *     \             -     |   /     /             |     -   \     *</span>
<span class="cp">#*     *     \           -     |     /     /           |     -     \     *</span>
<span class="cp"># *     *     \         -     |       /     /         |     -       \     *</span>
<span class="cp">#  *     *     \       -     |         /     /       |     -         \     *</span>
<span class="cp">#   *     *     \     -     |           /     /     |     -           \     *</span>
<span class="cp">#    *     *     \   -     |             /     /   |     -             \     *</span>
<span class="cp">#     *     *     \ -     |               /     / |     -               \     </span>
<span class="cp">#      *     -     \     |                 /     /     -                 \    </span>
<span class="cp">#	*   - *   - \   |                   /   | /   -                   \   </span>
<span class="cp">#	 * -   * -   \ |                     / |   / -                     \ _</span>
<span class="cp">#	  -     -     \                       |     /                       _</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_15.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% tkshufflepod chap15.pod</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch15/tkshufflepod</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># tkshufflepod - reorder =head1 sections in a pod file</span>

<span class="cp">use Tk;</span>
<span class="cp">use strict;</span>

<span class="cp"># declare variables</span>

<span class="cp">my $podfile;    		 # name of the file to open</span>
<span class="cp">my $m;    			     # main window</span>
<span class="cp">my $l;    			     # listbox</span>
<span class="cp">my ($up, $down);   # positions to move</span>
<span class="cp">my @sections;      # list of pod sections</span>
<span class="cp">my $all_pod;       # text of pod file (used when reading)</span>

<span class="cp"># read the pod file into memory, and split it into sections.</span>

<span class="cp">$podfile = shift || &quot;-&quot;;</span>

<span class="cp">undef $/;</span>
<span class="cp">open(F, &quot;&lt; $podfile&quot;)</span>
<span class="cp">  or die &quot;Can&#39;t open $podfile : $!\n&quot;;</span>
<span class="cp">$all_pod = &lt;F&gt;;</span>
<span class="cp">close(F);</span>
<span class="cp">@sections = split(/(?==head1)/, $all_pod);</span>

<span class="cp"># turn @sections into an array of anonymous arrays.  The first element</span>
<span class="cp"># in each of these arrays is the original text of the message, while</span>
<span class="cp"># the second element is the text following =head1 (the section title).</span>

<span class="cp">foreach (@sections) {</span>
<span class="cp">    /(.*)/;</span>
<span class="cp">    $_ = [ $_, $1 ];</span>
<span class="cp">}</span>

<span class="cp"># fire up Tk and display the list of sections.</span>

<span class="cp">$m = MainWindow-&gt;new();</span>
<span class="cp">$l = $m-&gt;Listbox(&#39;-width&#39; =&gt; 60)-&gt;pack(&#39;-expand&#39; =&gt; 1, &#39;-fill&#39; =&gt; &#39;both&#39;);</span>

<span class="cp">foreach my $section (@sections) {</span>
<span class="cp">    $l-&gt;insert(&quot;end&quot;, $section-&gt;[1]);</span>
<span class="cp">}</span>

<span class="cp"># permit dragging by binding to the Listbox widget.</span>
<span class="cp">$l-&gt;bind( &#39;&lt;Any-Button&gt;&#39;     =&gt; \&amp;down );</span>
<span class="cp">$l-&gt;bind( &#39;&lt;Any-ButtonRelease&gt;&#39; =&gt; \&amp;up );</span>

<span class="cp"># permit viewing by binding double-click</span>
<span class="cp">$l-&gt;bind( &#39;&lt;Double-Button&gt;&#39;     =&gt; \&amp;view );</span>

<span class="cp"># &#39;q&#39; quits and &#39;s&#39; saves</span>
<span class="cp">$m-&gt;bind( &#39;&lt;q&gt;&#39;     	=&gt; sub { exit } );</span>
<span class="cp">$m-&gt;bind( &#39;&lt;s&gt;&#39;    		=&gt; \&amp;save );</span>

<span class="cp">MainLoop;</span>

<span class="cp"># down(widget): called when the user clicks on an item in the Listbox.</span>

<span class="cp">sub down {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    $down = $self-&gt;curselection;;</span>
<span class="cp">}</span>

<span class="cp"># up(widget): called when the user releases the mouse button in the</span>
<span class="cp"># Listbox.</span>

<span class="cp">sub up {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    my $elt;</span>

<span class="cp">    $up = $self-&gt;curselection;;</span>

<span class="cp">    return if $down == $up;</span>

<span class="cp">    # change selection list</span>
<span class="cp">    $elt = $sections[$down];</span>
<span class="cp">    splice(@sections, $down, 1);</span>
<span class="cp">    splice(@sections, $up, 0, $elt);</span>
<span class="cp">    $self-&gt;delete($down);</span>
<span class="cp">    $self-&gt;insert($up, $sections[$up]-&gt;[1]);</span>
<span class="cp">}</span>

<span class="cp"># save(widget): called to save the list of sections.</span>

<span class="cp">sub save {</span>
<span class="cp">    my $self = shift;</span>

<span class="cp">    open(F, &quot;&gt; $podfile&quot;)</span>
<span class="cp">      or die &quot;Can&#39;t open $podfile for writing: $!&quot;;</span>
<span class="cp">    print F map { $_-&gt;[0] } @sections;</span>
<span class="cp">    close F;</span>

<span class="cp">    exit;</span>
<span class="cp">}</span>

<span class="cp"># view(widget): called to display the widget.  Uses the Pod widget.</span>

<span class="cp">sub view {</span>
<span class="cp">    my $self = shift;</span>
<span class="cp">    my $temporary = &quot;/tmp/$$-section.pod&quot;;</span>
<span class="cp">    my $popup;</span>

<span class="cp">    open(F, &quot;&gt; $temporary&quot;)</span>
<span class="cp">      or warn (&quot;Can&#39;t open $temporary : $!\n&quot;), return;</span>
<span class="cp">    print F $sections[$down]-&gt;[0];</span>
<span class="cp">    close(F);</span>
<span class="cp">    $popup = $m-&gt;Pod(&#39;-file&#39; =&gt; $temporary);</span>

<span class="cp">    $popup-&gt;bind(&#39;&lt;Destroy&gt;&#39; =&gt; sub { unlink $temporary } );</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$output = `program args`;   # collect output into one multiline string</span>
<span class="cp">@output = `program args`;   # collect output into array, one line per element</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(README, &quot;program args |&quot;) or die &quot;Can&#39;t run program: $!\n&quot;;</span>
<span class="cp">while(&lt;README&gt;) {</span>
<span class="cp">    $output .= $_;</span>
<span class="cp">}</span>
<span class="cp">close(README);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">`fsck -y /dev/rsd1a`;       # BAD AND SCARY</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(:sys_wait_h);</span>

<span class="cp">pipe(README, WRITEME);</span>
<span class="cp">if ($pid = fork) {</span>
<span class="cp">    # parent</span>
<span class="cp">    $SIG{CHLD} = sub { 1 while ( waitpid(-1, WNOHANG)) &gt; 0 };</span>
<span class="cp">    close(WRITEME);</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    # child</span>
<span class="cp">    open(STDOUT, &quot;&gt;&amp;=WRITEME&quot;)      or die &quot;Couldn&#39;t redirect STDOUT: $!&quot;;</span>
<span class="cp">    close(README);</span>
<span class="cp">    exec($program, $arg1, $arg2)    or die &quot;Couldn&#39;t run $program : $!\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">while (&lt;README&gt;) {</span>
<span class="cp">    $string .= $_;</span>
<span class="cp">    # or  push(@strings, $_);</span>
<span class="cp">}</span>
<span class="cp">close(README);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$status = system(&quot;vi $myfile&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$status = system(&quot;vi&quot;, $myfile);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">system(&quot;cmd1 args | cmd2 | cmd3 &gt;outfile&quot;);</span>
<span class="cp">system(&quot;cmd args &lt;infile &gt;outfile 2&gt;errfile&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$status = system($program, $arg1, $arg);</span>
<span class="cp">die &quot;$program exited funny: $?&quot; unless $status == 0;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if (($signo = system(@arglist)) &amp;= 127) { </span>
<span class="cp">    die &quot;program killed by signal $signo\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($pid = fork) {</span>
<span class="cp">    # parent catches INT and berates user</span>
<span class="cp">    local $SIG{INT} = sub { print &quot;Tsk tsk, no process interruptus\n&quot; };</span>
<span class="cp">    waitpid($pid, 0);</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    # child ignores INT and does its thing</span>
<span class="cp">    $SIG{INT} = &quot;IGNORE&quot;;</span>
<span class="cp">    exec(&quot;summarize&quot;, &quot;/etc/logfiles&quot;)             or die &quot;Can&#39;t exec: $!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$shell = &#39;/bin/tcsh&#39;;</span>
<span class="cp">system $shell &#39;-csh&#39;;           # pretend it&#39;s a login shell</span>
<span class="cp">#-----------------------------</span>
<span class="cp">system {&#39;/bin/tcsh&#39;} &#39;-csh&#39;;    # pretend it&#39;s a login shell</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># call expn as vrfy</span>
<span class="cp">system {&#39;/home/tchrist/scripts/expn&#39;} &#39;vrfy&#39;, @ADDRESSES;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@args = ( &quot;echo surprise&quot; );</span>

<span class="cp">system @args;               # subject to shell escapes if @args == 1</span>
<span class="cp">system { $args[0] } @args;  # safe even with one-arg list</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">exec(&quot;archive *.data&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t replace myself with archive: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">exec(&quot;archive&quot;, &quot;accounting.data&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t replace myself with archive: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">exec(&quot;archive accounting.data&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t replace myself with archive: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pid = open(README, &quot;program arguments |&quot;)  or die &quot;Couldn&#39;t fork: $!\n&quot;;</span>
<span class="cp">while (&lt;README&gt;) {</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">close(README)                               or die &quot;Couldn&#39;t close: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pid = open(WRITEME, &quot;| program arguments&quot;) or die &quot;Couldn&#39;t fork: $!\n&quot;;</span>
<span class="cp">print WRITEME &quot;data\n&quot;;</span>
<span class="cp">close(WRITEME)                              or die &quot;Couldn&#39;t close: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pid = open(F, &quot;sleep 100000|&quot;);    # child goes to sleep</span>
<span class="cp">close(F);                           # and the parent goes to lala land</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pid = open(WRITEME, &quot;| program args&quot;);</span>
<span class="cp">print WRITEME &quot;hello\n&quot;;            # program will get hello\n on STDIN</span>
<span class="cp">close(WRITEME);                     # program will get EOF on STDIN</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pager = $ENV{PAGER} || &#39;/usr/bin/less&#39;;  # XXX: might not exist</span>
<span class="cp">open(STDOUT, &quot;| $pager&quot;);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">head(100);</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    print;</span>
<span class="cp">} </span>

<span class="cp">sub head {</span>
<span class="cp">    my $lines = shift || 20;</span>
<span class="cp">    return if $pid = open(STDOUT, &quot;|-&quot;);</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    while (&lt;STDIN&gt;) {</span>
<span class="cp">        print;</span>
<span class="cp">        last unless --$lines ;</span>
<span class="cp">    } </span>
<span class="cp">    exit;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">1: &gt; Welcome to Linux, version 2.0.33 on a i686</span>

<span class="cp">2: &gt; </span>

<span class="cp">3: &gt;     &quot;The software required `Windows 95 or better&#39;, </span>

<span class="cp">4: &gt;      so I installed Linux.&quot;  </span>
<span class="cp">#-----------------------------</span>
<span class="cp">&gt; 1: Welcome to Linux, Kernel version 2.0.33 on a i686</span>

<span class="cp">&gt; 2: </span>

<span class="cp">&gt; 3:     &quot;The software required `Windows 95 or better&#39;, </span>

<span class="cp">&gt; 4:      so I installed Linux.&quot;  </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/qnumcat</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># qnumcat - demo additive output filters</span>

<span class="cp">number();                   # push number filter on STDOUT</span>
<span class="cp">quote();                    # push quote filter on STDOUT</span>

<span class="cp">while (&lt;&gt;) {                # act like /bin/cat</span>
<span class="cp">    print;</span>
<span class="cp">} </span>

<span class="cp">close STDOUT;               # tell kids we&#39;re done--politely</span>
<span class="cp">exit;</span>

<span class="cp">sub number {</span>
<span class="cp">    my $pid;</span>
<span class="cp">    return if $pid = open(STDOUT, &quot;|-&quot;);</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    while (&lt;STDIN&gt;) { printf &quot;%d: %s&quot;, $., $_ } </span>
<span class="cp">    exit;</span>
<span class="cp">} </span>

<span class="cp">sub quote {</span>
<span class="cp">    my $pid;</span>
<span class="cp">    return if $pid = open(STDOUT, &quot;|-&quot;);</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    while (&lt;STDIN&gt;) { print &quot;&gt; $_&quot; } </span>
<span class="cp">    exit;</span>
<span class="cp">} </span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ARGV = map { /\.(gz|Z)$/ ? &quot;gzip -dc $_ |&quot; : $_  } @ARGV;</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    # .......</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">@ARGV = map { m#^\w+://# ? &quot;GET $_ |&quot; : $_ } @ARGV;</span>
<span class="cp">while (&lt;&gt;) {</span>
<span class="cp">    # .......</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pwdinfo = `domainname` =~ /^(\(none\))?$/</span>
<span class="cp">                ? &#39;&lt; /etc/passwd&#39;</span>
<span class="cp">                : &#39;ypcat  passwd |&#39;;</span>

<span class="cp">open(PWD, $pwdinfo)                 or die &quot;can&#39;t open $pwdinfo: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;File, please? &quot;;</span>
<span class="cp">chomp($file = &lt;&gt;);</span>
<span class="cp">open (FH, $file)                    or die &quot;can&#39;t open $file: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$output = `cmd 2&gt;&amp;1`;                          # with backticks</span>
<span class="cp"># or</span>
<span class="cp">$pid = open(PH, &quot;cmd 2&gt;&amp;1 |&quot;);                 # with an open pipe</span>
<span class="cp">while (&lt;PH&gt;) { }                               # plus a read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$output = `cmd 2&gt;/dev/null`;                   # with backticks</span>
<span class="cp"># or</span>
<span class="cp">$pid = open(PH, &quot;cmd 2&gt;/dev/null |&quot;);          # with an open pipe</span>
<span class="cp">while (&lt;PH&gt;) { }                               # plus a read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$output = `cmd 2&gt;&amp;1 1&gt;/dev/null`;              # with backticks</span>
<span class="cp"># or</span>
<span class="cp">$pid = open(PH, &quot;cmd 2&gt;&amp;1 1&gt;/dev/null |&quot;);     # with an open pipe</span>
<span class="cp">while (&lt;PH&gt;) { }                               # plus a read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;           # with backticks</span>
<span class="cp"># or</span>
<span class="cp">$pid = open(PH, &quot;cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-|&quot;);   # with an open pipe</span>
<span class="cp">while (&lt;PH&gt;) { }                               # plus a read</span>
<span class="cp">#-----------------------------</span>
<span class="cp">system(&quot;program args 1&gt;/tmp/program.stdout 2&gt;/tmp/program.stderr&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;        </span>
<span class="cp">#-----------------------------</span>
<span class="cp">$fd3 = $fd1;</span>
<span class="cp">$fd1 = $fd2;</span>
<span class="cp">$fd2 = $fd3;</span>
<span class="cp">$fd3 = undef;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">system(&quot;prog args 1&gt;tmpfile 2&gt;&amp;1&quot;);</span>
<span class="cp">system(&quot;prog args 2&gt;&amp;1 1&gt;tmpfile&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># system (&quot;prog args 1&gt;tmpfile 2&gt;&amp;1&quot;);</span>
<span class="cp">$fd1 = &quot;tmpfile&quot;;        # change stdout destination first</span>
<span class="cp">$fd2 = $fd1;             # now point stderr there, too</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># system(&quot;prog args 2&gt;&amp;1 1&gt;tmpfile&quot;);</span>
<span class="cp">$fd2 = $fd1;             # stderr same destination as stdout</span>
<span class="cp">$fd1 = &quot;tmpfile&quot;;        # but change stdout destination </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IPC::Open2;</span>

<span class="cp">open2(*README, *WRITEME, $program);</span>
<span class="cp">print WRITEME &quot;here&#39;s your input\n&quot;;</span>
<span class="cp">$output = &lt;README&gt;;</span>
<span class="cp">close(WRITEME);</span>
<span class="cp">close(README);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(DOUBLE_HANDLE, &quot;| program args |&quot;)     # WRONG</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IPC::Open2;</span>
<span class="cp">use IO::Handle;</span>

<span class="cp">($reader, $writer) = (IO::Handle-&gt;new, IO::Handle-&gt;new);</span>
<span class="cp">open2($reader, $writer, $program);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval {</span>
<span class="cp">    open2($readme, $writeme, @program_and_arguments);</span>
<span class="cp">};</span>
<span class="cp">if ($@) { </span>
<span class="cp">    if ($@ =~ /^open2/) {</span>
<span class="cp">        warn &quot;open2 failed: $!\n$@\n&quot;;</span>
<span class="cp">        return;</span>
<span class="cp">    }</span>
<span class="cp">    die;            # reraise unforeseen exception</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@all = `($cmd | sed -e &#39;s/^/stdout: /&#39; ) 2&gt;&amp;1`;</span>
<span class="cp">for (@all) { push @{ s/stdout: // ? \@outlines : \@errlines }, $_ }</span>
<span class="cp">print &quot;STDOUT:\n&quot;, @outlines, &quot;\n&quot;;</span>
<span class="cp">print &quot;STDERR:\n&quot;, @errlines, &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open3(*WRITEHANDLE, *READHANDLE, *ERRHANDLE, &quot;program to run&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IPC::Open3;</span>
<span class="cp">$pid = open3(*HIS_IN, *HIS_OUT, *HIS_ERR, $cmd);</span>
<span class="cp">close(HIS_IN);  # give end of file to kid, or feed him</span>
<span class="cp">@outlines = &lt;HIS_OUT&gt;;              # read till EOF</span>
<span class="cp">@errlines = &lt;HIS_ERR&gt;;              # XXX: block potential if massive</span>
<span class="cp">print &quot;STDOUT:\n&quot;, @outlines, &quot;\n&quot;;</span>
<span class="cp">print &quot;STDERR:\n&quot;, @errlines, &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/cmd3sel</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># cmd3sel - control all three of kids in, out, and error.</span>
<span class="cp">use IPC::Open3;</span>
<span class="cp">use IO::Select;</span>

<span class="cp">$cmd = &quot;grep vt33 /none/such - /etc/termcap&quot;;</span>
<span class="cp">$pid = open3(*CMD_IN, *CMD_OUT, *CMD_ERR, $cmd);</span>

<span class="cp">$SIG{CHLD} = sub {</span>
<span class="cp">    print &quot;REAPER: status $? on $pid\n&quot; if waitpid($pid, 0) &gt; 0</span>
<span class="cp">};</span>

<span class="cp">print CMD_IN &quot;This line has a vt33 lurking in it\n&quot;;</span>
<span class="cp">close(CMD_IN);</span>

<span class="cp">$selector = IO::Select-&gt;new();</span>
<span class="cp">$selector-&gt;add(*CMD_ERR, *CMD_OUT);</span>

<span class="cp">while (@ready = $selector-&gt;can_read) {</span>
<span class="cp">    foreach $fh (@ready) {</span>
<span class="cp">        if (fileno($fh) == fileno(CMD_ERR)) {print &quot;STDERR: &quot;, scalar &lt;CMD_ERR&gt;}</span>
<span class="cp">        else                                {print &quot;STDOUT: &quot;, scalar &lt;CMD_OUT&gt;}</span>
<span class="cp">        $selector-&gt;remove($fh) if eof($fh);</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">close(CMD_CUT);</span>
<span class="cp">close(CMD_ERR);</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">pipe(READER, WRITER);</span>
<span class="cp">if (fork) {</span>
<span class="cp">    # run parent code, either reading or writing, not both</span>
<span class="cp">} else {</span>
<span class="cp">    # run child code, either reading or writing, not both</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($pid = open(CHILD, &quot;|-&quot;)) {</span>
<span class="cp">        # run parent code, writing to child</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    # otherwise run child code here, reading from parent</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($pid = open(CHILD, &quot;-|&quot;)) {</span>
<span class="cp">    # run parent code, reading from child</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    # otherwise run child code here, writing to parent</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/pipe1</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># pipe1 - use pipe and fork so parent can send to child</span>

<span class="cp">use IO::Handle;</span>
<span class="cp">pipe(READER, WRITER);</span>
<span class="cp">WRITER-&gt;autoflush(1);</span>

<span class="cp">if ($pid = fork) {</span>
<span class="cp">    close READER;</span>
<span class="cp">    print WRITER &quot;Parent Pid $$ is sending this\n&quot;;</span>
<span class="cp">    close WRITER;</span>
<span class="cp">    waitpid($pid,0);</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    close WRITER;</span>
<span class="cp">    chomp($line = &lt;READER&gt;);</span>
<span class="cp">    print &quot;Child Pid $$ just read this: `$line&#39;\n&quot;;</span>
<span class="cp">    close READER;  # this will happen anyway</span>
<span class="cp">    exit;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/pipe2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># pipe2 - use pipe and fork so child can send to parent</span>

<span class="cp">use IO::Handle;</span>
<span class="cp">pipe(READER, WRITER);</span>
<span class="cp">WRITER-&gt;autoflush(1);</span>

<span class="cp">if ($pid = fork) {</span>
<span class="cp">    close WRITER;</span>
<span class="cp">    chomp($line = &lt;READER&gt;);</span>
<span class="cp">    print &quot;Parent Pid $$ just read this: `$line&#39;\n&quot;;</span>
<span class="cp">    close READER;</span>
<span class="cp">    waitpid($pid,0);</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    close READER;</span>
<span class="cp">    print WRITER &quot;Child Pid $$ is sending this\n&quot;;</span>
<span class="cp">    close WRITER;  # this will happen anyway</span>
<span class="cp">    exit;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/pipe3</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># pipe3 - use forking open so parent can send to child</span>

<span class="cp">use IO::Handle;</span>
<span class="cp">if ($pid = open(CHILD, &quot;|-&quot;)) {</span>
<span class="cp">    CHILD-&gt;autoflush(1);</span>
<span class="cp">    print CHILD &quot;Parent Pid $$ is sending this\n&quot;;</span>
<span class="cp">    close(CHILD);</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    chomp($line = &lt;STDIN&gt;);</span>
<span class="cp">    print &quot;Child Pid $$ just read this: `$line&#39;\n&quot;;</span>
<span class="cp">    exit;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/pipe4</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># pipe4 - use forking open so child can send to parent</span>

<span class="cp">use IO::Handle;</span>
<span class="cp">if ($pid = open(CHILD, &quot;-|&quot;)) {</span>
<span class="cp">    chomp($line = &lt;CHILD&gt;);</span>
<span class="cp">    print &quot;Parent Pid $$ just read this: `$line&#39;\n&quot;;</span>
<span class="cp">    close(CHILD);</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    STDOUT-&gt;autoflush(1);</span>
<span class="cp">    print STDOUT &quot;Child Pid $$ is sending this\n&quot;;</span>
<span class="cp">    exit;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/pipe5</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># pipe5 - bidirectional communication using two pipe pairs</span>
<span class="cp">#         designed for the socketpair-challenged</span>
<span class="cp">use IO::Handle;</span>
<span class="cp">pipe(PARENT_RDR, CHILD_WTR);</span>
<span class="cp">pipe(CHILD_RDR,  PARENT_WTR);</span>
<span class="cp">CHILD_WTR-&gt;autoflush(1);</span>
<span class="cp">PARENT_WTR-&gt;autoflush(1);</span>

<span class="cp">if ($pid = fork) {</span>
<span class="cp">    close PARENT_RDR; close PARENT_WTR;</span>
<span class="cp">    print CHILD_WTR &quot;Parent Pid $$ is sending this\n&quot;;</span>
<span class="cp">    chomp($line = &lt;CHILD_RDR&gt;);</span>
<span class="cp">    print &quot;Parent Pid $$ just read this: `$line&#39;\n&quot;;</span>
<span class="cp">    close CHILD_RDR; close CHILD_WTR;</span>
<span class="cp">    waitpid($pid,0);</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    close CHILD_RDR; close CHILD_WTR;</span>
<span class="cp">    chomp($line = &lt;PARENT_RDR&gt;);</span>
<span class="cp">    print &quot;Child Pid $$ just read this: `$line&#39;\n&quot;;</span>
<span class="cp">    print PARENT_WTR &quot;Child Pid $$ is sending this\n&quot;;</span>
<span class="cp">    close PARENT_RDR; close PARENT_WTR;</span>
<span class="cp">    exit;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/pipe6</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># pipe6 - bidirectional communication using socketpair</span>
<span class="cp">#   &quot;the best ones always go both ways&quot;</span>

<span class="cp">use Socket;</span>
<span class="cp">use IO::Handle;</span>
<span class="cp"># We say AF_UNIX because although *_LOCAL is the</span>
<span class="cp"># POSIX 1003.1g form of the constant, many machines</span>
<span class="cp"># still don&#39;t have it.</span>
<span class="cp">socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)</span>
<span class="cp">    or  die &quot;socketpair: $!&quot;;</span>

<span class="cp">CHILD-&gt;autoflush(1);</span>
<span class="cp">PARENT-&gt;autoflush(1);</span>

<span class="cp">if ($pid = fork) {</span>
<span class="cp">    close PARENT;</span>
<span class="cp">    print CHILD &quot;Parent Pid $$ is sending this\n&quot;;</span>
<span class="cp">    chomp($line = &lt;CHILD&gt;);</span>
<span class="cp">    print &quot;Parent Pid $$ just read this: `$line&#39;\n&quot;;</span>
<span class="cp">    close CHILD;</span>
<span class="cp">    waitpid($pid,0);</span>
<span class="cp">} else {</span>
<span class="cp">    die &quot;cannot fork: $!&quot; unless defined $pid;</span>
<span class="cp">    close CHILD;</span>
<span class="cp">    chomp($line = &lt;PARENT&gt;);</span>
<span class="cp">    print &quot;Child Pid $$ just read this: `$line&#39;\n&quot;;</span>
<span class="cp">    print PARENT &quot;Child Pid $$ is sending this\n&quot;;</span>
<span class="cp">    close PARENT;</span>
<span class="cp">    exit;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">socketpair(READER, WRITER, AF_UNIX, SOCK_STREAM, PF_UNSPEC);</span>
<span class="cp">shutdown(READER, 1);        # no more writing for reader</span>
<span class="cp">shutdown(WRITER, 0);        # no more reading for writer</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% mkfifo /path/to/named.pipe</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FIFO, &quot;&lt; /path/to/named.pipe&quot;)         or die $!;</span>
<span class="cp">while (&lt;FIFO&gt;) {</span>
<span class="cp">    print &quot;Got: $_&quot;;</span>
<span class="cp">}</span>
<span class="cp">close(FIFO);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(FIFO, &quot;&gt; /path/to/named.pipe&quot;)         or die $!;</span>
<span class="cp">print FIFO &quot;Smoke this.\n&quot;;</span>
<span class="cp">close(FIFO);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% mkfifo ~/.plan                    # isn&#39;t this everywhere yet?</span>
<span class="cp">#% mknod  ~/.plan p                  # in case you don&#39;t have mkfifo</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/dateplan</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># dateplan - place current date and time in .plan file</span>
<span class="cp">while (1) {</span>
<span class="cp">    open(FIFO, &quot;&gt; $ENV{HOME}/.plan&quot;)</span>
<span class="cp">        or die &quot;Couldn&#39;t open $ENV{HOME}/.plan for writing: $!\n&quot;;</span>
<span class="cp">    print FIFO &quot;The current time is &quot;, scalar(localtime), &quot;\n&quot;;</span>
<span class="cp">    close FIFO;</span>
<span class="cp">    sleep 1;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/fifolog</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># fifolog - read and record log msgs from fifo</span>

<span class="cp">use IO::File;</span>

<span class="cp">$SIG{ALRM} = sub { close(FIFO) };   # move on to the next queued process</span>

<span class="cp">while (1) {</span>
<span class="cp">    alarm(0);                       # turn off alarm for blocking open</span>
<span class="cp">    open(FIFO, &quot;&lt; /tmp/log&quot;)        or die &quot;Can&#39;t open /tmp/log : $!\n&quot;;</span>
<span class="cp">    alarm(1);                       # you have 1 second to log</span>

<span class="cp">    $service = &lt;FIFO&gt;;</span>
<span class="cp">    next unless defined $service;   # interrupted or nothing logged</span>
<span class="cp">    chomp $service;</span>

<span class="cp">    $message = &lt;FIFO&gt;;</span>
<span class="cp">    next unless defined $message;   # interrupted or nothing logged</span>
<span class="cp">    chomp $message;</span>

<span class="cp">    alarm(0);                       # turn off alarms for message processing</span>

<span class="cp">    if ($service eq &quot;http&quot;) {</span>
<span class="cp">        # ignoring</span>
<span class="cp">    } elsif ($service eq &quot;login&quot;) {</span>
<span class="cp">        # log to /var/log/login</span>
<span class="cp">        if ( open(LOG, &quot;&gt;&gt; /tmp/login&quot;) ) {</span>
<span class="cp">            print LOG scalar(localtime), &quot; $service $message\n&quot;;</span>
<span class="cp">            close(LOG);</span>
<span class="cp">        } else {</span>
<span class="cp">            warn &quot;Couldn&#39;t log $service $message to /var/log/login : $!\n&quot;;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(:errno_h);</span>

<span class="cp">$SIG{PIPE} = &#39;IGNORE&#39;;</span>
<span class="cp"># ...</span>
<span class="cp">$status = print FIFO &quot;Are you there?\n&quot;;</span>
<span class="cp">if (!$status &amp;&amp; $! == EPIPE) {</span>
<span class="cp">    warn &quot;My reader has forsaken me!\n&quot;;</span>
<span class="cp">    next;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX;</span>
<span class="cp">print _POSIX_PIPE_BUF, &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/sharetest</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl </span>
<span class="cp"># sharetest - test shared variables across forks</span>
<span class="cp">use IPC::Shareable;</span>

<span class="cp">$handle = tie $buffer, &#39;IPC::Shareable&#39;, undef, { destroy =&gt; 1 };</span>
<span class="cp">$SIG{INT} = sub { die &quot;$$ dying\n&quot; };</span>

<span class="cp">for (1 .. 10) { </span>
<span class="cp">    unless ($child = fork) {        # i&#39;m the child</span>
<span class="cp">        die &quot;cannot fork: $!&quot; unless defined $child;</span>
<span class="cp">        squabble();</span>
<span class="cp">        exit;</span>
<span class="cp">    } </span>
<span class="cp">    push @kids, $child;  # in case we care about their pids</span>
<span class="cp">}</span>

<span class="cp">while (1) {</span>
<span class="cp">    print &quot;Buffer is $buffer\n&quot;;</span>
<span class="cp">    sleep 1;</span>
<span class="cp">} </span>
<span class="cp">die &quot;Not reached&quot;;</span>

<span class="cp">sub squabble {</span>
<span class="cp">    my $i = 0;</span>
<span class="cp">    while (1) { </span>
<span class="cp">        next if $buffer =~ /^$$\b/o;  </span>
<span class="cp">        $handle-&gt;shlock();</span>
<span class="cp">        $i++;</span>
<span class="cp">        $buffer = &quot;$$ $i&quot;;</span>
<span class="cp">        $handle-&gt;shunlock();</span>
<span class="cp">    }</span>
<span class="cp">} </span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% kill -l</span>
<span class="cp">#HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE </span>
<span class="cp">#</span>
<span class="cp">#ALRM TERM CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM </span>
<span class="cp">#</span>
<span class="cp">#PROF WINCH POLL PWR</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -e &#39;print join(&quot; &quot;, keys %SIG), &quot;\n&quot;&#39;</span>
<span class="cp">#XCPU ILL QUIT STOP EMT ABRT BUS USR1 XFSZ TSTP INT IOT USR2 INFO TTOU</span>
<span class="cp">#</span>
<span class="cp">#ALRM KILL HUP URG PIPE CONT SEGV VTALRM PROF TRAP IO TERM WINCH CHLD</span>
<span class="cp">#</span>
<span class="cp">#FPE TTIN SYS</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -MConfig -e &#39;print $Config{sig_name}&#39;</span>
<span class="cp">#ZERO HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM</span>
<span class="cp">#</span>
<span class="cp">#TERM URG STOP TSTP CONT CHLD TTIN TTOU IO XCPU XFSZ VTALRM PROF WINCH</span>
<span class="cp">#</span>
<span class="cp">#INFO USR1 USR2 IOT</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Config;</span>
<span class="cp">defined $Config{sig_name} or die &quot;No sigs?&quot;;</span>
<span class="cp">$i = 0;                     # Config prepends fake 0 signal called &quot;ZERO&quot;.</span>
<span class="cp">foreach $name (split(&#39; &#39;, $Config{sig_name})) {</span>
<span class="cp">    $signo{$name} = $i;</span>
<span class="cp">    $signame[$i] = $name;</span>
<span class="cp">    $i++;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">kill  9     =&gt; $pid;                    # send $pid a signal 9</span>
<span class="cp">kill -1     =&gt; $pgrp;                   # send whole job a signal 1</span>
<span class="cp">kill  USR1  =&gt; $$;                      # send myself a SIGUSR1</span>
<span class="cp">kill  HUP   =&gt; @pids;                   # send a SIGHUP to processes in @pids</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(:errno_h);</span>

<span class="cp">if (kill 0 =&gt; $minion) {</span>
<span class="cp">    print &quot;$minion is alive!\n&quot;;</span>
<span class="cp">} elsif ($! == EPERM) {             # changed uid</span>
<span class="cp">    print &quot;$minion has escaped my control!\n&quot;;</span>
<span class="cp">} elsif ($! == ESRCH) {</span>
<span class="cp">    print &quot;$minion is deceased.\n&quot;;  # or zombied</span>
<span class="cp">} else {</span>
<span class="cp">    warn &quot;Odd; I couldn&#39;t check on the status of $minion: $!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SIG{QUIT} = \&amp;got_sig_quit;     # call &amp;got_sig_quit for every SIGQUIT </span>
<span class="cp">$SIG{PIPE} = &#39;got_sig_pipe&#39;;     # call main::got_sig_pipe for every SIGPIPE </span>
<span class="cp">$SIG{INT}  = sub { $ouch++ };    # increment $ouch for every SIGINT</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SIG{INT} = &#39;IGNORE&#39;;            # ignore the signal INT</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SIG{STOP} = &#39;DEFAULT&#39;;          # restore default STOP signal handling</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># the signal handler</span>
<span class="cp">sub ding {</span>
<span class="cp">    $SIG{INT} = \&amp;ding;</span>
<span class="cp">    warn &quot;\aEnter your name!\n&quot;;</span>
<span class="cp">}</span>

<span class="cp"># prompt for name, overriding SIGINT</span>
<span class="cp">sub get_name {</span>
<span class="cp">    local $SIG{INT} = \&amp;ding;</span>
<span class="cp">    my $name;</span>

<span class="cp">    print &quot;Kindly Stranger, please enter your name: &quot;;</span>
<span class="cp">    chomp( $name = &lt;&gt; );</span>
<span class="cp">    return $name;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SIG{INT} = \&amp;got_int;</span>
<span class="cp">sub got_int {</span>
<span class="cp">    $SIG{INT} = \&amp;got_int;          # but not for SIGCHLD!</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">my $interrupted = 0;</span>

<span class="cp">sub got_int {</span>
<span class="cp">    $interrupted = 1;</span>
<span class="cp">    $SIG{INT} = &#39;DEFAULT&#39;;          # or &#39;IGNORE&#39;</span>
<span class="cp">    die;</span>
<span class="cp">}</span>

<span class="cp">eval {</span>
<span class="cp">    $SIG{INT} = \&amp;got_int;</span>
<span class="cp">    # ... long-running code that you don&#39;t want to restart</span>
<span class="cp">};</span>

<span class="cp">if ($interrupted) {</span>
<span class="cp">    # deal with the signal</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SIG{INT} = \&amp;catcher;</span>
<span class="cp">sub catcher {</span>
<span class="cp">    $SIG{INT} = \&amp;catcher;</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Config;</span>
<span class="cp">print &quot;Hurrah!\n&quot; if $Config{d_sigaction};</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% egrep &#39;S[AV]_(RESTART|INTERRUPT)&#39; /usr/include/*/signal.h</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SIG{INT} = &#39;IGNORE&#39;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SIG{INT} = \&amp;tsktsk;</span>

<span class="cp">sub tsktsk {</span>
<span class="cp">    $SIG{INT} = \&amp;tsktsk;           # See ``Writing A Signal Handler&#39;&#39;</span>
<span class="cp">    warn &quot;\aThe long habit of living indisposeth us for dying.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% stty -a</span>
<span class="cp">#speed 9600 baud; 38 rows; 80 columns;</span>
<span class="cp">#</span>
<span class="cp">#lflags: icanon isig iexten echo echoe -echok echoke -echonl echoctl</span>
<span class="cp">#</span>
<span class="cp">#	-echoprt -altwerase -noflsh -tostop -flusho pendin -nokerninfo</span>
<span class="cp">#</span>
<span class="cp">#	-extproc</span>
<span class="cp">#</span>
<span class="cp">#iflags: -istrip icrnl -inlcr -igncr ixon -ixoff ixany imaxbel -ignbrk</span>
<span class="cp">#</span>
<span class="cp">#	 brkint -inpck -ignpar -parmrk</span>
<span class="cp">#</span>
<span class="cp">#oflags: opost onlcr oxtabs</span>
<span class="cp">#</span>
<span class="cp">#cflags: cread cs8 -parenb -parodd hupcl -clocal -cstopb -crtscts -dsrflow</span>
<span class="cp">#</span>
<span class="cp">#	 -dtrflow -mdmbuf</span>
<span class="cp">#</span>
<span class="cp">#cchars: discard = ^O; dsusp = ^Y; eof = ^D; eol = &lt;undef;&gt;</span>
<span class="cp">#</span>
<span class="cp">#	 eol2 = &lt;undef; erase = ^H; intr = ^C; kill = ^U; lnext = ^V;&gt;</span>
<span class="cp">#</span>
<span class="cp">#	 min = 1; quit = ^\; reprint = ^R; start = ^Q; status = &lt;undef;&gt;</span>
<span class="cp">#</span>
<span class="cp">#	 stop = ^S; susp = ^Z; time = 0; werase = ^W;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.19</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SIG{CHLD} = &#39;IGNORE&#39;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX &quot;:sys_wait_h&quot;;</span>

<span class="cp">$SIG{CHLD} = \&amp;REAPER;</span>
<span class="cp">sub REAPER {</span>
<span class="cp">    my $stiff;</span>
<span class="cp">    while (($stiff = waitpid(-1, &amp;WNOHANG)) &gt; 0) {</span>
<span class="cp">        # do something with $stiff if you want</span>
<span class="cp">    }</span>
<span class="cp">    $SIG{CHLD} = \&amp;REAPER;                  # install *after* calling waitpid</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$exit_value  = $? &gt;&gt; 8;</span>
<span class="cp">$signal_num  = $? &amp; 127;</span>
<span class="cp">$dumped_core = $? &amp; 128;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(:signal_h :errno_h :sys_wait_h);</span>

<span class="cp">$SIG{CHLD} = \&amp;REAPER;</span>
<span class="cp">sub REAPER {</span>
<span class="cp">    my $pid;</span>

<span class="cp">    $pid = waitpid(-1, &amp;WNOHANG);</span>

<span class="cp">    if ($pid == -1) {</span>
<span class="cp">        # no child waiting.  Ignore it.</span>
<span class="cp">    } elsif (WIFEXITED($?)) {</span>
<span class="cp">        print &quot;Process $pid exited.\n&quot;;</span>
<span class="cp">    } else {</span>
<span class="cp">        print &quot;False alarm on $pid.\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    $SIG{CHLD} = \&amp;REAPER;          # in case of unreliable signals</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Config;</span>
<span class="cp">$has_nonblocking = $Config{d_waitpid} eq &quot;define&quot; ||</span>
<span class="cp">                   $Config{d_wait4}   eq &quot;define&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.20</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(:signal_h);</span>

<span class="cp">$sigset = POSIX::SigSet-&gt;new(SIGINT);    # define the signals to block</span>
<span class="cp">$old_sigset = POSIX::SigSet-&gt;new;        # where the old sigmask will be kept</span>

<span class="cp">unless (defined sigprocmask(SIG_BLOCK, $sigset, $old_sigset)) {</span>
<span class="cp">    die &quot;Could not block SIGINT\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unless (defined sigprocmask(SIG_UNBLOCK, $old_sigset)) {</span>
<span class="cp">    die &quot;Could not unblock SIGINT\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(:signal_h);</span>

<span class="cp">$sigset = POSIX::SigSet-&gt;new( SIGINT, SIGKILL );</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.21</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SIG{ALRM} = sub { die &quot;timeout&quot; };</span>

<span class="cp">eval {</span>
<span class="cp">    alarm(3600);</span>
<span class="cp">    # long-time operations here</span>
<span class="cp">    alarm(0);</span>
<span class="cp">};</span>

<span class="cp">if ($@) {</span>
<span class="cp">    if ($@ =~ /timeout/) {</span>
<span class="cp">                            # timed out; do what you will here</span>
<span class="cp">    } else {</span>
<span class="cp">        alarm(0);           # clear the still-pending alarm</span>
<span class="cp">        die;                # propagate unexpected exception</span>
<span class="cp">    } </span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_16.22</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Make is like Pascal: everybody likes it, so they go in and change it.</span>
<span class="cp">#					     --Dennis Ritchie</span>
<span class="cp">#%%</span>
<span class="cp">#I eschew embedded capital letters in names; to my prose-oriented eyes,</span>
<span class="cp">#they are too awkward to read comfortably. They jangle like bad typography.</span>
<span class="cp">#					     --Rob Pike</span>
<span class="cp">#%%</span>
<span class="cp">#God made the integers; all else is the work of Man.  </span>
<span class="cp">#					     --Kronecker</span>
<span class="cp">#%%</span>
<span class="cp">#I&#39;d rather have :rofix than const.          --Dennis Ritchie</span>
<span class="cp">#%%</span>
<span class="cp">#If you want to program in C, program in C.  It&#39;s a nice language.</span>
<span class="cp">#I use it occasionally...   :-)              --Larry Wall</span>
<span class="cp">#%%</span>
<span class="cp">#Twisted cleverness is my only skill as a programmer.       </span>
<span class="cp">#					     --Elizabeth Zwicky</span>
<span class="cp">#%%</span>
<span class="cp">#Basically, avoid comments. If your code needs a comment to be understood,</span>
<span class="cp">#it would be better to rewrite it so it&#39;s easier to understand.  </span>
<span class="cp">#					     --Rob Pike</span>
<span class="cp">#%%</span>
<span class="cp">#Comments on data are usually much more helpful than on algorithms.  </span>
<span class="cp">#					     --Rob Pike</span>
<span class="cp">#%% </span>
<span class="cp">#Programs that write programs are the happiest programs in the world.</span>
<span class="cp">#					     --Andrew Hume </span>
<span class="cp">#%%</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch16/sigrand</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># sigrand - supply random fortunes for .signature file</span>

<span class="cp">use strict;</span>

<span class="cp"># config section variables</span>
<span class="cp">use vars qw( $NG_IS_DIR $MKNOD $FULLNAME $FIFO $ART $NEWS $SIGS $SEMA</span>
<span class="cp">    	        $GLOBRAND $NAME );</span>

<span class="cp"># globals</span>
<span class="cp">use vars qw( $Home $Fortune_Path @Pwd );</span>

<span class="cp">################################################################</span>
<span class="cp"># begin configuration section </span>
<span class="cp"># should really read from ~/.sigrandrc</span>

<span class="cp">gethome();</span>

<span class="cp"># for rec/humor/funny instead of rec.humor.funny</span>
<span class="cp">$NG_IS_DIR      = 1;    </span>

<span class="cp">$MKNOD          = &quot;/bin/mknod&quot;;</span>
<span class="cp">$FULLNAME       = &quot;$Home/.fullname&quot;;</span>
<span class="cp">$FIFO           = &quot;$Home/.signature&quot;;</span>
<span class="cp">$ART            = &quot;$Home/.article&quot;;</span>
<span class="cp">$NEWS           = &quot;$Home/News&quot;;</span>
<span class="cp">$SIGS           = &quot;$NEWS/SIGNATURES&quot;;</span>
<span class="cp">$SEMA           = &quot;$Home/.sigrandpid&quot;;</span>
<span class="cp">$GLOBRAND       = 1/4;  # chance to use global sigs anyway</span>

<span class="cp"># $NAME should be (1) left undef to have program guess</span>
<span class="cp"># read address for signature maybe looking in ~/.fullname,</span>
<span class="cp"># (2) set to an exact address, or (3) set to empty string</span>
<span class="cp"># to be omitted entirely.</span>

<span class="cp">$NAME           = &#39;&#39;;           # means no name used</span>
<span class="cp">## $NAME        = &quot;me\@home.org\n&quot;;     </span>

<span class="cp"># end configuration section -- HOME and FORTUNE get autoconf&#39;d</span>
<span class="cp">################################################################</span>

<span class="cp">setup();                # pull in inits</span>
<span class="cp">justme();               # make sure program not already running</span>
<span class="cp">fork &amp;&amp; exit;           # background ourself and go away</span>

<span class="cp">open (SEMA, &quot;&gt; $SEMA&quot;)      	or die &quot;can&#39;t write $SEMA: $!&quot;;</span>
<span class="cp">print SEMA &quot;$$\n&quot;;</span>
<span class="cp">close(SEMA)                 	or die &quot;can&#39;t close $SEMA: $!&quot;;</span>

<span class="cp"># now loop forever, writing a signature into the </span>
<span class="cp"># fifo file.  if you don&#39;t have real fifos, change</span>
<span class="cp"># sleep time at bottom of loop to like 10 to update</span>
<span class="cp"># only every 10 seconds.</span>
<span class="cp">for (;;) {</span>
<span class="cp">    open (FIFO, &quot;&gt; $FIFO&quot;)		or die &quot;can&#39;t write $FIFO: $!&quot;;</span>
<span class="cp">    my $sig = pick_quote();</span>
<span class="cp">    for ($sig) { </span>
<span class="cp">        s/^((:?[^\n]*\n){4}).*$/$1/s;   # trunc to 4 lines</span>
<span class="cp">        s/^(.{1,80}).*? *$/$1/gm;       # trunc long lines</span>
<span class="cp">    }</span>
<span class="cp">    # print sig, with name if present, padded to four lines</span>
<span class="cp">    if ($NAME) { </span>
<span class="cp">        print FIFO $NAME, &quot;\n&quot; x (3 - ($sig =~ tr/\n//)), $sig;</span>
<span class="cp">    } else {</span>
<span class="cp">        print FIFO $sig;</span>
<span class="cp">    }</span>
<span class="cp">    close FIFO;</span>

<span class="cp">    # Without a microsleep, the reading process doesn&#39;t finish before</span>
<span class="cp">    # the writer tries to open it again, which since the reader exists,</span>
<span class="cp">    # succeeds.  They end up with multiple signatures.  Sleep a tiny bit</span>
<span class="cp">    # between opens to give readers a chance to finish reading and close</span>
<span class="cp">    # our pipe so we can block when opening it the next time.</span>

<span class="cp">    select(undef, undef, undef, 0.2);   # sleep 1/5 second</span>
<span class="cp">}</span>
<span class="cp">die &quot;XXX: NOT REACHED&quot;;         # you can&#39;t get here from anywhere</span>

<span class="cp">################################################################</span>

<span class="cp"># Ignore SIGPIPE in case someone opens us up and then closes the fifo</span>
<span class="cp"># without reading it; look in a .fullname file for their login name.</span>
<span class="cp"># Try to determine the fully qualified hostname.  Look our for silly</span>
<span class="cp"># ampersands in passwd entries.  Make sure we have signatures or fortunes.</span>
<span class="cp"># Build a fifo if we need to.</span>

<span class="cp">sub setup {</span>
<span class="cp">    $SIG{PIPE} = &#39;IGNORE&#39;;              </span>

<span class="cp">    unless (defined $NAME) {            # if $NAME undef in config</span>
<span class="cp">        if (-e $FULLNAME) {</span>
<span class="cp">    	        $NAME = `cat $FULLNAME`;</span>
<span class="cp">    	        die &quot;$FULLNAME should contain only 1 line, aborting&quot; </span>
<span class="cp">    	            if $NAME =~ tr/\n// &gt; 1;</span>
<span class="cp">        } else {</span>
<span class="cp">    	        my($user, $host);</span>
<span class="cp">    	        chop($host = `hostname`);</span>
<span class="cp">    	        ($host) = gethostbyname($host) unless $host =~ /\./;</span>
<span class="cp">    	        $user = $ENV{USER} || $ENV{LOGNAME} || $Pwd[0]</span>
<span class="cp">    	            or die &quot;intruder alert&quot;;</span>
<span class="cp">    	        ($NAME = $Pwd[6]) =~ s/,.*//;</span>
<span class="cp">    	        $NAME =~ s/&amp;/\u\L$user/g; # can&#39;t believe some folks still do this</span>
<span class="cp">    	        $NAME = &quot;\t$NAME\t$user\@$host\n&quot;;</span>
<span class="cp">        } </span>
<span class="cp">    }</span>

<span class="cp">    check_fortunes() if !-e $SIGS;</span>

<span class="cp">    unless (-p $FIFO) {         # -p checks whether it&#39;s a named pipe</span>
<span class="cp">        if (!-e _) {</span>
<span class="cp">    	         system(&quot;$MKNOD $FIFO p&quot;) &amp;&amp; die &quot;can&#39;t mknod $FIFO&quot;;</span>
<span class="cp">    	         warn &quot;created $FIFO as a named pipe\n&quot;;</span>
<span class="cp">        } else {</span>
<span class="cp">    	         die &quot;$0: won&#39;t overwrite file .signature\n&quot;;</span>
<span class="cp">        } </span>
<span class="cp">    } else {</span>
<span class="cp">        warn &quot;$0: using existing named pipe $FIFO\n&quot;;</span>
<span class="cp">    } </span>

<span class="cp">    # get a good random number seed.  not needed if 5.004 or better.</span>
<span class="cp">    srand(time() ^ ($$ + ($$ &lt;&lt; 15)));</span>
<span class="cp">}</span>

<span class="cp"># choose a random signature</span>
<span class="cp">sub pick_quote {</span>
<span class="cp">    my $sigfile = signame();</span>
<span class="cp">    if (!-e $sigfile) {</span>
<span class="cp">        return fortune();</span>
<span class="cp">    } </span>
<span class="cp">    open (SIGS, &quot;&lt; $sigfile&quot; )		or die &quot;can&#39;t open $sigfile&quot;;</span>
<span class="cp">    local $/  = &quot;%%\n&quot;;</span>
<span class="cp">    local $_;</span>
<span class="cp">    my $quip;</span>
<span class="cp">    rand($.) &lt; 1 &amp;&amp; ($quip = $_) while &lt;SIGS&gt;;</span>
<span class="cp">    close SIGS;</span>
<span class="cp">    chomp $quip;</span>
<span class="cp">    return $quip || &quot;ENOSIG: This signature file is empty.\n&quot;;</span>
<span class="cp">} </span>

<span class="cp"># See whether ~/.article contains a Newsgroups line.  if so, see the first</span>
<span class="cp"># group posted to and find out whether it has a dedicated set of fortunes.</span>
<span class="cp"># otherwise return the global one.  also, return the global one randomly</span>
<span class="cp"># now and then to spice up the sigs.</span>
<span class="cp">sub signame {</span>
<span class="cp">     (rand(1.0) &gt; ($GLOBRAND) &amp;&amp; open ART) || return $SIGS;   </span>
<span class="cp">     local $/  = &#39;&#39;;</span>
<span class="cp">     local $_  = &lt;ART&gt;;</span>
<span class="cp">     my($ng)   = /Newsgroups:\s*([^,\s]*)/;</span>
<span class="cp">     $ng =~ s!\.!/!g if $NG_IS_DIR;     # if rn -/,  or SAVEDIR=%p/%c</span>
<span class="cp">     $ng = &quot;$NEWS/$ng/SIGNATURES&quot;;</span>
<span class="cp">     return -f $ng ? $ng : $SIGS;</span>
<span class="cp">} </span>

<span class="cp"># Call the fortune program with -s for short flag until</span>
<span class="cp"># we get a small enough fortune or ask too much.</span>
<span class="cp">sub fortune {</span>
<span class="cp">   local $_;</span>
<span class="cp">   my $tries = 0;</span>
<span class="cp">   do { </span>
<span class="cp">       $_ = `$Fortune_Path -s`; </span>
<span class="cp">   } until tr/\n// &lt; 5 || $tries++ &gt; 20;</span>
<span class="cp">   s/^/ /mg;</span>
<span class="cp">   $_ || &quot; SIGRAND: deliver random signals to all processes.\n&quot;;</span>
<span class="cp">} </span>

<span class="cp"># Make sure there&#39;s a fortune program.  Search </span>
<span class="cp"># for its full path and set global to that.</span>
<span class="cp">sub check_fortunes {</span>
<span class="cp">    return if $Fortune_Path;    # already set</span>
<span class="cp">    for my $dir (split(/:/, $ENV{PATH}), &#39;/usr/games&#39;) {</span>
<span class="cp">        return if -x ($Fortune_Path = &quot;$dir/fortune&quot;);</span>
<span class="cp">    } </span>
<span class="cp">    die &quot;Need either $SIGS or a fortune program, bailing out&quot;;</span>
<span class="cp">} </span>

<span class="cp"># figure out our directory</span>
<span class="cp">sub gethome {</span>
<span class="cp">    @Pwd = getpwuid($&lt;);</span>
<span class="cp">    $Home = $ENV{HOME} || $ENV{LOGDIR} || $Pwd[7]</span>
<span class="cp">    		   or die &quot;no home directory for user $&lt;&quot;;</span>
<span class="cp">}</span>

<span class="cp"># &quot;There can be only one.&quot;  --the Highlander</span>
<span class="cp">sub justme {</span>
<span class="cp">    if (open SEMA) {</span>
<span class="cp">        my $pid;</span>
<span class="cp">        chop($pid = &lt;SEMA&gt;);</span>
<span class="cp">        kill(0, $pid)		and die &quot;$0 already running (pid $pid), bailing out&quot;;</span>
<span class="cp">        close SEMA;</span>
<span class="cp">    } </span>
<span class="cp">} </span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">$packed_ip   = inet_aton(&quot;208.146.240.1&quot;);</span>
<span class="cp">$socket_name = sockaddr_in($port, $packed_ip);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">$socket_name = sockaddr_un(&quot;/tmp/mysock&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($port, $packed_ip) = sockaddr_in($socket_name);    # for PF_INET sockets</span>
<span class="cp">($filename)         = sockaddr_un($socket_name);    # for PF_UNIX sockets</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ip_address = inet_ntoa($packed_ip);</span>
<span class="cp">$packed_ip  = inet_aton(&quot;204.148.40.9&quot;);</span>
<span class="cp">$packed_ip  = inet_aton(&quot;www.oreilly.com&quot;);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Socket;</span>

<span class="cp">$socket = IO::Socket::INET-&gt;new(PeerAddr =&gt; $remote_host,</span>
<span class="cp">                                PeerPort =&gt; $remote_port,</span>
<span class="cp">                                Proto    =&gt; &quot;tcp&quot;,</span>
<span class="cp">                                Type     =&gt; SOCK_STREAM)</span>
<span class="cp">    or die &quot;Couldn&#39;t connect to $remote_host:$remote_port : $@\n&quot;;</span>

<span class="cp"># ... do something with the socket</span>
<span class="cp">print $socket &quot;Why don&#39;t you call me anymore?\n&quot;;</span>

<span class="cp">$answer = &lt;$socket&gt;;</span>

<span class="cp"># and terminate the connection when we&#39;re done</span>
<span class="cp">close($socket);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp"># create a socket</span>
<span class="cp">socket(TO_SERVER, PF_INET, SOCK_STREAM, getprotobyname(&#39;tcp&#39;));</span>

<span class="cp"># build the address of the remote machine</span>
<span class="cp">$internet_addr = inet_aton($remote_host)</span>
<span class="cp">    or die &quot;Couldn&#39;t convert $remote_host into an Internet address: $!\n&quot;;</span>
<span class="cp">$paddr = sockaddr_in($remote_port, $internet_addr);</span>

<span class="cp"># connect</span>
<span class="cp">connect(TO_SERVER, $paddr)</span>
<span class="cp">    or die &quot;Couldn&#39;t connect to $remote_host:$remote_port : $!\n&quot;;</span>

<span class="cp"># ... do something with the socket</span>
<span class="cp">print TO_SERVER &quot;Why don&#39;t you call me anymore?\n&quot;;</span>

<span class="cp"># and terminate the connection when we&#39;re done</span>
<span class="cp">close(TO_SERVER);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$client = IO::Socket::INET-&gt;new(&quot;www.yahoo.com:80&quot;)</span>
<span class="cp">    or die $@;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$s = IO::Socket::INET-&gt;new(PeerAddr =&gt; &quot;Does not Exist&quot;,</span>
<span class="cp">                           Peerport =&gt; 80,</span>
<span class="cp">                           Type     =&gt; SOCK_STREAM )</span>
<span class="cp">    or die $@;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$s = IO::Socket::INET-&gt;new(PeerAddr =&gt; &quot;bad.host.com&quot;,</span>
<span class="cp">                           PeerPort =&gt; 80,</span>
<span class="cp">                           Type     =&gt; SOCK_STREAM,</span>
<span class="cp">                           Timeout  =&gt; 5 )</span>
<span class="cp">    or die $@;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$inet_addr = inet_aton(&quot;208.146.240.1&quot;);</span>
<span class="cp">$paddr     = sockaddr_in($port, $inet_addr);</span>
<span class="cp">bind(SOCKET, $paddr)         or die &quot;bind: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$inet_addr = gethostbyname(&quot;www.yahoo.com&quot;)</span>
<span class="cp">                            or die &quot;Can&#39;t resolve www.yahoo.com: $!&quot;;</span>
<span class="cp">$paddr     = sockaddr_in($port, $inet_addr);</span>
<span class="cp">bind(SOCKET, $paddr)        or die &quot;bind: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Socket;</span>

<span class="cp">$server = IO::Socket::INET-&gt;new(LocalPort =&gt; $server_port,</span>
<span class="cp">                                Type      =&gt; SOCK_STREAM,</span>
<span class="cp">                                Reuse     =&gt; 1,</span>
<span class="cp">                                Listen    =&gt; 10 )   # or SOMAXCONN</span>
<span class="cp">    or die &quot;Couldn&#39;t be a tcp server on port $server_port : $@\n&quot;;</span>

<span class="cp">while ($client = $server-&gt;accept()) {</span>
<span class="cp">    # $client is the new connection</span>
<span class="cp">}</span>

<span class="cp">close($server);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp"># make the socket</span>
<span class="cp">socket(SERVER, PF_INET, SOCK_STREAM, getprotobyname(&#39;tcp&#39;));</span>

<span class="cp"># so we can restart our server quickly</span>
<span class="cp">setsockopt(SERVER, SOL_SOCKET, SO_REUSEADDR, 1);</span>

<span class="cp"># build up my socket address</span>
<span class="cp">$my_addr = sockaddr_in($server_port, INADDR_ANY);</span>
<span class="cp">bind(SERVER, $my_addr)</span>
<span class="cp">    or die &quot;Couldn&#39;t bind to port $server_port : $!\n&quot;;</span>

<span class="cp"># establish a queue for incoming connections</span>
<span class="cp">listen(SERVER, SOMAXCONN)</span>
<span class="cp">    or die &quot;Couldn&#39;t listen on port $server_port : $!\n&quot;;</span>

<span class="cp"># accept and process connections</span>
<span class="cp">while (accept(CLIENT, SERVER)) {</span>
<span class="cp">    # do something with CLIENT</span>
<span class="cp">}</span>

<span class="cp">close(SERVER);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">while ($client_address = accept(CLIENT, SERVER)) {</span>
<span class="cp">    ($port, $packed_ip) = sockaddr_in($client_address);</span>
<span class="cp">    $dotted_quad = inet_ntoa($packed_ip);</span>
<span class="cp">    # do as thou wilt</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while ($client = $server-&gt;accept()) {</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (($client,$client_address) = $server-&gt;accept()) {</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);</span>

<span class="cp">$flags = fcntl(SERVER, F_GETFL, 0)</span>
<span class="cp">            or die &quot;Can&#39;t get flags for the socket: $!\n&quot;;</span>

<span class="cp">$flags = fcntl(SERVER, F_SETFL, $flags | O_NONBLOCK)</span>
<span class="cp">            or die &quot;Can&#39;t set flags for the socket: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print SERVER &quot;What is your name?\n&quot;;</span>
<span class="cp">chomp ($response = &lt;SERVER&gt;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">defined (send(SERVER, $data_to_send, $flags))</span>
<span class="cp">    or die &quot;Can&#39;t send : $!\n&quot;;</span>

<span class="cp">recv(SERVER, $data_read, $maxlen, $flags)</span>
<span class="cp">    or die &quot;Can&#39;t receive: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Socket;</span>

<span class="cp">$server-&gt;send($data_to_send, $flags)</span>
<span class="cp">    or die &quot;Can&#39;t send: $!\n&quot;;</span>

<span class="cp">$server-&gt;recv($data_read, $flags)</span>
<span class="cp">    or die &quot;Can&#39;t recv: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Select;</span>

<span class="cp">$select = IO::Select-&gt;new();</span>
<span class="cp">$select-&gt;add(*FROM_SERVER);</span>
<span class="cp">$select-&gt;add($to_client);</span>

<span class="cp">@read_from = $select-&gt;can_read($timeout);</span>
<span class="cp">foreach $socket (@read_from) {</span>
<span class="cp">    # read the pending data from $socket</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>
<span class="cp">require &quot;sys/socket.ph&quot;;    # for &amp;TCP_NODELAY</span>

<span class="cp">setsockopt(SERVER, SOL_SOCKET, &amp;TCP_NODELAY, 1)</span>
<span class="cp">    or die &quot;Couldn&#39;t disable Nagle&#39;s algorithm: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">setsockopt(SERVER, SOL_SOCKET, &amp;TCP_NODELAY, 0)</span>
<span class="cp">    or die &quot;Couldn&#39;t enable Nagle&#39;s algorithm: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$rin = &#39;&#39;;                          # initialize bitmask</span>
<span class="cp">vec($rin, fileno(SOCKET), 1) = 1;   # mark SOCKET in $rin</span>
<span class="cp"># repeat calls to vec() for each socket to check</span>

<span class="cp">$timeout = 10;                      # wait ten seconds</span>

<span class="cp">$nfound = select($rout = $rin, undef, undef, $timeout);</span>
<span class="cp">if (vec($rout, fileno(SOCKET),1)){</span>
<span class="cp">    # data to be read on SOCKET</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>
<span class="cp">socket(SOCKET, PF_INET, SOCK_DGRAM, getprotobyname(&quot;udp&quot;)) </span>
<span class="cp">    or die &quot;socket: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Socket;</span>
<span class="cp">$handle = IO::Socket::INET-&gt;new(Proto =&gt; &#39;udp&#39;) </span>
<span class="cp">    or die &quot;socket: $@&quot;;     # yes, it uses $@ here</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ipaddr   = inet_aton($HOSTNAME);</span>
<span class="cp">$portaddr = sockaddr_in($PORTNO, $ipaddr);</span>
<span class="cp">send(SOCKET, $MSG, 0, $portaddr) == length($MSG)</span>
<span class="cp">        or die &quot;cannot send to $HOSTNAME($PORTNO): $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$portaddr = recv(SOCKET, $MSG, $MAXLEN, 0)      or die &quot;recv: $!&quot;;</span>
<span class="cp">($portno, $ipaddr) = sockaddr_in($portaddr);</span>
<span class="cp">$host = gethostbyaddr($ipaddr, AF_INET);</span>
<span class="cp">print &quot;$host($portno) said $MSG\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">send(MYSOCKET, $msg_buffer, $flags, $remote_addr)</span>
<span class="cp">    or die &quot;Can&#39;t send: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch17/clockdrift</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># clockdrift - compare another system&#39;s clock with this one</span>
<span class="cp">use strict;</span>
<span class="cp">use Socket;</span>

<span class="cp">my ($host, $him, $src, $port, $ipaddr, $ptime, $delta);</span>
<span class="cp">my $SECS_of_70_YEARS      = 2_208_988_800;</span>

<span class="cp">socket(MsgBox, PF_INET, SOCK_DGRAM, getprotobyname(&quot;udp&quot;))</span>
<span class="cp">    or die &quot;socket: $!&quot;;</span>
<span class="cp">$him = sockaddr_in(scalar(getservbyname(&quot;time&quot;, &quot;udp&quot;)), </span>
<span class="cp">    inet_aton(shift || &#39;127.1&#39;));</span>
<span class="cp">defined(send(MsgBox, 0, 0, $him))</span>
<span class="cp">    or die &quot;send: $!&quot;;</span>
<span class="cp">defined($src = recv(MsgBox, $ptime, 4, 0))</span>
<span class="cp">    or die &quot;recv: $!&quot;;</span>
<span class="cp">($port, $ipaddr) = sockaddr_in($src);</span>
<span class="cp">$host = gethostbyaddr($ipaddr, AF_INET);</span>
<span class="cp">my $delta = (unpack(&quot;N&quot;, $ptime) - $SECS_of_70_YEARS) - time();</span>
<span class="cp">print &quot;Clock on $host is $delta seconds ahead of this one.\n&quot;;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Socket;</span>
<span class="cp">$server = IO::Socket::INET-&gt;new(LocalPort =&gt; $server_port,</span>
<span class="cp">                                Proto     =&gt; &quot;udp&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t be a udp server on port $server_port : $@\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while ($him = $server-&gt;recv($datagram, $MAX_TO_READ, $flags)) {</span>
<span class="cp">    # do something</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch17/udpqofd</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># udpqotd - UDP message server</span>
<span class="cp">use strict;</span>
<span class="cp">use IO::Socket;</span>
<span class="cp">my($sock, $oldmsg, $newmsg, $hisaddr, $hishost, $MAXLEN, $PORTNO);</span>
<span class="cp">$MAXLEN = 1024;</span>
<span class="cp">$PORTNO = 5151;</span>
<span class="cp">$sock = IO::Socket::INET-&gt;new(LocalPort =&gt; $PORTNO, Proto =&gt; &#39;udp&#39;)</span>
<span class="cp">    or die &quot;socket: $@&quot;;</span>
<span class="cp">print &quot;Awaiting UDP messages on port $PORTNO\n&quot;;</span>
<span class="cp">$oldmsg = &quot;This is the starting message.&quot;;</span>
<span class="cp">while ($sock-&gt;recv($newmsg, $MAXLEN)) {</span>
<span class="cp">    my($port, $ipaddr) = sockaddr_in($sock-&gt;peername);</span>
<span class="cp">    $hishost = gethostbyaddr($ipaddr, AF_INET);</span>
<span class="cp">    print &quot;Client $hishost said ``$newmsg&#39;&#39;\n&quot;;</span>
<span class="cp">    $sock-&gt;send($oldmsg);</span>
<span class="cp">    $oldmsg = &quot;[$hishost] $newmsg&quot;;</span>
<span class="cp">} </span>
<span class="cp">die &quot;recv: $!&quot;;</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch17/udpmsg</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># udpmsg - send a message to the udpquotd server</span>

<span class="cp">use IO::Socket;</span>
<span class="cp">use strict;</span>

<span class="cp">my($sock, $server_host, $msg, $port, $ipaddr, $hishost, </span>
<span class="cp">   $MAXLEN, $PORTNO, $TIMEOUT);</span>

<span class="cp">$MAXLEN  = 1024;</span>
<span class="cp">$PORTNO  = 5151;</span>
<span class="cp">$TIMEOUT = 5;</span>

<span class="cp">$server_host = shift;</span>
<span class="cp">$msg         = &quot;@ARGV&quot;;</span>
<span class="cp">$sock = IO::Socket::INET-&gt;new(Proto     =&gt; &#39;udp&#39;,</span>
<span class="cp">                              PeerPort  =&gt; $PORTNO,</span>
<span class="cp">                              PeerAddr  =&gt; $server_host)</span>
<span class="cp">    or die &quot;Creating socket: $!\n&quot;;</span>
<span class="cp">$sock-&gt;send($msg) or die &quot;send: $!&quot;;</span>

<span class="cp">eval {</span>
<span class="cp">    local $SIG{ALRM} = sub { die &quot;alarm time out&quot; };</span>
<span class="cp">    alarm $TIMEOUT;</span>
<span class="cp">    $sock-&gt;recv($msg, $MAXLEN)      or die &quot;recv: $!&quot;;</span>
<span class="cp">    alarm 0;</span>
<span class="cp">    1;  # return value from eval on normalcy</span>
<span class="cp">} or die &quot;recv from $server_host timed out after $TIMEOUT seconds.\n&quot;;</span>

<span class="cp">($port, $ipaddr) = sockaddr_in($sock-&gt;peername);</span>
<span class="cp">$hishost = gethostbyaddr($ipaddr, AF_INET);</span>
<span class="cp">print &quot;Server $hishost responded ``$msg&#39;&#39;\n&quot;;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use IO::Socket;</span>

<span class="cp">unlink &quot;/tmp/mysock&quot;;</span>
<span class="cp">$server = IO::Socket::UNIX-&gt;new(Local     =&gt; &quot;/tmp/mysock&quot;,</span>
<span class="cp">                                Type      =&gt; SOCK_DGRAM,</span>
<span class="cp">                                Listen    =&gt; 5 )</span>
<span class="cp">    or die $@;</span>

<span class="cp">$client = IO::Socket::UNIX-&gt;new(Peer       =&gt; &quot;/tmp/mysock&quot;,</span>
<span class="cp">                                Type      =&gt; SOCK_DGRAM,</span>
<span class="cp">                                Timeout   =&gt; 10 )</span>
<span class="cp">    or die $@;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>
<span class="cp">    </span>
<span class="cp">socket(SERVER, PF_UNIX, SOCK_STREAM, 0);</span>
<span class="cp">unlink &quot;/tmp/mysock&quot;;</span>
<span class="cp">bind(SERVER, sockaddr_un(&quot;/tmp/mysock&quot;))</span>
<span class="cp">    or die &quot;Can&#39;t create server: $!&quot;;</span>

<span class="cp">socket(CLIENT, PF_UNIX, SOCK_STREAM, 0);</span>
<span class="cp">connect(CLIENT, sockaddr_un(&quot;/tmp/mysock&quot;))</span>
<span class="cp">    or die &quot;Can&#39;t connect to /tmp/mysock: $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">$other_end         = getpeername(SOCKET)</span>
<span class="cp">    or die &quot;Couldn&#39;t identify other end: $!\n&quot;;</span>
<span class="cp">($port, $iaddr)    = unpack_sockaddr_in($other_end);</span>
<span class="cp">$ip_address        = inet_ntoa($iaddr);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">$other_end        = getpeername(SOCKET)</span>
<span class="cp">    or die &quot;Couldn&#39;t identify other end: $!\n&quot;;</span>
<span class="cp">($port, $iaddr)   = unpack_sockaddr_in($other_end);</span>
<span class="cp">$actual_ip        = inet_ntoa($iaddr);</span>
<span class="cp">$claimed_hostname = gethostbyaddr($iaddr, AF_INET);</span>
<span class="cp">@name_lookup      = gethostbyname($claimed_hostname)</span>
<span class="cp">    or die &quot;Could not look up $claimed_hostname : $!\n&quot;;</span>
<span class="cp">@resolved_ips     = map { inet_ntoa($_) }</span>
<span class="cp">    @name_lookup[ 4 .. $#ips_for_hostname ];</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$packed_ip  = gethostbyname($name) or die &quot;Couldn&#39;t look up $name : $!\n&quot;;</span>
<span class="cp">$ip_address = inet_ntoa($packed_ip);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Sys::Hostname;</span>

<span class="cp">$hostname = hostname();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX qw(uname);</span>
<span class="cp">($kernel, $hostname, $release, $version, $hardware) = uname();</span>

<span class="cp">$hostname = (uname)[1];             # or just one</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;                         # for AF_INET</span>
<span class="cp">$address  = gethostbyname($hostname)</span>
<span class="cp">    or die &quot;Couldn&#39;t resolve $hostname : $!&quot;;</span>
<span class="cp">$hostname = gethostbyaddr($address, AF_INET)</span>
<span class="cp">    or die &quot;Couldn&#39;t re-resolve $hostname : $!&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">shutdown(SOCKET, 0);                # I/we have stopped reading data</span>
<span class="cp">shutdown(SOCKET, 1);                # I/we have stopped writing data</span>
<span class="cp">shutdown(SOCKET, 2);                # I/we have stopped using this socket</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$socket-&gt;shutdown(0);               # I/we have stopped reading data</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print SERVER &quot;my request\n&quot;;        # send some data</span>
<span class="cp">shutdown(SERVER, 1);                # send eof; no more writing</span>
<span class="cp">$answer = &lt;SERVER&gt;;                 # but you can still read</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch17/biclient</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># biclient - bidirectional forking client</span>
<span class="cp">    use strict;</span>
<span class="cp">use IO::Socket;</span>
<span class="cp">my ($host, $port, $kidpid, $handle, $line);</span>

<span class="cp">unless (@ARGV == 2) { die &quot;usage: $0 host port&quot; }</span>
<span class="cp">($host, $port) = @ARGV;</span>

<span class="cp"># create a tcp connection to the specified host and port</span>
<span class="cp">$handle = IO::Socket::INET-&gt;new(Proto     =&gt; &quot;tcp&quot;,</span>
<span class="cp">                                PeerAddr  =&gt; $host,</span>
<span class="cp">                                PeerPort  =&gt; $port)</span>
<span class="cp">       or die &quot;can&#39;t connect to port $port on $host: $!&quot;;</span>

<span class="cp">$handle-&gt;autoflush(1);              # so output gets there right away</span>
<span class="cp">print STDERR &quot;[Connected to $host:$port]\n&quot;;</span>

<span class="cp"># split the program into two processes, identical twins</span>
<span class="cp">die &quot;can&#39;t fork: $!&quot; unless defined($kidpid = fork());</span>

<span class="cp">if ($kidpid) {                      </span>
<span class="cp">    # parent copies the socket to standard output</span>
<span class="cp">    while (defined ($line = &lt;$handle&gt;)) {</span>
<span class="cp">        print STDOUT $line;</span>
<span class="cp">    }</span>
<span class="cp">    kill(&quot;TERM&quot; =&gt; $kidpid);        # send SIGTERM to child</span>
<span class="cp">}</span>
<span class="cp">else {                              </span>
<span class="cp">    # child copies standard input to the socket</span>
<span class="cp">    while (defined ($line = &lt;STDIN&gt;)) {</span>
<span class="cp">        print $handle $line;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">exit;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">my $byte;</span>
<span class="cp">while (sysread($handle, $byte, 1) == 1) {</span>
<span class="cp">    print STDOUT $byte;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># set up the socket SERVER, bind and listen ...</span>
<span class="cp">use POSIX qw(:sys_wait_h);</span>

<span class="cp">sub REAPER {</span>
<span class="cp">    1 until (-1 == waitpid(-1, WNOHANG));</span>
<span class="cp">    $SIG{CHLD} = \&amp;REAPER;                 # unless $] &gt;= 5.002</span>
<span class="cp">}</span>

<span class="cp">$SIG{CHLD} = \&amp;REAPER;</span>

<span class="cp">while ($hisaddr = accept(CLIENT, SERVER)) {</span>
<span class="cp">    next if $pid = fork;                    # parent</span>
<span class="cp">    die &quot;fork: $!&quot; unless defined $pid;     # failure</span>
<span class="cp">    # otherwise child</span>
<span class="cp">    close(SERVER);                          # no use to child</span>
<span class="cp">    # ... do something</span>
<span class="cp">    exit;                                   # child leaves</span>
<span class="cp">} continue { </span>
<span class="cp">    close(CLIENT);                          # no use to parent</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch17/preforker</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># preforker - server who forks first</span>
<span class="cp">use IO::Socket;</span>
<span class="cp">use Symbol;</span>
<span class="cp">use POSIX;</span>

<span class="cp"># establish SERVER socket, bind and listen.</span>
<span class="cp">$server = IO::Socket::INET-&gt;new(LocalPort =&gt; 6969,</span>
<span class="cp">                                Type      =&gt; SOCK_STREAM,</span>
<span class="cp">                                Proto     =&gt; &#39;tcp&#39;,</span>
<span class="cp">                                Reuse     =&gt; 1,</span>
<span class="cp">                                Listen    =&gt; 10 )</span>
<span class="cp">  or die &quot;making socket: $@\n&quot;;</span>

<span class="cp"># global variables</span>
<span class="cp">$PREFORK                = 5;        # number of children to maintain</span>
<span class="cp">$MAX_CLIENTS_PER_CHILD  = 5;        # number of clients each child should process</span>
<span class="cp">%children               = ();       # keys are current child process IDs</span>
<span class="cp">$children               = 0;        # current number of children</span>

<span class="cp">sub REAPER {                        # takes care of dead children</span>
<span class="cp">    $SIG{CHLD} = \&amp;REAPER;</span>
<span class="cp">    my $pid = wait;</span>
<span class="cp">    $children --;</span>
<span class="cp">    delete $children{$pid};</span>
<span class="cp">}</span>

<span class="cp">sub HUNTSMAN {                      # signal handler for SIGINT</span>
<span class="cp">    local($SIG{CHLD}) = &#39;IGNORE&#39;;   # we&#39;re going to kill our children</span>
<span class="cp">    kill &#39;INT&#39; =&gt; keys %children;</span>
<span class="cp">    exit;                           # clean up with dignity</span>
<span class="cp">}</span>

<span class="cp">    </span>
<span class="cp"># Fork off our children.</span>
<span class="cp">for (1 .. $PREFORK) {</span>
<span class="cp">    make_new_child();</span>
<span class="cp">}</span>

<span class="cp"># Install signal handlers.</span>
<span class="cp">$SIG{CHLD} = \&amp;REAPER;</span>
<span class="cp">$SIG{INT}  = \&amp;HUNTSMAN;</span>

<span class="cp"># And maintain the population.</span>
<span class="cp">while (1) {</span>
<span class="cp">    sleep;                          # wait for a signal (i.e., child&#39;s death)</span>
<span class="cp">    for ($i = $children; $i &lt; $PREFORK; $i++) {</span>
<span class="cp">        make_new_child();           # top up the child pool</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">sub make_new_child {</span>
<span class="cp">    my $pid;</span>
<span class="cp">    my $sigset;</span>
<span class="cp">    </span>
<span class="cp">    # block signal for fork</span>
<span class="cp">    $sigset = POSIX::SigSet-&gt;new(SIGINT);</span>
<span class="cp">    sigprocmask(SIG_BLOCK, $sigset)</span>
<span class="cp">        or die &quot;Can&#39;t block SIGINT for fork: $!\n&quot;;</span>
<span class="cp">    </span>
<span class="cp">    die &quot;fork: $!&quot; unless defined ($pid = fork);</span>
<span class="cp">    </span>
<span class="cp">    if ($pid) {</span>
<span class="cp">        # Parent records the child&#39;s birth and returns.</span>
<span class="cp">        sigprocmask(SIG_UNBLOCK, $sigset)</span>
<span class="cp">            or die &quot;Can&#39;t unblock SIGINT for fork: $!\n&quot;;</span>
<span class="cp">        $children{$pid} = 1;</span>
<span class="cp">        $children++;</span>
<span class="cp">        return;</span>
<span class="cp">    } else {</span>
<span class="cp">        # Child can *not* return from this subroutine.</span>
<span class="cp">        $SIG{INT} = &#39;DEFAULT&#39;;      # make SIGINT kill us as it did before</span>
<span class="cp">    </span>
<span class="cp">        # unblock signals</span>
<span class="cp">        sigprocmask(SIG_UNBLOCK, $sigset)</span>
<span class="cp">            or die &quot;Can&#39;t unblock SIGINT for fork: $!\n&quot;;</span>
<span class="cp">    </span>
<span class="cp">        # handle connections until we&#39;ve reached $MAX_CLIENTS_PER_CHILD</span>
<span class="cp">        for ($i=0; $i &lt; $MAX_CLIENTS_PER_CHILD; $i++) {</span>
<span class="cp">            $client = $server-&gt;accept()     or last;</span>
<span class="cp">            # do something with the connection</span>
<span class="cp">        }</span>
<span class="cp">    </span>
<span class="cp">        # tidy up gracefully and finish</span>
<span class="cp">    </span>
<span class="cp">        # this exit is VERY important, otherwise the child will become</span>
<span class="cp">        # a producer of more and more children, forking yourself into</span>
<span class="cp">        # process death.</span>
<span class="cp">        exit;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch17/nonforker</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># nonforker - server who multiplexes without forking</span>
<span class="cp">use POSIX;</span>
<span class="cp">use IO::Socket;</span>
<span class="cp">use IO::Select;</span>
<span class="cp">use Socket;</span>
<span class="cp">use Fcntl;</span>
<span class="cp">use Tie::RefHash;</span>

<span class="cp">$port = 1685;               # change this at will</span>

<span class="cp"># Listen to port.</span>
<span class="cp">$server = IO::Socket::INET-&gt;new(LocalPort =&gt; $port,</span>
<span class="cp">                                Listen    =&gt; 10 )</span>
<span class="cp">  or die &quot;Can&#39;t make server socket: $@\n&quot;;</span>

<span class="cp"># begin with empty buffers</span>
<span class="cp">%inbuffer  = ();</span>
<span class="cp">%outbuffer = ();</span>
<span class="cp">%ready     = ();</span>

<span class="cp">tie %ready, &#39;Tie::RefHash&#39;;</span>

<span class="cp">nonblock($server);</span>
<span class="cp">$select = IO::Select-&gt;new($server);</span>

<span class="cp"># Main loop: check reads/accepts, check writes, check ready to process</span>
<span class="cp">while (1) {</span>
<span class="cp">    my $client;</span>
<span class="cp">    my $rv;</span>
<span class="cp">    my $data;</span>

<span class="cp">    # check for new information on the connections we have</span>

<span class="cp">    # anything to read or accept?</span>
<span class="cp">    foreach $client ($select-&gt;can_read(1)) {</span>

<span class="cp">        if ($client == $server) {</span>
<span class="cp">            # accept a new connection</span>

<span class="cp">            $client = $server-&gt;accept();</span>
<span class="cp">            $select-&gt;add($client);</span>
<span class="cp">            nonblock($client);</span>
<span class="cp">        } else {</span>
<span class="cp">            # read data</span>
<span class="cp">            $data = &#39;&#39;;</span>
<span class="cp">            $rv   = $client-&gt;recv($data, POSIX::BUFSIZ, 0);</span>

<span class="cp">            unless (defined($rv) &amp;&amp; length $data) {</span>
<span class="cp">                # This would be the end of file, so close the client</span>
<span class="cp">                delete $inbuffer{$client};</span>
<span class="cp">                delete $outbuffer{$client};</span>
<span class="cp">                delete $ready{$client};</span>

<span class="cp">                $select-&gt;remove($client);</span>
<span class="cp">                close $client;</span>
<span class="cp">                next;</span>
<span class="cp">            }</span>

<span class="cp">            $inbuffer{$client} .= $data;</span>

<span class="cp">            # test whether the data in the buffer or the data we</span>
<span class="cp">            # just read means there is a complete request waiting</span>
<span class="cp">            # to be fulfilled.  If there is, set $ready{$client}</span>
<span class="cp">            # to the requests waiting to be fulfilled.</span>
<span class="cp">            while ($inbuffer{$client} =~ s/(.*\n)//) {</span>
<span class="cp">                push( @{$ready{$client}}, $1 );</span>
<span class="cp">            }</span>
<span class="cp">        }</span>
<span class="cp">    }</span>

<span class="cp">    # Any complete requests to process?</span>
<span class="cp">    foreach $client (keys %ready) {</span>
<span class="cp">        handle($client);</span>
<span class="cp">    }</span>

<span class="cp">    # Buffers to flush?</span>
<span class="cp">    foreach $client ($select-&gt;can_write(1)) {</span>
<span class="cp">        # Skip this client if we have nothing to say</span>
<span class="cp">        next unless exists $outbuffer{$client};</span>

<span class="cp">        $rv = $client-&gt;send($outbuffer{$client}, 0);</span>
<span class="cp">        unless (defined $rv) {</span>
<span class="cp">            # Whine, but move on.</span>
<span class="cp">            warn &quot;I was told I could write, but I can&#39;t.\n&quot;;</span>
<span class="cp">            next;</span>
<span class="cp">        }</span>
<span class="cp">        if ($rv == length $outbuffer{$client} ||</span>
<span class="cp">            {$! == POSIX::EWOULDBLOCK) {</span>
<span class="cp">            substr($outbuffer{$client}, 0, $rv) = &#39;&#39;;</span>
<span class="cp">            delete $outbuffer{$client} unless length $outbuffer{$client};</span>
<span class="cp">        } else {</span>
<span class="cp">            # Couldn&#39;t write all the data, and it wasn&#39;t because</span>
<span class="cp">            # it would have blocked.  Shutdown and move on.</span>
<span class="cp">            delete $inbuffer{$client};</span>
<span class="cp">            delete $outbuffer{$client};</span>
<span class="cp">            delete $ready{$client};</span>

<span class="cp">            $select-&gt;remove($client);</span>
<span class="cp">            close($client);</span>
<span class="cp">            next;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>

<span class="cp">    # Out of band data?</span>
<span class="cp">    foreach $client ($select-&gt;has_exception(0)) {  # arg is timeout</span>
<span class="cp">        # Deal with out-of-band data here, if you want to.</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp"># handle($socket) deals with all pending requests for $client</span>
<span class="cp">sub handle {</span>
<span class="cp">    # requests are in $ready{$client}</span>
<span class="cp">    # send output to $outbuffer{$client}</span>
<span class="cp">    my $client = shift;</span>
<span class="cp">    my $request;</span>

<span class="cp">    foreach $request (@{$ready{$client}}) {</span>
<span class="cp">        # $request is the text of the request</span>
<span class="cp">        # put text of reply into $outbuffer{$client}</span>
<span class="cp">    }</span>
<span class="cp">    delete $ready{$client};</span>
<span class="cp">}</span>

<span class="cp"># nonblock($socket) puts socket into nonblocking mode</span>
<span class="cp">sub nonblock {</span>
<span class="cp">    my $socket = shift;</span>
<span class="cp">    my $flags;</span>

<span class="cp">    </span>
<span class="cp">    $flags = fcntl($socket, F_GETFL, 0)</span>
<span class="cp">            or die &quot;Can&#39;t get flags for socket: $!\n&quot;;</span>
<span class="cp">    fcntl($socket, F_SETFL, $flags | O_NONBLOCK)</span>
<span class="cp">            or die &quot;Can&#39;t make socket nonblocking: $!\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">while ($inbuffer{$client} =~ s/(.*\n)//) {</span>
<span class="cp">    push( @{$ready{$client}}, $1 );</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$outbuffer{$client} .= $request;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">socket(SERVER, PF_INET, SOCK_STREAM, getprotobyname(&#39;tcp&#39;));</span>
<span class="cp">setsockopt(SERVER, SOL_SOCKET, SO_REUSEADDR, 1);</span>
<span class="cp">bind(SERVER, sockaddr_in($server_port, INADDR_ANY))</span>
<span class="cp">    or die &quot;Binding: $!\n&quot;;</span>

<span class="cp"># accept loop</span>
<span class="cp">while (accept(CLIENT, SERVER)) {</span>
<span class="cp">    $my_socket_address = getsockname(CLIENT);</span>
<span class="cp">    ($port, $myaddr)   = sockaddr_in($my_socket_address);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$server = IO::Socket::INET-&gt;new(LocalPort =&gt; $server_port,</span>
<span class="cp">                                Type      =&gt; SOCK_STREAM,</span>
<span class="cp">                                Proto     =&gt; &#39;tcp&#39;,</span>
<span class="cp">                                Listen    =&gt; 10)</span>
<span class="cp">    or die &quot;Can&#39;t create server socket: $@\n&quot;;</span>

<span class="cp">while ($client = $server-&gt;accept()) {</span>
<span class="cp">    $my_socket_address = $client-&gt;sockname();</span>
<span class="cp">    ($port, $myaddr)   = sockaddr_in($my_socket_address);</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">$port = 4269;                       # port to bind to</span>
<span class="cp">$host = &quot;specific.host.com&quot;;        # virtual host to listen on</span>

<span class="cp">socket(Server, PF_INET, SOCK_STREAM, getprotobyname(&quot;tcp&quot;))</span>
<span class="cp">    or die &quot;socket: $!&quot;;</span>
<span class="cp">bind(Server, sockaddr_in($port, inet_aton($host)))</span>
<span class="cp">    or die &quot;bind: $!&quot;;</span>
<span class="cp">while ($client_address = accept(Client, Server)) {</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">chroot(&quot;/var/daemon&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t chroot to /var/daemon: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pid = fork;</span>
<span class="cp">exit if $pid;</span>
<span class="cp">die &quot;Couldn&#39;t fork: $!&quot; unless defined($pid);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use POSIX;</span>

<span class="cp">POSIX::setsid()</span>
<span class="cp">    or die &quot;Can&#39;t start a new session: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$time_to_die = 0;</span>

<span class="cp">sub signal_handler {</span>
<span class="cp">    $time_to_die = 1;</span>
<span class="cp">}</span>

<span class="cp">$SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&amp;signal_handler;</span>
<span class="cp"># trap or ignore $SIG{PIPE}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">until ($time_to_die) {</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.16</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$SELF = &quot;/usr/local/libexec/myd&quot;;   # which program I am</span>
<span class="cp">@ARGS = qw(-l /var/log/myd -d);     # program arguments</span>

<span class="cp">$SIG{HUP} = \&amp;phoenix;</span>

<span class="cp">sub phoenix {</span>
<span class="cp">    # close all your connections, kill your children, and</span>
<span class="cp">    # generally prepare to be reincarnated with dignity.</span>
<span class="cp">    exec($SELF, @ARGS)              or die &quot;Couldn&#39;t restart: $!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$CONFIG_FILE = &quot;/usr/local/etc/myprog/server_conf.pl&quot;;</span>
<span class="cp">$SIG{HUP} = \&amp;read_config;</span>
<span class="cp">sub read_config {</span>
<span class="cp">    do $CONFIG_FILE;</span>
<span class="cp">} </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.17</span>
<span class="cp">#-----------------------------</span>
<span class="cp">May 25 15:50:22 coprolith sniffer: Connection from 207.46.131.141 to</span>

<span class="cp">207.46.130.164:echo </span>
<span class="cp">#-----------------------------</span>
<span class="cp">echo    stream  tcp nowait  nobody /usr/scripts/snfsqrd sniffer</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch17/backsniff</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># backsniff - log attempts to connect to particular ports</span>

<span class="cp">use Sys::Syslog;</span>
<span class="cp">use Socket;</span>

<span class="cp"># identify my port and address</span>
<span class="cp">$sockname          = getsockname(STDIN)</span>
<span class="cp">                     or die &quot;Couldn&#39;t identify myself: $!\n&quot;;</span>
<span class="cp">($port, $iaddr)    = sockaddr_in($sockname);</span>
<span class="cp">$my_address        = inet_ntoa($iaddr);</span>

<span class="cp"># get a name for the service</span>
<span class="cp">$service = (getservbyport ($port, &quot;tcp&quot;))[0] || $port;</span>
<span class="cp"># now identify remote address</span>
<span class="cp">$sockname          = getpeername(STDIN)</span>
<span class="cp">                         or die &quot;Couldn&#39;t identify other end: $!\n&quot;;</span>
<span class="cp">($port, $iaddr)    = sockaddr_in($sockname);</span>
<span class="cp">$ex_address        = inet_ntoa($iaddr);</span>

<span class="cp"># and log the information</span>
<span class="cp">openlog(&quot;sniffer&quot;, &quot;ndelay&quot;, &quot;daemon&quot;);</span>
<span class="cp">syslog(&quot;notice&quot;, &quot;Connection from %s to %s:%s\n&quot;, $ex_address, </span>

<span class="cp">        $my_address, $service);</span>
<span class="cp">closelog();</span>
<span class="cp">exit;</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_17.18</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% fwdport -s nntp -l fw.oursite.com -r news.bigorg.com</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% fwdport -l myname:9191 -r news.bigorg.com:nntp</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch17/fwdport</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># fwdport -- act as proxy forwarder for dedicated services</span>

<span class="cp">use strict;                 # require declarations</span>
<span class="cp">use Getopt::Long;           # for option processing</span>
<span class="cp">use Net::hostent;       Example 17-8    # by-name interface for host info</span>
<span class="cp">use IO::Socket;             # for creating server and client sockets</span>
<span class="cp">use POSIX &quot;:sys_wait_h&quot;;    # for reaping our dead children</span>

<span class="cp">my (</span>
<span class="cp">    %Children,              # hash of outstanding child processes</span>
<span class="cp">    $REMOTE,                # whom we connect to on the outside</span>
<span class="cp">    $LOCAL,                 # where we listen to on the inside</span>
<span class="cp">    $SERVICE,               # our service name or port number</span>
<span class="cp">    $proxy_server,          # the socket we accept() from</span>
<span class="cp">    $ME,                    # basename of this program</span>
<span class="cp">);</span>

<span class="cp">($ME = $0) =~ s,.*/,,;      # retain just basename of script name</span>

<span class="cp">check_args();               # processing switches</span>
<span class="cp">start_proxy();              # launch our own server</span>
<span class="cp">service_clients();          # wait for incoming</span>
<span class="cp">die &quot;NOT REACHED&quot;;          # you can&#39;t get here from there</span>

<span class="cp"># process command line switches using the extended</span>
<span class="cp"># version of the getopts library.</span>
<span class="cp">sub check_args { </span>
<span class="cp">    GetOptions(</span>
<span class="cp">        &quot;remote=s&quot;    =&gt; \$REMOTE,</span>
<span class="cp">        &quot;local=s&quot;     =&gt; \$LOCAL,</span>
<span class="cp">        &quot;service=s&quot;   =&gt; \$SERVICE,</span>
<span class="cp">    ) or die &lt;&lt;EOUSAGE;</span>
<span class="cp">    usage: $0 [ --remote host ] [ --local interface ] [ --service service ]   </span>
<span class="cp">EOUSAGE</span>
<span class="cp">    die &quot;Need remote&quot;                   unless $REMOTE;</span>
<span class="cp">    die &quot;Need local or service&quot;         unless $LOCAL || $SERVICE;</span>
<span class="cp">}</span>

<span class="cp"># begin our server </span>
<span class="cp">sub start_proxy {</span>
<span class="cp">    my @proxy_server_config = (</span>
<span class="cp">      Proto     =&gt; &#39;tcp&#39;,</span>
<span class="cp">      Reuse     =&gt; 1,</span>
<span class="cp">      Listen    =&gt; SOMAXCONN,</span>
<span class="cp">    );</span>
<span class="cp">    push @proxy_server_config, LocalPort =&gt; $SERVICE if $SERVICE;</span>
<span class="cp">    push @proxy_server_config, LocalAddr =&gt; $LOCAL   if $LOCAL;</span>
<span class="cp">    $proxy_server = IO::Socket::INET-&gt;new(@proxy_server_config)</span>
<span class="cp">                    or die &quot;can&#39;t create proxy server: $@&quot;;</span>
<span class="cp">    print &quot;[Proxy server on &quot;, ($LOCAL || $SERVICE), &quot; initialized.]\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">sub service_clients { </span>
<span class="cp">    my (</span>
<span class="cp">        $local_client,              # someone internal wanting out</span>
<span class="cp">        $lc_info,                   # local client&#39;s name/port information</span>
<span class="cp">        $remote_server,             # the socket for escaping out</span>
<span class="cp">        @rs_config,                 # temp array for remote socket options</span>
<span class="cp">        $rs_info,                   # remote server&#39;s name/port information</span>
<span class="cp">        $kidpid,                    # spawned child for each connection</span>
<span class="cp">    );</span>

<span class="cp">    $SIG{CHLD} = \&amp;REAPER;          # harvest the moribund</span>

<span class="cp">    accepting();</span>

<span class="cp">    # an accepted connection here means someone inside wants out</span>
<span class="cp">    while ($local_client = $proxy_server-&gt;accept()) {</span>
<span class="cp">        $lc_info = peerinfo($local_client);</span>
<span class="cp">        set_state(&quot;servicing local $lc_info&quot;);</span>
<span class="cp">        printf &quot;[Connect from $lc_info]\n&quot;;</span>

<span class="cp">        @rs_config = (</span>
<span class="cp">            Proto     =&gt; &#39;tcp&#39;,</span>
<span class="cp">            PeerAddr  =&gt; $REMOTE,</span>
<span class="cp">        );</span>
<span class="cp">        push(@rs_config, PeerPort =&gt; $SERVICE) if $SERVICE;</span>

<span class="cp">        print &quot;[Connecting to $REMOTE...&quot;;</span>
<span class="cp">        set_state(&quot;connecting to $REMOTE&quot;);                 # see below</span>
<span class="cp">        $remote_server = IO::Socket::INET-&gt;new(@rs_config)</span>
<span class="cp">                         or die &quot;remote server: $@&quot;;</span>
<span class="cp">        print &quot;done]\n&quot;;</span>

<span class="cp">        $rs_info = peerinfo($remote_server);</span>
<span class="cp">        set_state(&quot;connected to $rs_info&quot;);</span>

<span class="cp">        $kidpid = fork();</span>
<span class="cp">        die &quot;Cannot fork&quot; unless defined $kidpid;</span>
<span class="cp">        if ($kidpid) {</span>
<span class="cp">            $Children{$kidpid} = time();            # remember his start time</span>
<span class="cp">            close $remote_server;                   # no use to master</span>
<span class="cp">            close $local_client;                    # likewise</span>
<span class="cp">            next;                                   # go get another client</span>
<span class="cp">        } </span>

<span class="cp">        # at this point, we are the forked child process dedicated</span>
<span class="cp">        # to the incoming client.  but we want a twin to make i/o</span>
<span class="cp">        # easier.</span>

<span class="cp">        close $proxy_server;                        # no use to slave</span>

<span class="cp">        $kidpid = fork(); </span>
<span class="cp">        die &quot;Cannot fork&quot; unless defined $kidpid;</span>

<span class="cp">        # now each twin sits around and ferries lines of data.</span>
<span class="cp">        # see how simple the algorithm is when you can have</span>
<span class="cp">        # multiple threads of control?</span>

<span class="cp">        # this is the fork&#39;s parent, the master&#39;s child</span>
<span class="cp">        if ($kidpid) {              </span>
<span class="cp">            set_state(&quot;$rs_info --&gt; $lc_info&quot;);</span>
<span class="cp">            select($local_client); $| = 1;</span>
<span class="cp">            print while &lt;$remote_server&gt;;</span>
<span class="cp">            kill(&#39;TERM&#39;, $kidpid);      # kill my twin cause we&#39;re done</span>
<span class="cp">            } </span>
<span class="cp">        # this is the fork&#39;s child, the master&#39;s grandchild</span>
<span class="cp">        else {                      </span>
<span class="cp">            set_state(&quot;$rs_info &lt;-- $lc_info&quot;);</span>
<span class="cp">            select($remote_server); $| = 1;</span>
<span class="cp">            print while &lt;$local_client&gt;;</span>
<span class="cp">            kill(&#39;TERM&#39;, getppid());    # kill my twin cause we&#39;re done</span>
<span class="cp">        } </span>
<span class="cp">        exit;                           # whoever&#39;s still alive bites it</span>
<span class="cp">    } continue {</span>
<span class="cp">        accepting();</span>
<span class="cp">    } </span>
<span class="cp">}</span>

<span class="cp"># helper function to produce a nice string in the form HOST:PORT</span>
<span class="cp">sub peerinfo {</span>
<span class="cp">    my $sock = shift;</span>
<span class="cp">    my $hostinfo = gethostbyaddr($sock-&gt;peeraddr);</span>
<span class="cp">    return sprintf(&quot;%s:%s&quot;, </span>
<span class="cp">                    $hostinfo-&gt;name || $sock-&gt;peerhost, </span>
<span class="cp">                    $sock-&gt;peerport);</span>
<span class="cp">} </span>

<span class="cp"># reset our $0, which on some systems make &quot;ps&quot; report</span>
<span class="cp"># something interesting: the string we set $0 to!</span>
<span class="cp">sub set_state { $0 = &quot;$ME [@_]&quot; } </span>

<span class="cp"># helper function to call set_state</span>
<span class="cp">sub accepting {</span>
<span class="cp">    set_state(&quot;accepting proxy for &quot; . ($REMOTE || $SERVICE));</span>
<span class="cp">}</span>

<span class="cp"># somebody just died.  keep harvesting the dead until </span>
<span class="cp"># we run out of them.  check how long they ran.</span>
<span class="cp">sub REAPER { </span>
<span class="cp">    my $child;</span>
<span class="cp">    my $start;</span>
<span class="cp">    while (($child = waitpid(-1,WNOHANG)) &gt; 0) {</span>
<span class="cp">        if ($start = $Children{$child}) {</span>
<span class="cp">            my $runtime = time() - $start;</span>
<span class="cp">            printf &quot;Child $child ran %dm%ss\n&quot;, </span>
<span class="cp">                $runtime / 60, $runtime % 60;</span>
<span class="cp">            delete $Children{$child};</span>
<span class="cp">        } else {</span>
<span class="cp">            print &quot;Bizarre kid $child exited $?\n&quot;;</span>
<span class="cp">        } </span>
<span class="cp">    }</span>
<span class="cp">    # If I had to choose between System V and 4.2, I&#39;d resign. --Peter Honeyman</span>
<span class="cp">    $SIG{CHLD} = \&amp;REAPER; </span>
<span class="cp">};</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_18.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">@addresses = gethostbyname($name)   or die &quot;Can&#39;t resolve $name: $!\n&quot;;</span>
<span class="cp">@addresses = map { inet_ntoa($_) } @addresses[4 .. $#addresses];</span>
<span class="cp"># @addresses is a list of IP addresses (&quot;208.201.239.48&quot;, &quot;208.201.239.49&quot;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">$address = inet_ntoa(inet_aton($name));</span>
<span class="cp"># $address is a single IP address &quot;208.201.239.48&quot;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>

<span class="cp">$name = gethostbyaddr(inet_aton($address), AF_INET)</span>
<span class="cp">            or die &quot;Can&#39;t resolve $address: $!\n&quot;;</span>
<span class="cp"># $name is the hostname (&quot;www.perl.com&quot;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Socket;</span>
<span class="cp">$packed_address = inet_aton(&quot;208.146.140.1&quot;);</span>
<span class="cp">$ascii_address  = inet_ntoa($packed_address);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$packed = gethostbyname($hostname)</span>
<span class="cp">            or die &quot;Couldn&#39;t resolve address for $hostname: $!\n&quot;;</span>
<span class="cp">$address = inet_ntoa($packed);</span>
<span class="cp">print &quot;I will use $address as the address for $hostname\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># $address is the IP address I&#39;m checking, like &quot;128.138.243.20&quot;</span>
<span class="cp">use Socket;</span>
<span class="cp">$name    = gethostbyaddr(inet_aton($address), AF_INET)</span>
<span class="cp">                or die &quot;Can&#39;t look up $address : $!\n&quot;;</span>
<span class="cp">@addr    = gethostbyname($name)</span>
<span class="cp">                or die &quot;Can&#39;t look up $name : $!\n&quot;;</span>
<span class="cp">$found   = grep { $address eq inet_ntoa($_) } @addr[4..$#addr];</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch18/mxhost</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># mxhost - find mx exchangers for a host</span>
<span class="cp">use Net::DNS;</span>

<span class="cp">$host = shift;</span>
<span class="cp">$res = Net::DNS::Resolver-&gt;new();</span>
<span class="cp">@mx = mx($res, $host)</span>
<span class="cp">   or die &quot;Can&#39;t find MX records for $host (&quot;.$res-&gt;errorstring,&quot;)\n&quot;;</span>

<span class="cp">foreach $record (@mx) {</span>
<span class="cp">    print $record-&gt;preference, &quot; &quot;, $record-&gt;exchange, &quot;\n&quot;;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% mxhost cnn.com</span>
<span class="cp">#10 mail.turner.com</span>
<span class="cp">#</span>
<span class="cp">#30 alfw2.turner.com</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch18/hostaddrs</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># hostaddrs - canonize name and show addresses</span>
<span class="cp">use Socket;</span>
<span class="cp">use Net::hostent;</span>
<span class="cp">$name = shift;</span>
<span class="cp">if ($hent = gethostbyname($name)) {</span>
<span class="cp">    $name      = $hent-&gt;name;                # in case different</span>
<span class="cp">    $addr_ref  = $hent-&gt;addr_list;</span>
<span class="cp">    @addresses = map { inet_ntoa($_) } @$addr_ref;</span>
<span class="cp">}</span>
<span class="cp">print &quot;$name =&gt; @addresses\n&quot;;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% hostaddrs www.ora.com</span>
<span class="cp">#helio.ora.com =&gt; 204.148.40.9</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#% hostaddrs www.whitehouse.gov</span>
<span class="cp">#www.whitehouse.gov =&gt; 198.137.240.91 198.137.240.92</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_18.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Net::FTP;</span>

<span class="cp">$ftp = Net::FTP-&gt;new(&quot;ftp.host.com&quot;)    or die &quot;Can&#39;t connect: $@\n&quot;;</span>
<span class="cp">$ftp-&gt;login($username, $password)       or die &quot;Couldn&#39;t login\n&quot;;</span>
<span class="cp">$ftp-&gt;cwd($directory)                   or die &quot;Couldn&#39;t change directory\n&quot;;</span>
<span class="cp">$ftp-&gt;get($filename)                    or die &quot;Couldn&#39;t get $filename\n&quot;;</span>
<span class="cp">$ftp-&gt;put($filename)                    or die &quot;Couldn&#39;t put $filename\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ftp = Net::FTP-&gt;new(&quot;ftp.host.com&quot;,</span>
<span class="cp">                     Timeout =&gt; 30,</span>
<span class="cp">                     Debug   =&gt; 1)</span>
<span class="cp">    or die &quot;Can&#39;t connect: $@\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ftp-&gt;</span>
<span class="cp">login()</span>

<span class="cp">    or die &quot;Couldn&#39;t authenticate.\n&quot;;</span>

<span class="cp">$ftp-&gt;login($username)</span>
<span class="cp">    or die &quot;Still couldn&#39;t authenticate.\n&quot;;</span>

<span class="cp">$ftp-&gt;login($username, $password)</span>
<span class="cp">    or die &quot;Couldn&#39;t authenticate, even with explicit username</span>
<span class="cp">            and password.\n&quot;;</span>

<span class="cp">$ftp-&gt;login($username, $password, $account)</span>
<span class="cp">    or die &quot;No dice.  It hates me.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ftp-&gt;put($localfile, $remotefile)</span>
<span class="cp">    or die &quot;Can&#39;t send $localfile: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ftp-&gt;put(*STDIN, $remotefile)</span>
<span class="cp">    or die &quot;Can&#39;t send from STDIN: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ftp-&gt;get($remotefile, $localfile)</span>
<span class="cp">    or die &quot;Can&#39;t fetch $remotefile : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ftp-&gt;get($remotefile, *STDOUT)</span>
<span class="cp">    or die &quot;Can&#39;t fetch $remotefile: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ftp-&gt;cwd(&quot;/pub/perl/CPAN/images/g-rated&quot;);</span>
<span class="cp">print &quot;I&#39;m in the directory &quot;, $ftp-&gt;pwd(), &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">   $ftp-&gt;mkdir(&quot;/pub/gnat/perl&quot;, 1)</span>
<span class="cp">    or die &quot;Can&#39;t create /pub/gnat/perl recursively: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = $ftp-&gt;ls(&quot;/pub/gnat/perl&quot;)</span>
<span class="cp">    or die &quot;Can&#39;t get a list of files in /pub/gnat/perl: $!&quot;;</span>
<span class="cp">$ref_to_lines = $ftp-&gt;dir(&quot;/pub/perl/CPAN/src/latest.tar.gz&quot;)</span>
<span class="cp">    or die &quot;Can&#39;t check status of latest.tar.gz: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ftp-&gt;quit()    or warn &quot;Couldn&#39;t quit.  Oh well.\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_18.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Mail::Mailer;</span>

<span class="cp">$mailer = Mail::Mailer-&gt;new(&quot;sendmail&quot;);</span>
<span class="cp">$mailer-&gt;open({ From    =&gt; $from_address,</span>
<span class="cp">                To      =&gt; $to_address,</span>
<span class="cp">                Subject =&gt; $subject,</span>
<span class="cp">              })</span>
<span class="cp">    or die &quot;Can&#39;t open: $!\n&quot;;</span>
<span class="cp">print $mailer $body;</span>
<span class="cp">$mailer-&gt;</span>
<span class="cp">close();</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(SENDMAIL, &quot;|/usr/lib/sendmail -oi -t -odq&quot;)</span>
<span class="cp">                    or die &quot;Can&#39;t fork for sendmail: $!\n&quot;;</span>
<span class="cp">print SENDMAIL &lt;&lt;&quot;EOF&quot;;</span>
<span class="cp">From: User Originating Mail &lt;me\@host&gt;</span>
<span class="cp">To: Final Destination &lt;you\@otherhost&gt;</span>
<span class="cp">Subject: A relevant subject line</span>

<span class="cp">Body of the message goes here, in as many lines as you like.</span>
<span class="cp">EOF</span>
<span class="cp">close(SENDMAIL)     or warn &quot;sendmail didn&#39;t close nicely&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$mailer = Mail::Mailer-&gt;new(&quot;sendmail&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$mailer = Mail::Mailer-&gt;new(&quot;mail&quot;, &quot;/u/gnat/bin/funkymailer&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$mailer = Mail::Mailer-&gt;new(&quot;smtp&quot;, &quot;mail.myisp.com&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">eval {</span>
<span class="cp">    $mailer = Mail::Mailer-&gt;new(&quot;bogus&quot;, &quot;arguments&quot;);</span>
<span class="cp">    # ...</span>
<span class="cp">};</span>
<span class="cp">if ($@) {</span>
<span class="cp">    # the eval failed</span>
<span class="cp">    print &quot;Couldn&#39;t send mail: $@\n&quot;;</span>
<span class="cp">} else {</span>
<span class="cp">    # the eval succeeded</span>
<span class="cp">    print &quot;The authorities have been notified.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$mailer-&gt;open( &#39;From&#39;    =&gt; &#39;Nathan Torkington &lt;gnat@frii.com&gt;&#39;,</span>
<span class="cp">               &#39;To&#39;      =&gt; &#39;Tom Christiansen &lt;tchrist@perl.com&gt;&#39;,</span>
<span class="cp">               &#39;Subject&#39; =&gt; &#39;The Perl Cookbook&#39; );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print $mailer &lt;&lt;EO_SIG;</span>
<span class="cp">Are we ever going to finish this book?</span>
<span class="cp">My wife is threatening to leave me.</span>
<span class="cp">She says I love EMACS more than I love her.</span>
<span class="cp">Do you have a recipe that can help me?</span>

<span class="cp">Nat</span>
<span class="cp">EO_SIG</span>
<span class="cp">#-----------------------------</span>
<span class="cp">close($mailer)                      or die &quot;can&#39;t close mailer: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(SENDMAIL, &quot;|/usr/sbin/sendmail -oi -t -odq&quot;)</span>
<span class="cp">            or die &quot;Can&#39;t fork for sendmail: $!\n&quot;;</span>
<span class="cp">print SENDMAIL &lt;&lt;&quot;EOF&quot;;</span>
<span class="cp">From: Tom Christiansen &lt;tchrist\@perl.com&gt;</span>
<span class="cp">To: Nathan Torkington &lt;gnat\@frii.com&gt;</span>
<span class="cp">Subject: Re: The Perl Cookbook</span>

<span class="cp">(1) We will never finish the book.</span>
<span class="cp">(2) No man who uses EMACS is deserving of love.</span>
<span class="cp">(3) I recommend coq au vi.</span>

<span class="cp">tom</span>
<span class="cp">EOF</span>
<span class="cp">close(SENDMAIL);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_18.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Net::NNTP;</span>

<span class="cp">$server = Net::NNTP-&gt;new(&quot;news.host.dom&quot;)</span>
<span class="cp">    or die &quot;Can&#39;t connect to news server: $@\n&quot;;</span>
<span class="cp">($narticles, $first, $last, $name) = $server-&gt;group( &quot;misc.test&quot; )</span>
<span class="cp">    or die &quot;Can&#39;t select misc.test\n&quot;;</span>
<span class="cp">$headers  = $server-&gt;head($first)</span>
<span class="cp">    or die &quot;Can&#39;t get headers from article $first in $name\n&quot;;</span>
<span class="cp">$bodytext = $server-&gt;body($first)</span>
<span class="cp">    or die &quot;Can&#39;t get body from article $first in $name\n&quot;;</span>
<span class="cp">$article  = $server-&gt;article($first)</span>
<span class="cp">    or die &quot;Can&#39;t get article $first from $name\n&quot;;</span>

<span class="cp">$server-&gt;</span>
<span class="cp">postok()</span>

<span class="cp">    or warn &quot;Server didn&#39;t tell me I could post.\n&quot;;</span>

<span class="cp">$server-&gt;post( [ @lines ] )</span>
<span class="cp">    or die &quot;Can&#39;t post: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">&lt;0401@jpl-devvax.JPL.NASA.GOV&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$server = Net::NNTP-&gt;new(&quot;news.mycompany.com&quot;)</span>
<span class="cp">    or die &quot;Couldn&#39;t connect to news.mycompany.com: $@\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$grouplist = $server-&gt;</span>
<span class="cp">list()</span>

<span class="cp">    or die &quot;Couldn&#39;t fetch group list\n&quot;;</span>

<span class="cp">foreach $group (keys %$grouplist) {</span>
<span class="cp">    if ($grouplist-&gt;{$group}-&gt;[2] eq &#39;y&#39;) {</span>
<span class="cp">        # I can post to $group</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($narticles, $first, $last, $name) = $server-&gt;group(&quot;comp.lang.perl.misc&quot;)</span>
<span class="cp">    or die &quot;Can&#39;t select comp.lang.perl.misc\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@lines = $server-&gt;article($message_id)</span>
<span class="cp">    or die &quot;Can&#39;t fetch article $message_id: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@group = $server-&gt;group(&quot;comp.lang.perl.misc&quot;)</span>
<span class="cp">    or die &quot;Can&#39;t select group comp.lang.perl.misc\n&quot;;</span>
<span class="cp">@lines = $server-&gt;head($group[1])</span>
<span class="cp">    or die &quot;Can&#39;t get headers from first article in comp.lang.perl.misc\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$server-&gt;post(@message)</span>
<span class="cp">    or die &quot;Can&#39;t post\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unless ($server-&gt;</span>
<span class="cp">postok()</span>
<span class="cp">) {</span>
<span class="cp">    warn &quot;You may not post.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_18.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pop = Net::POP3-&gt;new($mail_server)</span>
<span class="cp">    or die &quot;Can&#39;t open connection to $mail_server : $!\n&quot;;</span>
<span class="cp">defined ($pop-&gt;login($username, $password))</span>
<span class="cp">    or die &quot;Can&#39;t authenticate: $!\n&quot;;</span>
<span class="cp">$messages = $pop-&gt;list</span>
<span class="cp">    or die &quot;Can&#39;t get list of undeleted messages: $!\n&quot;;</span>
<span class="cp">foreach $msgid (keys %$messages) {</span>
<span class="cp">    $message = $pop-&gt;get($msgid);</span>
<span class="cp">    unless (defined $message) {</span>
<span class="cp">        warn &quot;Couldn&#39;t fetch $msgid from server: $!\n&quot;;</span>
<span class="cp">        next;</span>
<span class="cp">    }</span>
<span class="cp">    # $message is a reference to an array of lines</span>
<span class="cp">    $pop-&gt;delete($msgid);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pop = Net::POP3-&gt;new( &quot;pop.myisp.com&quot; )</span>
<span class="cp">    or die &quot;Can&#39;t connect to pop.myisp.com: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pop = Net::POP3-&gt;new( &quot;pop.myisp.com&quot;,</span>
<span class="cp">                       Timeout =&gt; 30 )</span>
<span class="cp">    or die &quot;Can&#39;t connect to pop.myisp.com : $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">defined ($pop-&gt;login(&quot;gnat&quot;, &quot;S33kr1T Pa55w0rD&quot;))</span>
<span class="cp">    or die &quot;Hey, my username and password didn&#39;t work!\n&quot;;</span>

<span class="cp">defined ($pop-&gt;login( &quot;midget&quot; ))           # use Net::Netrc to find password</span>
<span class="cp">    or die &quot;Authentication failed.\n&quot;;</span>

<span class="cp">defined ($pop-&gt;</span>
<span class="cp">login())</span>
<span class="cp">                     # current username and Net::Netrc</span>
<span class="cp">    or die &quot;Authentication failed.  Miserably.\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pop-&gt;apop( $username, $password )</span>
<span class="cp">    or die &quot;Couldn&#39;t authenticate: $!\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%undeleted = $pop-&gt;</span>
<span class="cp">list();</span>

<span class="cp">foreach $msgnum (keys %undeleted) {</span>
<span class="cp">    print &quot;Message $msgnum is $undeleted{$msgnum} bytes long.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;Retrieving $msgnum : &quot;;</span>
<span class="cp">$message = $pop-&gt;get($msgnum);</span>
<span class="cp">if ($message) {</span>
<span class="cp">    # succeeded</span>
<span class="cp">    print &quot;\n&quot;;</span>
<span class="cp">    print @$message;                # print the message</span>
<span class="cp">} else {</span>
<span class="cp">        # failed</span>
<span class="cp">    print &quot;failed ($!)\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_18.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Net::Telnet;</span>

<span class="cp">$t = Net::Telnet-&gt;new( Timeout =&gt; 10,</span>
<span class="cp">                       Prompt  =&gt; &#39;/%/&#39;,</span>
<span class="cp">                       Host    =&gt; $hostname );</span>

<span class="cp">$t-&gt;login($username, $password);</span>
<span class="cp">@files = $t-&gt;cmd(&quot;ls&quot;);</span>
<span class="cp">$t-&gt;print(&quot;top&quot;);</span>
<span class="cp">(undef, $process_string) = $t-&gt;waitfor(&#39;/\d+ processes/&#39;);</span>
<span class="cp">$t-&gt;close;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">/[\$%#&gt;] $/</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$telnet = Net::Telnet-&gt;new( Errmode =&gt; sub { main::log(@_) }, ... );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$telnet-&gt;login($username, $password)</span>
<span class="cp">    or die &quot;Login failed: @{[ $telnet-&gt;errmsg() ]}\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$telnet-&gt;waitfor(&#39;/--more--/&#39;)</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$telnet-&gt;waitfor(String =&gt; &#39;greasy smoke&#39;, Timeout =&gt; 30)</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_18.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Net::Ping;</span>

<span class="cp">$p = Net::Ping-&gt;new()</span>
<span class="cp">    or die &quot;Can&#39;t create new ping object: $!\n&quot;;</span>
<span class="cp">print &quot;$host is alive&quot; if $p-&gt;ping($host);</span>
<span class="cp">$p-&gt;close;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># use TCP if we&#39;re not root, ICMP if we are</span>
<span class="cp">$pong = Net::Ping-&gt;new( $&gt; ? &quot;tcp&quot; : &quot;icmp&quot; );</span>

<span class="cp">(defined $pong)</span>
<span class="cp">    or die &quot;Couldn&#39;t create Net::Ping object: $!\n&quot;;</span>

<span class="cp">if ($pong-&gt;ping(&quot;kingkong.com&quot;)) {</span>
<span class="cp">    print &quot;The giant ape lives!\n&quot;;</span>
<span class="cp">} else {</span>
<span class="cp">    print &quot;All hail mighty Gamera, friend of children!\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_18.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use Net::Whois;</span>

<span class="cp">$domain_obj = Net::Whois::Domain-&gt;new($domain_name)</span>
<span class="cp">    or die &quot;Couldn&#39;t get information on $domain_name: $!\n&quot;;</span>

<span class="cp"># call methods on $domain_obj to get name, tag, address, etc.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$d = Net::Whois::Domain-&gt;new( &quot;perl.org&quot; )</span>
<span class="cp">    or die &quot;Can&#39;t get information on perl.org\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;The domain is called &quot;, $d-&gt;domain, &quot;\n&quot;;</span>
<span class="cp">print &quot;Its tag is &quot;, $d-&gt;tag, &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print &quot;Mail for &quot;, $d-&gt;name, &quot; should be sent to:\n&quot;;</span>
<span class="cp">print map { &quot;\t$_\n&quot; } $d-&gt;address;</span>
<span class="cp">print &quot;\t&quot;, $d-&gt;country, &quot;\n&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$contact_hash = $d-&gt;contacts;</span>
<span class="cp">if ($contact_hash) {</span>
<span class="cp">    print &quot;Contacts:\n&quot;;</span>
<span class="cp">    foreach $type (sort keys %$contact_hash) {</span>
<span class="cp">        print &quot;  $type:\n&quot;;</span>
<span class="cp">        foreach $line (@{$contact_hash-&gt;{$type}}) {</span>
<span class="cp">            print &quot;    $line\n&quot;;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">} else {</span>
<span class="cp">    print &quot;No contact information.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_18.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% cat &gt; expn</span>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp">#...</span>
<span class="cp">#^D</span>
<span class="cp">#% ln expn vrfy</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% expn gnat@frii.com</span>
<span class="cp">#Expanding gnat at frii.com (gnat@frii.com):</span>
<span class="cp">#</span>
<span class="cp">#calisto.frii.com Hello coprolith.frii.com [207.46.130.14],</span>
<span class="cp">#</span>
<span class="cp">#    pleased to meet you</span>
<span class="cp">#</span>
<span class="cp">#&lt;gnat@mail.frii.com&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% expn gnat@frii.com</span>
<span class="cp">#Expanding gnat at mail.frii.net (gnat@frii.com):</span>
<span class="cp">#</span>
<span class="cp">#deimos.frii.com Hello coprolith.frii.com [207.46.130.14],</span>
<span class="cp">#</span>
<span class="cp">#    pleased to meet you</span>
<span class="cp">#</span>
<span class="cp">#Nathan Torkington &lt;gnat@deimos.frii.com&gt;</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#Expanding gnat at mx1.frii.net (gnat@frii.com):</span>
<span class="cp">#</span>
<span class="cp">#phobos.frii.com Hello coprolith.frii.com [207.46.130.14],</span>
<span class="cp">#</span>
<span class="cp">#    pleased to meet you</span>
<span class="cp">#</span>
<span class="cp">#&lt;gnat@mail.frii.com&gt;</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#E</span>
<span class="cp">#xpanding gnat at mx2.frii.net (gnat@frii.com):</span>
<span class="cp">#</span>
<span class="cp">#europa.frii.com Hello coprolith.frii.com [207.46.130.14],</span>
<span class="cp">#</span>
<span class="cp">#    pleased to meet you</span>
<span class="cp">#</span>
<span class="cp">#&lt;gnat@mail.frii.com&gt;</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#Expanding gnat at mx3.frii.net (gnat@frii.com):</span>
<span class="cp">#</span>
<span class="cp">#ns2.winterlan.com Hello coprolith.frii.com [207.46.130.14],</span>
<span class="cp">#</span>
<span class="cp">#    pleased to meet you</span>
<span class="cp">#</span>
<span class="cp">#550 gnat... User unknown</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch18/expn</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># expn -- convince smtp to divulge an alias expansion</span>
<span class="cp">use strict;</span>
<span class="cp">use IO::Socket;</span>
<span class="cp">use Sys::Hostname;</span>

<span class="cp">my $fetch_mx = 0;</span>
<span class="cp"># try loading the module, but don&#39;t blow up if missing</span>
<span class="cp">eval {    </span>
<span class="cp">    require Net::DNS;</span>
<span class="cp">    Net::DNS-&gt;import(&#39;mx&#39;);</span>
<span class="cp">    $fetch_mx = 1;</span>
<span class="cp">};</span>

<span class="cp">my $selfname = hostname();</span>
<span class="cp">die &quot;usage: $0 address\@host ...\n&quot; unless @ARGV;</span>

<span class="cp"># Find out whether called as &quot;vrfy&quot; or &quot;expn&quot;.</span>
<span class="cp">my $VERB = ($0 =~ /ve?ri?fy$/i)  ? &#39;VRFY&#39; : &#39;EXPN&#39;;</span>
<span class="cp">my $multi = @ARGV &gt; 1;</span>
<span class="cp">my $remote;</span>

<span class="cp"># Iterate over addresses give on command line.</span>
<span class="cp">foreach my $combo (@ARGV) {</span>
<span class="cp">    my ($name, $host) = split(/\@/, $combo);</span>
<span class="cp">    my @hosts;</span>
<span class="cp">    $host ||= &#39;localhost&#39;;</span>
<span class="cp">    @hosts = map { $_-&gt;exchange } mx($host)     if $fetch_mx;</span>
<span class="cp">    @hosts = ($host)   unless @hosts;</span>

<span class="cp">    foreach my $host (@hosts) { </span>
<span class="cp">        print $VERB eq &#39;VRFY&#39; ? &quot;Verify&quot; : &quot;Expand&quot;, </span>
<span class="cp">            &quot;ing $name at $host ($combo):&quot;;</span>

<span class="cp">        $remote = IO::Socket::INET-&gt;new(</span>
<span class="cp">    		       Proto    =&gt; &quot;tcp&quot;,</span>
<span class="cp">    		       PeerAddr =&gt; $host,</span>
<span class="cp">    		       PeerPort =&gt; &quot;smtp(25)&quot;,</span>
<span class="cp">    		   ); </span>

<span class="cp">        unless ($remote) { </span>
<span class="cp">            warn &quot;cannot connect to $host\n&quot;;</span>
<span class="cp">            next;</span>
<span class="cp">        }</span>
<span class="cp">        print &quot;\n&quot;;</span>

<span class="cp">        $remote-&gt;autoflush(1);</span>

<span class="cp">        # use CRLF network line terminators</span>
<span class="cp">        print $remote &quot;HELO $selfname\015\012&quot;;</span>
<span class="cp">        print $remote &quot;$VERB $name\015\012&quot;;</span>
<span class="cp">        print $remote &quot;quit\015\012&quot;;</span>
<span class="cp">        while (&lt;$remote&gt;) {</span>
<span class="cp">    	        /^220\b/ &amp;&amp; next;</span>
<span class="cp">    	        /^221\b/ &amp;&amp; last;</span>
<span class="cp">    	        s/250\b[\-\s]+//;</span>
<span class="cp">    	        print;</span>
<span class="cp">        } </span>
<span class="cp">        close($remote)			or die &quot;can&#39;t close socket: $!&quot;;</span>
<span class="cp">        print &quot;\n&quot;; #  if @ARGV;</span>
<span class="cp">    }</span>
<span class="cp">} </span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># http://www.perl.com/CPAN/</span>
<span class="cp"># http://www.perl.com:8001/bad/mojo.html</span>
<span class="cp"># ftp://gatekeeper.dec.com/pub/misc/netlib.tar.Z</span>
<span class="cp"># ftp://anonymous@myplace:gatekeeper.dec.com/pub/misc/netlib.tar.Z</span>
<span class="cp"># file:///etc/motd</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># http://mox.perl.com/cgi-bin/program?name=Johann&amp;born=1685</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># http://mox.perl.com/cgi-bin/program</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch19/hiweb</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># hiweb - load CGI module to decode information given by web server</span>
<span class="cp">use strict;</span>

<span class="cp">use CGI qw(:standard escapeHTML);</span>

<span class="cp"># get a parameter from a form</span>
<span class="cp">my $value = param(&#39;PARAM_NAME&#39;);</span>

<span class="cp"># output a document</span>
<span class="cp">print header(), start_html(&quot;Howdy there!&quot;),</span>
<span class="cp">      p(&quot;You typed: &quot;, tt(escapeHTML($value))),</span>
<span class="cp">      end_html();</span>

<span class="cp">#-----------------------------</span>
<span class="cp">use CGI qw(:standard);</span>
<span class="cp">$who   = param(&quot;Name&quot;);</span>
<span class="cp">$phone = param(&quot;Number&quot;);</span>
<span class="cp">@picks = param(&quot;Choices&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print header( -TYPE    =&gt; &#39;text/plain&#39;,</span>
<span class="cp">              -EXPIRES =&gt; &#39;+3d&#39; );</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use CGI::Carp;</span>
<span class="cp">warn &quot;This is a complaint&quot;;</span>
<span class="cp">die &quot;But this one is serious&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">BEGIN {</span>
<span class="cp">    use CGI::Carp qw(carpout);</span>
<span class="cp">    open(LOG, &quot;&gt;&gt;/var/local/cgi-logs/mycgi-log&quot;)</span>
<span class="cp">        or die &quot;Unable to append to mycgi-log: $!\n&quot;;</span>
<span class="cp">    carpout(*LOG);</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use CGI::Carp qw(fatalsToBrowser);</span>
<span class="cp">die &quot;Bad error here&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch19/webwhoami</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># webwhoami - show web users id</span>
<span class="cp">print &quot;Content-Type: text/plain\n\n&quot;;</span>
<span class="cp">print &quot;Running as &quot;, scalar getpwuid($&gt;), &quot;\n&quot;;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -wc cgi-script        # just compilation</span>
<span class="cp">#</span>
<span class="cp">#% perl -w  cgi-script        # parms from stdin</span>
<span class="cp">#(offline mode: enter name=value pairs on standard input)</span>
<span class="cp">#</span>
<span class="cp">#name=joe</span>
<span class="cp">#</span>
<span class="cp">#number=10</span>
<span class="cp">#</span>
<span class="cp">#^D</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#% perl -w  cgi-script name=joe number=10    # run with mock form input</span>
<span class="cp">#% perl -d  cgi-script name=joe number=10    # ditto, under the debugger</span>
<span class="cp">#</span>
<span class="cp">## POST method script in csh</span>
<span class="cp">#% (setenv HTTP_METHOD POST; perl -w cgi-script name=joe number=10)</span>
<span class="cp">## POST method script in sh</span>
<span class="cp">#% HTTP_METHOD=POST perl -w cgi-script name=joe number=10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -MCGI -le &#39;print CGI-&gt;VERSION&#39;</span>
<span class="cp">#2.49</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$| = 1;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/usr/bin/perl -T</span>
<span class="cp">open(FH, &quot;&gt; $ARGV[0]&quot;) or die;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># Insecure dependency in open while running with -T switch at ...</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$file = $ARGV[0];                                   # $file tainted</span>
<span class="cp">unless ($file =~ m#^([\w.-]+)$#) {                  # $1 is untainted</span>
<span class="cp">    die &quot;filename &#39;$file&#39; has invalid characters.\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">$file = $1;                                         # $file untainted</span>
<span class="cp">#-----------------------------</span>
<span class="cp">unless (-e $filename) {                     # WRONG!</span>
<span class="cp">    open(FH, &quot;&gt; $filename&quot;);</span>
<span class="cp">    # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Alias /perl/ /real/path/to/perl/scripts/</span>
<span class="cp">#</span>
<span class="cp">#&lt;Location /perl&gt;</span>
<span class="cp">#SetHandler  perl-script</span>
<span class="cp">#PerlHandler Apache::Registry</span>
<span class="cp">#Options ExecCGI</span>
<span class="cp">#&lt;/Location&gt;</span>
<span class="cp">#</span>
<span class="cp">#PerlModule Apache::Registry</span>
<span class="cp">#PerlModule CGI</span>
<span class="cp">#PerlSendHeader On</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&lt;Files *.perl&gt;</span>
<span class="cp">#SetHandler  perl-script</span>
<span class="cp">#PerlHandler Apache::Registry</span>
<span class="cp">#Options ExecCGI</span>
<span class="cp">#&lt;/Files&gt;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">system(&quot;command $input @files&quot;);            # UNSAFE</span>
<span class="cp">#-----------------------------</span>
<span class="cp">system(&quot;command&quot;, $input, @files);          # safer</span>
<span class="cp">#-----------------------------</span>
<span class="cp">chomp($now = `date`);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@output = `grep $input @files`;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">die &quot;cannot fork: $!&quot; unless defined ($pid = open(SAFE_KID, &quot;|-&quot;));</span>
<span class="cp">if ($pid == 0) {</span>
<span class="cp">    exec(&#39;grep&#39;, $input, @files) or die &quot;can&#39;t exec grep: $!&quot;;</span>
<span class="cp">} else {</span>
<span class="cp">    @output = &lt;SAFE_KID&gt;;</span>
<span class="cp">    close SAFE_KID;                 # $? contains status</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(KID_TO_READ, &quot;$program @options @args |&quot;);    # UNSAFE</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># add error processing as above</span>
<span class="cp">die &quot;cannot fork: $!&quot; unless defined($pid = open(KID_TO_READ, &quot;-|&quot;));</span>

<span class="cp">if ($pid) {   # parent</span>
<span class="cp">   while (&lt;KID_TO_READ&gt;) {</span>
<span class="cp">       # do something interesting</span>
<span class="cp">   }</span>
<span class="cp">   close(KID_TO_READ)               or warn &quot;kid exited $?&quot;;</span>

<span class="cp">} else {      # child</span>
<span class="cp">   # reconfigure, then</span>
<span class="cp">   exec($program, @options, @args)  or die &quot;can&#39;t exec program: $!&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">open(KID_TO_WRITE, &quot;|$program $options @args&quot;);   # UNSAFE</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$pid = open(KID_TO_WRITE, &quot;|-&quot;);</span>
<span class="cp">die &quot;cannot fork: $!&quot; unless defined($pid = open(KID_TO_WRITE, &quot;|-&quot;));</span>
<span class="cp">$SIG{ALRM} = sub { die &quot;whoops, $program pipe broke&quot; };</span>

<span class="cp">if ($pid) {  # parent</span>
<span class="cp">   for (@data) { print KID_TO_WRITE $_ }</span>
<span class="cp">   close(KID_TO_WRITE)              or warn &quot;kid exited $?&quot;;</span>

<span class="cp">} else {     # child</span>
<span class="cp">   # reconfigure, then</span>
<span class="cp">   exec($program, @options, @args)  or die &quot;can&#39;t exec program: $!&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print ol( li([ qw(red blue green)]) );</span>
<span class="cp"># &lt;OL&gt;&lt;LI&gt;red&lt;/LI&gt; &lt;LI&gt;blue&lt;/LI&gt; &lt;LI&gt;green&lt;/LI&gt;&lt;/OL&gt;</span>

<span class="cp">@names = qw(Larry Moe Curly);</span>
<span class="cp">print ul( li({ -TYPE =&gt; &quot;disc&quot; }, \@names) );</span>
<span class="cp"># &lt;UL&gt;&lt;LI TYPE=&quot;disc&quot;&gt;Larry&lt;/LI&gt; &lt;LI TYPE=&quot;disc&quot;&gt;Moe&lt;/LI&gt;</span>
<span class="cp">#</span>
<span class="cp">#     &lt;LI TYPE=&quot;disc&quot;&gt;Curly&lt;/LI&gt;&lt;/UL&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print li(&quot;alpha&quot;);</span>
<span class="cp">#     &lt;LI&gt;alpha&lt;/LI&gt;</span>

<span class="cp">print li( [ &quot;alpha&quot;, &quot;omega&quot;] );</span>
<span class="cp">#     &lt;LI&gt;alpha&lt;/LI&gt; &lt;LI&gt;omega&lt;/LI&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use CGI qw(:standard :html3);</span>

<span class="cp">%hash = (</span>
<span class="cp">    &quot;Wisconsin&quot;  =&gt; [ &quot;Superior&quot;, &quot;Lake Geneva&quot;, &quot;Madison&quot; ],</span>
<span class="cp">    &quot;Colorado&quot;   =&gt; [ &quot;Denver&quot;, &quot;Fort Collins&quot;, &quot;Boulder&quot; ],</span>
<span class="cp">    &quot;Texas&quot;      =&gt; [ &quot;Plano&quot;, &quot;Austin&quot;, &quot;Fort Stockton&quot; ],</span>
<span class="cp">    &quot;California&quot; =&gt; [ &quot;Sebastopol&quot;, &quot;Santa Rosa&quot;, &quot;Berkeley&quot; ],</span>
<span class="cp">);</span>

<span class="cp">$\ = &quot;\n&quot;;</span>

<span class="cp">print &quot;&lt;TABLE&gt; &lt;CAPTION&gt;Cities I Have Known&lt;/CAPTION&gt;&quot;;</span>
<span class="cp">print Tr(th [qw(State Cities)]);</span>
<span class="cp">for $k (sort keys %hash) {</span>
<span class="cp">    print Tr(th($k), td( [ sort @{$hash{$k}} ] ));</span>
<span class="cp">}</span>
<span class="cp">print &quot;&lt;/TABLE&gt;&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># &lt;TABLE&gt; &lt;CAPTION&gt;Cities I Have Known&lt;/CAPTION&gt;</span>
<span class="cp"># </span>
<span class="cp">#     &lt;TR&gt;&lt;TH&gt;State&lt;/TH&gt; &lt;TH&gt;Cities&lt;/TH&gt;&lt;/TR&gt;</span>
<span class="cp"># </span>
<span class="cp">#     &lt;TR&gt;&lt;TH&gt;California&lt;/TH&gt; &lt;TD&gt;Berkeley&lt;/TD&gt; &lt;TD&gt;Santa Rosa&lt;/TD&gt; </span>
<span class="cp"># </span>
<span class="cp"># 	  &lt;TD&gt;Sebastopol&lt;/TD&gt; &lt;/TR&gt;</span>
<span class="cp"># </span>
<span class="cp">#     &lt;TR&gt;&lt;TH&gt;Colorado&lt;/TH&gt; &lt;TD&gt;Boulder&lt;/TD&gt; &lt;TD&gt;Denver&lt;/TD&gt; </span>
<span class="cp"># </span>
<span class="cp"># 	  &lt;TD&gt;Fort Collins&lt;/TD&gt; &lt;/TR&gt;</span>
<span class="cp"># </span>
<span class="cp">#     &lt;TR&gt;&lt;TH&gt;Texas&lt;/TH&gt; &lt;TD&gt;Austin&lt;/TD&gt; &lt;TD&gt;Fort Stockton&lt;/TD&gt; </span>
<span class="cp"># </span>
<span class="cp"># 	  &lt;TD&gt;Plano&lt;/TD&gt;&lt;/TR&gt;</span>
<span class="cp"># </span>
<span class="cp">#     &lt;TR&gt;&lt;TH&gt;Wisconsin&lt;/TH&gt; &lt;TD&gt;Lake Geneva&lt;/TD&gt; &lt;TD&gt;Madison&lt;/TD&gt; </span>
<span class="cp"># </span>
<span class="cp"># 	  &lt;TD&gt;Superior&lt;/TD&gt;&lt;/TR&gt;</span>
<span class="cp"># </span>
<span class="cp"># &lt;/TABLE&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print table</span>
<span class="cp">        caption(&#39;Cities I have Known&#39;),</span>
<span class="cp">        Tr(th [qw(State Cities)]),</span>
<span class="cp">        map { Tr(th($_), td( [ sort @{$hash{$_}} ] )) } sort keys %hash;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch19/salcheck</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># salcheck - check for salaries</span>
<span class="cp">use DBI;</span>
<span class="cp">use CGI qw(:standard :html3);</span>

<span class="cp">$limit = param(&quot;LIMIT&quot;);</span>

<span class="cp">print header(), start_html(&quot;Salary Query&quot;),</span>
<span class="cp">      h1(&quot;Search&quot;),</span>
<span class="cp">      start_form(),</span>
<span class="cp">      p(&quot;Enter minimum salary&quot;, textfield(&quot;LIMIT&quot;)),</span>
<span class="cp">      submit(),</span>
<span class="cp">      end_form();</span>

<span class="cp">if (defined $limit) {</span>
<span class="cp">    $dbh = DBI-&gt;connect(&quot;dbi:mysql:somedb:server.host.dom:3306&quot;, </span>
<span class="cp">        &quot;username&quot;, &quot;password&quot;) </span>
<span class="cp">        or die &quot;Connecting: $DBI::errstr&quot;;</span>
<span class="cp">    $sth = $dbh-&gt;prepare(&quot;SELECT name,salary FROM employees </span>
<span class="cp">        WHERE salary &gt; $limit&quot;)</span>
<span class="cp">        or die &quot;Preparing: &quot;, $dbh-&gt;errstr;</span>
<span class="cp">    $sth-&gt;execute</span>
<span class="cp">        or die &quot;Executing: &quot;, $sth-&gt;errstr;</span>

<span class="cp">    print h1(&quot;Results&quot;), &quot;&lt;TABLE BORDER=1&gt;&quot;;</span>

<span class="cp">    while (@row = $sth-&gt;fetchrow()) {</span>
<span class="cp">           print Tr( td( \@row ) );</span>
<span class="cp">    }</span>

<span class="cp">    print &quot;&lt;/TABLE&gt;\n&quot;;</span>
<span class="cp">    $sth-&gt;finish;</span>
<span class="cp">    $dbh-&gt;disconnect;</span>
<span class="cp">}</span>

<span class="cp">print end_html();</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$url = &quot;http://www.perl.com/CPAN/&quot;;</span>
<span class="cp">print &quot;Location: $url\n\n&quot;;</span>
<span class="cp">exit;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch19/oreobounce</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># oreobounce - set a cookie and redirect the browser</span>
<span class="cp">use CGI qw(:cgi);</span>

<span class="cp">$oreo = cookie( -NAME    =&gt; &#39;filling&#39;,</span>
<span class="cp">                -VALUE   =&gt; &quot;vanilla crme&quot;,</span>
<span class="cp">                -EXPIRES =&gt; &#39;+3M&#39;,    # M for month, m for minute</span>
<span class="cp">                -DOMAIN  =&gt; &#39;.perl.com&#39;);</span>

<span class="cp">$whither  = &quot;http://somewhere.perl.com/nonesuch.html&quot;;</span>

<span class="cp">print redirect( -URL     =&gt; $whither,</span>
<span class="cp">                -COOKIE  =&gt; $oreo);</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#Status: 302 Moved Temporarily</span>
<span class="cp">#</span>
<span class="cp">#Set-Cookie: filling=vanilla%20cr%E4me; domain=.perl.com; </span>
<span class="cp">#</span>
<span class="cp">#    expires=Tue, 21-Jul-1998 11:58:55 GMT</span>
<span class="cp">#</span>
<span class="cp">#Date: Tue, 21 Apr 1998 11:55:55 GMT</span>
<span class="cp">#</span>
<span class="cp">#Location: http://somewhere.perl.com/nonesuch.html</span>
<span class="cp">#</span>
<span class="cp">#Content-Type: text/html</span>
<span class="cp">#</span>
<span class="cp">#B&lt;&lt;blank line here&gt;&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch19/os_snipe</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># os_snipe - redirect to a Jargon File entry about current OS</span>
<span class="cp">$dir = &#39;http://www.wins.uva.nl/%7Emes/jargon&#39;;</span>
<span class="cp">for ($ENV{HTTP_USER_AGENT}) {</span>
<span class="cp">    $page  =    /Mac/            &amp;&amp; &#39;m/Macintrash.html&#39;</span>
<span class="cp">             || /Win(dows )?NT/  &amp;&amp; &#39;e/evilandrude.html&#39;</span>
<span class="cp">             || /Win|MSIE|WebTV/ &amp;&amp; &#39;m/MicroslothWindows.html&#39;</span>
<span class="cp">             || /Linux/          &amp;&amp; &#39;l/Linux.html&#39;</span>
<span class="cp">             || /HP-UX/          &amp;&amp; &#39;h/HP-SUX.html&#39;</span>
<span class="cp">             || /SunOS/          &amp;&amp; &#39;s/ScumOS.html&#39;</span>
<span class="cp">             ||                     &#39;a/AppendixB.html&#39;;</span>
<span class="cp">}</span>
<span class="cp">print &quot;Location: $dir/$page\n\n&quot;;</span>

<span class="cp">#-----------------------------</span>
<span class="cp">use CGI qw(:standard);</span>
<span class="cp">print header( -STATUS =&gt; &#39;204 No response&#39; );</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#Status: 204 No response</span>
<span class="cp">#</span>
<span class="cp">#Content-Type: text/html</span>
<span class="cp">#</span>
<span class="cp">#&lt;blank line here&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#!/bin/sh</span>

<span class="cp">cat &lt;&lt;EOCAT</span>
<span class="cp">Status: 204 No response</span>
<span class="cp"> </span>
<span class="cp">EOCAT</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch19/dummyhttpd</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># dummyhttpd - start an HTTP daemon and print what the client sends</span>

<span class="cp">use strict;</span>
<span class="cp">use HTTP::Daemon;  # need LWP-5.32 or better</span>

<span class="cp">my $server = HTTP::Daemon-&gt;new(Timeout =&gt; 60);</span>
<span class="cp">print &quot;Please contact me at: &lt;URL:&quot;, $server-&gt;url, &quot;&gt;\n&quot;;</span>

<span class="cp">while (my $client = $server-&gt;accept) {</span>
<span class="cp">  CONNECTION:</span>
<span class="cp">    while (my $answer = $client-&gt;get_request) {</span>
<span class="cp">        print $answer-&gt;as_string;</span>
<span class="cp">        $client-&gt;autoflush;</span>
<span class="cp">      RESPONSE:</span>
<span class="cp">        while (&lt;STDIN&gt;) {</span>
<span class="cp">            last RESPONSE   if $_ eq &quot;.\n&quot;;</span>
<span class="cp">            last CONNECTION if $_ eq &quot;..\n&quot;;</span>
<span class="cp">            print $client $_;</span>
<span class="cp">        }</span>
<span class="cp">        print &quot;\nEOF\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    print &quot;CLOSE: &quot;, $client-&gt;reason, &quot;\n&quot;;</span>
<span class="cp">    $client-&gt;close;</span>
<span class="cp">    undef $client;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#http://somewhere.com/cgi-bin/whatever</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#http://somewhere.com:8989/cgi-bin/whatever</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% telnet www.perl.com 80</span>
<span class="cp">#GET /bogotic HTTP/1.0</span>
<span class="cp">#</span>
<span class="cp">#&lt;blank line here&gt;</span>
<span class="cp">#</span>
<span class="cp">#HTTP/1.1 404 File Not Found</span>
<span class="cp">#</span>
<span class="cp">#Date: Tue, 21 Apr 1998 11:25:43 GMT</span>
<span class="cp">#</span>
<span class="cp">#Server: Apache/1.2.4</span>
<span class="cp">#</span>
<span class="cp">#Connection: close</span>
<span class="cp">#</span>
<span class="cp">#Content-Type: text/html</span>
<span class="cp">#</span>
<span class="cp">#</span>
<span class="cp">#&lt;HTML&gt;&lt;HEAD&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;TITLE&gt;404 File Not Found&lt;/TITLE&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;/HEAD&gt;&lt;BODY&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;H1&gt;File Not Found&lt;/H1&gt;</span>
<span class="cp">#</span>
<span class="cp">#The requested URL /bogotic was not found on this server.&lt;P&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;/BODY&gt;&lt;/HTML&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">% GET -esuSU http://mox.perl.com/perl/bogotic</span>
<span class="cp"># GET http://language.perl.com/bogotic</span>
<span class="cp"># </span>
<span class="cp"># Host: mox.perl.com</span>
<span class="cp"># </span>
<span class="cp"># User-Agent: lwp-request/1.32</span>
<span class="cp"># </span>
<span class="cp"># </span>
<span class="cp"># GET http://mox.perl.com/perl/bogotic --&gt; 302 Moved Temporarily</span>
<span class="cp"># </span>
<span class="cp"># GET http://www.perl.com/perl/bogotic --&gt; 302 Moved Temporarily</span>
<span class="cp"># </span>
<span class="cp"># GET http://language.perl.com/bogotic --&gt; 404 File Not Found</span>
<span class="cp"># </span>
<span class="cp"># Connection: close</span>
<span class="cp"># </span>
<span class="cp"># Date: Tue, 21 Apr 1998 11:29:03 GMT</span>
<span class="cp"># </span>
<span class="cp"># Server: Apache/1.2.4</span>
<span class="cp"># </span>
<span class="cp"># Content-Type: text/html</span>
<span class="cp"># </span>
<span class="cp"># Client-Date: Tue, 21 Apr 1998 12:29:01 GMT</span>
<span class="cp"># </span>
<span class="cp"># Client-Peer: 208.201.239.47:80</span>
<span class="cp"># </span>
<span class="cp"># Title: Broken perl.com Links</span>
<span class="cp"># </span>
<span class="cp"># </span>
<span class="cp"># &lt;HTML&gt;</span>
<span class="cp"># </span>
<span class="cp"># &lt;HEAD&gt;&lt;TITLE&gt;An Error Occurred&lt;/TITLE&gt;&lt;/HEAD&gt;</span>
<span class="cp"># </span>
<span class="cp"># &lt;BODY&gt;</span>
<span class="cp"># </span>
<span class="cp"># &lt;H1&gt;An Error Occurred&lt;/h1&gt;</span>
<span class="cp"># </span>
<span class="cp"># 404 File Not Found</span>
<span class="cp"># </span>
<span class="cp"># &lt;/BODY&gt;</span>
<span class="cp"># </span>
<span class="cp"># &lt;/HTML&gt;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$preference_value = cookie(&quot;preference name&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$packed_cookie = cookie( -NAME    =&gt; &quot;preference name&quot;,</span>
<span class="cp">                         -VALUE   =&gt; &quot;whatever you&#39;d like&quot;,</span>
<span class="cp">                         -EXPIRES =&gt; &quot;+2y&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print header(-COOKIE =&gt; $packed_cookie);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch19/ic_cookies</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># ic_cookies - sample CGI script that uses a cookie</span>
<span class="cp">use CGI qw(:standard);</span>

<span class="cp">use strict;</span>

<span class="cp">my $cookname = &quot;favorite ice cream&quot;;</span>
<span class="cp">my $favorite = param(&quot;flavor&quot;);</span>
<span class="cp">my $tasty    = cookie($cookname) || &#39;mint&#39;;</span>

<span class="cp">unless ($favorite) {</span>
<span class="cp">    print header(), start_html(&quot;Ice Cookies&quot;), h1(&quot;Hello Ice Cream&quot;),</span>
<span class="cp">          hr(), start_form(),</span>
<span class="cp">            p(&quot;Please select a flavor: &quot;, textfield(&quot;flavor&quot;,$tasty)),</span>
<span class="cp">              end_form(), hr();</span>
<span class="cp">    exit;</span>
<span class="cp">}</span>

<span class="cp">my $cookie = cookie(</span>
<span class="cp">                -NAME    =&gt; $cookname,</span>
<span class="cp">                -VALUE   =&gt; $favorite,</span>
<span class="cp">                -EXPIRES =&gt; &quot;+2y&quot;,</span>
<span class="cp">            );</span>

<span class="cp">print header(-COOKIE =&gt; $cookie),</span>
<span class="cp">      start_html(&quot;Ice Cookies, #2&quot;),</span>
<span class="cp">      h1(&quot;Hello Ice Cream&quot;),</span>
<span class="cp">      p(&quot;You chose as your favorite flavor `$favorite&#39;.&quot;);</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print textfield(&quot;SEARCH&quot;);          # previous SEARCH value is the default</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch19/who.cgi</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -wT</span>
<span class="cp"># who.cgi - run who(1) on a user and format the results nicely</span>

<span class="cp">$ENV{IFS}=&#39;&#39;;</span>
<span class="cp">$ENV{PATH}=&#39;/bin:/usr/bin&#39;;</span>

<span class="cp">use CGI qw(:standard);</span>

<span class="cp"># print search form</span>
<span class="cp">print header(), start_html(&quot;Query Users&quot;), h1(&quot;Search&quot;);</span>
<span class="cp">print start_form(), p(&quot;Which user?&quot;, textfield(&quot;WHO&quot;)); submit(), end_form();</span>

<span class="cp"># print results of the query if we have someone to look for</span>
<span class="cp">$name = param(&quot;WHO&quot;);</span>
<span class="cp">if ($name) {</span>
<span class="cp">    print h1(&quot;Results&quot;);</span>
<span class="cp">    $html = &#39;&#39;;</span>
<span class="cp">    </span>
<span class="cp">    # call who and build up text of response</span>
<span class="cp">    foreach (`who`) {</span>
<span class="cp">        next unless /^$name\s/o;            # only lines matching $name</span>
<span class="cp">        s/&amp;/&amp;amp;/g;                        # escape HTML</span>
<span class="cp">        s/&lt;/&amp;lt;/g;</span>
<span class="cp">        s/&gt;/&amp;gt;/g;</span>
<span class="cp">        $html .= $_;</span>
<span class="cp">    }</span>
<span class="cp">    # nice message if we didn&#39;t find anyone by that name</span>
<span class="cp">    $html = $html || &quot;$name is not logged in&quot;;</span>
<span class="cp">    </span>
<span class="cp">    print pre($html);</span>
<span class="cp">}</span>

<span class="cp">print end_html();</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use CGI qw(:standard);</span>
<span class="cp">print hidden(&quot;bacon&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">    print submit(-NAME =&gt; &quot;.State&quot;, -VALUE =&gt; &quot;Checkout&quot;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub to_page { return submit( -NAME =&gt; &quot;.State&quot;, -VALUE =&gt; shift ) }</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$page = param(&quot;.State&quot;) || &quot;Default&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($page eq &quot;Default&quot;) {</span>
<span class="cp">    front_page();</span>
<span class="cp">} elsif ($page eq &quot;Checkout&quot;) {</span>
<span class="cp">    checkout();</span>
<span class="cp">} else {</span>
<span class="cp">    no_such_page();         # when we get a .State that doesn&#39;t exist</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%States = (</span>
<span class="cp">    &#39;Default&#39;     =&gt; \&amp;front_page,</span>
<span class="cp">    &#39;Shirt&#39;       =&gt; \&amp;shirt,</span>
<span class="cp">    &#39;Sweater&#39;     =&gt; \&amp;sweater,</span>
<span class="cp">    &#39;Checkout&#39;    =&gt; \&amp;checkout,</span>
<span class="cp">    &#39;Card&#39;        =&gt; \&amp;credit_card,</span>
<span class="cp">    &#39;Order&#39;       =&gt; \&amp;order,</span>
<span class="cp">    &#39;Cancel&#39;      =&gt; \&amp;front_page,</span>
<span class="cp">);</span>

<span class="cp">if ($States{$page}) {</span>
<span class="cp">    $States{$page}-&gt;();   # call the correct subroutine </span>
<span class="cp">} else {</span>
<span class="cp">    no_such_page();</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (($state, $sub) = each %States) {</span>
<span class="cp">    $sub-&gt;( $page eq $state );</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub t_shirt {</span>
<span class="cp">    my $active = shift;</span>

<span class="cp">    unless ($active) {</span>
<span class="cp">        print hidden(&quot;size&quot;), hidden(&quot;color&quot;);</span>
<span class="cp">        return;</span>
<span class="cp">    }</span>

<span class="cp">    print p(&quot;You want to buy a t-shirt?&quot;);</span>
<span class="cp">    print p(&quot;Size: &quot;, popup_menu(&#39;size&#39;, [ qw(XL L M S XS) ]));</span>
<span class="cp">    print p(&quot;Color:&quot;, popup_menu(&#39;color&#39;, [ qw(Black White) ]));</span>

<span class="cp">    print p( to_page(&quot;Shoes&quot;), to_page(&quot;Checkout&quot;) );</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">print header(&quot;Program Title&quot;), start_html();</span>
<span class="cp">print standard_header(), begin_form();</span>
<span class="cp">while (($state, $sub) = each %States) {</span>
<span class="cp">    $sub-&gt;( $page eq $state );</span>
<span class="cp">}</span>
<span class="cp">print standard_footer(), end_form(), end_html();</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># first open and exclusively lock the file</span>
<span class="cp">open(FH, &quot;&gt;&gt;/tmp/formlog&quot;)              or die &quot;can&#39;t append to formlog: $!&quot;;</span>
<span class="cp">flock(FH, 2)                            or die &quot;can&#39;t flock formlog: $!&quot;;</span>

<span class="cp"># either using the procedural interface</span>
<span class="cp">use CGI qw(:standard);</span>
<span class="cp">save_parameters(*FH);                   # with CGI::save</span>

<span class="cp"># or using the object interface</span>
<span class="cp">use CGI;</span>
<span class="cp">$query = CGI-&gt;new();</span>
<span class="cp">$query-&gt;save(*FH);</span>

<span class="cp">close(FH)                               or die &quot;can&#39;t close formlog: $!&quot;;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use CGI qw(:standard);</span>
<span class="cp">open(MAIL, &quot;|/usr/lib/sendmail -oi -t&quot;) or die &quot;can&#39;t fork sendmail: $!&quot;;</span>
<span class="cp">print MAIL &lt;&lt;EOF;</span>
<span class="cp">From: $0 (your cgi script)</span>
<span class="cp">To: hisname\@hishost.com</span>
<span class="cp">Subject: mailed form submission</span>

<span class="cp">EOF</span>
<span class="cp">save_parameters(*MAIL);</span>
<span class="cp">close(MAIL)                             or die &quot;can&#39;t close sendmail: $!&quot;; </span>
<span class="cp">#-----------------------------</span>
<span class="cp">param(&quot;_timestamp&quot;, scalar localtime);</span>
<span class="cp">param(&quot;_environs&quot;, %ENV);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use CGI;</span>
<span class="cp">open(FORMS, &quot;&lt; /tmp/formlog&quot;)       or die &quot;can&#39;t read formlog: $!&quot;;</span>
<span class="cp">flock(FORMS, 1)                     or die &quot;can&#39;t lock formlog: $!&quot;;</span>
<span class="cp">while ($query = CGI-&gt;new(*FORMS)) {</span>
<span class="cp">    last unless $query-&gt;param();     # means end of file</span>
<span class="cp">    %his_env = $query-&gt;param(&#39;_environs&#39;);</span>
<span class="cp">    $count  += $query-&gt;param(&#39;items requested&#39;)</span>
<span class="cp">                unless $his_env{REMOTE_HOST} =~ /(^|\.)perl\.com$/</span>
<span class="cp">}</span>
<span class="cp">print &quot;Total orders: $count\n&quot;;</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_19.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch19/chemiserie</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># chemiserie - simple CGI shopping for shirts and sweaters</span>

<span class="cp">use strict;</span>
<span class="cp">use CGI qw(:standard);</span>
<span class="cp">use CGI::Carp qw(fatalsToBrowser);</span>

<span class="cp">my %States;    	         # state table mapping pages to functions</span>
<span class="cp">my $Current_Screen;    	# the current screen</span>

<span class="cp"># Hash of pages and functions.</span>

<span class="cp">%States = (</span>
<span class="cp">    &#39;Default&#39;     =&gt; \&amp;front_page,</span>
<span class="cp">    &#39;Shirt&#39;       =&gt; \&amp;shirt,</span>
<span class="cp">    &#39;Sweater&#39;     =&gt; \&amp;sweater,</span>
<span class="cp">    &#39;Checkout&#39;    =&gt; \&amp;checkout,</span>
<span class="cp">    &#39;Card&#39;        =&gt; \&amp;credit_card,</span>
<span class="cp">    &#39;Order&#39;       =&gt; \&amp;order,</span>
<span class="cp">    &#39;Cancel&#39;      =&gt; \&amp;front_page,</span>
<span class="cp">);</span>

<span class="cp">$Current_Screen = param(&quot;.State&quot;) || &quot;Default&quot;;</span>
<span class="cp">die &quot;No screen for $Current_Screen&quot; unless $States{$Current_Screen};</span>

<span class="cp"># Generate the current page.</span>

<span class="cp">standard_header();</span>

<span class="cp">while (my($screen_name, $function) = each %States) {</span>
<span class="cp">    $function-&gt;($screen_name eq $Current_Screen);</span>
<span class="cp">}</span>
<span class="cp">standard_footer();</span>
<span class="cp">exit;</span>

<span class="cp">################################</span>
<span class="cp"># header, footer, menu functions</span>
<span class="cp">################################</span>

<span class="cp">sub standard_header {</span>
<span class="cp">    print header(), start_html(-Title =&gt; &quot;Shirts&quot;, -BGCOLOR=&gt;&quot;White&quot;);</span>
<span class="cp">    print start_form(); # start_multipart_form() if file upload</span>
<span class="cp">}</span>

<span class="cp">sub standard_footer { print end_form(), end_html() }</span>

<span class="cp">sub shop_menu {</span>
<span class="cp">    print p(defaults(&quot;Empty My Shopping Cart&quot;),</span>
<span class="cp">        to_page(&quot;Shirt&quot;),</span>
<span class="cp">        to_page(&quot;Sweater&quot;),</span>
<span class="cp">        to_page(&quot;Checkout&quot;));</span>
<span class="cp">}</span>

<span class="cp">#############################</span>
<span class="cp"># subroutines for each screen</span>
<span class="cp">#############################</span>

<span class="cp"># The default page.</span>
<span class="cp">sub front_page {</span>
<span class="cp">    my $active = shift;</span>
<span class="cp">    return unless $active;</span>

<span class="cp">    print &quot;&lt;H1&gt;Hi!&lt;/H1&gt;\n&quot;;</span>
<span class="cp">    print &quot;Welcome to our Shirt Shop!  Please make your selection from &quot;;</span>
<span class="cp">    print &quot;the menu below.\n&quot;;</span>

<span class="cp">    shop_menu();</span>
<span class="cp">}</span>

<span class="cp"># Page to order a shirt from.</span>
<span class="cp">sub shirt {</span>
<span class="cp">    my $active = shift;</span>
<span class="cp">    my @sizes  = qw(XL L M S);</span>
<span class="cp">    my @colors = qw(Black White);</span>

<span class="cp">    my ($size, $color, $count) =</span>
<span class="cp">      (param(&quot;shirt_size&quot;), param(&quot;shirt_color&quot;), param(&quot;shirt_count&quot;));</span>

<span class="cp">    # sanity check</span>
<span class="cp">    if ($count) {</span>
<span class="cp">        $color = $colors[0] unless grep { $_ eq $color } @colors;</span>
<span class="cp">        $size  = $sizes[0]  unless grep { $_ eq $size  } @sizes;</span>
<span class="cp">        param(&quot;shirt_color&quot;, $color);</span>
<span class="cp">        param(&quot;shirt_size&quot;,  $size);</span>
<span class="cp">    }</span>

<span class="cp">    unless ($active) {</span>
<span class="cp">        print hidden(&quot;shirt_size&quot;)  if $size;</span>
<span class="cp">        print hidden(&quot;shirt_color&quot;) if $color;</span>
<span class="cp">        print hidden(&quot;shirt_count&quot;) if $count;</span>
<span class="cp">        return;</span>
<span class="cp">    }</span>

<span class="cp">    print h1(&quot;T-Shirt&quot;);</span>
<span class="cp">    print p(&quot;What a shirt!  This baby is decked out with all the options.&quot;,</span>
<span class="cp">        &quot;It comes with full luxury interior, cotton trim, and a collar&quot;,</span>
<span class="cp">        &quot;to make your eyes water!  Unit price: \$33.00&quot;);</span>
<span class="cp">    print h2(&quot;Options&quot;);</span>
<span class="cp">    print p(&quot;How Many?&quot;, textfield(&quot;shirt_count&quot;));</span>
<span class="cp">    print p(&quot;Size?&quot;,  popup_menu(&quot;shirt_size&quot;,  \@sizes ),</span>
<span class="cp">        &quot;Color?&quot;, popup_menu(&quot;shirt_color&quot;, \@colors));</span>

<span class="cp">    shop_menu();</span>
<span class="cp">}</span>

<span class="cp"># Page to order a sweater from.</span>
<span class="cp">sub sweater {</span>
<span class="cp">    my $active = shift;</span>
<span class="cp">    my @sizes  = qw(XL L M);</span>
<span class="cp">    my @colors = qw(Chartreuse Puce Lavender);</span>

<span class="cp">    my ($size, $color, $count) =</span>
<span class="cp">      (param(&quot;sweater_size&quot;), param(&quot;sweater_color&quot;), param(&quot;sweater_count&quot;));</span>

<span class="cp">    # sanity check</span>
<span class="cp">    if ($count) {</span>
<span class="cp">        $color = $colors[0] unless grep { $_ eq $color } @colors;</span>
<span class="cp">        $size  = $sizes[0]  unless grep { $_ eq $size  } @sizes;</span>
<span class="cp">        param(&quot;sweater_color&quot;, $color);</span>
<span class="cp">        param(&quot;sweater_size&quot;,  $size);</span>
<span class="cp">    }</span>

<span class="cp">    unless ($active) {</span>
<span class="cp">        print hidden(&quot;sweater_size&quot;)  if $size;</span>
<span class="cp">        print hidden(&quot;sweater_color&quot;) if $color;</span>
<span class="cp">        print hidden(&quot;sweater_count&quot;) if $count;</span>
<span class="cp">        return;</span>
<span class="cp">    }</span>

<span class="cp">    print h1(&quot;Sweater&quot;);</span>
<span class="cp">    print p(&quot;Nothing implies preppy elegance more than this fine&quot;,</span>
<span class="cp">        &quot;sweater.  Made by peasant workers from black market silk,&quot;,</span>
<span class="cp">        &quot;it slides onto your lean form and cries out ``Take me,&quot;,</span>
<span class="cp">        &quot;for I am a god!&#39;&#39;.  Unit price: \$49.99.&quot;);</span>
<span class="cp">    print h2(&quot;Options&quot;);</span>
<span class="cp">    print p(&quot;How Many?&quot;, textfield(&quot;sweater_count&quot;));</span>
<span class="cp">    print p(&quot;Size?&quot;,  popup_menu(&quot;sweater_size&quot;,  \@sizes));</span>
<span class="cp">    print p(&quot;Color?&quot;, popup_menu(&quot;sweater_color&quot;, \@colors));</span>

<span class="cp">    shop_menu();</span>
<span class="cp">}</span>

<span class="cp"># Page to display current order for confirmation.</span>
<span class="cp">sub checkout {</span>
<span class="cp">    my $active = shift;</span>

<span class="cp">    return unless $active;</span>

<span class="cp">    print h1(&quot;Order Confirmation&quot;);</span>
<span class="cp">    print p(&quot;You ordered the following:&quot;);</span>
<span class="cp">    print order_text();</span>
<span class="cp">    print p(&quot;Is this right?  Select &#39;Card&#39; to pay for the items&quot;,</span>
<span class="cp">        &quot;or &#39;Shirt&#39; or &#39;Sweater&#39; to continue shopping.&quot;);</span>
<span class="cp">    print p(to_page(&quot;Card&quot;),</span>
<span class="cp">        to_page(&quot;Shirt&quot;), </span>
<span class="cp">        to_page(&quot;Sweater&quot;));</span>
<span class="cp">}</span>

<span class="cp"># Page to gather credit-card information.</span>
<span class="cp">sub credit_card {</span>
<span class="cp">    my $active = shift;</span>
<span class="cp">    my @widgets = qw(Name Address1 Address2 City Zip State Phone Card Expiry);</span>

<span class="cp">    unless ($active) {</span>
<span class="cp">        print map { hidden($_) } @widgets;</span>
<span class="cp">        return;</span>
<span class="cp">    }</span>

<span class="cp">    print pre(p(&quot;Name:          &quot;, textfield(&quot;Name&quot;)),</span>
<span class="cp">    	  p(&quot;Address:       &quot;, textfield(&quot;Address1&quot;)),</span>
<span class="cp">    	  p(&quot;               &quot;, textfield(&quot;Address2&quot;)),</span>
<span class="cp">    	  p(&quot;City:          &quot;, textfield(&quot;City&quot;)),</span>
<span class="cp">    	  p(&quot;Zip:           &quot;, textfield(&quot;Zip&quot;)),</span>
<span class="cp">    	  p(&quot;State:         &quot;, textfield(&quot;State&quot;)),</span>
<span class="cp">    	  p(&quot;Phone:         &quot;, textfield(&quot;Phone&quot;)),</span>
<span class="cp">    	  p(&quot;Credit Card #: &quot;, textfield(&quot;Card&quot;)),</span>
<span class="cp">    	  p(&quot;Expiry:        &quot;, textfield(&quot;Expiry&quot;)));</span>

<span class="cp">    print p(&quot;Click on &#39;Order&#39; to order the items.  Click on &#39;Cancel&#39; to return </span>
<span class="cp">shopping.&quot;);</span>

<span class="cp">    print p(to_page(&quot;Order&quot;), to_page(&quot;Cancel&quot;));</span>
<span class="cp">}</span>

<span class="cp"># Page to complete an order.</span>
<span class="cp">sub order {</span>
<span class="cp">    my $active = shift;</span>

<span class="cp">    unless ($active) {</span>
<span class="cp">        return;</span>
<span class="cp">    }</span>

<span class="cp">    # you&#39;d check credit card values here</span>

<span class="cp">    print h1(&quot;Ordered!&quot;);</span>
<span class="cp">    print p(&quot;You have ordered the following toppings:&quot;);</span>
<span class="cp">    print order_text();</span>

<span class="cp">    print p(defaults(&quot;Begin Again&quot;));</span>
<span class="cp">}</span>

<span class="cp"># Returns HTML for the current order (&quot;You have ordered ...&quot;)</span>
<span class="cp">sub order_text {</span>
<span class="cp">    my $html = &#39;&#39;;</span>

<span class="cp">    if (param(&quot;shirt_count&quot;)) {</span>
<span class="cp">        $html .= p(&quot;You have ordered &quot;, param(&quot;shirt_count&quot;),</span>
<span class="cp">    	       &quot; shirts of size &quot;,  param(&quot;shirt_size&quot;),</span>
<span class="cp">    	       &quot; and color &quot;, param(&quot;shirt_color&quot;), &quot;.&quot;);</span>
<span class="cp">    }</span>
<span class="cp">    if (param(&quot;sweater_count&quot;)) {</span>
<span class="cp">        $html .= p(&quot;You have ordered &quot;,  param(&quot;sweater_count&quot;),</span>
<span class="cp">    	       &quot; sweaters of size &quot;, param(&quot;sweater_size&quot;),</span>
<span class="cp">    	       &quot; and color &quot;, param(&quot;sweater_color&quot;), &quot;.&quot;);</span>
<span class="cp">    }</span>
<span class="cp">    $html = p(&quot;Nothing!&quot;) unless $html;</span>
<span class="cp">    $html .= p(&quot;For a total cost of &quot;, calculate_price());</span>
<span class="cp">    return $html;</span>
<span class="cp">}</span>

<span class="cp">sub calculate_price {</span>
<span class="cp">    my $shirts   = param(&quot;shirt_count&quot;)   || 0;</span>
<span class="cp">    my $sweaters = param(&quot;sweater_count&quot;) || 0;</span>
<span class="cp">    return sprintf(&quot;\$%.2f&quot;, $shirts*33 + $sweaters * 49.99);</span>
<span class="cp">}</span>

<span class="cp">sub to_page { submit(-NAME =&gt; &quot;.State&quot;, -VALUE =&gt; shift) }</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.0</span>
<span class="cp">#-----------------------------</span>
<span class="cp">http://www.perl.com/CPAN/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.1</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use LWP::Simple;</span>
<span class="cp">$content = get($URL);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use LWP::Simple;</span>
<span class="cp">unless (defined ($content = get $URL)) {</span>
<span class="cp">    die &quot;could not get $URL\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/titlebytes</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w </span>
<span class="cp"># titlebytes - find the title and size of documents </span>
<span class="cp">use LWP::UserAgent; </span>
<span class="cp">use HTTP::Request; </span>
<span class="cp">use HTTP::Response; </span>
<span class="cp">use URI::Heuristic;</span>
<span class="cp">my $raw_url = shift                or die &quot;usage: $0 url\n&quot;; </span>
<span class="cp">my $url = URI::Heuristic::uf_urlstr($raw_url);</span>
<span class="cp">$| = 1; 									# to flush next line </span>
<span class="cp">printf &quot;%s =&gt;\n\t&quot;, $url;</span>
<span class="cp">my $ua = LWP::UserAgent-&gt;new(); </span>
<span class="cp">$ua-&gt;agent(&quot;Schmozilla/v9.14 Platinum&quot;); # give it time, it&#39;ll get there</span>
<span class="cp">my $req = HTTP::Request-&gt;new(GET =&gt; $url); </span>
<span class="cp">$req-&gt;referer(&quot;http://wizard.yellowbrick.oz&quot;);</span>
<span class="cp">			                            # perplex the log analysers</span>
<span class="cp">my $response = $ua-&gt;request($req);</span>
<span class="cp">if ($response-&gt;is_error()) {</span>
<span class="cp">     printf &quot; %s\n&quot;, $response-&gt;status_line;</span>
<span class="cp"> } else {</span>
<span class="cp">     my $count;</span>
<span class="cp">     my $bytes;</span>
<span class="cp">     my $content = $response-&gt;content();</span>
<span class="cp">     $bytes = length $content;</span>
<span class="cp">     $count = ($content =~ tr/\n/\n/);</span>
<span class="cp">     printf &quot;%s (%d lines, %d bytes)\n&quot;, $response-&gt;title(), $count, $bytes; } </span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% titlebytes http://www.tpj.com/</span>
<span class="cp">#http://www.tpj.com/ =&gt;</span>
<span class="cp">#    The Perl Journal (109 lines, 4530 bytes)</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.2</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use LWP::Simple;</span>
<span class="cp">use URI::URL;</span>

<span class="cp">my $url = url(&#39;http://www.perl.com/cgi-bin/cpan_mod&#39;);</span>
<span class="cp">$url-&gt;query_form(module =&gt; &#39;DB_File&#39;, readme =&gt; 1);</span>
<span class="cp">$content = get($url);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use HTTP::Request::Common qw(POST);</span>
<span class="cp">use LWP::UserAgent;</span>

<span class="cp">$ua = LWP::UserAgent-&gt;new();</span>
<span class="cp">my $req = POST &#39;http://www.perl.com/cgi-bin/cpan_mod&#39;,</span>
<span class="cp">               [ module =&gt; &#39;DB_File&#39;, readme =&gt; 1 ];</span>
<span class="cp">$content = $ua-&gt;request($req)-&gt;as_string;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">field1=value1&amp;field2=value2&amp;field3=value3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">http://www.site.com/path/to/</span>
<span class="cp">script.cgi?field1=value1&amp;field2=value2&amp;field3=value3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">http://www.site.com/path/to/</span>
<span class="cp">script.cgi?arg=%22this+isn%27t+%3CEASY%3E+%26+%3CFUN%3E%22</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ua-&gt;proxy([&#39;http&#39;, &#39;ftp&#39;] =&gt; &#39;http://proxy.myorg.com:8081&#39;);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.3</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use HTML::LinkExtor;</span>

<span class="cp">$parser = HTML::LinkExtor-&gt;new(undef, $base_url);</span>
<span class="cp">$parser-&gt;parse_file($filename);</span>
<span class="cp">@links = $parser-&gt;links;</span>
<span class="cp">foreach $linkarray (@links) {</span>
<span class="cp">    my @element = @$linkarray;</span>
<span class="cp">    my $elt_type = shift @element;                  # element type</span>

<span class="cp">    # possibly test whether this is an element we&#39;re interested in</span>
<span class="cp">    while (@element) {</span>
<span class="cp">        # extract the next attribute and its value</span>
<span class="cp">        my ($attr_name, $attr_value) = splice(@element, 0, 2);</span>
<span class="cp">        # ... do something with them ...</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">&lt;A HREF=&quot;http://www.perl.com/&quot;&gt;Home page&lt;/A&gt;</span>
<span class="cp">&lt;IMG SRC=&quot;images/big.gif&quot; LOWSRC=&quot;images/big-lowres.gif&quot;&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">[</span>
<span class="cp">  [ a,   href   =&gt; &quot;http://www.perl.com/&quot; ],</span>
<span class="cp">  [ img, src    =&gt; &quot;images/big.gif&quot;,</span>
<span class="cp">         lowsrc =&gt; &quot;images/big-lowres.gif&quot; ]</span>
<span class="cp">]</span>
<span class="cp">#-----------------------------</span>
<span class="cp">if ($elt_type eq &#39;a&#39; &amp;&amp; $attr_name eq &#39;href&#39;) {</span>
<span class="cp">    print &quot;ANCHOR: $attr_value\n&quot; </span>
<span class="cp">        if $attr_value-&gt;scheme =~ /http|ftp/;</span>
<span class="cp">}</span>
<span class="cp">if ($elt_type eq &#39;img&#39; &amp;&amp; $attr_name eq &#39;src&#39;) {</span>
<span class="cp">    print &quot;IMAGE:  $attr_value\n&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/xurl</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># xurl - extract unique, sorted list of links from URL</span>
<span class="cp">use HTML::LinkExtor;</span>
<span class="cp">use LWP::Simple;</span>

<span class="cp">$base_url = shift;</span>
<span class="cp">$parser = HTML::LinkExtor-&gt;new(undef, $base_url);</span>
<span class="cp">$parser-&gt;parse(get($base_url))-&gt;eof;</span>
<span class="cp">@links = $parser-&gt;links;</span>
<span class="cp">foreach $linkarray (@links) {</span>
<span class="cp">    my @element  = @$linkarray;</span>
<span class="cp">    my $elt_type = shift @element;</span>
<span class="cp">    while (@element) {</span>
<span class="cp">        my ($attr_name , $attr_value) = splice(@element, 0, 2);</span>
<span class="cp">        $seen{$attr_value}++;</span>
<span class="cp">    }</span>
<span class="cp">}</span>
<span class="cp">for (sort keys %seen) { print $_, &quot;\n&quot; }</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% xurl http://www.perl.com/CPAN</span>
<span class="cp">#ftp://ftp@ftp.perl.com/CPAN/CPAN.html</span>
<span class="cp">#</span>
<span class="cp">#http://language.perl.com/misc/CPAN.cgi</span>
<span class="cp">#</span>
<span class="cp">#http://language.perl.com/misc/cpan_module</span>
<span class="cp">#</span>
<span class="cp">#http://language.perl.com/misc/getcpan</span>
<span class="cp">#</span>
<span class="cp">#http://www.perl.com/index.html</span>
<span class="cp">#</span>
<span class="cp">#http://www.perl.com/gifs/lcb.xbm</span>
<span class="cp">#-----------------------------</span>
<span class="cp">&lt;URL:http://www.perl.com&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">@URLs = ($message =~ /&lt;URL:(.*?)&gt;/g);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.4</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/text2html</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w -p00</span>
<span class="cp"># text2html - trivial html encoding of normal text</span>
<span class="cp"># -p means apply this script to each record.</span>
<span class="cp"># -00 mean that a record is now a paragraph</span>

<span class="cp">use HTML::Entities;</span>
<span class="cp">$_ = encode_entities($_, &quot;\200-\377&quot;);</span>

<span class="cp">if (/^\s/) {</span>
<span class="cp">    # Paragraphs beginning with whitespace are wrapped in &lt;PRE&gt; </span>
<span class="cp">    s{(.*)$}        {&lt;PRE&gt;\n$1&lt;/PRE&gt;\n}s;           # indented verbatim</span>
<span class="cp">} else {</span>
<span class="cp">    s{^(&gt;.*)}       {$1&lt;BR&gt;}gm;                    # quoted text</span>
<span class="cp">    s{&lt;URL:(.*?)&gt;}    {&lt;A HREF=&quot;$1&quot;&gt;$1&lt;/A&gt;}gs         # embedded URL  (good)</span>
<span class="cp">                    ||</span>
<span class="cp">    s{(http:\S+)}   {&lt;A HREF=&quot;$1&quot;&gt;$1&lt;/A&gt;}gs;        # guessed URL   (bad)</span>
<span class="cp">    s{\*(\S+)\*}    {&lt;STRONG&gt;$1&lt;/STRONG&gt;}g;         # this is *bold* here</span>
<span class="cp">    s{\b_(\S+)\_\b} {&lt;EM&gt;$1&lt;/EM&gt;}g;                 # this is _italics_ here</span>
<span class="cp">    s{^}            {&lt;P&gt;\n};                        # add paragraph tag</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">BEGIN {</span>
<span class="cp">    print &quot;&lt;TABLE&gt;&quot;;</span>
<span class="cp">    $_ = encode_entities(scalar &lt;&gt;);</span>
<span class="cp">    s/\n\s+/ /g;  # continuation lines</span>
<span class="cp">    while ( /^(\S+?:)\s*(.*)$/gm ) {                # parse heading</span>
<span class="cp">        print &quot;&lt;TR&gt;&lt;TH ALIGN=&#39;LEFT&#39;&gt;$1&lt;/TH&gt;&lt;TD&gt;$2&lt;/TD&gt;&lt;/TR&gt;\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">    print &quot;&lt;/TABLE&gt;&lt;HR&gt;&quot;;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.5</span>
<span class="cp">#-----------------------------</span>
<span class="cp">$ascii = `lynx -dump $filename`;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use HTML::FormatText;</span>
<span class="cp">use HTML::Parse;</span>

<span class="cp">$html = parse_htmlfile($filename);</span>
<span class="cp">$formatter = HTML::FormatText-&gt;new(leftmargin =&gt; 0, rightmargin =&gt; 50);</span>
<span class="cp">$ascii = $formatter-&gt;format($html);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use HTML::TreeBuilder;</span>
<span class="cp">use HTML::FormatText;</span>

<span class="cp">$html = HTML::TreeBuilder-&gt;new();</span>
<span class="cp">$html-&gt;parse($document);</span>

<span class="cp">$formatter = HTML::FormatText-&gt;new(leftmargin =&gt; 0, rightmargin =&gt; 50);</span>

<span class="cp">$ascii = $formatter-&gt;format($html);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.6</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($plain_text = $html_text) =~ s/&lt;[^&gt;]*&gt;//gs;     #WRONG</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use HTML::Parse;</span>
<span class="cp">use HTML::FormatText;</span>
<span class="cp">$plain_text = HTML::FormatText-&gt;new-&gt;format(parse_html($html_text));</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -pe &#39;s/&lt;[^&gt;]*&gt;//g&#39; file</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&lt;IMG SRC = &quot;foo.gif&quot;</span>
<span class="cp">#     ALT = &quot;Flurp!&quot;&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% perl -0777 -pe &#39;s/&lt;[^&gt;]*&gt;//gs&#39; file</span>
<span class="cp">#-----------------------------</span>
<span class="cp">{</span>
<span class="cp">    local $/;               # temporary whole-file input mode</span>
<span class="cp">    $html = &lt;FILE&gt;;</span>
<span class="cp">    $html =~ s/&lt;[^&gt;]*&gt;//gs;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&lt;IMG SRC = &quot;foo.gif&quot; ALT = &quot;A &gt; B&quot;&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;!-- &lt;A comment&gt; --&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;script&gt;if (a&lt;b &amp;&amp; a&gt;c)&lt;/script&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;# Just data #&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;![INCLUDE CDATA [ &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ]]&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&lt;!-- This section commented out.</span>
<span class="cp">#    &lt;B&gt;You can&#39;t see me!&lt;/B&gt;</span>
<span class="cp">#--&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">package MyParser;</span>
<span class="cp">use HTML::Parser;</span>
<span class="cp">use HTML::Entities qw(decode_entities);</span>

<span class="cp">@ISA = qw(HTML::Parser);</span>

<span class="cp">sub text {</span>
<span class="cp">    my($self, $text) = @_;</span>
<span class="cp">    print decode_entities($text);</span>
<span class="cp">}</span>

<span class="cp">package main;</span>
<span class="cp">MyParser-&gt;new-&gt;parse_file(*F);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">($title) = ($html =~ m#&lt;TITLE&gt;\s*(.*?)\s*&lt;/TITLE&gt;#is);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/htitle</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl</span>
<span class="cp"># htitle - get html title from URL</span>

<span class="cp">die &quot;usage: $0 url ...\n&quot; unless @ARGV;</span>
<span class="cp">require LWP;</span>

<span class="cp">foreach $url (@ARGV) {</span>
<span class="cp">    $ua = LWP::UserAgent-&gt;new();</span>
<span class="cp">    $res = $ua-&gt;request(HTTP::Request-&gt;new(GET =&gt; $url));</span>
<span class="cp">    print &quot;$url: &quot; if @ARGV &gt; 1;</span>
<span class="cp">    if ($res-&gt;is_success) {</span>
<span class="cp">        print $res-&gt;title, &quot;\n&quot;;</span>
<span class="cp">    } else {</span>
<span class="cp">        print $res-&gt;status_line, &quot;\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% htitle http://www.ora.com</span>
<span class="cp">#www.oreilly.com -- Welcome to O&#39;Reilly &amp; Associates!</span>
<span class="cp">#</span>
<span class="cp">#% htitle http://www.perl.com/ http://www.perl.com/nullvoid</span>
<span class="cp">#http://www.perl.com/: The www.perl.com Home Page</span>
<span class="cp">#http://www.perl.com/nullvoid: 404 File Not Found</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.7</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/churl</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># churl - check urls</span>

<span class="cp">use HTML::LinkExtor;</span>
<span class="cp">use LWP::Simple qw(get head);</span>

<span class="cp">$base_url = shift</span>
<span class="cp">    or die &quot;usage: $0 &lt;start_url&gt;\n&quot;;</span>
<span class="cp">$parser = HTML::LinkExtor-&gt;new(undef, $base_url);</span>
<span class="cp">$parser-&gt;parse(get($base_url));</span>
<span class="cp">@links = $parser-&gt;links;</span>
<span class="cp">print &quot;$base_url: \n&quot;;</span>
<span class="cp">foreach $linkarray (@links) {</span>
<span class="cp">    my @element  = @$linkarray;</span>
<span class="cp">    my $elt_type = shift @element;</span>
<span class="cp">    while (@element) {</span>
<span class="cp">        my ($attr_name , $attr_value) = splice(@element, 0, 2);</span>
<span class="cp">        if ($attr_value-&gt;scheme =~ /\b(ftp|https?|file)\b/) {</span>
<span class="cp">            print &quot;  $attr_value: &quot;, head($attr_value) ? &quot;OK&quot; : &quot;BAD&quot;, &quot;\n&quot;;</span>
<span class="cp">        }</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% churl http://www.wizards.com</span>
<span class="cp">#http://www.wizards.com:</span>
<span class="cp">#</span>
<span class="cp">#  FrontPage/FP_Color.gif:  OK</span>
<span class="cp">#</span>
<span class="cp">#  FrontPage/FP_BW.gif:  BAD</span>
<span class="cp">#</span>
<span class="cp">#  #FP_Map:  OK</span>
<span class="cp">#</span>
<span class="cp">#  Games_Library/Welcome.html:  OK</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.8</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/surl</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># surl - sort URLs by their last modification date</span>

<span class="cp">use LWP::UserAgent;</span>
<span class="cp">use HTTP::Request;</span>
<span class="cp">use URI::URL qw(url);</span>

<span class="cp">my($url, %Date);</span>
<span class="cp">my $ua = LWP::UserAgent-&gt;new();</span>

<span class="cp">while ( $url = url(scalar &lt;&gt;) ) {</span>
<span class="cp">    my($req, $ans);</span>
<span class="cp">    next unless $url-&gt;scheme =~ /^(file|https?)$/;</span>
<span class="cp">    $ans = $ua-&gt;request(HTTP::Request-&gt;new(&quot;HEAD&quot;, $url));</span>
<span class="cp">    if ($ans-&gt;is_success) {</span>
<span class="cp">        $Date{$url} = $ans-&gt;last_modified || 0;  # unknown</span>
<span class="cp">    } else {</span>
<span class="cp">        print STDERR &quot;$url: Error [&quot;, $ans-&gt;code, &quot;] &quot;, $ans-&gt;message, &quot;!\n&quot;;</span>
<span class="cp">    }</span>
<span class="cp">}</span>

<span class="cp">foreach $url ( sort { $Date{$b} &lt;=&gt; $Date{$a} } keys %Date ) {</span>
<span class="cp">    printf &quot;%-25s %s\n&quot;, $Date{$url} ? (scalar localtime $Date{$url})</span>
<span class="cp">                                     : &quot;&lt;NONE SPECIFIED&gt;&quot;, $url;</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#% xurl http://www.perl.com/  | surl | head</span>
<span class="cp">#Mon Apr 20 06:16:02 1998  http://electriclichen.com/linux/srom.html</span>
<span class="cp">#</span>
<span class="cp">#Fri Apr 17 13:38:51 1998  http://www.oreilly.com/</span>
<span class="cp">#</span>
<span class="cp">#Fri Mar 13 12:16:47 1998  http://www2.binevolve.com/</span>
<span class="cp">#</span>
<span class="cp">#Sun Mar  8 21:01:27 1998  http://www.perl.org/</span>
<span class="cp">#</span>
<span class="cp">#Tue Nov 18 13:41:32 1997  http://www.perl.com/universal/header.map</span>
<span class="cp">#</span>
<span class="cp">#Wed Oct  1 12:55:13 1997  http://www.songline.com/</span>
<span class="cp">#</span>
<span class="cp">#Sun Aug 17 21:43:51 1997  http://www.perl.com/graphics/perlhome_header.jpg</span>
<span class="cp">#</span>
<span class="cp">#Sun Aug 17 21:43:47 1997  http://www.perl.com/graphics/perl_id_313c.gif</span>
<span class="cp">#</span>
<span class="cp">#Sun Aug 17 21:43:46 1997  http://www.perl.com/graphics/ora_logo.gif</span>
<span class="cp">#</span>
<span class="cp">#Sun Aug 17 21:43:44 1997  http://www.perl.com/graphics/header-nav.gif</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.9</span>
<span class="cp">#-----------------------------</span>
<span class="cp">sub template {</span>
<span class="cp">    my ($filename, $fillings) = @_;</span>
<span class="cp">    my $text;</span>
<span class="cp">    local $/;                   # slurp mode (undef)</span>
<span class="cp">    local *F;                   # create local filehandle</span>
<span class="cp">    open(F, &quot;&lt; $filename\0&quot;)    || return;</span>
<span class="cp">    $text = &lt;F&gt;;                # read whole file</span>
<span class="cp">    close(F);                   # ignore retval</span>
<span class="cp">    # replace quoted words with value in %$fillings hash</span>
<span class="cp">    $text =~ s{ %% ( .*? ) %% }</span>
<span class="cp">              { exists( $fillings-&gt;{$1} )</span>
<span class="cp">                      ? $fillings-&gt;{$1}</span>
<span class="cp">                      : &quot;&quot;</span>
<span class="cp">              }gsex;</span>
<span class="cp">    return $text;</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&lt;!-- simple.template for internal template() function --&gt;</span>
<span class="cp">#&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Report for %%username%%&lt;/TITLE&gt;&lt;/HEAD&gt;</span>
<span class="cp">#&lt;BODY&gt;&lt;H1&gt;Report for %%username%%&lt;/H1&gt;</span>
<span class="cp">#%%username%% logged in %%count%% times, for a total of %%total%% minutes.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&lt;!-- fancy.template for Text::Template --&gt;</span>
<span class="cp">#&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Report for {$user}&lt;/TITLE&gt;&lt;/HEAD&gt;</span>
<span class="cp">#&lt;BODY&gt;&lt;H1&gt;Report for {$user}&lt;/H1&gt;</span>
<span class="cp">#{ lcfirst($user) } logged in {$count} times, for a total of </span>
<span class="cp">#{ int($total / 60) } minutes.</span>
<span class="cp">#-----------------------------</span>
<span class="cp">%fields = (</span>
<span class="cp">            username =&gt; $whats_his_name,</span>
<span class="cp">            count    =&gt; $login_count,</span>
<span class="cp">            total    =&gt; $minute_used,</span>
<span class="cp">);</span>

<span class="cp">print template(&quot;/home/httpd/templates/simple.template&quot;, \%fields);</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/userrep</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># userrep1 - report duration of user logins using SQL database</span>

<span class="cp">use DBI;</span>
<span class="cp">use CGI qw(:standard);</span>

<span class="cp"># template() defined as in the Solution section above</span>
<span class="cp">$user = param(&quot;username&quot;)                   or die &quot;No username&quot;;</span>

<span class="cp">$dbh = DBI-&gt;connect(&quot;dbi:mysql:connections:mysql.domain.com:3306&quot;,</span>
<span class="cp">    &quot;connections&quot;, &quot;seekritpassword&quot;)       or die &quot;Couldn&#39;t connect\n&quot;;</span>
<span class="cp">$sth = $dbh-&gt;prepare(&lt;&lt;&quot;END_OF_SELECT&quot;)     or die &quot;Couldn&#39;t prepare SQL&quot;;</span>
<span class="cp">    SELECT COUNT(duration),SUM(duration) </span>
<span class="cp">    FROM logins WHERE username=&#39;$user&#39;</span>
<span class="cp">END_OF_SELECT</span>

<span class="cp"># this time the duration is assumed to be in seconds</span>
<span class="cp">if (@row = $sth-&gt;fetchrow()) {</span>
<span class="cp">    ($count, $seconds) = @row;</span>
<span class="cp">} else {</span>
<span class="cp">    ($count, $seconds) = (0,0);</span>
<span class="cp">} </span>

<span class="cp">$sth-&gt;finish();</span>
<span class="cp">$dbh-&gt;disconnect;</span>

<span class="cp">print header();</span>
<span class="cp">print template(&quot;report.tpl&quot;, {   </span>
<span class="cp">    &#39;username&#39; =&gt; $user,</span>
<span class="cp">    &#39;count&#39;    =&gt; $count,</span>
<span class="cp">    &#39;total&#39;    =&gt; $total </span>
<span class="cp">});</span>

<span class="cp">#-----------------------------</span>
<span class="cp">You owe: {$total}</span>
<span class="cp">#-----------------------------</span>
<span class="cp">The average was {$count ?  ($total/$count) : 0}.</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/userrep2</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># userrep2 - report duration of user logins using SQL database</span>

<span class="cp">use Text::Template;</span>
<span class="cp">use DBI;</span>
<span class="cp">use CGI qw(:standard);</span>

<span class="cp">$tmpl = &quot;/home/httpd/templates/fancy.template&quot;;</span>
<span class="cp">$template = Text::Template-&gt;new(-type =&gt; &quot;file&quot;, -source =&gt; $tmpl);</span>
<span class="cp">$user = param(&quot;username&quot;)                   or die &quot;No username&quot;;</span>

<span class="cp">$dbh = DBI-&gt;connect(&quot;dbi:mysql:connections:mysql.domain.com:3306&quot;,</span>
<span class="cp">    &quot;connections&quot;, &quot;secret passwd&quot;)         or die &quot;Couldn&#39;t db connect\n&quot;;</span>
<span class="cp">$sth = $dbh-&gt;prepare(&lt;&lt;&quot;END_OF_SELECT&quot;)     or die &quot;Couldn&#39;t prepare SQL&quot;;</span>
<span class="cp">    SELECT COUNT(duration),SUM(duration) </span>
<span class="cp">    FROM logins WHERE username=&#39;$user&#39;</span>
<span class="cp">END_OF_SELECT</span>

<span class="cp">$sth-&gt;execute()                             or die &quot;Couldn&#39;t execute SQL&quot;;</span>

<span class="cp">if (@row = $sth-&gt;fetchrow()) {</span>
<span class="cp">    ($count, $total) = @row;</span>
<span class="cp">} else {</span>
<span class="cp">    $count = $total = 0;</span>
<span class="cp">}</span>

<span class="cp">$sth-&gt;finish();</span>
<span class="cp">$dbh-&gt;disconnect;</span>

<span class="cp">print header();</span>
<span class="cp">print $template-&gt;fill_in();</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.10</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use LWP::Simple;</span>
<span class="cp">mirror($URL, $local_filename);</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.11</span>
<span class="cp">#-----------------------------</span>
<span class="cp">use LWP::RobotUA;</span>
<span class="cp">$ua = LWP::RobotUA-&gt;new(&#39;websnuffler/0.1&#39;, &#39;me@wherever.com&#39;);</span>
<span class="cp">#-----------------------------</span>
<span class="cp">403 (Forbidden) Forbidden by robots.txt</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% GET http://www.webtechniques.com/robots.txt </span>
<span class="cp">#User-agent: *</span>
<span class="cp">#</span>
<span class="cp">#     Disallow: /stats</span>
<span class="cp">#</span>
<span class="cp">#     Disallow: /db</span>
<span class="cp">#</span>
<span class="cp">#     Disallow: /logs</span>
<span class="cp">#</span>
<span class="cp">#     Disallow: /store</span>
<span class="cp">#</span>
<span class="cp">#     Disallow: /forms</span>
<span class="cp">#</span>
<span class="cp">#     Disallow: /gifs</span>
<span class="cp">#</span>
<span class="cp">#     Disallow: /wais-src</span>
<span class="cp">#</span>
<span class="cp">#     Disallow: /scripts</span>
<span class="cp">#</span>
<span class="cp">#     Disallow: /config</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% GET http://www.cnn.com/robots.txt | head</span>
<span class="cp">## robots, scram</span>
<span class="cp">#</span>
<span class="cp">## $I d : robots.txt,v 1.2 1998/03/10 18:27:01 mreed Exp $</span>
<span class="cp">#</span>
<span class="cp">#User-agent: *</span>
<span class="cp">#</span>
<span class="cp">#Disallow: /</span>
<span class="cp">#</span>
<span class="cp">#User-agent:     Mozilla/3.01 (hotwired-test/0.1)</span>
<span class="cp">#</span>
<span class="cp">#Disallow:   /cgi-bin</span>
<span class="cp">#</span>
<span class="cp">#Disallow:   /TRANSCRIPTS</span>
<span class="cp">#</span>
<span class="cp">#Disallow:   /development</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.12</span>
<span class="cp">#-----------------------------</span>
<span class="cp">while (&lt;LOGFILE&gt;) {</span>
<span class="cp">  my ($client, $identuser, $authuser, $date, $time, $tz, $method,</span>
<span class="cp">      $url, $protocol, $status, $bytes) =</span>
<span class="cp">      /^(\S+) (\S+) (\S+) \[([^:]+):(\d+:\d+:\d+) ([^\]]+) &quot;(\S+) (.*?) (\S+)&quot; (\S+) (\S+)$/ or next;</span>
<span class="cp">  # ...</span>
<span class="cp">}</span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.13</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/sumwww</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># sumwww - summarize web server log activity</span>

<span class="cp">$lastdate = &quot;&quot;;</span>
<span class="cp">daily_logs();</span>
<span class="cp">summary();</span>
<span class="cp">exit;</span>

<span class="cp"># read CLF files and tally hits from the host and to the URL</span>
<span class="cp">sub daily_logs {</span>
<span class="cp">    while (&lt;&gt;) {</span>
<span class="cp">        ($type, $what) = /&quot;(GET|POST)\s+(\S+?) \S+&quot;/ or next;</span>
<span class="cp">        ($host, undef, undef, $datetime) = split;</span>
<span class="cp">        ($bytes) = /\s(\d+)\s*$/ or next;</span>
<span class="cp">        ($date)  = ($datetime =~ /\[([^:]*)/);</span>
<span class="cp">        $posts  += ($type eq POST);</span>
<span class="cp">        $home++ if m, / ,;</span>
<span class="cp">        if ($date ne $lastdate) {</span>
<span class="cp">            if ($lastdate) { write_report()     }</span>
<span class="cp">            else           { $lastdate = $date  }</span>
<span class="cp">        }</span>
<span class="cp">        $count++;</span>
<span class="cp">        $hosts{$host}++;</span>
<span class="cp">        $what{$what}++;</span>
<span class="cp">        $bytesum += $bytes;</span>
<span class="cp">    }</span>
<span class="cp">    write_report() if $count;</span>
<span class="cp">}</span>

<span class="cp"># use *typeglob aliasing of global variables for cheap copy</span>
<span class="cp">sub summary  {</span>
<span class="cp">    $lastdate = &quot;Grand Total&quot;;</span>
<span class="cp">    *count   = *sumcount;</span>
<span class="cp">    *bytesum = *bytesumsum;</span>
<span class="cp">    *hosts   = *allhosts;</span>
<span class="cp">    *posts   = *allposts;</span>
<span class="cp">    *what    = *allwhat;</span>
<span class="cp">    *home    = *allhome;</span>
<span class="cp">    write;</span>
<span class="cp">}</span>

<span class="cp"># display the tallies of hosts and URLs, using formats</span>
<span class="cp">sub write_report {</span>
<span class="cp">    write;</span>

<span class="cp">    # add to summary data</span>
<span class="cp">    $lastdate    = $date;</span>
<span class="cp">    $sumcount   += $count;</span>
<span class="cp">    $bytesumsum += $bytesum;</span>
<span class="cp">    $allposts   += $posts;</span>
<span class="cp">    $allhome    += $home;</span>

<span class="cp">    # reset daily data</span>
<span class="cp">    $posts = $count = $bytesum = $home = 0;</span>
<span class="cp">    @allwhat{keys %what}   = keys %what;</span>
<span class="cp">    @allhosts{keys %hosts} = keys %hosts;</span>
<span class="cp">    %hosts = %what = ();</span>
<span class="cp">}</span>

<span class="cp">format STDOUT_TOP =</span>
<span class="cp">@|||||||||| @|||||| @||||||| @||||||| @|||||| @|||||| @|||||||||||||</span>
<span class="cp">&quot;Date&quot;,     &quot;Hosts&quot;, &quot;Accesses&quot;, &quot;Unidocs&quot;, &quot;POST&quot;, &quot;Home&quot;, &quot;Bytes&quot;</span>
<span class="cp">----------- ------- -------- -------- ------- ------- --------------</span>
<span class="cp">.</span>

<span class="cp">format STDOUT =</span>
<span class="cp">@&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; @&gt;&gt;&gt;&gt;&gt;&gt; @&gt;&gt;&gt;&gt;&gt;&gt;&gt; @&gt;&gt;&gt;&gt;&gt;&gt;&gt; @&gt;&gt;&gt;&gt;&gt;&gt; @&gt;&gt;&gt;&gt;&gt;&gt; @&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="cp">$lastdate,  scalar(keys %hosts), </span>
<span class="cp">            $count, scalar(keys %what), </span>
<span class="cp">                             $posts,  $home,  $bytesum</span>
<span class="cp">.</span>

<span class="cp">#-----------------------------</span>
<span class="cp">#     Date      Hosts  Accesses Unidocs   POST    Home       Bytes</span>
<span class="cp"># </span>
<span class="cp"># ----------- ------- -------- -------- ------- ------- --------------</span>
<span class="cp"># </span>
<span class="cp"># 19/May/1998     353     6447     3074     352      51       16058246</span>
<span class="cp"># </span>
<span class="cp"># 20/May/1998    1938    23868     4288     972     350       61879643</span>
<span class="cp"># </span>
<span class="cp"># 21/May/1998    1775    27872     6596    1064     376       64613798</span>
<span class="cp"># </span>
<span class="cp"># 22/May/1998    1680    21402     4467     735     285       52437374</span>
<span class="cp"># </span>
<span class="cp"># 23/May/1998    1128    21260     4944     592     186       55623059</span>
<span class="cp"># </span>
<span class="cp"># Grand Total    6050   100849    10090    3715    1248      250612120</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/aprept</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># aprept - report on Apache logs</span>

<span class="cp">use Logfile::Apache;</span>

<span class="cp">$l = Logfile::Apache-&gt;new(</span>
<span class="cp">    File  =&gt; &quot;-&quot;,                   # STDIN</span>
<span class="cp">    Group =&gt; [ Domain, File ]);</span>

<span class="cp">$l-&gt;report(Group =&gt; Domain, Sort =&gt; Records);</span>
<span class="cp">$l-&gt;report(Group =&gt; File,   List =&gt; [Bytes,Records]);</span>

<span class="cp">#-----------------------------</span>
<span class="cp"># Domain                  Records </span>
<span class="cp"># </span>
<span class="cp"># ===============================</span>
<span class="cp"># </span>
<span class="cp"># US Commercial        222 38.47% </span>
<span class="cp"># </span>
<span class="cp"># US Educational       115 19.93% </span>
<span class="cp"># </span>
<span class="cp"># Network               93 16.12% </span>
<span class="cp"># </span>
<span class="cp"># Unresolved            54  9.36% </span>
<span class="cp"># </span>
<span class="cp"># Australia             48  8.32% </span>
<span class="cp"># </span>
<span class="cp"># Canada                20  3.47% </span>
<span class="cp"># </span>
<span class="cp"># Mexico                 8  1.39% </span>
<span class="cp"># </span>
<span class="cp"># United Kingdom         6  1.04% </span>
<span class="cp"># </span>
<span class="cp"># </span>
<span class="cp"># File                               Bytes          Records </span>
<span class="cp"># </span>
<span class="cp"># =========================================================</span>
<span class="cp"># </span>
<span class="cp"># /                           13008  0.89%         6  1.04% </span>
<span class="cp"># </span>
<span class="cp"># /cgi-bin/MxScreen           11870  0.81%         2  0.35% </span>
<span class="cp"># </span>
<span class="cp"># /cgi-bin/pickcards          39431  2.70%        48  8.32% </span>
<span class="cp"># </span>
<span class="cp"># /deckmaster                143793  9.83%        21  3.64% </span>
<span class="cp"># </span>
<span class="cp"># /deckmaster/admin           54447  3.72%         3  0.52% </span>
<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.14</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Hi!&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;</span>
<span class="cp">#&lt;H1&gt;Welcome to Scooby World!&lt;/H1&gt;</span>
<span class="cp">#I have &lt;A HREF=&quot;pictures.html&quot;&gt;pictures&lt;/A&gt; of the crazy dog</span>
<span class="cp">#himself.  Here&#39;s one!&lt;P&gt;</span>
<span class="cp">#&lt;IMG SRC=&quot;scooby.jpg&quot; ALT=&quot;Good doggy!&quot;&gt;&lt;P&gt;</span>
<span class="cp">#&lt;BLINK&gt;He&#39;s my hero!&lt;/BLINK&gt;  I would like to meet him some day,</span>
<span class="cp">#and get my picture taken with him.&lt;P&gt;</span>
<span class="cp">#P.S. I am deathly ill.  &lt;A HREF=&quot;shergold.html&quot;&gt;Please send</span>
<span class="cp">#cards&lt;/A&gt;.</span>
<span class="cp">#&lt;/BODY&gt;&lt;/HTML&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% htmlsub picture photo scooby.html</span>
<span class="cp">#&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Hi!&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;H1&gt;Welcome to Scooby World!&lt;/H1&gt;</span>
<span class="cp">#</span>
<span class="cp">#I have &lt;A HREF=&quot;pictures.html&quot;&gt;photos&lt;/A&gt; of the crazy dog</span>
<span class="cp">#</span>
<span class="cp">#himself.  Here&#39;s one!&lt;P&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;IMG SRC=&quot;scooby.jpg&quot; ALT=&quot;Good doggy!&quot;&gt;&lt;P&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;BLINK&gt;He&#39;s my hero!&lt;/BLINK&gt;  I would like to meet him some day,</span>
<span class="cp">#</span>
<span class="cp">#and get my photo taken with him.&lt;P&gt;</span>
<span class="cp">#</span>
<span class="cp">#P.S. I am deathly ill.  &lt;A HREF=&quot;shergold.html&quot;&gt;Please send</span>
<span class="cp">#</span>
<span class="cp">#cards&lt;/A&gt;.</span>
<span class="cp">#</span>
<span class="cp">#&lt;/BODY&gt;&lt;/HTML&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/htmlsub</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># htmlsub - make substitutions in normal text of HTML files</span>
<span class="cp"># from Gisle Aas &lt;gisle@aas.no&gt;</span>

<span class="cp">sub usage { die &quot;Usage: $0 &lt;from&gt; &lt;to&gt; &lt;file&gt;...\n&quot; }</span>

<span class="cp">my $from = shift or usage;</span>
<span class="cp">my $to   = shift or usage;</span>
<span class="cp">usage unless @ARGV;</span>

<span class="cp"># Build the HTML::Filter subclass to do the substituting.</span>

<span class="cp">package MyFilter;</span>
<span class="cp">require HTML::Filter;</span>
<span class="cp">@ISA=qw(HTML::Filter);</span>
<span class="cp">use HTML::Entities qw(decode_entities encode_entities);</span>

<span class="cp">sub text</span>
<span class="cp">{</span>
<span class="cp">   my $self = shift;</span>
<span class="cp">   my $text = decode_entities($_[0]);</span>
<span class="cp">   $text =~ s/\Q$from/$to/go;       # most important line</span>
<span class="cp">   $self-&gt;SUPER::text(encode_entities($text));</span>
<span class="cp">}</span>

<span class="cp"># Now use the class.</span>

<span class="cp">package main;</span>
<span class="cp">foreach (@ARGV) {</span>
<span class="cp">    MyFilter-&gt;new-&gt;parse_file($_);</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>

<span class="cp"># ^^PLEAC^^_20.15</span>
<span class="cp">#-----------------------------</span>
<span class="cp">#% hrefsub shergold.html cards.html scooby.html</span>
<span class="cp">#&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Hi!&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;H1&gt;Welcome to Scooby World!&lt;/H1&gt;</span>
<span class="cp">#</span>
<span class="cp">#I have &lt;A HREF=&quot;pictures.html&quot;&gt;pictures&lt;/A&gt; of the crazy dog</span>
<span class="cp">#</span>
<span class="cp">#himself.  Here&#39;s one!&lt;P&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;IMG SRC=&quot;scooby.jpg&quot; ALT=&quot;Good doggy!&quot;&gt;&lt;P&gt;</span>
<span class="cp">#</span>
<span class="cp">#&lt;BLINK&gt;He&#39;s my hero!&lt;/BLINK&gt;  I would like to meet him some day,</span>
<span class="cp">#</span>
<span class="cp">#and get my picture taken with him.&lt;P&gt;</span>
<span class="cp">#</span>
<span class="cp">#P.S. I am deathly ill.  &lt;a href=&quot;cards.html&quot;&gt;Please send</span>
<span class="cp">#</span>
<span class="cp">#cards&lt;/A&gt;.</span>
<span class="cp">#</span>
<span class="cp">#&lt;/BODY&gt;&lt;/HTML&gt;</span>
<span class="cp">#-----------------------------</span>
<span class="cp"># <font size="-1"><a href="http://pleac.sourceforge.net/include/perl/ch20/hrefsub</span>">download the following standalone program</a></font>
<span class="cp">#!/usr/bin/perl -w</span>
<span class="cp"># hrefsub - make substitutions in &lt;A HREF=&quot;...&quot;&gt; fields of HTML files</span>
<span class="cp"># from Gisle Aas &lt;gisle@aas.no&gt;</span>

<span class="cp">sub usage { die &quot;Usage: $0 &lt;from&gt; &lt;to&gt; &lt;file&gt;...\n&quot; }</span>

<span class="cp">my $from = shift or usage;</span>
<span class="cp">my $to   = shift or usage;</span>
<span class="cp">usage unless @ARGV;</span>

<span class="cp"># The HTML::Filter subclass to do the substitution.</span>

<span class="cp">package MyFilter;</span>
<span class="cp">require HTML::Filter;</span>
<span class="cp">@ISA=qw(HTML::Filter);</span>
<span class="cp">use HTML::Entities qw(encode_entities);</span>

<span class="cp">sub start {</span>
<span class="cp">   my($self, $tag, $attr, $attrseq, $orig) = @_;</span>
<span class="cp">   if ($tag eq &#39;a&#39; &amp;&amp; exists $attr-&gt;{href}) {</span>
<span class="cp">           if ($attr-&gt;{href} =~ s/\Q$from/$to/g) {</span>
<span class="cp">               # must reconstruct the start tag based on $tag and $attr.</span>
<span class="cp">               # wish we instead were told the extent of the &#39;href&#39; value</span>
<span class="cp">               # in $orig.</span>
<span class="cp">               my $tmp = &quot;&lt;$tag&quot;;</span>
<span class="cp">               for (@$attrseq) {</span>
<span class="cp">                   my $encoded = encode_entities($attr-&gt;{$_});</span>
<span class="cp">                   $tmp .= qq( $_=&quot;$encoded &quot;);</span>
<span class="cp">               }</span>
<span class="cp">               $tmp .= &quot;&gt;&quot;;</span>
<span class="cp">               $self-&gt;output($tmp);</span>
<span class="cp">               return;</span>
<span class="cp">           }</span>
<span class="cp">   }</span>
<span class="cp">   $self-&gt;output($orig);</span>
<span class="cp">}</span>

<span class="cp"># Now use the class.</span>

<span class="cp">package main;</span>
<span class="cp">foreach (@ARGV) {</span>
<span class="cp">        MyFilter-&gt;new-&gt;parse_file($_);</span>
<span class="cp">}</span>

<span class="cp">#-----------------------------</span>
</pre></div>
</body>
</html>
